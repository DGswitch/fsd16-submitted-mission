import { y as computed, bM as getLanguageTag, bN as getTimezone, bO as getUseUtc, bP as getFormatTag, bQ as defaultTimezone, w as watch, bR as languageTags, bS as isSignMode, bT as isEnableMode, by as isSidePanel, U as dispatchSignal, b1 as global, bU as epochParams$1, a1 as el, a2 as sl, M as toHexBuffer, N as toHexString, R as toHexArray, bH as error, q as commonjsGlobal, Q as Buffer$1, bV as byteaToHex, $ as getNetworkId, P as networkAddressPrefix, bB as uint8ArrayToUtf8String, aP as isHexString, bW as getApiURL, bX as DEFAULT_WS_TIMEOUT_MS, ab as DEFAULT_ACCOUNT_ID, H as networkId$9, bY as ChainError, r as ref$1, bZ as getEpochParams, a8 as addSignalListener, bE as onNetworkIdUpdated, b_ as setEpochParams, b$ as onEpochParamsUpdated, a4 as json, a7 as Dexie, n as networkIdList, c0 as MAX_UTXOS, c1 as MAX_COLLATERAL_UTXOS, c2 as MIN_ADA_ONLY_UTXOS, a3 as dispatchSignalSync, aa as dispatchSignalSyncTo, a5 as getRef, L as forceSetLS, a6 as useLocalStorage, a as reactive, ad as removeSignalListener, c3 as LOW_PRIO_SYNC_SEC, c4 as HIGH_PRIO_SYNC_SEC, c5 as decodeHex, aF as createJsonFromCborJson, Y as api$1, bc as prefix0x, a9 as DEFAULT_WALLET_GROUP_NAME, c6 as RAPID_INTERVAL_MS, c7 as getChainTip, c8 as setChainTip, c9 as getAppCurrencies, ca as getCoingeckoTicker, cb as setCoingeckoTicker, cc as getAppCurrency, cd as setAppCurrencies$1, ce as createICoingeckoTickerItem, cf as createICoingeckoTicker, cg as createICurrency, ch as createICurrencyItem, ci as trimAllStrings } from './sidePanel.js';

let _offsetFromServer = 0;
const now = () => Date.now() - _offsetFromServer;
const setOffsetFromServer = (ts) => {
  _offsetFromServer = Date.now() - ts;
};

let _appAccount = null;
let _appWallet = null;
const setAppAccount = (appAccount) => {
  _appAccount = appAccount ?? null;
};
const getAppAccount = () => {
  return _appAccount;
};
const setAppWallet = (appWallet) => {
  _appWallet = appWallet ?? null;
};
const getAppWallet = () => {
  return _appWallet;
};

/*
 *  big.js v6.2.2
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2024 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,            // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,     // true or false


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true && typeof n !== 'bigint') {
          throw TypeError(INVALID + 'value');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }

      parse$1(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;
  Big.roundDown = 0;
  Big.roundHalfUp = 1;
  Big.roundHalfEven = 2;
  Big.roundUp = 3;

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse$1(x, n) {
  var e, i, nl;

  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round$1(x, sd, rm, more) {
  var xc = x.c;

  if (rm === UNDEFINED) rm = x.constructor.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }

  if (sd < 1) {
    more =
      rm === 3 && (more || !!xc[0]) || sd === 0 && (
      rm === 1 && xc[0] >= 5 ||
      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))
    );

    xc.length = 1;

    if (more) {

      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {

      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {

    // xc[sd] is the digit after the digit that may be rounded up.
    more =
      rm === 1 && xc[sd] >= 5 ||
      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&
        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||
      rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd;

    // Round up?
    if (more) {

      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[--sd] > 9;) {
        xc[sd] = 0;
        if (sd === 0) {
          ++x.e;
          xc.unshift(1);
          break;
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && isNonzero ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round$1(q, p, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big negated.
 */
P.neg = function () {
  var x = new this.constructor(this);
  x.s = -x.s;
  return x;
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e, k, t,
    x = this,
    Big = x.constructor;

  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }

    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -1e6 || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }

  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round$1(new this.constructor(this), sd, rm);
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -1e6 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round$1(new this.constructor(this), dp + this.e + 1, rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(+stringify(x, true, true));

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round$1(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round$1(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, true, !!n);
};


/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round$1(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, false, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P[Symbol.for('nodejs.util.inspect.custom')] = P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};


/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = +stringify(this, true, true);
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];

  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round$1(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }

  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};


// Export


var Big = _Big_();

const parse = (n) => Big(n.toString().length === 0 ? 0 : n);
const add = (n1, n2) => parse(n1).plus(parse(n2)).toString();
const subtract = (n1, n2) => parse(n1).minus(parse(n2)).toString();
const multiply = (n1, n2, dp) => parse(n1).times(parse(n2)).toFixed(dp, Big.roundDown);
const divide = (n1, n2, dp) => parse(n1).div(parse(n2)).toFixed(dp, Big.roundDown);
const abs = (n1) => parse(n1).abs().toString();
const mod = (n1, num) => parse(n1).mod(num).toString();
const pow = (n1, num) => parse(n1).pow(num).toString();
const neg = (n1) => parse(n1).neg().toString();
const bigToNum = (n1) => parse(n1).toNumber();
const isNaN$1 = (n1) => {
  try {
    parse(n1);
    return false;
  } catch (err) {
  }
  return true;
};
const round = (n1, dp, mode) => {
  if (!mode) {
    return parse(n1).round(dp).toString();
  }
  let roundingMode;
  switch (mode) {
    case "down":
      roundingMode = Big.roundDown;
      break;
    case "half-up":
      roundingMode = Big.roundHalfUp;
      break;
    case "half-even":
      roundingMode = Big.roundHalfEven;
      break;
    case "up":
      roundingMode = Big.roundUp;
      break;
  }
  return parse(n1).round(dp, roundingMode).toString();
};
const compare$1 = (n1, func, n2) => {
  const b1 = parse(n1);
  const b2 = parse(n2);
  switch (func) {
    case "<":
    case "lt":
      return b1.lt(b2);
    case "<=":
    case "lte":
      return b1.lte(b2);
    case "==":
    case "eq":
      return b1.eq(b2);
    case ">":
    case "gt":
      return b1.gt(b2);
    case ">=":
    case "gte":
      return b1.gte(b2);
    default:
      throw new Error("Error: MathLib.compare: unknown comparison.");
  }
};
const isZero = (n1) => compare$1(n1, "==", 0);
const isLessThanZero = (n1) => compare$1(n1, "<", 0);
const isGreaterThanZero = (n1) => compare$1(n1, ">", 0);

const _appLanguageTag = getLanguageTag("en-US");
const _appTimezone = getTimezone(defaultTimezone);
const _appUseUtc = getUseUtc();
const _appFormatTag = getFormatTag();
watch(_appLanguageTag, () => {
});
const appLanguageTag = computed(() => _appLanguageTag.value);
const appTimezone = computed(() => _appTimezone.value);
const appUseUtc = computed(() => _appUseUtc.value);
const appFormatTag = computed(() => _appFormatTag.value);
computed(
  () => languageTags.find((item) => item.languageTag === appLanguageTag.value) ?? languageTags.find((item) => item.languageTag === "en-US")
);
computed(
  () => languageTags.find((item) => item.languageTag === appFormatTag.value) ?? languageTags.find((item) => item.languageTag === "en-US")
);

var ITxBalanceType = /* @__PURE__ */ ((ITxBalanceType2) => {
  ITxBalanceType2[ITxBalanceType2["uninitialized"] = 0] = "uninitialized";
  ITxBalanceType2[ITxBalanceType2["withdrawal"] = 1] = "withdrawal";
  ITxBalanceType2[ITxBalanceType2["receivedTokens"] = 2] = "receivedTokens";
  ITxBalanceType2[ITxBalanceType2["sentTokens"] = 4] = "sentTokens";
  ITxBalanceType2[ITxBalanceType2["intraWallet"] = 8] = "intraWallet";
  ITxBalanceType2[ITxBalanceType2["sentAda"] = 16] = "sentAda";
  ITxBalanceType2[ITxBalanceType2["receivedAda"] = 32] = "receivedAda";
  ITxBalanceType2[ITxBalanceType2["external"] = 64] = "external";
  ITxBalanceType2[ITxBalanceType2["externalWithdrawal"] = 128] = "externalWithdrawal";
  ITxBalanceType2[ITxBalanceType2["rewards"] = 256] = "rewards";
  return ITxBalanceType2;
})(ITxBalanceType || {});
const createITxBalance = (tx) => {
  const balance = {
    hash: tx?.hash ?? "",
    slot: tx?.slot ?? -1,
    idx: tx?.idx ?? -1,
    coin: "0",
    c: 0,
    al: [],
    t: 0 /* uninitialized */
  };
  if (tx?.block) {
    balance.block = tx.block;
  }
  return balance;
};
const createITxBalanceList = (txList) => {
  const txBalanceList = new Array(txList.length);
  for (let i = 0; i < txList.length; i++) {
    txBalanceList[i] = createITxBalance(txList[i]);
  }
  return txBalanceList;
};

const onOnlyDappAccountSet = "onOnlyDappAccountSet";
const doSwitchSelectedWalletAccount = "doSwitchSelectedWalletAccount";
const doToggleFixedDappAccountId = "doToggleFixedDappAccountId";
const doToggleLockedUtxo = "doToggleLockedUtxo";
const doToggleSelectedUtxo = "doToggleSelectedUtxo";
const doClearSelectedUtxos = "doClearSelectedUtxos";
const onLockedUtxoToggled = "onLockedUtxoToggled";
const onSelectedUtxoToggled = "onSelectedUtxoToggled";
const doUpdateAccountBalances = "doUpdateAccountBalances";
const onAccountBalancesUpdated = "onAccountBalancesUpdated";
const onAppAccountAddedToAppWallet = "onAppAccountAddedToAppWallet";
const doAddAccountToRecovery = "doAddAccountToRecovery";
const doAddWalletToRecovery = "doAddWalletToRecovery";
const doGetWalletListFromRecovery = "doGetWalletListFromRecovery";
const doUpdateWalletRecoveryData = "doUpdateWalletRecoveryData";
const doGetAccountSettingsFromRecovery = "doGetAccountSettingsFromRecovery";

const getRandomId = () => Math.floor(Math.random() * 999999) + "-" + Math.floor(Math.random() * 999999) + "-" + Math.floor(Math.random() * 999999);
const getShortId = () => Math.floor(Math.random() * 9999) + "-" + Math.floor(Math.random() * 9999);

const doSetActiveApp = "doSetActiveApp";
const doInitApp = "doInitApp";
const doPostInitApp = "doPostInitApp";
const onSyncLeader = "onSyncLeader";
const onFocus = "onFocus";

const doSendOpen = "doSendOpen";
const doSendClose = "doSendClose";
const doSendUpdateNetworkId = "doSendUpdateNetworkId";
const doSendUpdateWalletList = "doSendUpdateWalletList";
const doSendUpdateAccountData = "doSendUpdateAccountData";
const doSendUpdateDappAccountId = "doSendUpdateDappAccountId";
const doSendUpdatePendingTx = "doSendUpdatePendingTx";
const doSendUpdatePeerInfoList = "doSendUpdatePeerInfoList";
const doSendUpdatePeerInfo = "doSendUpdatePeerInfo";
const doSendForcePeerDisconnect = "doSendForcePeerDisconnect";
const doSendForcePeerConnect = "doSendForcePeerConnect";
const doSendUpdateWalletConnectList = "doSendUpdateWalletConnectList";

let _toid = -1;
const createAppId = () => {
  if (typeof window === "undefined") {
    return getRandomId();
  }
  const appId = window.name === "" ? getRandomId() : window.name;
  window.name = appId;
  return appId;
};
const instanceAppId = createAppId();
const startTime$9 = now();
const appStateList = [{ id: instanceAppId, ping: startTime$9 }];
const isSyncLeader = () => {
  if (isSignMode() || isEnableMode() || isSidePanel()) {
    return false;
  }
  return appStateList.length > 0 && appStateList[appStateList.length - 1].id === instanceAppId;
};
const removeAllForeignIds = () => {
  clearTimeout(_toid);
  let found = 0;
  for (let i = appStateList.length - 1; i >= 0; i--) {
    if (appStateList[i].id === instanceAppId) {
      found++;
      if (found > 1) {
        appStateList.splice(i, 1);
      }
    }
  }
};
const onAppOpen = (appId) => {
  removeAllForeignIds();
  appStateList.push({ id: appId, ping: now() });
  return dispatchSignal(onSyncLeader, isSyncLeader());
};
const onAppClose = (appId) => {
  removeAllForeignIds();
  _toid = setTimeout(() => {
    setActiveInstance();
  }, 25 + (appStateList.length - 1) * 1e3);
  return dispatchSignal(onSyncLeader, isSyncLeader());
};
const setActiveInstance = async () => {
  if (isSignMode() || isEnableMode() || isSidePanel()) {
    return false;
  }
  await onAppOpen(instanceAppId);
  return dispatchSignal(doSendOpen, instanceAppId);
};

let NOT_IMPLEMENTED = 'NOT_IMPLEMENTED';
let VERSION_12_1_1$1 = '12.1.1';
let VERSION_13_2_0$1 = '13.2.0';
let version$2 = VERSION_13_2_0$1;

let wasm$1;

const heap$1 = new Array(128).fill(undefined);

heap$1.push(undefined, null, true, false);

function getObject$1(idx) { return heap$1[idx]; }

let heap_next$1 = heap$1.length;

function dropObject$1(idx) {
  if (idx < 132) return;
  heap$1[idx] = heap_next$1;
  heap_next$1 = idx;
}

function takeObject$1(idx) {
  const ret = getObject$1(idx);
  dropObject$1(idx);
  return ret;
}

const cachedTextDecoder$1 = (typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-8', { ignoreBOM: true, fatal: true }) : { decode: () => { throw Error('TextDecoder not available') } } );

if (typeof TextDecoder !== 'undefined') { cachedTextDecoder$1.decode(); }
let cachedUint8Memory0 = null;

function getUint8Memory0$1() {
  if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
    cachedUint8Memory0 = new Uint8Array(wasm$1.memory.buffer);
  }
  return cachedUint8Memory0;
}

function getStringFromWasm0$1(ptr, len) {
  ptr = ptr >>> 0;
  return cachedTextDecoder$1.decode(getUint8Memory0$1().subarray(ptr, ptr + len));
}

function addHeapObject$1(obj) {
  if (heap_next$1 === heap$1.length) heap$1.push(heap$1.length + 1);
  const idx = heap_next$1;
  heap_next$1 = heap$1[idx];

  heap$1[idx] = obj;
  return idx;
}

let WASM_VECTOR_LEN$1 = 0;

const cachedTextEncoder$1 = (typeof TextEncoder !== 'undefined' ? new TextEncoder('utf-8') : { encode: () => { throw Error('TextEncoder not available') } } );

const encodeString$1 = (typeof cachedTextEncoder$1.encodeInto === 'function'
  ? function (arg, view) {
    return cachedTextEncoder$1.encodeInto(arg, view);
  }
  : function (arg, view) {
    const buf = cachedTextEncoder$1.encode(arg);
    view.set(buf);
    return {
      read: arg.length,
      written: buf.length
    };
  });

function passStringToWasm0$1(arg, malloc, realloc) {

  if (realloc === undefined) {
    const buf = cachedTextEncoder$1.encode(arg);
    const ptr = malloc(buf.length, 1) >>> 0;
    getUint8Memory0$1().subarray(ptr, ptr + buf.length).set(buf);
    WASM_VECTOR_LEN$1 = buf.length;
    return ptr;
  }

  let len = arg.length;
  let ptr = malloc(len, 1) >>> 0;

  const mem = getUint8Memory0$1();

  let offset = 0;

  for (; offset < len; offset++) {
    const code = arg.charCodeAt(offset);
    if (code > 0x7F) break;
    mem[ptr + offset] = code;
  }

  if (offset !== len) {
    if (offset !== 0) {
      arg = arg.slice(offset);
    }
    ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
    const view = getUint8Memory0$1().subarray(ptr + offset, ptr + len);
    const ret = encodeString$1(arg, view);

    offset += ret.written;
    ptr = realloc(ptr, len, offset, 1) >>> 0;
  }

  WASM_VECTOR_LEN$1 = offset;
  return ptr;
}

function isLikeNone$1(x) {
  return x === undefined || x === null;
}

let cachedInt32Memory0 = null;

function getInt32Memory0$1() {
  if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
    cachedInt32Memory0 = new Int32Array(wasm$1.memory.buffer);
  }
  return cachedInt32Memory0;
}

function debugString$1(val) {
  // primitive types
  const type = typeof val;
  if (type == 'number' || type == 'boolean' || val == null) {
    return  `${val}`;
  }
  if (type == 'string') {
    return `"${val}"`;
  }
  if (type == 'symbol') {
    const description = val.description;
    if (description == null) {
      return 'Symbol';
    } else {
      return `Symbol(${description})`;
    }
  }
  if (type == 'function') {
    const name = val.name;
    if (typeof name == 'string' && name.length > 0) {
      return `Function(${name})`;
    } else {
      return 'Function';
    }
  }
  // objects
  if (Array.isArray(val)) {
    const length = val.length;
    let debug = '[';
    if (length > 0) {
      debug += debugString$1(val[0]);
    }
    for(let i = 1; i < length; i++) {
      debug += ', ' + debugString$1(val[i]);
    }
    debug += ']';
    return debug;
  }
  // Test for built-in
  const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
  let className;
  if (builtInMatches.length > 1) {
    className = builtInMatches[1];
  } else {
    // Failed to match the standard '[object ClassName]'
    return toString.call(val);
  }
  if (className == 'Object') {
    // we're a user defined class or Object
    // JSON.stringify avoids problems with cycles, and is generally much
    // easier than looping through ownProperties of `val`.
    try {
      return 'Object(' + JSON.stringify(val) + ')';
    } catch (_) {
      return 'Object';
    }
  }
  // errors
  if (val instanceof Error) {
    return `${val.name}: ${val.message}\n${val.stack}`;
  }
  // TODO we could test for more things here, like `Set`s and `Map`s.
  return className;
}

function getArrayU8FromWasm0$1(ptr, len) {
  ptr = ptr >>> 0;
  return getUint8Memory0$1().subarray(ptr / 1, ptr / 1 + len);
}

function passArray8ToWasm0$1(arg, malloc) {
  const ptr = malloc(arg.length * 1, 1) >>> 0;
  getUint8Memory0$1().set(arg, ptr / 1);
  WASM_VECTOR_LEN$1 = arg.length;
  return ptr;
}

function _assertClass$1(instance, klass) {
  if (!(instance instanceof klass)) {
    throw new Error(`expected instance of ${klass.name}`);
  }
  return instance.ptr;
}

/**
 * @param {string} json
 * @param {MetadataJsonSchema} schema
 * @returns {TransactionMetadatum}
 */
function encode_json_str_to_metadatum(json, schema) {
  try {
    const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
    const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN$1;
    wasm$1.encode_json_str_to_metadatum(retptr, ptr0, len0, schema);
    var r0 = getInt32Memory0$1()[retptr / 4 + 0];
    var r1 = getInt32Memory0$1()[retptr / 4 + 1];
    var r2 = getInt32Memory0$1()[retptr / 4 + 2];
    if (r2) {
      throw takeObject$1(r1);
    }
    return TransactionMetadatum.__wrap(r0);
  } finally {
    wasm$1.__wbindgen_add_to_stack_pointer(16);
  }
}

/**
 * @param {TransactionMetadatum} metadatum
 * @param {MetadataJsonSchema} schema
 * @returns {string}
 */
function decode_metadatum_to_json_str(metadatum, schema) {
  let deferred2_0;
  let deferred2_1;
  try {
    const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
    _assertClass$1(metadatum, TransactionMetadatum);
    wasm$1.decode_metadatum_to_json_str(retptr, metadatum.__wbg_ptr, schema);
    var r0 = getInt32Memory0$1()[retptr / 4 + 0];
    var r1 = getInt32Memory0$1()[retptr / 4 + 1];
    var r2 = getInt32Memory0$1()[retptr / 4 + 2];
    var r3 = getInt32Memory0$1()[retptr / 4 + 3];
    var ptr1 = r0;
    var len1 = r1;
    if (r3) {
      ptr1 = 0; len1 = 0;
      throw takeObject$1(r2);
    }
    deferred2_0 = ptr1;
    deferred2_1 = len1;
    return getStringFromWasm0$1(ptr1, len1);
  } finally {
    wasm$1.__wbindgen_add_to_stack_pointer(16);
    wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
  }
}

/**
 * @param {TransactionHash} tx_body_hash
 * @param {PrivateKey} sk
 * @returns {Vkeywitness}
 */
function make_vkey_witness(tx_body_hash, sk) {
  _assertClass$1(tx_body_hash, TransactionHash);
  _assertClass$1(sk, PrivateKey);
  const ret = wasm$1.make_vkey_witness(tx_body_hash.__wbg_ptr, sk.__wbg_ptr);
  return Vkeywitness.__wrap(ret);
}

/**
 * @param {AuxiliaryData} auxiliary_data
 * @returns {AuxiliaryDataHash}
 */
function hash_auxiliary_data(auxiliary_data) {
  _assertClass$1(auxiliary_data, AuxiliaryData);
  const ret = wasm$1.hash_auxiliary_data(auxiliary_data.__wbg_ptr);
  return AuxiliaryDataHash.__wrap(ret);
}

/** VERSION_12_1_1
 * @param {TransactionBody} tx_body
 * @returns {TransactionHash}
 */
function hash_transaction(tx_body) {
  if (version$2 === VERSION_12_1_1$1) {
    _assertClass$1(tx_body, TransactionBody);
    const ret = wasm$1.hash_transaction(tx_body.__wbg_ptr);
    return TransactionHash.__wrap(ret);
  }
  throw NOT_IMPLEMENTED
}

/**
 * @param {PlutusData} plutus_data
 * @returns {DataHash}
 */
function hash_plutus_data(plutus_data) {
  _assertClass$1(plutus_data, PlutusData);
  const ret = wasm$1.hash_plutus_data(plutus_data.__wbg_ptr);
  return DataHash.__wrap(ret);
}

function handleError(f, args) {
  try {
    return f.apply(this, args);
  } catch (e) {
    wasm$1.__wbindgen_exn_store(addHeapObject$1(e));
  }
}
/**
 * JSON <-> PlutusData conversion schemas.
 * Follows ScriptDataJsonSchema in cardano-cli defined at:
 * https://github.com/input-output-hk/cardano-node/blob/master/cardano-api/src/Cardano/Api/ScriptData.hs#L254
 *
 * All methods here have the following restrictions due to limitations on dependencies:
 * * JSON numbers above u64::MAX (positive) or below i64::MIN (negative) will throw errors
 * * Hex strings for bytes don't accept odd-length (half-byte) strings.
 *      cardano-cli seems to support these however but it seems to be different than just 0-padding
 *      on either side when tested so proceed with caution
 */
const PlutusDatumSchema = Object.freeze({
  /**
   * ScriptDataJsonNoSchema in cardano-node.
   *
   * This is the format used by --script-data-value in cardano-cli
   * This tries to accept most JSON but does not support the full spectrum of Plutus datums.
   * From JSON:
   * * null/true/false/floats NOT supported
   * * strings starting with 0x are treated as hex bytes. All other strings are encoded as their utf8 bytes.
   * To JSON:
   * * ConstrPlutusData not supported in ANY FORM (neither keys nor values)
   * * Lists not supported in keys
   * * Maps not supported in keys
   */
  BasicConversions:0,"0":"BasicConversions",
  /**
   * ScriptDataJsonDetailedSchema in cardano-node.
   *
   * This is the format used by --script-data-file in cardano-cli
   * This covers almost all (only minor exceptions) Plutus datums, but the JSON must conform to a strict schema.
   * The schema specifies that ALL keys and ALL values must be contained in a JSON map with 2 cases:
   * 1. For ConstrPlutusData there must be two fields "constructor" contianing a number and "fields" containing its fields
   *    e.g. { "constructor": 2, "fields": [{"int": 2}, {"list": [{"bytes": "CAFEF00D"}]}]}
   * 2. For all other cases there must be only one field named "int", "bytes", "list" or "map"
   *    Integer's value is a JSON number e.g. {"int": 100}
   *    Bytes' value is a hex string representing the bytes WITHOUT any prefix e.g. {"bytes": "CAFEF00D"}
   *    Lists' value is a JSON list of its elements encoded via the same schema e.g. {"list": [{"bytes": "CAFEF00D"}]}
   *    Maps' value is a JSON list of objects, one for each key-value pair in the map, with keys "k" and "v"
   *          respectively with their values being the plutus datum encoded via this same schema
   *          e.g. {"map": [
   *              {"k": {"int": 2}, "v": {"int": 5}},
   *              {"k": {"map": [{"k": {"list": [{"int": 1}]}, "v": {"bytes": "FF03"}}]}, "v": {"list": []}}
   *          ]}
   * From JSON:
   * * null/true/false/floats NOT supported
   * * the JSON must conform to a very specific schema
   * To JSON:
   * * all Plutus datums should be fully supported outside of the integer range limitations outlined above.
   */
  DetailedSchema:1,"1":"DetailedSchema", });
/**
 */
const CertificateKind = Object.freeze({ StakeRegistration:0,"0":"StakeRegistration",StakeDeregistration:1,"1":"StakeDeregistration",StakeDelegation:2,"2":"StakeDelegation",PoolRegistration:3,"3":"PoolRegistration",PoolRetirement:4,"4":"PoolRetirement",GenesisKeyDelegation:5,"5":"GenesisKeyDelegation",MoveInstantaneousRewardsCert:6,"6":"MoveInstantaneousRewardsCert",CommitteeHotAuth:7,"7":"CommitteeHotAuth",CommitteeColdResign:8,"8":"CommitteeColdResign",DRepDeregistration:9,"9":"DRepDeregistration",DRepRegistration:10,"10":"DRepRegistration",DRepUpdate:11,"11":"DRepUpdate",StakeAndVoteDelegation:12,"12":"StakeAndVoteDelegation",StakeRegistrationAndDelegation:13,"13":"StakeRegistrationAndDelegation",StakeVoteRegistrationAndDelegation:14,"14":"StakeVoteRegistrationAndDelegation",VoteDelegation:15,"15":"VoteDelegation",VoteRegistrationAndDelegation:16,"16":"VoteRegistrationAndDelegation", });
/**
 */
const LanguageKind = Object.freeze({ PlutusV1:0,"0":"PlutusV1",PlutusV2:1,"1":"PlutusV2",PlutusV3:2,"2":"PlutusV3", });
/**
 */
const CborContainerType = Object.freeze({ Array:0,"0":"Array",Map:1,"1":"Map", });
/**
 */
const MetadataJsonSchema = Object.freeze({ NoConversions:0,"0":"NoConversions",BasicConversions:1,"1":"BasicConversions",DetailedSchema:2,"2":"DetailedSchema", });

const AddressFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_address_free(ptr >>> 0));
/**
 */
class Address {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Address.prototype);
    obj.__wbg_ptr = ptr;
    AddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AddressFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_address_free(ptr);
  }
  /**
   * @param {Uint8Array} data
   * @returns {Address}
   */
  static from_bytes(data) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(data, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.address_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.address_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.address_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Address}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.address_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {AddressKind}
   */
  kind() {
    const ret = wasm$1.address_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {Credential | undefined}
   */
  payment_cred() {
    const ret = wasm$1.address_payment_cred(this.__wbg_ptr);
    return ret === 0 ? undefined : Credential.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  is_malformed() {
    const ret = wasm$1.address_is_malformed(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.address_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Address}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.address_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.address_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string | undefined} [prefix]
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      var ptr0 = isLikeNone$1(prefix) ? 0 : passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      var len0 = WASM_VECTOR_LEN$1;
      wasm$1.address_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {Address}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.address_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  network_id() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.address_network_id(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const AnchorFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_anchor_free(ptr >>> 0));
/**
 */
class Anchor {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Anchor.prototype);
    obj.__wbg_ptr = ptr;
    AnchorFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AnchorFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_anchor_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchor_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Anchor}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchor_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Anchor.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchor_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Anchor}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchor_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Anchor.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchor_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchor_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Anchor}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchor_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Anchor.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {URL}
   */
  url() {
    const ret = wasm$1.anchor_url(this.__wbg_ptr);
    return URL$1.__wrap(ret);
  }
  /**
   * @returns {AnchorDataHash}
   */
  anchor_data_hash() {
    const ret = wasm$1.anchor_anchor_data_hash(this.__wbg_ptr);
    return AnchorDataHash.__wrap(ret);
  }
  /**
   * @param {URL} anchor_url
   * @param {AnchorDataHash} anchor_data_hash
   * @returns {Anchor}
   */
  static new(anchor_url, anchor_data_hash) {
    _assertClass$1(anchor_url, URL$1);
    _assertClass$1(anchor_data_hash, AnchorDataHash);
    const ret = wasm$1.anchor_new(anchor_url.__wbg_ptr, anchor_data_hash.__wbg_ptr);
    return Anchor.__wrap(ret);
  }
}

const AnchorDataHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_anchordatahash_free(ptr >>> 0));
/**
 */
class AnchorDataHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(AnchorDataHash.prototype);
    obj.__wbg_ptr = ptr;
    AnchorDataHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AnchorDataHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_anchordatahash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AnchorDataHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AnchorDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {AnchorDataHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AnchorDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {AnchorDataHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AnchorDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const AssetNameFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_assetname_free(ptr >>> 0));
/**
 */
class AssetName {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(AssetName.prototype);
    obj.__wbg_ptr = ptr;
    AssetNameFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AssetNameFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_assetname_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetname_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AssetName}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetname_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetname_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {AssetName}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetname_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetname_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetname_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {AssetName}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetname_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} name
   * @returns {AssetName}
   */
  static new(name) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(name, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetname_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  name() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetname_name(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const AssetNamesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_assetnames_free(ptr >>> 0));
/**
 */
class AssetNames {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(AssetNames.prototype);
    obj.__wbg_ptr = ptr;
    AssetNamesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AssetNamesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_assetnames_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetnames_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AssetNames}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetnames_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetNames.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetnames_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {AssetNames}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetnames_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetNames.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetnames_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assetnames_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {AssetNames}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assetnames_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AssetNames.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {AssetNames}
   */
  static new() {
    const ret = wasm$1.assetnames_new();
    return AssetNames.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {AssetName}
   */
  get(index) {
    const ret = wasm$1.assetnames_get(this.__wbg_ptr, index);
    return AssetName.__wrap(ret);
  }
  /**
   * @param {AssetName} elem
   */
  add(elem) {
    _assertClass$1(elem, AssetName);
    wasm$1.assetnames_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const AssetsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_assets_free(ptr >>> 0));
/**
 */
class Assets {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Assets.prototype);
    obj.__wbg_ptr = ptr;
    AssetsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AssetsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_assets_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assets_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Assets}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assets_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Assets.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assets_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Assets}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assets_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Assets.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assets_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.assets_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Assets}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.assets_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Assets.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Assets}
   */
  static new() {
    const ret = wasm$1.assets_new();
    return Assets.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {AssetName} key
   * @param {BigNum} value
   * @returns {BigNum | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, AssetName);
    _assertClass$1(value, BigNum$1);
    const ret = wasm$1.assets_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {AssetName} key
   * @returns {BigNum | undefined}
   */
  get(key) {
    _assertClass$1(key, AssetName);
    const ret = wasm$1.assets_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @returns {AssetNames}
   */
  keys() {
    const ret = wasm$1.assets_keys(this.__wbg_ptr);
    return AssetNames.__wrap(ret);
  }
}

const AuxiliaryDataFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_auxiliarydata_free(ptr >>> 0));
/**
 */
class AuxiliaryData {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(AuxiliaryData.prototype);
    obj.__wbg_ptr = ptr;
    AuxiliaryDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AuxiliaryDataFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_auxiliarydata_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.auxiliarydata_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AuxiliaryData}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.auxiliarydata_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AuxiliaryData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.auxiliarydata_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {AuxiliaryData}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.auxiliarydata_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AuxiliaryData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.auxiliarydata_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.auxiliarydata_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {AuxiliaryData}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.auxiliarydata_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AuxiliaryData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {AuxiliaryData}
   */
  static new() {
    const ret = wasm$1.auxiliarydata_new();
    return AuxiliaryData.__wrap(ret);
  }
  /**
   * @returns {GeneralTransactionMetadata | undefined}
   */
  metadata() {
    const ret = wasm$1.auxiliarydata_metadata(this.__wbg_ptr);
    return ret === 0 ? undefined : GeneralTransactionMetadata.__wrap(ret);
  }
  /**
   * @param {GeneralTransactionMetadata} metadata
   */
  set_metadata(metadata) {
    _assertClass$1(metadata, GeneralTransactionMetadata);
    wasm$1.auxiliarydata_set_metadata(this.__wbg_ptr, metadata.__wbg_ptr);
  }
  /**
   * @returns {NativeScripts | undefined}
   */
  native_scripts() {
    const ret = wasm$1.auxiliarydata_native_scripts(this.__wbg_ptr);
    return ret === 0 ? undefined : NativeScripts.__wrap(ret);
  }
  /**
   * @param {NativeScripts} native_scripts
   */
  set_native_scripts(native_scripts) {
    _assertClass$1(native_scripts, NativeScripts);
    wasm$1.auxiliarydata_set_native_scripts(this.__wbg_ptr, native_scripts.__wbg_ptr);
  }
  /**
   * @returns {PlutusScripts | undefined}
   */
  plutus_scripts() {
    const ret = wasm$1.auxiliarydata_plutus_scripts(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusScripts.__wrap(ret);
  }
  /**
   * @param {PlutusScripts} plutus_scripts
   */
  set_plutus_scripts(plutus_scripts) {
    _assertClass$1(plutus_scripts, PlutusScripts);
    wasm$1.auxiliarydata_set_plutus_scripts(this.__wbg_ptr, plutus_scripts.__wbg_ptr);
  }
  /**
   * @returns {boolean}
   */
  prefer_alonzo_format() {
    const ret = wasm$1.auxiliarydata_prefer_alonzo_format(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {boolean} prefer
   */
  set_prefer_alonzo_format(prefer) {
    wasm$1.auxiliarydata_set_prefer_alonzo_format(this.__wbg_ptr, prefer);
  }
}

const AuxiliaryDataHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_auxiliarydatahash_free(ptr >>> 0));
/**
 */
class AuxiliaryDataHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(AuxiliaryDataHash.prototype);
    obj.__wbg_ptr = ptr;
    AuxiliaryDataHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    AuxiliaryDataHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_auxiliarydatahash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {AuxiliaryDataHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.auxiliarydatahash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AuxiliaryDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {AuxiliaryDataHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.auxiliarydatahash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AuxiliaryDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {AuxiliaryDataHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.auxiliarydatahash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return AuxiliaryDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_auxiliarydataset_free(ptr >>> 0));

const BaseAddressFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_baseaddress_free(ptr >>> 0));
/**
 */
class BaseAddress {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(BaseAddress.prototype);
    obj.__wbg_ptr = ptr;
    BaseAddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BaseAddressFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_baseaddress_free(ptr);
  }
  /**
   * @param {number} network
   * @param {Credential} payment
   * @param {Credential} stake
   * @returns {BaseAddress}
   */
  static new(network, payment, stake) {
    _assertClass$1(payment, Credential);
    _assertClass$1(stake, Credential);
    const ret = wasm$1.baseaddress_new(network, payment.__wbg_ptr, stake.__wbg_ptr);
    return BaseAddress.__wrap(ret);
  }
  /**
   * @returns {Credential}
   */
  payment_cred() {
    const ret = wasm$1.baseaddress_payment_cred(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Credential}
   */
  stake_cred() {
    const ret = wasm$1.baseaddress_stake_cred(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Address}
   */
  to_address() {
    const ret = wasm$1.baseaddress_to_address(this.__wbg_ptr);
    return Address.__wrap(ret);
  }
  /**
   * @param {Address} addr
   * @returns {BaseAddress | undefined}
   */
  static from_address(addr) {
    _assertClass$1(addr, Address);
    const ret = wasm$1.baseaddress_from_address(addr.__wbg_ptr);
    return ret === 0 ? undefined : BaseAddress.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  network_id() {
    const ret = wasm$1.baseaddress_network_id(this.__wbg_ptr);
    return ret;
  }
}

const BigIntFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_bigint_free(ptr >>> 0));
/**
 */
let BigInt$1 = class BigInt {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(BigInt.prototype);
    obj.__wbg_ptr = ptr;
    BigIntFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BigIntFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_bigint_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bigint_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {BigInt}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bigint_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigInt.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bigint_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {BigInt}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bigint_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigInt.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bigint_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bigint_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {BigInt}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bigint_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigInt.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {boolean}
   */
  is_zero() {
    const ret = wasm$1.bigint_is_zero(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {BigNum | undefined}
   */
  as_u64() {
    const ret = wasm$1.bigint_as_u64(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @returns {Int | undefined}
   */
  as_int() {
    const ret = wasm$1.bigint_as_int(this.__wbg_ptr);
    return ret === 0 ? undefined : Int$1.__wrap(ret);
  }
  /**
   * @param {string} text
   * @returns {BigInt}
   */
  static from_str(text) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(text, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bigint_from_str(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigInt.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_str() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bigint_to_str(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {BigInt} other
   * @returns {BigInt}
   */
  add(other) {
    _assertClass$1(other, BigInt);
    const ret = wasm$1.bigint_add(this.__wbg_ptr, other.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
  /**
   * @param {BigInt} other
   * @returns {BigInt}
   */
  sub(other) {
    _assertClass$1(other, BigInt);
    const ret = wasm$1.bigint_sub(this.__wbg_ptr, other.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
  /**
   * @param {BigInt} other
   * @returns {BigInt}
   */
  mul(other) {
    _assertClass$1(other, BigInt);
    const ret = wasm$1.bigint_mul(this.__wbg_ptr, other.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
  /**
   * @param {number} exp
   * @returns {BigInt}
   */
  pow(exp) {
    const ret = wasm$1.bigint_pow(this.__wbg_ptr, exp);
    return BigInt.__wrap(ret);
  }
  /**
   * @returns {BigInt}
   */
  static one() {
    const ret = wasm$1.bigint_one();
    return BigInt.__wrap(ret);
  }
  /**
   * @returns {BigInt}
   */
  static zero() {
    const ret = wasm$1.bigint_zero();
    return BigInt.__wrap(ret);
  }
  /**
   * @returns {BigInt}
   */
  abs() {
    const ret = wasm$1.bigint_abs(this.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
  /**
   * @returns {BigInt}
   */
  increment() {
    const ret = wasm$1.bigint_increment(this.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
  /**
   * @param {BigInt} other
   * @returns {BigInt}
   */
  div_ceil(other) {
    _assertClass$1(other, BigInt);
    const ret = wasm$1.bigint_div_ceil(this.__wbg_ptr, other.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
  /**
   * @param {BigInt} other
   * @returns {BigInt}
   */
  div_floor(other) {
    _assertClass$1(other, BigInt);
    const ret = wasm$1.bigint_div_floor(this.__wbg_ptr, other.__wbg_ptr);
    return BigInt.__wrap(ret);
  }
};

const BigNumFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_bignum_free(ptr >>> 0));
/**
 */
let BigNum$1 = class BigNum {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(BigNum.prototype);
    obj.__wbg_ptr = ptr;
    BigNumFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BigNumFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_bignum_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bignum_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {BigNum}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bignum_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bignum_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {BigNum}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bignum_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bignum_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bignum_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {BigNum}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bignum_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} string
   * @returns {BigNum}
   */
  static from_str(string) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(string, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bignum_from_str(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_str() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bignum_to_str(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {BigNum}
   */
  static zero() {
    const ret = wasm$1.bignum_zero();
    return BigNum.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  static one() {
    const ret = wasm$1.bignum_one();
    return BigNum.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  is_zero() {
    const ret = wasm$1.bignum_is_zero(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  div_floor(other) {
    _assertClass$1(other, BigNum);
    const ret = wasm$1.bignum_div_floor(this.__wbg_ptr, other.__wbg_ptr);
    return BigNum.__wrap(ret);
  }
  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  checked_mul(other) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(other, BigNum);
      wasm$1.bignum_checked_mul(retptr, this.__wbg_ptr, other.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  checked_add(other) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(other, BigNum);
      wasm$1.bignum_checked_add(retptr, this.__wbg_ptr, other.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} other
   * @returns {BigNum}
   */
  checked_sub(other) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(other, BigNum);
      wasm$1.bignum_checked_sub(retptr, this.__wbg_ptr, other.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BigNum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * returns 0 if it would otherwise underflow
   * @param {BigNum} other
   * @returns {BigNum}
   */
  clamped_sub(other) {
    _assertClass$1(other, BigNum);
    const ret = wasm$1.bignum_clamped_sub(this.__wbg_ptr, other.__wbg_ptr);
    return BigNum.__wrap(ret);
  }
  /**
   * @param {BigNum} rhs_value
   * @returns {number}
   */
  compare(rhs_value) {
    _assertClass$1(rhs_value, BigNum);
    const ret = wasm$1.bignum_compare(this.__wbg_ptr, rhs_value.__wbg_ptr);
    return ret;
  }
  /**
   * @param {BigNum} rhs_value
   * @returns {boolean}
   */
  less_than(rhs_value) {
    _assertClass$1(rhs_value, BigNum);
    const ret = wasm$1.bignum_less_than(this.__wbg_ptr, rhs_value.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {BigNum}
   */
  static max_value() {
    const ret = wasm$1.bignum_max_value();
    return BigNum.__wrap(ret);
  }
  /**
   * @param {BigNum} a
   * @param {BigNum} b
   * @returns {BigNum}
   */
  static max(a, b) {
    _assertClass$1(a, BigNum);
    _assertClass$1(b, BigNum);
    const ret = wasm$1.bignum_max(a.__wbg_ptr, b.__wbg_ptr);
    return BigNum.__wrap(ret);
  }
};

const Bip32PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_bip32privatekey_free(ptr >>> 0));
/**
 */
class Bip32PrivateKey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Bip32PrivateKey.prototype);
    obj.__wbg_ptr = ptr;
    Bip32PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Bip32PrivateKeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_bip32privatekey_free(ptr);
  }
  /**
   * derive this private key with the given index.
   *
   * # Security considerations
   *
   * * hard derivation index cannot be soft derived with the public key
   *
   * # Hard derivation vs Soft derivation
   *
   * If you pass an index below 0x80000000 then it is a soft derivation.
   * The advantage of soft derivation is that it is possible to derive the
   * public key too. I.e. derivation the private key with a soft derivation
   * index and then retrieving the associated public key is equivalent to
   * deriving the public key associated to the parent private key.
   *
   * Hard derivation index does not allow public key derivation.
   *
   * This is why deriving the private key should not fail while deriving
   * the public key may fail (if the derivation index is invalid).
   * @param {number} index
   * @returns {Bip32PrivateKey}
   */
  derive(index) {
    const ret = wasm$1.bip32privatekey_derive(this.__wbg_ptr, index);
    return Bip32PrivateKey.__wrap(ret);
  }
  /**
   * 128-byte xprv a key format in Cardano that some software still uses or requires
   * the traditional 96-byte xprv is simply encoded as
   * prv | chaincode
   * however, because some software may not know how to compute a public key from a private key,
   * the 128-byte inlines the public key in the following format
   * prv | pub | chaincode
   * so be careful if you see the term "xprv" as it could refer to either one
   * our library does not require the pub (instead we compute the pub key when needed)
   * @param {Uint8Array} bytes
   * @returns {Bip32PrivateKey}
   */
  static from_128_xprv(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32privatekey_from_128_xprv(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * see from_128_xprv
   * @returns {Uint8Array}
   */
  to_128_xprv() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32privatekey_to_128_xprv(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Bip32PrivateKey}
   */
  static generate_ed25519_bip32() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32privatekey_generate_ed25519_bip32(retptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PrivateKey}
   */
  to_raw_key() {
    const ret = wasm$1.bip32privatekey_to_raw_key(this.__wbg_ptr);
    return PrivateKey.__wrap(ret);
  }
  /**
   * @returns {Bip32PublicKey}
   */
  to_public() {
    const ret = wasm$1.bip32privatekey_to_public(this.__wbg_ptr);
    return Bip32PublicKey.__wrap(ret);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Bip32PrivateKey}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32privatekey_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32privatekey_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} bech32_str
   * @returns {Bip32PrivateKey}
   */
  static from_bech32(bech32_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech32_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32privatekey_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_bech32() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32privatekey_to_bech32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {Uint8Array} entropy
   * @param {Uint8Array} password
   * @returns {Bip32PrivateKey}
   */
  static from_bip39_entropy(entropy, password) {
    const ptr0 = passArray8ToWasm0$1(entropy, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ptr1 = passArray8ToWasm0$1(password, wasm$1.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.bip32privatekey_from_bip39_entropy(ptr0, len0, ptr1, len1);
    return Bip32PrivateKey.__wrap(ret);
  }
  /**
   * @returns {Uint8Array}
   */
  chaincode() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32privatekey_chaincode(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32privatekey_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Bip32PrivateKey}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32privatekey_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const Bip32PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_bip32publickey_free(ptr >>> 0));
/**
 */
class Bip32PublicKey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Bip32PublicKey.prototype);
    obj.__wbg_ptr = ptr;
    Bip32PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Bip32PublicKeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_bip32publickey_free(ptr);
  }
  /**
   * @param {string} hex_str
   * @returns {Bip32PublicKey}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32publickey_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32publickey_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  chaincode() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32publickey_chaincode(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_bech32() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32publickey_to_bech32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} bech32_str
   * @returns {Bip32PublicKey}
   */
  static from_bech32(bech32_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech32_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32publickey_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32publickey_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Bip32PublicKey}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bip32publickey_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PublicKey}
   */
  to_raw_key() {
    const ret = wasm$1.bip32publickey_to_raw_key(this.__wbg_ptr);
    return PublicKey.__wrap(ret);
  }
  /**
   * derive this public key with the given index.
   *
   * # Errors
   *
   * If the index is not a soft derivation index (< 0x80000000) then
   * calling this method will fail.
   *
   * # Security considerations
   *
   * * hard derivation index cannot be soft derived with the public key
   *
   * # Hard derivation vs Soft derivation
   *
   * If you pass an index below 0x80000000 then it is a soft derivation.
   * The advantage of soft derivation is that it is possible to derive the
   * public key too. I.e. derivation the private key with a soft derivation
   * index and then retrieving the associated public key is equivalent to
   * deriving the public key associated to the parent private key.
   *
   * Hard derivation index does not allow public key derivation.
   *
   * This is why deriving the private key should not fail while deriving
   * the public key may fail (if the derivation index is invalid).
   * @param {number} index
   * @returns {Bip32PublicKey}
   */
  derive(index) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bip32publickey_derive(retptr, this.__wbg_ptr, index);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Bip32PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_block_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_blockhash_free(ptr >>> 0));

const BootstrapWitnessFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_bootstrapwitness_free(ptr >>> 0));
/**
 */
class BootstrapWitness {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(BootstrapWitness.prototype);
    obj.__wbg_ptr = ptr;
    BootstrapWitnessFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BootstrapWitnessFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_bootstrapwitness_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitness_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {BootstrapWitness}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bootstrapwitness_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BootstrapWitness.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitness_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {BootstrapWitness}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bootstrapwitness_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BootstrapWitness.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitness_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitness_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {BootstrapWitness}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bootstrapwitness_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BootstrapWitness.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Vkey}
   */
  vkey() {
    const ret = wasm$1.bootstrapwitness_vkey(this.__wbg_ptr);
    return Vkey.__wrap(ret);
  }
  /**
   * @returns {Ed25519Signature}
   */
  signature() {
    const ret = wasm$1.bootstrapwitness_signature(this.__wbg_ptr);
    return Ed25519Signature.__wrap(ret);
  }
  /**
   * @returns {Uint8Array}
   */
  chain_code() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitness_chain_code(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  attributes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitness_attributes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Vkey} vkey
   * @param {Ed25519Signature} signature
   * @param {Uint8Array} chain_code
   * @param {Uint8Array} attributes
   * @returns {BootstrapWitness}
   */
  static new(vkey, signature, chain_code, attributes) {
    _assertClass$1(vkey, Vkey);
    _assertClass$1(signature, Ed25519Signature);
    const ptr0 = passArray8ToWasm0$1(chain_code, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ptr1 = passArray8ToWasm0$1(attributes, wasm$1.__wbindgen_malloc);
    const len1 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.bootstrapwitness_new(vkey.__wbg_ptr, signature.__wbg_ptr, ptr0, len0, ptr1, len1);
    return BootstrapWitness.__wrap(ret);
  }
}

const BootstrapWitnessesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_bootstrapwitnesses_free(ptr >>> 0));
/**
 */
class BootstrapWitnesses {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(BootstrapWitnesses.prototype);
    obj.__wbg_ptr = ptr;
    BootstrapWitnessesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    BootstrapWitnessesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_bootstrapwitnesses_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitnesses_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {BootstrapWitnesses}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bootstrapwitnesses_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BootstrapWitnesses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitnesses_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {BootstrapWitnesses}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bootstrapwitnesses_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BootstrapWitnesses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitnesses_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.bootstrapwitnesses_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {BootstrapWitnesses}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.bootstrapwitnesses_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return BootstrapWitnesses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BootstrapWitnesses}
   */
  static new() {
    const ret = wasm$1.bootstrapwitnesses_new();
    return BootstrapWitnesses.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.bootstrapwitnesses_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {BootstrapWitness}
   */
  get(index) {
    const ret = wasm$1.bootstrapwitnesses_get(this.__wbg_ptr, index);
    return BootstrapWitness.__wrap(ret);
  }
  /**
   * Add a new `BootstrapWitness` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {BootstrapWitness} witness
   * @returns {boolean}
   */
  add(witness) {
    _assertClass$1(witness, BootstrapWitness);
    const ret = wasm$1.bootstrapwitnesses_add(this.__wbg_ptr, witness.__wbg_ptr);
    return ret !== 0;
  }
}

const ByronAddressFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_byronaddress_free(ptr >>> 0));
/**
 */
class ByronAddress {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ByronAddress.prototype);
    obj.__wbg_ptr = ptr;
    ByronAddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ByronAddressFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_byronaddress_free(ptr);
  }
  /**
   * @returns {string}
   */
  to_base58() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.byronaddress_to_base58(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.byronaddress_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ByronAddress}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.byronaddress_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ByronAddress.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * returns the byron protocol magic embedded in the address, or mainnet id if none is present
   * note: for bech32 addresses, you need to use network_id instead
   * @returns {number}
   */
  byron_protocol_magic() {
    const ret = wasm$1.byronaddress_byron_protocol_magic(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {Uint8Array}
   */
  attributes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.byronaddress_attributes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  network_id() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.byronaddress_network_id(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} s
   * @returns {ByronAddress}
   */
  static from_base58(s) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(s, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.byronaddress_from_base58(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ByronAddress.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Bip32PublicKey} key
   * @param {number} protocol_magic
   * @returns {ByronAddress}
   */
  static icarus_from_key(key, protocol_magic) {
    _assertClass$1(key, Bip32PublicKey);
    const ret = wasm$1.byronaddress_icarus_from_key(key.__wbg_ptr, protocol_magic);
    return ByronAddress.__wrap(ret);
  }
  /**
   * @param {string} s
   * @returns {boolean}
   */
  static is_valid(s) {
    const ptr0 = passStringToWasm0$1(s, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.byronaddress_is_valid(ptr0, len0);
    return ret !== 0;
  }
  /**
   * @returns {Address}
   */
  to_address() {
    const ret = wasm$1.byronaddress_to_address(this.__wbg_ptr);
    return Address.__wrap(ret);
  }
  /**
   * @param {Address} addr
   * @returns {ByronAddress | undefined}
   */
  static from_address(addr) {
    _assertClass$1(addr, Address);
    const ret = wasm$1.byronaddress_from_address(addr.__wbg_ptr);
    return ret === 0 ? undefined : ByronAddress.__wrap(ret);
  }
}

const CertificateFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_certificate_free(ptr >>> 0));
/**
 */
class Certificate {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Certificate.prototype);
    obj.__wbg_ptr = ptr;
    CertificateFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CertificateFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_certificate_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificate_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Certificate}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.certificate_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificate_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Certificate}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.certificate_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificate_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificate_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Certificate}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.certificate_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {StakeRegistration} stake_registration
   * @returns {Certificate}
   */
  static new_stake_registration(stake_registration) {
    _assertClass$1(stake_registration, StakeRegistration);
    const ret = wasm$1.certificate_new_stake_registration(stake_registration.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * Since StakeRegistration can represent stake_registration certificate or reg_cert certificate, because both certificates have the same semantics.
   * And in some cases you want to create a reg_cert, this function is used to create a reg_cert.
   * The function will return an error if StakeRegistration represents a stake_registration certificate.
   * @param {StakeRegistration} stake_registration
   * @returns {Certificate}
   */
  static new_reg_cert(stake_registration) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(stake_registration, StakeRegistration);
      wasm$1.certificate_new_reg_cert(retptr, stake_registration.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {StakeDeregistration} stake_deregistration
   * @returns {Certificate}
   */
  static new_stake_deregistration(stake_deregistration) {
    _assertClass$1(stake_deregistration, StakeDeregistration);
    const ret = wasm$1.certificate_new_stake_deregistration(stake_deregistration.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * Since StakeDeregistration can represent stake_deregistration certificate or unreg_cert certificate, because both certificates have the same semantics.
   * And in some cases you want to create an unreg_cert, this function is used to create an unreg_cert.
   * The function will return an error if StakeDeregistration represents a stake_deregistration certificate.
   * @param {StakeDeregistration} stake_deregistration
   * @returns {Certificate}
   */
  static new_unreg_cert(stake_deregistration) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(stake_deregistration, StakeDeregistration);
      wasm$1.certificate_new_unreg_cert(retptr, stake_deregistration.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {StakeDelegation} stake_delegation
   * @returns {Certificate}
   */
  static new_stake_delegation(stake_delegation) {
    _assertClass$1(stake_delegation, StakeDelegation);
    const ret = wasm$1.certificate_new_stake_delegation(stake_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {PoolRegistration} pool_registration
   * @returns {Certificate}
   */
  static new_pool_registration(pool_registration) {
    _assertClass$1(pool_registration, PoolRegistration);
    const ret = wasm$1.certificate_new_pool_registration(pool_registration.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {PoolRetirement} pool_retirement
   * @returns {Certificate}
   */
  static new_pool_retirement(pool_retirement) {
    _assertClass$1(pool_retirement, PoolRetirement);
    const ret = wasm$1.certificate_new_pool_retirement(pool_retirement.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {GenesisKeyDelegation} genesis_key_delegation
   * @returns {Certificate}
   */
  static new_genesis_key_delegation(genesis_key_delegation) {
    _assertClass$1(genesis_key_delegation, GenesisKeyDelegation);
    const ret = wasm$1.certificate_new_genesis_key_delegation(genesis_key_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {MoveInstantaneousRewardsCert} move_instantaneous_rewards_cert
   * @returns {Certificate}
   */
  static new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert) {
    _assertClass$1(move_instantaneous_rewards_cert, MoveInstantaneousRewardsCert);
    const ret = wasm$1.certificate_new_move_instantaneous_rewards_cert(move_instantaneous_rewards_cert.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {CommitteeHotAuth} committee_hot_auth
   * @returns {Certificate}
   */
  static new_committee_hot_auth(committee_hot_auth) {
    _assertClass$1(committee_hot_auth, CommitteeHotAuth);
    const ret = wasm$1.certificate_new_committee_hot_auth(committee_hot_auth.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {CommitteeColdResign} committee_cold_resign
   * @returns {Certificate}
   */
  static new_committee_cold_resign(committee_cold_resign) {
    _assertClass$1(committee_cold_resign, CommitteeColdResign);
    const ret = wasm$1.certificate_new_committee_cold_resign(committee_cold_resign.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {DRepDeregistration} drep_deregistration
   * @returns {Certificate}
   */
  static new_drep_deregistration(drep_deregistration) {
    _assertClass$1(drep_deregistration, DRepDeregistration);
    const ret = wasm$1.certificate_new_drep_deregistration(drep_deregistration.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {DRepRegistration} drep_registration
   * @returns {Certificate}
   */
  static new_drep_registration(drep_registration) {
    _assertClass$1(drep_registration, DRepRegistration);
    const ret = wasm$1.certificate_new_drep_registration(drep_registration.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {DRepUpdate} drep_update
   * @returns {Certificate}
   */
  static new_drep_update(drep_update) {
    _assertClass$1(drep_update, DRepUpdate);
    const ret = wasm$1.certificate_new_drep_update(drep_update.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {StakeAndVoteDelegation} stake_and_vote_delegation
   * @returns {Certificate}
   */
  static new_stake_and_vote_delegation(stake_and_vote_delegation) {
    _assertClass$1(stake_and_vote_delegation, StakeAndVoteDelegation);
    const ret = wasm$1.certificate_new_stake_and_vote_delegation(stake_and_vote_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {StakeRegistrationAndDelegation} stake_registration_and_delegation
   * @returns {Certificate}
   */
  static new_stake_registration_and_delegation(stake_registration_and_delegation) {
    _assertClass$1(stake_registration_and_delegation, StakeRegistrationAndDelegation);
    const ret = wasm$1.certificate_new_stake_registration_and_delegation(stake_registration_and_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {StakeVoteRegistrationAndDelegation} stake_vote_registration_and_delegation
   * @returns {Certificate}
   */
  static new_stake_vote_registration_and_delegation(stake_vote_registration_and_delegation) {
    _assertClass$1(stake_vote_registration_and_delegation, StakeVoteRegistrationAndDelegation);
    const ret = wasm$1.certificate_new_stake_vote_registration_and_delegation(stake_vote_registration_and_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {VoteDelegation} vote_delegation
   * @returns {Certificate}
   */
  static new_vote_delegation(vote_delegation) {
    _assertClass$1(vote_delegation, VoteDelegation);
    const ret = wasm$1.certificate_new_vote_delegation(vote_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @param {VoteRegistrationAndDelegation} vote_registration_and_delegation
   * @returns {Certificate}
   */
  static new_vote_registration_and_delegation(vote_registration_and_delegation) {
    _assertClass$1(vote_registration_and_delegation, VoteRegistrationAndDelegation);
    const ret = wasm$1.certificate_new_vote_registration_and_delegation(vote_registration_and_delegation.__wbg_ptr);
    return Certificate.__wrap(ret);
  }
  /**
   * @returns {CertificateKind}
   */
  kind() {
    const ret = wasm$1.certificate_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {StakeRegistration | undefined}
   */
  as_stake_registration() {
    const ret = wasm$1.certificate_as_stake_registration(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeRegistration.__wrap(ret);
  }
  /**
   * Since StakeRegistration can represent stake_registration certificate or reg_cert certificate, because both certificates have the same semantics.
   * And in some cases you want to get a reg_cert, this function is used to get a reg_cert.
   * The function will return None if StakeRegistration represents a stake_registration certificate or Certificate is not a StakeRegistration.
   * @returns {StakeRegistration | undefined}
   */
  as_reg_cert() {
    const ret = wasm$1.certificate_as_reg_cert(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeRegistration.__wrap(ret);
  }
  /**
   * @returns {StakeDeregistration | undefined}
   */
  as_stake_deregistration() {
    const ret = wasm$1.certificate_as_stake_deregistration(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);
  }
  /**
   * Since StakeDeregistration can represent stake_deregistration certificate or unreg_cert certificate, because both certificates have the same semantics.
   * And in some cases you want to get an unreg_cert, this function is used to get an unreg_cert.
   * The function will return None if StakeDeregistration represents a stake_deregistration certificate or Certificate is not a StakeDeregistration.
   * @returns {StakeDeregistration | undefined}
   */
  as_unreg_cert() {
    const ret = wasm$1.certificate_as_unreg_cert(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeDeregistration.__wrap(ret);
  }
  /**
   * @returns {StakeDelegation | undefined}
   */
  as_stake_delegation() {
    const ret = wasm$1.certificate_as_stake_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeDelegation.__wrap(ret);
  }
  /**
   * @returns {PoolRegistration | undefined}
   */
  as_pool_registration() {
    const ret = wasm$1.certificate_as_pool_registration(this.__wbg_ptr);
    return ret === 0 ? undefined : PoolRegistration.__wrap(ret);
  }
  /**
   * @returns {PoolRetirement | undefined}
   */
  as_pool_retirement() {
    const ret = wasm$1.certificate_as_pool_retirement(this.__wbg_ptr);
    return ret === 0 ? undefined : PoolRetirement.__wrap(ret);
  }
  /**
   * @returns {GenesisKeyDelegation | undefined}
   */
  as_genesis_key_delegation() {
    const ret = wasm$1.certificate_as_genesis_key_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : GenesisKeyDelegation.__wrap(ret);
  }
  /**
   * @returns {MoveInstantaneousRewardsCert | undefined}
   */
  as_move_instantaneous_rewards_cert() {
    const ret = wasm$1.certificate_as_move_instantaneous_rewards_cert(this.__wbg_ptr);
    return ret === 0 ? undefined : MoveInstantaneousRewardsCert.__wrap(ret);
  }
  /**
   * @returns {CommitteeHotAuth | undefined}
   */
  as_committee_hot_auth() {
    const ret = wasm$1.certificate_as_committee_hot_auth(this.__wbg_ptr);
    return ret === 0 ? undefined : CommitteeHotAuth.__wrap(ret);
  }
  /**
   * @returns {CommitteeColdResign | undefined}
   */
  as_committee_cold_resign() {
    const ret = wasm$1.certificate_as_committee_cold_resign(this.__wbg_ptr);
    return ret === 0 ? undefined : CommitteeColdResign.__wrap(ret);
  }
  /**
   * @returns {DRepDeregistration | undefined}
   */
  as_drep_deregistration() {
    const ret = wasm$1.certificate_as_drep_deregistration(this.__wbg_ptr);
    return ret === 0 ? undefined : DRepDeregistration.__wrap(ret);
  }
  /**
   * @returns {DRepRegistration | undefined}
   */
  as_drep_registration() {
    const ret = wasm$1.certificate_as_drep_registration(this.__wbg_ptr);
    return ret === 0 ? undefined : DRepRegistration.__wrap(ret);
  }
  /**
   * @returns {DRepUpdate | undefined}
   */
  as_drep_update() {
    const ret = wasm$1.certificate_as_drep_update(this.__wbg_ptr);
    return ret === 0 ? undefined : DRepUpdate.__wrap(ret);
  }
  /**
   * @returns {StakeAndVoteDelegation | undefined}
   */
  as_stake_and_vote_delegation() {
    const ret = wasm$1.certificate_as_stake_and_vote_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeAndVoteDelegation.__wrap(ret);
  }
  /**
   * @returns {StakeRegistrationAndDelegation | undefined}
   */
  as_stake_registration_and_delegation() {
    const ret = wasm$1.certificate_as_stake_registration_and_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeRegistrationAndDelegation.__wrap(ret);
  }
  /**
   * @returns {StakeVoteRegistrationAndDelegation | undefined}
   */
  as_stake_vote_registration_and_delegation() {
    const ret = wasm$1.certificate_as_stake_vote_registration_and_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : StakeVoteRegistrationAndDelegation.__wrap(ret);
  }
  /**
   * @returns {VoteDelegation | undefined}
   */
  as_vote_delegation() {
    const ret = wasm$1.certificate_as_vote_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : VoteDelegation.__wrap(ret);
  }
  /**
   * @returns {VoteRegistrationAndDelegation | undefined}
   */
  as_vote_registration_and_delegation() {
    const ret = wasm$1.certificate_as_vote_registration_and_delegation(this.__wbg_ptr);
    return ret === 0 ? undefined : VoteRegistrationAndDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_required_script_witness() {
    const ret = wasm$1.certificate_has_required_script_witness(this.__wbg_ptr);
    return ret !== 0;
  }
}

const CertificatesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_certificates_free(ptr >>> 0));
/**
 */
class Certificates {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Certificates.prototype);
    obj.__wbg_ptr = ptr;
    CertificatesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CertificatesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_certificates_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificates_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Certificates}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.certificates_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificates.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificates_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Certificates}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.certificates_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificates.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificates_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.certificates_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Certificates}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.certificates_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Certificates.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Certificates}
   */
  static new() {
    const ret = wasm$1.certificates_new();
    return Certificates.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.certificates_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Certificate}
   */
  get(index) {
    const ret = wasm$1.certificates_get(this.__wbg_ptr, index);
    return Certificate.__wrap(ret);
  }
  /**
   * Add a new `Certificate` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {Certificate} elem
   * @returns {boolean}
   */
  add(elem) {
    _assertClass$1(elem, Certificate);
    const ret = wasm$1.certificates_add(this.__wbg_ptr, elem.__wbg_ptr);
    return ret !== 0;
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_certificatesbuilder_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_changeconfig_free(ptr >>> 0));

const CommitteeFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_committee_free(ptr >>> 0));
/**
 */
class Committee {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Committee.prototype);
    obj.__wbg_ptr = ptr;
    CommitteeFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CommitteeFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_committee_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committee_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Committee}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committee_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Committee.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committee_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Committee}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committee_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Committee.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committee_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committee_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Committee}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committee_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Committee.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {UnitInterval} quorum_threshold
   * @returns {Committee}
   */
  static new(quorum_threshold) {
    _assertClass$1(quorum_threshold, UnitInterval);
    const ret = wasm$1.committee_new(quorum_threshold.__wbg_ptr);
    return Committee.__wrap(ret);
  }
  /**
   * @returns {Credentials}
   */
  members_keys() {
    const ret = wasm$1.committee_members_keys(this.__wbg_ptr);
    return Credentials.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  quorum_threshold() {
    const ret = wasm$1.committee_quorum_threshold(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @param {Credential} committee_cold_credential
   * @param {number} epoch
   */
  add_member(committee_cold_credential, epoch) {
    _assertClass$1(committee_cold_credential, Credential);
    wasm$1.committee_add_member(this.__wbg_ptr, committee_cold_credential.__wbg_ptr, epoch);
  }
  /**
   * @param {Credential} committee_cold_credential
   * @returns {number | undefined}
   */
  get_member_epoch(committee_cold_credential) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(committee_cold_credential, Credential);
      wasm$1.committee_get_member_epoch(retptr, this.__wbg_ptr, committee_cold_credential.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const CommitteeColdResignFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_committeecoldresign_free(ptr >>> 0));
/**
 */
class CommitteeColdResign {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(CommitteeColdResign.prototype);
    obj.__wbg_ptr = ptr;
    CommitteeColdResignFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CommitteeColdResignFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_committeecoldresign_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeecoldresign_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {CommitteeColdResign}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committeecoldresign_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CommitteeColdResign.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeecoldresign_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {CommitteeColdResign}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committeecoldresign_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CommitteeColdResign.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeecoldresign_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeecoldresign_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {CommitteeColdResign}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committeecoldresign_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CommitteeColdResign.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  committee_cold_credential() {
    const ret = wasm$1.committeecoldresign_committee_cold_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Anchor | undefined}
   */
  anchor() {
    const ret = wasm$1.committeecoldresign_anchor(this.__wbg_ptr);
    return ret === 0 ? undefined : Anchor.__wrap(ret);
  }
  /**
   * @param {Credential} committee_cold_credential
   * @returns {CommitteeColdResign}
   */
  static new(committee_cold_credential) {
    _assertClass$1(committee_cold_credential, Credential);
    const ret = wasm$1.committeecoldresign_new(committee_cold_credential.__wbg_ptr);
    return CommitteeColdResign.__wrap(ret);
  }
  /**
   * @param {Credential} committee_cold_credential
   * @param {Anchor} anchor
   * @returns {CommitteeColdResign}
   */
  static new_with_anchor(committee_cold_credential, anchor) {
    _assertClass$1(committee_cold_credential, Credential);
    _assertClass$1(anchor, Anchor);
    const ret = wasm$1.committeecoldresign_new_with_anchor(committee_cold_credential.__wbg_ptr, anchor.__wbg_ptr);
    return CommitteeColdResign.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.committeecoldresign_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const CommitteeHotAuthFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_committeehotauth_free(ptr >>> 0));
/**
 */
class CommitteeHotAuth {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(CommitteeHotAuth.prototype);
    obj.__wbg_ptr = ptr;
    CommitteeHotAuthFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CommitteeHotAuthFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_committeehotauth_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeehotauth_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {CommitteeHotAuth}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committeehotauth_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CommitteeHotAuth.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeehotauth_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {CommitteeHotAuth}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committeehotauth_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CommitteeHotAuth.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeehotauth_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.committeehotauth_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {CommitteeHotAuth}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.committeehotauth_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CommitteeHotAuth.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  committee_cold_credential() {
    const ret = wasm$1.committeehotauth_committee_cold_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Credential}
   */
  committee_hot_credential() {
    const ret = wasm$1.committeehotauth_committee_hot_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @param {Credential} committee_cold_credential
   * @param {Credential} committee_hot_credential
   * @returns {CommitteeHotAuth}
   */
  static new(committee_cold_credential, committee_hot_credential) {
    _assertClass$1(committee_cold_credential, Credential);
    _assertClass$1(committee_hot_credential, Credential);
    const ret = wasm$1.committeehotauth_new(committee_cold_credential.__wbg_ptr, committee_hot_credential.__wbg_ptr);
    return CommitteeHotAuth.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.committeehotauth_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const ConstitutionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_constitution_free(ptr >>> 0));
/**
 */
class Constitution {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Constitution.prototype);
    obj.__wbg_ptr = ptr;
    ConstitutionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ConstitutionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_constitution_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.constitution_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Constitution}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.constitution_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Constitution.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.constitution_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Constitution}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.constitution_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Constitution.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.constitution_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.constitution_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Constitution}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.constitution_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Constitution.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Anchor}
   */
  anchor() {
    const ret = wasm$1.constitution_anchor(this.__wbg_ptr);
    return Anchor.__wrap(ret);
  }
  /**
   * @returns {ScriptHash | undefined}
   */
  script_hash() {
    const ret = wasm$1.constitution_script_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptHash.__wrap(ret);
  }
  /**
   * @param {Anchor} anchor
   * @returns {Constitution}
   */
  static new(anchor) {
    _assertClass$1(anchor, Anchor);
    const ret = wasm$1.constitution_new(anchor.__wbg_ptr);
    return Constitution.__wrap(ret);
  }
  /**
   * @param {Anchor} anchor
   * @param {ScriptHash} script_hash
   * @returns {Constitution}
   */
  static new_with_script_hash(anchor, script_hash) {
    _assertClass$1(anchor, Anchor);
    _assertClass$1(script_hash, ScriptHash);
    const ret = wasm$1.constitution_new_with_script_hash(anchor.__wbg_ptr, script_hash.__wbg_ptr);
    return Constitution.__wrap(ret);
  }
}

const ConstrPlutusDataFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_constrplutusdata_free(ptr >>> 0));
/**
 */
class ConstrPlutusData {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ConstrPlutusData.prototype);
    obj.__wbg_ptr = ptr;
    ConstrPlutusDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ConstrPlutusDataFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_constrplutusdata_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.constrplutusdata_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ConstrPlutusData}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.constrplutusdata_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ConstrPlutusData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.constrplutusdata_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ConstrPlutusData}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.constrplutusdata_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ConstrPlutusData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum}
   */
  alternative() {
    const ret = wasm$1.constrplutusdata_alternative(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {PlutusList}
   */
  data() {
    const ret = wasm$1.constrplutusdata_data(this.__wbg_ptr);
    return PlutusList.__wrap(ret);
  }
  /**
   * @param {BigNum} alternative
   * @param {PlutusList} data
   * @returns {ConstrPlutusData}
   */
  static new(alternative, data) {
    _assertClass$1(alternative, BigNum$1);
    _assertClass$1(data, PlutusList);
    const ret = wasm$1.constrplutusdata_new(alternative.__wbg_ptr, data.__wbg_ptr);
    return ConstrPlutusData.__wrap(ret);
  }
}

const CostModelFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_costmodel_free(ptr >>> 0));
/**
 */
class CostModel {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(CostModel.prototype);
    obj.__wbg_ptr = ptr;
    CostModelFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CostModelFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_costmodel_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmodel_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {CostModel}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.costmodel_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CostModel.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmodel_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {CostModel}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.costmodel_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CostModel.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmodel_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmodel_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {CostModel}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.costmodel_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return CostModel.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Creates a new CostModels instance of an unrestricted length
   * @returns {CostModel}
   */
  static new() {
    const ret = wasm$1.costmodel_new();
    return CostModel.__wrap(ret);
  }
  /**
   * Sets the cost at the specified index to the specified value.
   * In case the operation index is larger than the previous largest used index,
   * it will fill any inbetween indexes with zeroes
   * @param {number} operation
   * @param {Int} cost
   * @returns {Int}
   */
  set(operation, cost) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(cost, Int$1);
      wasm$1.costmodel_set(retptr, this.__wbg_ptr, operation, cost.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int$1.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} operation
   * @returns {Int}
   */
  get(operation) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmodel_get(retptr, this.__wbg_ptr, operation);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int$1.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.certificates_len(this.__wbg_ptr); } else {
      ret = wasm$1.costmodel_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
}

const CostmdlsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_costmdls_free(ptr >>> 0));
/**
 */
class Costmdls {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Costmdls.prototype);
    obj.__wbg_ptr = ptr;
    CostmdlsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CostmdlsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_costmdls_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmdls_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Costmdls}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.costmdls_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Costmdls.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmdls_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Costmdls}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.costmdls_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Costmdls.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmdls_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.costmdls_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Costmdls}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.costmdls_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Costmdls.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Costmdls}
   */
  static new() {
    const ret = wasm$1.costmdls_new();
    return Costmdls.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.costmdls_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {Language} key
   * @param {CostModel} value
   * @returns {CostModel | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, Language);
    _assertClass$1(value, CostModel);
    const ret = wasm$1.costmdls_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : CostModel.__wrap(ret);
  }
  /**
   * @param {Language} key
   * @returns {CostModel | undefined}
   */
  get(key) {
    _assertClass$1(key, Language);
    const ret = wasm$1.costmdls_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : CostModel.__wrap(ret);
  }
  /**
   * @returns {Languages}
   */
  keys() {
    const ret = wasm$1.costmdls_keys(this.__wbg_ptr);
    return Languages.__wrap(ret);
  }
  /**
   * @param {Languages} languages
   * @returns {Costmdls}
   */
  retain_language_versions(languages) {
    _assertClass$1(languages, Languages);
    const ret = wasm$1.costmdls_retain_language_versions(this.__wbg_ptr, languages.__wbg_ptr);
    return Costmdls.__wrap(ret);
  }
}

const CredentialFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_credential_free(ptr >>> 0));
/**
 */
class Credential {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Credential.prototype);
    obj.__wbg_ptr = ptr;
    CredentialFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CredentialFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_credential_free(ptr);
  }
  /**
   * @param {Ed25519KeyHash} hash
   * @returns {Credential}
   */
  static from_keyhash(hash) {
    _assertClass$1(hash, Ed25519KeyHash);
    const ret = wasm$1.credential_from_keyhash(hash.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @param {ScriptHash} hash
   * @returns {Credential}
   */
  static from_scripthash(hash) {
    _assertClass$1(hash, ScriptHash);
    const ret = wasm$1.credential_from_scripthash(hash.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHash | undefined}
   */
  to_keyhash() {
    const ret = wasm$1.credential_to_keyhash(this.__wbg_ptr);
    return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {ScriptHash | undefined}
   */
  to_scripthash() {
    const ret = wasm$1.credential_to_scripthash(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptHash.__wrap(ret);
  }
  /**
   * @returns {CredKind}
   */
  kind() {
    const ret = wasm$1.credential_has_script_hash(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {boolean}
   */
  has_script_hash() {
    const ret = wasm$1.credential_has_script_hash(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credential_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Credential}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.credential_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Credential.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credential_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Credential}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.credential_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Credential.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credential_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credential_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Credential}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.credential_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Credential.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const CredentialsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_credentials_free(ptr >>> 0));
/**
 */
class Credentials {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Credentials.prototype);
    obj.__wbg_ptr = ptr;
    CredentialsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    CredentialsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_credentials_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credentials_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Credentials}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.credentials_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Credentials.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credentials_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Credentials}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.credentials_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Credentials.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credentials_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.credentials_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Credentials}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.credentials_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Credentials.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credentials}
   */
  static new() {
    const ret = wasm$1.credentials_new();
    return Credentials.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.credentials_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Credential}
   */
  get(index) {
    const ret = wasm$1.credentials_get(this.__wbg_ptr, index);
    return Credential.__wrap(ret);
  }
  /**
   * Add a new `Credential` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {Credential} credential
   * @returns {boolean}
   */
  add(credential) {
    _assertClass$1(credential, Credential);
    const ret = wasm$1.credentials_add(this.__wbg_ptr, credential.__wbg_ptr);
    return ret !== 0;
  }
}

const DNSRecordAorAAAAFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_dnsrecordaoraaaa_free(ptr >>> 0));
/**
 */
class DNSRecordAorAAAA {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DNSRecordAorAAAA.prototype);
    obj.__wbg_ptr = ptr;
    DNSRecordAorAAAAFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DNSRecordAorAAAAFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_dnsrecordaoraaaa_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DNSRecordAorAAAA}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordaoraaaa_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordAorAAAA.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DNSRecordAorAAAA}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordaoraaaa_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordAorAAAA.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DNSRecordAorAAAA}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordaoraaaa_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordAorAAAA.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} dns_name
   * @returns {DNSRecordAorAAAA}
   */
  static new(dns_name) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(dns_name, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordaoraaaa_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordAorAAAA.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  record() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_record(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
}

const DNSRecordSRVFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_dnsrecordsrv_free(ptr >>> 0));
/**
 */
class DNSRecordSRV {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DNSRecordSRV.prototype);
    obj.__wbg_ptr = ptr;
    DNSRecordSRVFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DNSRecordSRVFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_dnsrecordsrv_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordsrv_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DNSRecordSRV}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordsrv_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordSRV.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordsrv_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DNSRecordSRV}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordsrv_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordSRV.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DNSRecordSRV}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordsrv_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordSRV.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} dns_name
   * @returns {DNSRecordSRV}
   */
  static new(dns_name) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(dns_name, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.dnsrecordsrv_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DNSRecordSRV.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  record() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_record(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
}

const DRepFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_drep_free(ptr >>> 0));
/**
 */
class DRep {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DRep.prototype);
    obj.__wbg_ptr = ptr;
    DRepFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DRepFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_drep_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drep_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DRep}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drep_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRep.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drep_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DRep}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drep_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRep.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drep_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drep_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DRep}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drep_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRep.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Ed25519KeyHash} key_hash
   * @returns {DRep}
   */
  static new_key_hash(key_hash) {
    _assertClass$1(key_hash, Ed25519KeyHash);
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.drep_new_key_hash(key_hash.__wbg_ptr); } else {
      ret = wasm$1.credential_from_keyhash(key_hash.__wbg_ptr); }
    return DRep.__wrap(ret);
  }
  /**
   * @param {ScriptHash} script_hash
   * @returns {DRep}
   */
  static new_script_hash(script_hash) {
    _assertClass$1(script_hash, ScriptHash);
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.drep_new_script_hash(script_hash.__wbg_ptr); } else {
      ret = wasm$1.credential_from_scripthash(script_hash.__wbg_ptr); }
    return DRep.__wrap(ret);
  }
  /**
   * @returns {DRep}
   */
  static new_always_abstain() {
    const ret = wasm$1.drep_new_always_abstain();
    return DRep.__wrap(ret);
  }
  /**
   * @returns {DRep}
   */
  static new_always_no_confidence() {
    const ret = wasm$1.drep_new_always_no_confidence();
    return DRep.__wrap(ret);
  }
  /**
   * @param {Credential} cred
   * @returns {DRep}
   */
  static new_from_credential(cred) {
    _assertClass$1(cred, Credential);
    const ret = wasm$1.drep_new_from_credential(cred.__wbg_ptr);
    return DRep.__wrap(ret);
  }
  /**
   * @returns {DRepKind}
   */
  kind() {
    const ret = wasm$1.drep_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {Ed25519KeyHash | undefined}
   */
  to_key_hash() {
    const ret = wasm$1.drep_to_key_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {ScriptHash | undefined}
   */
  to_script_hash() {
    const ret = wasm$1.drep_to_script_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptHash.__wrap(ret);
  }
  /**
   * @returns {string}
   */
  to_bech32() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drep_to_bech32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @param {string} bech32_str
   * @returns {DRep}
   */
  static from_bech32(bech32_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech32_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drep_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRep.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const DRepDeregistrationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_drepderegistration_free(ptr >>> 0));
/**
 */
class DRepDeregistration {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DRepDeregistration.prototype);
    obj.__wbg_ptr = ptr;
    DRepDeregistrationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DRepDeregistrationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_drepderegistration_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepderegistration_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DRepDeregistration}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepderegistration_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepDeregistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepderegistration_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DRepDeregistration}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepderegistration_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepDeregistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepderegistration_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepderegistration_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DRepDeregistration}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepderegistration_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepDeregistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  voting_credential() {
    const ret = wasm$1.drepderegistration_voting_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  coin() {
    const ret = wasm$1.drepderegistration_coin(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {Credential} voting_credential
   * @param {BigNum} coin
   * @returns {DRepDeregistration}
   */
  static new(voting_credential, coin) {
    _assertClass$1(voting_credential, Credential);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.drepderegistration_new(voting_credential.__wbg_ptr, coin.__wbg_ptr);
    return DRepDeregistration.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.drepderegistration_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const DRepRegistrationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_drepregistration_free(ptr >>> 0));
/**
 */
class DRepRegistration {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DRepRegistration.prototype);
    obj.__wbg_ptr = ptr;
    DRepRegistrationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DRepRegistrationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_drepregistration_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepregistration_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DRepRegistration}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepregistration_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepregistration_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DRepRegistration}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepregistration_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepregistration_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepregistration_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DRepRegistration}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepregistration_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  voting_credential() {
    const ret = wasm$1.drepregistration_voting_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  coin() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.drepderegistration_coin(this.__wbg_ptr); } else {
      ret = wasm$1.drepregistration_coin(this.__wbg_ptr); }
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {Anchor | undefined}
   */
  anchor() {
    const ret = wasm$1.drepregistration_anchor(this.__wbg_ptr);
    return ret === 0 ? undefined : Anchor.__wrap(ret);
  }
  /**
   * @param {Credential} voting_credential
   * @param {BigNum} coin
   * @returns {DRepRegistration}
   */
  static new(voting_credential, coin) {
    _assertClass$1(voting_credential, Credential);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.drepregistration_new(voting_credential.__wbg_ptr, coin.__wbg_ptr);
    return DRepRegistration.__wrap(ret);
  }
  /**
   * @param {Credential} voting_credential
   * @param {BigNum} coin
   * @param {Anchor} anchor
   * @returns {DRepRegistration}
   */
  static new_with_anchor(voting_credential, coin, anchor) {
    _assertClass$1(voting_credential, Credential);
    _assertClass$1(coin, BigNum$1);
    _assertClass$1(anchor, Anchor);
    const ret = wasm$1.drepregistration_new_with_anchor(voting_credential.__wbg_ptr, coin.__wbg_ptr, anchor.__wbg_ptr);
    return DRepRegistration.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.drepregistration_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const DRepUpdateFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_drepupdate_free(ptr >>> 0));
/**
 */
class DRepUpdate {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DRepUpdate.prototype);
    obj.__wbg_ptr = ptr;
    DRepUpdateFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DRepUpdateFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_drepupdate_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepupdate_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DRepUpdate}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepupdate_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepUpdate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepupdate_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DRepUpdate}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepupdate_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepUpdate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepupdate_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepupdate_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DRepUpdate}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepupdate_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepUpdate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  voting_credential() {
    const ret = wasm$1.drepupdate_voting_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Anchor | undefined}
   */
  anchor() {
    const ret = wasm$1.drepupdate_anchor(this.__wbg_ptr);
    return ret === 0 ? undefined : Anchor.__wrap(ret);
  }
  /**
   * @param {Credential} voting_credential
   * @returns {DRepUpdate}
   */
  static new(voting_credential) {
    _assertClass$1(voting_credential, Credential);
    const ret = wasm$1.drepupdate_new(voting_credential.__wbg_ptr);
    return DRepUpdate.__wrap(ret);
  }
  /**
   * @param {Credential} voting_credential
   * @param {Anchor} anchor
   * @returns {DRepUpdate}
   */
  static new_with_anchor(voting_credential, anchor) {
    _assertClass$1(voting_credential, Credential);
    _assertClass$1(anchor, Anchor);
    const ret = wasm$1.drepupdate_new_with_anchor(voting_credential.__wbg_ptr, anchor.__wbg_ptr);
    return DRepUpdate.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.drepupdate_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const DRepVotingThresholdsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_drepvotingthresholds_free(ptr >>> 0));
/**
 */
class DRepVotingThresholds {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DRepVotingThresholds.prototype);
    obj.__wbg_ptr = ptr;
    DRepVotingThresholdsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DRepVotingThresholdsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_drepvotingthresholds_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepvotingthresholds_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DRepVotingThresholds}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepvotingthresholds_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepVotingThresholds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepvotingthresholds_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {DRepVotingThresholds}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepvotingthresholds_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepVotingThresholds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepvotingthresholds_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.drepvotingthresholds_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {DRepVotingThresholds}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.drepvotingthresholds_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DRepVotingThresholds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {UnitInterval} motion_no_confidence
   * @param {UnitInterval} committee_normal
   * @param {UnitInterval} committee_no_confidence
   * @param {UnitInterval} update_constitution
   * @param {UnitInterval} hard_fork_initiation
   * @param {UnitInterval} pp_network_group
   * @param {UnitInterval} pp_economic_group
   * @param {UnitInterval} pp_technical_group
   * @param {UnitInterval} pp_governance_group
   * @param {UnitInterval} treasury_withdrawal
   * @returns {DRepVotingThresholds}
   */
  static new(motion_no_confidence, committee_normal, committee_no_confidence, update_constitution, hard_fork_initiation, pp_network_group, pp_economic_group, pp_technical_group, pp_governance_group, treasury_withdrawal) {
    _assertClass$1(motion_no_confidence, UnitInterval);
    _assertClass$1(committee_normal, UnitInterval);
    _assertClass$1(committee_no_confidence, UnitInterval);
    _assertClass$1(update_constitution, UnitInterval);
    _assertClass$1(hard_fork_initiation, UnitInterval);
    _assertClass$1(pp_network_group, UnitInterval);
    _assertClass$1(pp_economic_group, UnitInterval);
    _assertClass$1(pp_technical_group, UnitInterval);
    _assertClass$1(pp_governance_group, UnitInterval);
    _assertClass$1(treasury_withdrawal, UnitInterval);
    const ret = wasm$1.drepvotingthresholds_new(motion_no_confidence.__wbg_ptr, committee_normal.__wbg_ptr, committee_no_confidence.__wbg_ptr, update_constitution.__wbg_ptr, hard_fork_initiation.__wbg_ptr, pp_network_group.__wbg_ptr, pp_economic_group.__wbg_ptr, pp_technical_group.__wbg_ptr, pp_governance_group.__wbg_ptr, treasury_withdrawal.__wbg_ptr);
    return DRepVotingThresholds.__wrap(ret);
  }
  /**
   * @param {UnitInterval} motion_no_confidence
   */
  set_motion_no_confidence(motion_no_confidence) {
    _assertClass$1(motion_no_confidence, UnitInterval);
    wasm$1.drepvotingthresholds_set_motion_no_confidence(this.__wbg_ptr, motion_no_confidence.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} committee_normal
   */
  set_committee_normal(committee_normal) {
    _assertClass$1(committee_normal, UnitInterval);
    wasm$1.drepvotingthresholds_set_committee_normal(this.__wbg_ptr, committee_normal.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} committee_no_confidence
   */
  set_committee_no_confidence(committee_no_confidence) {
    _assertClass$1(committee_no_confidence, UnitInterval);
    wasm$1.drepvotingthresholds_set_committee_no_confidence(this.__wbg_ptr, committee_no_confidence.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} update_constitution
   */
  set_update_constitution(update_constitution) {
    _assertClass$1(update_constitution, UnitInterval);
    wasm$1.drepvotingthresholds_set_update_constitution(this.__wbg_ptr, update_constitution.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} hard_fork_initiation
   */
  set_hard_fork_initiation(hard_fork_initiation) {
    _assertClass$1(hard_fork_initiation, UnitInterval);
    wasm$1.drepvotingthresholds_set_hard_fork_initiation(this.__wbg_ptr, hard_fork_initiation.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} pp_network_group
   */
  set_pp_network_group(pp_network_group) {
    _assertClass$1(pp_network_group, UnitInterval);
    wasm$1.drepvotingthresholds_set_pp_network_group(this.__wbg_ptr, pp_network_group.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} pp_economic_group
   */
  set_pp_economic_group(pp_economic_group) {
    _assertClass$1(pp_economic_group, UnitInterval);
    wasm$1.drepvotingthresholds_set_pp_economic_group(this.__wbg_ptr, pp_economic_group.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} pp_technical_group
   */
  set_pp_technical_group(pp_technical_group) {
    _assertClass$1(pp_technical_group, UnitInterval);
    wasm$1.drepvotingthresholds_set_pp_technical_group(this.__wbg_ptr, pp_technical_group.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} pp_governance_group
   */
  set_pp_governance_group(pp_governance_group) {
    _assertClass$1(pp_governance_group, UnitInterval);
    wasm$1.drepvotingthresholds_set_pp_governance_group(this.__wbg_ptr, pp_governance_group.__wbg_ptr);
  }
  /**
   * @param {UnitInterval} treasury_withdrawal
   */
  set_treasury_withdrawal(treasury_withdrawal) {
    _assertClass$1(treasury_withdrawal, UnitInterval);
    wasm$1.drepvotingthresholds_set_treasury_withdrawal(this.__wbg_ptr, treasury_withdrawal.__wbg_ptr);
  }
  /**
   * @returns {UnitInterval}
   */
  motion_no_confidence() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr); } else {
      ret = wasm$1.committee_quorum_threshold(this.__wbg_ptr); }
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  committee_normal() {
    const ret = wasm$1.drepvotingthresholds_committee_normal(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  committee_no_confidence() {
    const ret = wasm$1.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  update_constitution() {
    const ret = wasm$1.drepvotingthresholds_update_constitution(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  hard_fork_initiation() {
    const ret = wasm$1.drepvotingthresholds_hard_fork_initiation(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  pp_network_group() {
    const ret = wasm$1.drepvotingthresholds_pp_network_group(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  pp_economic_group() {
    const ret = wasm$1.drepvotingthresholds_pp_economic_group(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  pp_technical_group() {
    const ret = wasm$1.drepvotingthresholds_pp_technical_group(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  pp_governance_group() {
    const ret = wasm$1.drepvotingthresholds_pp_governance_group(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  treasury_withdrawal() {
    const ret = wasm$1.drepvotingthresholds_treasury_withdrawal(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_datacost_free(ptr >>> 0));

const DataHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_datahash_free(ptr >>> 0));
/**
 */
class DataHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(DataHash.prototype);
    obj.__wbg_ptr = ptr;
    DataHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    DataHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_datahash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {DataHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.datahash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {DataHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.datahash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {DataHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.datahash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return DataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_datumsource_free(ptr >>> 0));

const Ed25519KeyHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_ed25519keyhash_free(ptr >>> 0));
/**
 */
class Ed25519KeyHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Ed25519KeyHash.prototype);
    obj.__wbg_ptr = ptr;
    Ed25519KeyHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Ed25519KeyHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_ed25519keyhash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519KeyHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519KeyHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {Ed25519KeyHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519KeyHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {Ed25519KeyHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519KeyHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const Ed25519KeyHashesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_ed25519keyhashes_free(ptr >>> 0));
/**
 */
class Ed25519KeyHashes {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Ed25519KeyHashes.prototype);
    obj.__wbg_ptr = ptr;
    Ed25519KeyHashesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Ed25519KeyHashesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_ed25519keyhashes_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhashes_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519KeyHashes}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhashes_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519KeyHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhashes_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Ed25519KeyHashes}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhashes_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519KeyHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhashes_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhashes_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Ed25519KeyHashes}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhashes_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519KeyHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Ed25519KeyHashes}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.ed25519keyhashes_new(); } else {
      ret = wasm$1.credentials_new(); }
    return Ed25519KeyHashes.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.ed25519keyhashes_len(this.__wbg_ptr); } else {
      ret = wasm$1.credentials_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Ed25519KeyHash}
   */
  get(index) {
    const ret = wasm$1.ed25519keyhashes_get(this.__wbg_ptr, index);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * Add a new `Ed25519KeyHash` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {Ed25519KeyHash} keyhash
   * @returns {boolean}
   */
  add(keyhash) {
    _assertClass$1(keyhash, Ed25519KeyHash);
    const ret = wasm$1.ed25519keyhashes_add(this.__wbg_ptr, keyhash.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {Ed25519KeyHash} elem
   * @returns {boolean}
   */
  contains(elem) {
    _assertClass$1(elem, Ed25519KeyHash);
    const ret = wasm$1.ed25519keyhashes_contains(this.__wbg_ptr, elem.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {Ed25519KeyHashes | undefined}
   */
  to_option() {
    const ret = wasm$1.ed25519keyhashes_to_option(this.__wbg_ptr);
    return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);
  }
}

const Ed25519SignatureFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_ed25519signature_free(ptr >>> 0));
/**
 */
class Ed25519Signature {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Ed25519Signature.prototype);
    obj.__wbg_ptr = ptr;
    Ed25519SignatureFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Ed25519SignatureFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_ed25519signature_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519signature_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_bech32() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519signature_to_bech32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519signature_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} bech32_str
   * @returns {Ed25519Signature}
   */
  static from_bech32(bech32_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech32_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519signature_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519Signature.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} input
   * @returns {Ed25519Signature}
   */
  static from_hex(input) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(input, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519signature_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519Signature.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Ed25519Signature}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519signature_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ed25519Signature.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const EnterpriseAddressFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_enterpriseaddress_free(ptr >>> 0));
/**
 */
class EnterpriseAddress {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(EnterpriseAddress.prototype);
    obj.__wbg_ptr = ptr;
    EnterpriseAddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    EnterpriseAddressFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_enterpriseaddress_free(ptr);
  }
  /**
   * @param {number} network
   * @param {Credential} payment
   * @returns {EnterpriseAddress}
   */
  static new(network, payment) {
    _assertClass$1(payment, Credential);
    const ret = wasm$1.enterpriseaddress_new(network, payment.__wbg_ptr);
    return EnterpriseAddress.__wrap(ret);
  }
  /**
   * @returns {Credential}
   */
  payment_cred() {
    const ret = wasm$1.baseaddress_payment_cred(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Address}
   */
  to_address() {
    const ret = wasm$1.enterpriseaddress_to_address(this.__wbg_ptr);
    return Address.__wrap(ret);
  }
  /**
   * @param {Address} addr
   * @returns {EnterpriseAddress | undefined}
   */
  static from_address(addr) {
    _assertClass$1(addr, Address);
    const ret = wasm$1.enterpriseaddress_from_address(addr.__wbg_ptr);
    return ret === 0 ? undefined : EnterpriseAddress.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  network_id() {
    const ret = wasm$1.enterpriseaddress_network_id(this.__wbg_ptr);
    return ret;
  }
}

const ExUnitPricesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_exunitprices_free(ptr >>> 0));
/**
 */
class ExUnitPrices {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ExUnitPrices.prototype);
    obj.__wbg_ptr = ptr;
    ExUnitPricesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ExUnitPricesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_exunitprices_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunitprices_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ExUnitPrices}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.exunitprices_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnitPrices.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunitprices_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ExUnitPrices}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.exunitprices_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnitPrices.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunitprices_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunitprices_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ExUnitPrices}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.exunitprices_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnitPrices.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {UnitInterval}
   */
  mem_price() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.exunitprices_mem_price(this.__wbg_ptr); } else {
      ret = wasm$1.committee_quorum_threshold(this.__wbg_ptr); }
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  step_price() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.exunitprices_step_price(this.__wbg_ptr); } else {
      ret = wasm$1.drepvotingthresholds_committee_normal(this.__wbg_ptr); }
    return UnitInterval.__wrap(ret);
  }
  /**
   * @param {UnitInterval} mem_price
   * @param {UnitInterval} step_price
   * @returns {ExUnitPrices}
   */
  static new(mem_price, step_price) {
    _assertClass$1(mem_price, UnitInterval);
    _assertClass$1(step_price, UnitInterval);
    const ret = wasm$1.exunitprices_new(mem_price.__wbg_ptr, step_price.__wbg_ptr);
    return ExUnitPrices.__wrap(ret);
  }
}

const ExUnitsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_exunits_free(ptr >>> 0));
/**
 */
class ExUnits {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ExUnits.prototype);
    obj.__wbg_ptr = ptr;
    ExUnitsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ExUnitsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_exunits_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunits_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ExUnits}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.exunits_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnits.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunits_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ExUnits}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.exunits_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnits.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunits_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.exunits_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ExUnits}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.exunits_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnits.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum}
   */
  mem() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.drepderegistration_coin(this.__wbg_ptr); } else {
      ret = wasm$1.exunits_mem(this.__wbg_ptr); }
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  steps() {
    const ret = wasm$1.exunits_steps(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} mem
   * @param {BigNum} steps
   * @returns {ExUnits}
   */
  static new(mem, steps) {
    _assertClass$1(mem, BigNum$1);
    _assertClass$1(steps, BigNum$1);
    const ret = wasm$1.exunits_new(mem.__wbg_ptr, steps.__wbg_ptr);
    return ExUnits.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_fixedblock_free(ptr >>> 0));

const FixedTransactionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_fixedtransaction_free(ptr >>> 0));
/**
 */
class FixedTransaction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(FixedTransaction.prototype);
    obj.__wbg_ptr = ptr;
    FixedTransactionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    FixedTransactionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_fixedtransaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.fixedtransaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {FixedTransaction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return FixedTransaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.fixedtransaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {FixedTransaction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return FixedTransaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} raw_body
   * @param {Uint8Array} raw_witness_set
   * @param {boolean} is_valid
   * @returns {FixedTransaction}
   */
  static new(raw_body, raw_witness_set, is_valid) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(raw_body, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      const ptr1 = passArray8ToWasm0$1(raw_witness_set, wasm$1.__wbindgen_malloc);
      const len1 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_new(retptr, ptr0, len0, ptr1, len1, is_valid);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return FixedTransaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} raw_body
   * @param {Uint8Array} raw_witness_set
   * @param {Uint8Array} raw_auxiliary_data
   * @param {boolean} is_valid
   * @returns {FixedTransaction}
   */
  static new_with_auxiliary(raw_body, raw_witness_set, raw_auxiliary_data, is_valid) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(raw_body, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      const ptr1 = passArray8ToWasm0$1(raw_witness_set, wasm$1.__wbindgen_malloc);
      const len1 = WASM_VECTOR_LEN$1;
      const ptr2 = passArray8ToWasm0$1(raw_auxiliary_data, wasm$1.__wbindgen_malloc);
      const len2 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_new_with_auxiliary(retptr, ptr0, len0, ptr1, len1, ptr2, len2, is_valid);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return FixedTransaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /** VERSION_13_2_0
   * @param {Uint8Array} raw_body
   * @returns {FixedTransaction}
   */
  static new_from_body_bytes(raw_body) {
    if (version$2 === VERSION_12_1_1$1) { throw NOT_IMPLEMENTED }
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(raw_body, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_new_from_body_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return FixedTransaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionBody}
   */
  body() {
    const ret = wasm$1.fixedtransaction_body(this.__wbg_ptr);
    return TransactionBody.__wrap(ret);
  }
  /**
   * @returns {Uint8Array}
   */
  raw_body() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.fixedtransaction_raw_body(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} raw_body
   */
  set_body(raw_body) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(raw_body, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_set_body(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      if (r1) {
        throw takeObject$1(r0);
      }
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * We do not recommend using this function, since it might lead to script integrity hash.
   * The only purpose of this struct is to sign the transaction from third-party sources.
   * Use `.sign_and_add_vkey_signature` or `.sign_and_add_icarus_bootstrap_signature` or `.sign_and_add_daedalus_bootstrap_signature` instead.
   * @param {Uint8Array} raw_witness_set
   */
  set_witness_set(raw_witness_set) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(raw_witness_set, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_set_witness_set(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      if (r1) {
        throw takeObject$1(r0);
      }
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionWitnessSet}
   */
  witness_set() {
    const ret = wasm$1.fixedtransaction_witness_set(this.__wbg_ptr);
    return TransactionWitnessSet.__wrap(ret);
  }
  /**
   * @returns {Uint8Array}
   */
  raw_witness_set() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.fixedtransaction_raw_witness_set(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {boolean} valid
   */
  set_is_valid(valid) {
    wasm$1.fixedtransaction_set_is_valid(this.__wbg_ptr, valid);
  }
  /**
   * @returns {boolean}
   */
  is_valid() {
    const ret = wasm$1.fixedtransaction_is_valid(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {Uint8Array} raw_auxiliary_data
   */
  set_auxiliary_data(raw_auxiliary_data) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(raw_auxiliary_data, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.fixedtransaction_set_auxiliary_data(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      if (r1) {
        throw takeObject$1(r0);
      }
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {AuxiliaryData | undefined}
   */
  auxiliary_data() {
    const ret = wasm$1.fixedtransaction_auxiliary_data(this.__wbg_ptr);
    return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
  }
  /**
   * @returns {Uint8Array | undefined}
   */
  raw_auxiliary_data() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.fixedtransaction_raw_auxiliary_data(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      let v1;
      if (r0 !== 0) {
        v1 = getArrayU8FromWasm0$1(r0, r1).slice();
        wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionHash}
   */
  transaction_hash() {
    const ret = wasm$1.fixedtransaction_transaction_hash(this.__wbg_ptr);
    return TransactionHash.__wrap(ret);
  }
  /**
   * @param {Vkeywitness} vkey_witness
   */
  add_vkey_witness(vkey_witness) {
    _assertClass$1(vkey_witness, Vkeywitness);
    wasm$1.fixedtransaction_add_vkey_witness(this.__wbg_ptr, vkey_witness.__wbg_ptr);
  }
  /**
   * @param {BootstrapWitness} bootstrap_witness
   */
  add_bootstrap_witness(bootstrap_witness) {
    _assertClass$1(bootstrap_witness, BootstrapWitness);
    wasm$1.fixedtransaction_add_bootstrap_witness(this.__wbg_ptr, bootstrap_witness.__wbg_ptr);
  }
  /**
   * @param {PrivateKey} private_key
   */
  sign_and_add_vkey_signature(private_key) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(private_key, PrivateKey);
      wasm$1.fixedtransaction_sign_and_add_vkey_signature(retptr, this.__wbg_ptr, private_key.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      if (r1) {
        throw takeObject$1(r0);
      }
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {ByronAddress} addr
   * @param {Bip32PrivateKey} private_key
   */
  sign_and_add_icarus_bootstrap_signature(addr, private_key) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(addr, ByronAddress);
      _assertClass$1(private_key, Bip32PrivateKey);
      wasm$1.fixedtransaction_sign_and_add_icarus_bootstrap_signature(retptr, this.__wbg_ptr, addr.__wbg_ptr, private_key.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      if (r1) {
        throw takeObject$1(r0);
      }
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {ByronAddress} addr
   * @param {LegacyDaedalusPrivateKey} private_key
   */
  sign_and_add_daedalus_bootstrap_signature(addr, private_key) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(addr, ByronAddress);
      _assertClass$1(private_key, LegacyDaedalusPrivateKey);
      wasm$1.fixedtransaction_sign_and_add_daedalus_bootstrap_signature(retptr, this.__wbg_ptr, addr.__wbg_ptr, private_key.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      if (r1) {
        throw takeObject$1(r0);
      }
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_fixedtransactionbodies_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_fixedtransactionbody_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_fixedtxwitnessesset_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_fixedversionedblock_free(ptr >>> 0));

const GeneralTransactionMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_generaltransactionmetadata_free(ptr >>> 0));
/**
 */
class GeneralTransactionMetadata {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GeneralTransactionMetadata.prototype);
    obj.__wbg_ptr = ptr;
    GeneralTransactionMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GeneralTransactionMetadataFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_generaltransactionmetadata_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.generaltransactionmetadata_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GeneralTransactionMetadata}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.generaltransactionmetadata_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GeneralTransactionMetadata.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.generaltransactionmetadata_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {GeneralTransactionMetadata}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.generaltransactionmetadata_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GeneralTransactionMetadata.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.generaltransactionmetadata_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.generaltransactionmetadata_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {GeneralTransactionMetadata}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.generaltransactionmetadata_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GeneralTransactionMetadata.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GeneralTransactionMetadata}
   */
  static new() {
    const ret = wasm$1.generaltransactionmetadata_new();
    return GeneralTransactionMetadata.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.generaltransactionmetadata_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {BigNum} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, BigNum$1);
    _assertClass$1(value, TransactionMetadatum);
    const ret = wasm$1.generaltransactionmetadata_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {BigNum} key
   * @returns {TransactionMetadatum | undefined}
   */
  get(key) {
    _assertClass$1(key, BigNum$1);
    const ret = wasm$1.generaltransactionmetadata_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
  }
  /**
   * @returns {TransactionMetadatumLabels}
   */
  keys() {
    const ret = wasm$1.generaltransactionmetadata_keys(this.__wbg_ptr);
    return TransactionMetadatumLabels.__wrap(ret);
  }
}

const GenesisDelegateHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_genesisdelegatehash_free(ptr >>> 0));
/**
 */
class GenesisDelegateHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GenesisDelegateHash.prototype);
    obj.__wbg_ptr = ptr;
    GenesisDelegateHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GenesisDelegateHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_genesisdelegatehash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisDelegateHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesisdelegatehash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisDelegateHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {GenesisDelegateHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesisdelegatehash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisDelegateHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {GenesisDelegateHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesisdelegatehash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisDelegateHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const GenesisHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_genesishash_free(ptr >>> 0));
/**
 */
class GenesisHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GenesisHash.prototype);
    obj.__wbg_ptr = ptr;
    GenesisHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GenesisHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_genesishash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesishash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {GenesisHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesishash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {GenesisHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesishash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const GenesisHashesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_genesishashes_free(ptr >>> 0));
/**
 */
class GenesisHashes {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GenesisHashes.prototype);
    obj.__wbg_ptr = ptr;
    GenesisHashesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GenesisHashesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_genesishashes_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesishashes_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisHashes}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesishashes_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesishashes_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {GenesisHashes}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesishashes_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesishashes_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesishashes_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {GenesisHashes}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesishashes_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GenesisHashes}
   */
  static new() {
    const ret = wasm$1.genesishashes_new();
    return GenesisHashes.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {GenesisHash}
   */
  get(index) {
    const ret = wasm$1.genesishashes_get(this.__wbg_ptr, index);
    return GenesisHash.__wrap(ret);
  }
  /**
   * @param {GenesisHash} elem
   */
  add(elem) {
    _assertClass$1(elem, GenesisHash);
    wasm$1.genesishashes_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const GenesisKeyDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_genesiskeydelegation_free(ptr >>> 0));
/**
 */
class GenesisKeyDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GenesisKeyDelegation.prototype);
    obj.__wbg_ptr = ptr;
    GenesisKeyDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GenesisKeyDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_genesiskeydelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesiskeydelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GenesisKeyDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesiskeydelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisKeyDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesiskeydelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {GenesisKeyDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesiskeydelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisKeyDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesiskeydelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.genesiskeydelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {GenesisKeyDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.genesiskeydelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GenesisKeyDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GenesisHash}
   */
  genesishash() {
    const ret = wasm$1.genesiskeydelegation_genesishash(this.__wbg_ptr);
    return GenesisHash.__wrap(ret);
  }
  /**
   * @returns {GenesisDelegateHash}
   */
  genesis_delegate_hash() {
    const ret = wasm$1.genesiskeydelegation_genesis_delegate_hash(this.__wbg_ptr);
    return GenesisDelegateHash.__wrap(ret);
  }
  /**
   * @returns {VRFKeyHash}
   */
  vrf_keyhash() {
    const ret = wasm$1.genesiskeydelegation_vrf_keyhash(this.__wbg_ptr);
    return VRFKeyHash.__wrap(ret);
  }
  /**
   * @param {GenesisHash} genesishash
   * @param {GenesisDelegateHash} genesis_delegate_hash
   * @param {VRFKeyHash} vrf_keyhash
   * @returns {GenesisKeyDelegation}
   */
  static new(genesishash, genesis_delegate_hash, vrf_keyhash) {
    _assertClass$1(genesishash, GenesisHash);
    _assertClass$1(genesis_delegate_hash, GenesisDelegateHash);
    _assertClass$1(vrf_keyhash, VRFKeyHash);
    const ret = wasm$1.genesiskeydelegation_new(genesishash.__wbg_ptr, genesis_delegate_hash.__wbg_ptr, vrf_keyhash.__wbg_ptr);
    return GenesisKeyDelegation.__wrap(ret);
  }
}

const GovernanceActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_governanceaction_free(ptr >>> 0));
/**
 */
class GovernanceAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GovernanceAction.prototype);
    obj.__wbg_ptr = ptr;
    GovernanceActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GovernanceActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_governanceaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GovernanceAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {GovernanceAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {GovernanceAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {ParameterChangeAction} parameter_change_action
   * @returns {GovernanceAction}
   */
  static new_parameter_change_action(parameter_change_action) {
    _assertClass$1(parameter_change_action, ParameterChangeAction);
    const ret = wasm$1.governanceaction_new_parameter_change_action(parameter_change_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @param {HardForkInitiationAction} hard_fork_initiation_action
   * @returns {GovernanceAction}
   */
  static new_hard_fork_initiation_action(hard_fork_initiation_action) {
    _assertClass$1(hard_fork_initiation_action, HardForkInitiationAction);
    const ret = wasm$1.governanceaction_new_hard_fork_initiation_action(hard_fork_initiation_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @param {TreasuryWithdrawalsAction} treasury_withdrawals_action
   * @returns {GovernanceAction}
   */
  static new_treasury_withdrawals_action(treasury_withdrawals_action) {
    _assertClass$1(treasury_withdrawals_action, TreasuryWithdrawalsAction);
    const ret = wasm$1.governanceaction_new_treasury_withdrawals_action(treasury_withdrawals_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @param {NoConfidenceAction} no_confidence_action
   * @returns {GovernanceAction}
   */
  static new_no_confidence_action(no_confidence_action) {
    _assertClass$1(no_confidence_action, NoConfidenceAction);
    const ret = wasm$1.governanceaction_new_no_confidence_action(no_confidence_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @param {UpdateCommitteeAction} new_committee_action
   * @returns {GovernanceAction}
   */
  static new_new_committee_action(new_committee_action) {
    _assertClass$1(new_committee_action, UpdateCommitteeAction);
    const ret = wasm$1.governanceaction_new_new_committee_action(new_committee_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @param {NewConstitutionAction} new_constitution_action
   * @returns {GovernanceAction}
   */
  static new_new_constitution_action(new_constitution_action) {
    _assertClass$1(new_constitution_action, NewConstitutionAction);
    const ret = wasm$1.governanceaction_new_new_constitution_action(new_constitution_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @param {InfoAction} info_action
   * @returns {GovernanceAction}
   */
  static new_info_action(info_action) {
    _assertClass$1(info_action, InfoAction);
    const ret = wasm$1.governanceaction_new_info_action(info_action.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @returns {GovernanceActionKind}
   */
  kind() {
    const ret = wasm$1.governanceaction_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {ParameterChangeAction | undefined}
   */
  as_parameter_change_action() {
    const ret = wasm$1.governanceaction_as_parameter_change_action(this.__wbg_ptr);
    return ret === 0 ? undefined : ParameterChangeAction.__wrap(ret);
  }
  /**
   * @returns {HardForkInitiationAction | undefined}
   */
  as_hard_fork_initiation_action() {
    const ret = wasm$1.governanceaction_as_hard_fork_initiation_action(this.__wbg_ptr);
    return ret === 0 ? undefined : HardForkInitiationAction.__wrap(ret);
  }
  /**
   * @returns {TreasuryWithdrawalsAction | undefined}
   */
  as_treasury_withdrawals_action() {
    const ret = wasm$1.governanceaction_as_treasury_withdrawals_action(this.__wbg_ptr);
    return ret === 0 ? undefined : TreasuryWithdrawalsAction.__wrap(ret);
  }
  /**
   * @returns {NoConfidenceAction | undefined}
   */
  as_no_confidence_action() {
    const ret = wasm$1.governanceaction_as_no_confidence_action(this.__wbg_ptr);
    return ret === 0 ? undefined : NoConfidenceAction.__wrap(ret);
  }
  /**
   * @returns {UpdateCommitteeAction | undefined}
   */
  as_new_committee_action() {
    const ret = wasm$1.governanceaction_as_new_committee_action(this.__wbg_ptr);
    return ret === 0 ? undefined : UpdateCommitteeAction.__wrap(ret);
  }
  /**
   * @returns {NewConstitutionAction | undefined}
   */
  as_new_constitution_action() {
    const ret = wasm$1.governanceaction_as_new_constitution_action(this.__wbg_ptr);
    return ret === 0 ? undefined : NewConstitutionAction.__wrap(ret);
  }
  /**
   * @returns {InfoAction | undefined}
   */
  as_info_action() {
    const ret = wasm$1.governanceaction_as_info_action(this.__wbg_ptr);
    return ret === 0 ? undefined : InfoAction.__wrap(ret);
  }
}

const GovernanceActionIdFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_governanceactionid_free(ptr >>> 0));
/**
 */
class GovernanceActionId {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GovernanceActionId.prototype);
    obj.__wbg_ptr = ptr;
    GovernanceActionIdFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GovernanceActionIdFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_governanceactionid_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceactionid_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {GovernanceActionId}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceactionid_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceActionId.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceactionid_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {GovernanceActionId}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceactionid_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceActionId.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceactionid_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceactionid_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {GovernanceActionId}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceactionid_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceActionId.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionHash}
   */
  transaction_id() {
    const ret = wasm$1.governanceactionid_transaction_id(this.__wbg_ptr);
    return TransactionHash.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  index() {
    const ret = wasm$1.governanceactionid_index(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {TransactionHash} transaction_id
   * @param {number} index
   * @returns {GovernanceActionId}
   */
  static new(transaction_id, index) {
    _assertClass$1(transaction_id, TransactionHash);
    const ret = wasm$1.governanceactionid_new(transaction_id.__wbg_ptr, index);
    return GovernanceActionId.__wrap(ret);
  }
}

const GovernanceActionIdsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_governanceactionids_free(ptr >>> 0));
/**
 */
class GovernanceActionIds {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(GovernanceActionIds.prototype);
    obj.__wbg_ptr = ptr;
    GovernanceActionIdsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    GovernanceActionIdsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_governanceactionids_free(ptr);
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceactionids_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.governanceactionids_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {GovernanceActionIds}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.governanceactionids_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return GovernanceActionIds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceActionIds}
   */
  static new() {
    const ret = wasm$1.governanceactionids_new();
    return GovernanceActionIds.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} governance_action_id
   */
  add(governance_action_id) {
    _assertClass$1(governance_action_id, GovernanceActionId);
    wasm$1.governanceactionids_add(this.__wbg_ptr, governance_action_id.__wbg_ptr);
  }
  /**
   * @param {number} index
   * @returns {GovernanceActionId | undefined}
   */
  get(index) {
    const ret = wasm$1.governanceactionids_get(this.__wbg_ptr, index);
    return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.governanceactionids_len(this.__wbg_ptr);
    return ret >>> 0;
  }
}

const HardForkInitiationActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_hardforkinitiationaction_free(ptr >>> 0));
/**
 */
class HardForkInitiationAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(HardForkInitiationAction.prototype);
    obj.__wbg_ptr = ptr;
    HardForkInitiationActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    HardForkInitiationActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_hardforkinitiationaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.hardforkinitiationaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {HardForkInitiationAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.hardforkinitiationaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return HardForkInitiationAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.hardforkinitiationaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {HardForkInitiationAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.hardforkinitiationaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return HardForkInitiationAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.hardforkinitiationaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.hardforkinitiationaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {HardForkInitiationAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.hardforkinitiationaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return HardForkInitiationAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceActionId | undefined}
   */
  gov_action_id() {
    const ret = wasm$1.hardforkinitiationaction_gov_action_id(this.__wbg_ptr);
    return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);
  }
  /**
   * @returns {ProtocolVersion}
   */
  protocol_version() {
    const ret = wasm$1.hardforkinitiationaction_protocol_version(this.__wbg_ptr);
    return ProtocolVersion.__wrap(ret);
  }
  /**
   * @param {ProtocolVersion} protocol_version
   * @returns {HardForkInitiationAction}
   */
  static new(protocol_version) {
    _assertClass$1(protocol_version, ProtocolVersion);
    const ret = wasm$1.hardforkinitiationaction_new(protocol_version.__wbg_ptr);
    return HardForkInitiationAction.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} gov_action_id
   * @param {ProtocolVersion} protocol_version
   * @returns {HardForkInitiationAction}
   */
  static new_with_action_id(gov_action_id, protocol_version) {
    _assertClass$1(gov_action_id, GovernanceActionId);
    _assertClass$1(protocol_version, ProtocolVersion);
    const ret = wasm$1.hardforkinitiationaction_new_with_action_id(gov_action_id.__wbg_ptr, protocol_version.__wbg_ptr);
    return HardForkInitiationAction.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_header_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_headerbody_free(ptr >>> 0));

const InfoActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_infoaction_free(ptr >>> 0));
/**
 */
class InfoAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(InfoAction.prototype);
    obj.__wbg_ptr = ptr;
    InfoActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    InfoActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_infoaction_free(ptr);
  }
  /**
   * @returns {InfoAction}
   */
  static new() {
    const ret = wasm$1.infoaction_new();
    return InfoAction.__wrap(ret);
  }
}

const IntFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_int_free(ptr >>> 0));
/**
 */
let Int$1 = class Int {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Int.prototype);
    obj.__wbg_ptr = ptr;
    IntFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    IntFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_int_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Int}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.int_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Int}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.int_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Int}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.int_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} x
   * @returns {Int}
   */
  static new(x) {
    _assertClass$1(x, BigNum$1);
    const ret = wasm$1.int_new(x.__wbg_ptr);
    return Int.__wrap(ret);
  }
  /**
   * @param {BigNum} x
   * @returns {Int}
   */
  static new_negative(x) {
    _assertClass$1(x, BigNum$1);
    const ret = wasm$1.int_new_negative(x.__wbg_ptr);
    return Int.__wrap(ret);
  }
  /**
   * @param {number} x
   * @returns {Int}
   */
  static new_i32(x) {
    const ret = wasm$1.int_new_i32(x);
    return Int.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  is_positive() {
    const ret = wasm$1.int_is_positive(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * BigNum can only contain unsigned u64 values
   *
   * This function will return the BigNum representation
   * only in case the underlying i128 value is positive.
   *
   * Otherwise nothing will be returned (undefined).
   * @returns {BigNum | undefined}
   */
  as_positive() {
    const ret = wasm$1.int_as_positive(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * BigNum can only contain unsigned u64 values
   *
   * This function will return the *absolute* BigNum representation
   * only in case the underlying i128 value is negative.
   *
   * Otherwise nothing will be returned (undefined).
   * @returns {BigNum | undefined}
   */
  as_negative() {
    const ret = wasm$1.int_as_negative(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Returns an i32 value in case the underlying original i128 value is within the limits.
   * Otherwise will just return an empty value (undefined).
   * @returns {number | undefined}
   */
  as_i32() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_as_i32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Returns the underlying value converted to i32 if possible (within limits)
   * Otherwise will just return an empty value (undefined).
   * @returns {number | undefined}
   */
  as_i32_or_nothing() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_as_i32_or_nothing(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Returns the underlying value converted to i32 if possible (within limits)
   * JsError in case of out of boundary overflow
   * @returns {number}
   */
  as_i32_or_fail() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_as_i32_or_fail(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Returns string representation of the underlying i128 value directly.
   * Might contain the minus sign (-) in case of negative value.
   * @returns {string}
   */
  to_str() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.int_to_str(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} string
   * @returns {Int}
   */
  static from_str(string) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(string, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.int_from_str(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
};

const Ipv4Finalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_ipv4_free(ptr >>> 0));
/**
 */
class Ipv4 {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Ipv4.prototype);
    obj.__wbg_ptr = ptr;
    Ipv4Finalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Ipv4Finalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_ipv4_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv4_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Ipv4}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv4_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv4.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv4_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Ipv4}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv4_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv4.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv4_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv4_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Ipv4}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv4_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv4.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ipv4}
   */
  static new(data) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(data, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv4_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv4.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  ip() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv4_ip(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const Ipv6Finalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_ipv6_free(ptr >>> 0));
/**
 */
class Ipv6 {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Ipv6.prototype);
    obj.__wbg_ptr = ptr;
    Ipv6Finalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    Ipv6Finalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_ipv6_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv6_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Ipv6}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv6_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv6.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv6_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Ipv6}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv6_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv6.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv6_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv6_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Ipv6}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv6_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv6.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} data
   * @returns {Ipv6}
   */
  static new(data) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(data, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ipv6_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Ipv6.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  ip() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ipv6_ip(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_kessignature_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_kesvkey_free(ptr >>> 0));

const LanguageFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_language_free(ptr >>> 0));
/**
 */
class Language {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Language.prototype);
    obj.__wbg_ptr = ptr;
    LanguageFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    LanguageFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_language_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.language_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Language}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.language_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Language.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.language_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Language}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.language_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Language.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.language_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.language_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Language}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.language_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Language.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Language}
   */
  static new_plutus_v1() {
    const ret = wasm$1.language_new_plutus_v1();
    return Language.__wrap(ret);
  }
  /**
   * @returns {Language}
   */
  static new_plutus_v2() {
    const ret = wasm$1.language_new_plutus_v2();
    return Language.__wrap(ret);
  }
  /**
   * @returns {Language}
   */
  static new_plutus_v3() {
    const ret = wasm$1.language_new_plutus_v3();
    return Language.__wrap(ret);
  }
  /**
   * @returns {LanguageKind}
   */
  kind() {
    const ret = wasm$1.language_kind(this.__wbg_ptr);
    return ret;
  }
}

const LanguagesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_languages_free(ptr >>> 0));
/**
 */
class Languages {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Languages.prototype);
    obj.__wbg_ptr = ptr;
    LanguagesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    LanguagesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_languages_free(ptr);
  }
  /**
   * @returns {Languages}
   */
  static new() {
    const ret = wasm$1.languages_new();
    return Languages.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.credentials_len(this.__wbg_ptr); } else {
      ret = wasm$1.costmdls_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Language}
   */
  get(index) {
    const ret = wasm$1.languages_get(this.__wbg_ptr, index);
    return Language.__wrap(ret);
  }
  /**
   * @param {Language} elem
   */
  add(elem) {
    _assertClass$1(elem, Language);
    var ptr0 = elem.__destroy_into_raw();
    wasm$1.languages_add(this.__wbg_ptr, ptr0);
  }
  /**
   * @returns {Languages}
   */
  static list() {
    const ret = wasm$1.languages_list();
    return Languages.__wrap(ret);
  }
}

const LegacyDaedalusPrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_legacydaedalusprivatekey_free(ptr >>> 0));
/**
 */
class LegacyDaedalusPrivateKey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(LegacyDaedalusPrivateKey.prototype);
    obj.__wbg_ptr = ptr;
    LegacyDaedalusPrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    LegacyDaedalusPrivateKeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_legacydaedalusprivatekey_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {LegacyDaedalusPrivateKey}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.legacydaedalusprivatekey_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return LegacyDaedalusPrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.legacydaedalusprivatekey_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  chaincode() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.legacydaedalusprivatekey_chaincode(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_linearfee_free(ptr >>> 0));

const MIRToStakeCredentialsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_mirtostakecredentials_free(ptr >>> 0));
/**
 */
class MIRToStakeCredentials {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MIRToStakeCredentials.prototype);
    obj.__wbg_ptr = ptr;
    MIRToStakeCredentialsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MIRToStakeCredentialsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_mirtostakecredentials_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mirtostakecredentials_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MIRToStakeCredentials}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mirtostakecredentials_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MIRToStakeCredentials.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mirtostakecredentials_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MIRToStakeCredentials}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mirtostakecredentials_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MIRToStakeCredentials.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mirtostakecredentials_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mirtostakecredentials_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {MIRToStakeCredentials}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mirtostakecredentials_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MIRToStakeCredentials.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MIRToStakeCredentials}
   */
  static new() {
    const ret = wasm$1.mirtostakecredentials_new();
    return MIRToStakeCredentials.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.mirtostakecredentials_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {Credential} cred
   * @param {Int} delta
   * @returns {Int | undefined}
   */
  insert(cred, delta) {
    _assertClass$1(cred, Credential);
    _assertClass$1(delta, Int$1);
    const ret = wasm$1.mirtostakecredentials_insert(this.__wbg_ptr, cred.__wbg_ptr, delta.__wbg_ptr);
    return ret === 0 ? undefined : Int$1.__wrap(ret);
  }
  /**
   * @param {Credential} cred
   * @returns {Int | undefined}
   */
  get(cred) {
    _assertClass$1(cred, Credential);
    const ret = wasm$1.mirtostakecredentials_get(this.__wbg_ptr, cred.__wbg_ptr);
    return ret === 0 ? undefined : Int$1.__wrap(ret);
  }
  /**
   * @returns {Credentials}
   */
  keys() {
    const ret = wasm$1.mirtostakecredentials_keys(this.__wbg_ptr);
    return Credentials.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_malformedaddress_free(ptr >>> 0));

const MetadataListFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_metadatalist_free(ptr >>> 0));
/**
 */
class MetadataList {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MetadataList.prototype);
    obj.__wbg_ptr = ptr;
    MetadataListFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MetadataListFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_metadatalist_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.metadatalist_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MetadataList}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.metadatalist_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MetadataList.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.metadatalist_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MetadataList}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.metadatalist_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MetadataList.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MetadataList}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.metadatalist_new(); } else {
      ret = wasm$1.fixedtransactionbodies_new(); }
    return MetadataList.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.metadatalist_len(this.__wbg_ptr); } else {
      ret = wasm$1.fixedtransactionbodies_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {TransactionMetadatum}
   */
  get(index) {
    const ret = wasm$1.metadatalist_get(this.__wbg_ptr, index);
    return TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {TransactionMetadatum} elem
   */
  add(elem) {
    _assertClass$1(elem, TransactionMetadatum);
    wasm$1.metadatalist_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const MetadataMapFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_metadatamap_free(ptr >>> 0));
/**
 */
class MetadataMap {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MetadataMap.prototype);
    obj.__wbg_ptr = ptr;
    MetadataMapFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MetadataMapFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_metadatamap_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.metadatamap_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MetadataMap}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.metadatamap_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MetadataMap.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.metadatamap_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MetadataMap}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.metadatamap_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MetadataMap.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MetadataMap}
   */
  static new() {
    const ret = wasm$1.generaltransactionmetadata_new();
    return MetadataMap.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.generaltransactionmetadata_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {TransactionMetadatum} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, TransactionMetadatum);
    _assertClass$1(value, TransactionMetadatum);
    const ret = wasm$1.metadatamap_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {string} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | undefined}
   */
  insert_str(key, value) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(key, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      _assertClass$1(value, TransactionMetadatum);
      wasm$1.metadatamap_insert_str(retptr, this.__wbg_ptr, ptr0, len0, value.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 === 0 ? undefined : TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} key
   * @param {TransactionMetadatum} value
   * @returns {TransactionMetadatum | undefined}
   */
  insert_i32(key, value) {
    _assertClass$1(value, TransactionMetadatum);
    const ret = wasm$1.metadatamap_insert_i32(this.__wbg_ptr, key, value.__wbg_ptr);
    return ret === 0 ? undefined : TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {TransactionMetadatum} key
   * @returns {TransactionMetadatum}
   */
  get(key) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(key, TransactionMetadatum);
      wasm$1.metadatamap_get(retptr, this.__wbg_ptr, key.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} key
   * @returns {TransactionMetadatum}
   */
  get_str(key) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(key, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.metadatamap_get_str(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} key
   * @returns {TransactionMetadatum}
   */
  get_i32(key) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.metadatamap_get_i32(retptr, this.__wbg_ptr, key);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {TransactionMetadatum} key
   * @returns {boolean}
   */
  has(key) {
    _assertClass$1(key, TransactionMetadatum);
    const ret = wasm$1.metadatamap_has(this.__wbg_ptr, key.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {MetadataList}
   */
  keys() {
    const ret = wasm$1.metadatamap_keys(this.__wbg_ptr);
    return MetadataList.__wrap(ret);
  }
}

const MintFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_mint_free(ptr >>> 0));
/**
 */
class Mint {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Mint.prototype);
    obj.__wbg_ptr = ptr;
    MintFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MintFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_mint_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mint_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Mint}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mint_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Mint.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mint_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Mint}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mint_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Mint.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mint_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mint_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Mint}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mint_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Mint.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Mint}
   */
  static new() {
    const ret = wasm$1.assetnames_new();
    return Mint.__wrap(ret);
  }
  /**
   * @param {ScriptHash} key
   * @param {MintAssets} value
   * @returns {Mint}
   */
  static new_from_entry(key, value) {
    _assertClass$1(key, ScriptHash);
    _assertClass$1(value, MintAssets);
    const ret = wasm$1.mint_new_from_entry(key.__wbg_ptr, value.__wbg_ptr);
    return Mint.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {ScriptHash} key
   * @param {MintAssets} value
   * @returns {MintAssets | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, ScriptHash);
    _assertClass$1(value, MintAssets);
    const ret = wasm$1.mint_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : MintAssets.__wrap(ret);
  }
  /**
   * @param {ScriptHash} key
   * @returns {MintsAssets | undefined}
   */
  get(key) {
    _assertClass$1(key, ScriptHash);
    const ret = wasm$1.mint_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : MintsAssets.__wrap(ret);
  }
  /**
   * @returns {ScriptHashes}
   */
  keys() {
    const ret = wasm$1.mint_keys(this.__wbg_ptr);
    return ScriptHashes.__wrap(ret);
  }
  /**
   * Returns the multiasset where only positive (minting) entries are present
   * @returns {MultiAsset}
   */
  as_positive_multiasset() {
    const ret = wasm$1.mint_as_positive_multiasset(this.__wbg_ptr);
    return MultiAsset.__wrap(ret);
  }
  /**
   * Returns the multiasset where only negative (burning) entries are present
   * @returns {MultiAsset}
   */
  as_negative_multiasset() {
    const ret = wasm$1.mint_as_negative_multiasset(this.__wbg_ptr);
    return MultiAsset.__wrap(ret);
  }
}

const MintAssetsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_mintassets_free(ptr >>> 0));
/**
 */
class MintAssets {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MintAssets.prototype);
    obj.__wbg_ptr = ptr;
    MintAssetsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MintAssetsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_mintassets_free(ptr);
  }
  /**
   * @returns {MintAssets}
   */
  static new() {
    const ret = wasm$1.assets_new();
    return MintAssets.__wrap(ret);
  }
  /**
   * @param {AssetName} key
   * @param {Int} value
   * @returns {MintAssets}
   */
  static new_from_entry(key, value) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(key, AssetName);
      _assertClass$1(value, Int$1);
      wasm$1.mintassets_new_from_entry(retptr, key.__wbg_ptr, value.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MintAssets.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {AssetName} key
   * @param {Int} value
   * @returns {Int | undefined}
   */
  insert(key, value) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(key, AssetName);
      _assertClass$1(value, Int$1);
      wasm$1.mintassets_insert(retptr, this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 === 0 ? undefined : Int$1.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {AssetName} key
   * @returns {Int | undefined}
   */
  get(key) {
    _assertClass$1(key, AssetName);
    const ret = wasm$1.mintassets_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : Int$1.__wrap(ret);
  }
  /**
   * @returns {AssetNames}
   */
  keys() {
    const ret = wasm$1.mintassets_keys(this.__wbg_ptr);
    return AssetNames.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_mintbuilder_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_mintwitness_free(ptr >>> 0));

const MintsAssetsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_mintsassets_free(ptr >>> 0));
/**
 */
class MintsAssets {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MintsAssets.prototype);
    obj.__wbg_ptr = ptr;
    MintsAssetsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MintsAssetsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_mintsassets_free(ptr);
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mintsassets_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.mintsassets_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {MintsAssets}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.mintsassets_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MintsAssets.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MintsAssets}
   */
  static new() {
    const ret = wasm$1.assetnames_new();
    return MintsAssets.__wrap(ret);
  }
  /**
   * @param {MintAssets} mint_assets
   */
  add(mint_assets) {
    _assertClass$1(mint_assets, MintAssets);
    wasm$1.mintsassets_add(this.__wbg_ptr, mint_assets.__wbg_ptr);
  }
  /**
   * @param {number} index
   * @returns {MintAssets | undefined}
   */
  get(index) {
    const ret = wasm$1.mintsassets_get(this.__wbg_ptr, index);
    return ret === 0 ? undefined : MintAssets.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
}

const MoveInstantaneousRewardFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_moveinstantaneousreward_free(ptr >>> 0));
/**
 */
class MoveInstantaneousReward {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MoveInstantaneousReward.prototype);
    obj.__wbg_ptr = ptr;
    MoveInstantaneousRewardFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MoveInstantaneousRewardFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_moveinstantaneousreward_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousreward_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MoveInstantaneousReward}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.moveinstantaneousreward_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MoveInstantaneousReward.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousreward_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MoveInstantaneousReward}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.moveinstantaneousreward_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MoveInstantaneousReward.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousreward_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousreward_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {MoveInstantaneousReward}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.moveinstantaneousreward_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MoveInstantaneousReward.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {MIRPot} pot
   * @param {BigNum} amount
   * @returns {MoveInstantaneousReward}
   */
  static new_to_other_pot(pot, amount) {
    _assertClass$1(amount, BigNum$1);
    const ret = wasm$1.moveinstantaneousreward_new_to_other_pot(pot, amount.__wbg_ptr);
    return MoveInstantaneousReward.__wrap(ret);
  }
  /**
   * @param {MIRPot} pot
   * @param {MIRToStakeCredentials} amounts
   * @returns {MoveInstantaneousReward}
   */
  static new_to_stake_creds(pot, amounts) {
    _assertClass$1(amounts, MIRToStakeCredentials);
    const ret = wasm$1.moveinstantaneousreward_new_to_stake_creds(pot, amounts.__wbg_ptr);
    return MoveInstantaneousReward.__wrap(ret);
  }
  /**
   * @returns {MIRPot}
   */
  pot() {
    const ret = wasm$1.moveinstantaneousreward_pot(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {MIRKind}
   */
  kind() {
    const ret = wasm$1.moveinstantaneousreward_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {BigNum | undefined}
   */
  as_to_other_pot() {
    const ret = wasm$1.moveinstantaneousreward_as_to_other_pot(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @returns {MIRToStakeCredentials | undefined}
   */
  as_to_stake_creds() {
    const ret = wasm$1.moveinstantaneousreward_as_to_stake_creds(this.__wbg_ptr);
    return ret === 0 ? undefined : MIRToStakeCredentials.__wrap(ret);
  }
}

const MoveInstantaneousRewardsCertFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_moveinstantaneousrewardscert_free(ptr >>> 0));
/**
 */
class MoveInstantaneousRewardsCert {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MoveInstantaneousRewardsCert.prototype);
    obj.__wbg_ptr = ptr;
    MoveInstantaneousRewardsCertFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MoveInstantaneousRewardsCertFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_moveinstantaneousrewardscert_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousrewardscert_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MoveInstantaneousRewardsCert}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.moveinstantaneousrewardscert_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MoveInstantaneousRewardsCert.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousrewardscert_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MoveInstantaneousRewardsCert}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.moveinstantaneousrewardscert_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MoveInstantaneousRewardsCert.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousrewardscert_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.moveinstantaneousrewardscert_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {MoveInstantaneousRewardsCert}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.moveinstantaneousrewardscert_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MoveInstantaneousRewardsCert.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MoveInstantaneousReward}
   */
  move_instantaneous_reward() {
    const ret = wasm$1.moveinstantaneousrewardscert_move_instantaneous_reward(this.__wbg_ptr);
    return MoveInstantaneousReward.__wrap(ret);
  }
  /**
   * @param {MoveInstantaneousReward} move_instantaneous_reward
   * @returns {MoveInstantaneousRewardsCert}
   */
  static new(move_instantaneous_reward) {
    _assertClass$1(move_instantaneous_reward, MoveInstantaneousReward);
    const ret = wasm$1.moveinstantaneousrewardscert_new(move_instantaneous_reward.__wbg_ptr);
    return MoveInstantaneousRewardsCert.__wrap(ret);
  }
}

const MultiAssetFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_multiasset_free(ptr >>> 0));
/**
 */
class MultiAsset {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MultiAsset.prototype);
    obj.__wbg_ptr = ptr;
    MultiAssetFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MultiAssetFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_multiasset_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multiasset_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MultiAsset}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.multiasset_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MultiAsset.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multiasset_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MultiAsset}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.multiasset_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MultiAsset.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multiasset_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multiasset_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {MultiAsset}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.multiasset_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MultiAsset.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MultiAsset}
   */
  static new() {
    const ret = wasm$1.assets_new();
    return MultiAsset.__wrap(ret);
  }
  /**
   * the number of unique policy IDs in the multiasset
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * set (and replace if it exists) all assets with policy {policy_id} to a copy of {assets}
   * @param {ScriptHash} policy_id
   * @param {Assets} assets
   * @returns {Assets | undefined}
   */
  insert(policy_id, assets) {
    _assertClass$1(policy_id, ScriptHash);
    _assertClass$1(assets, Assets);
    const ret = wasm$1.multiasset_insert(this.__wbg_ptr, policy_id.__wbg_ptr, assets.__wbg_ptr);
    return ret === 0 ? undefined : Assets.__wrap(ret);
  }
  /**
   * all assets under {policy_id}, if any exist, or else None (undefined in JS)
   * @param {ScriptHash} policy_id
   * @returns {Assets | undefined}
   */
  get(policy_id) {
    _assertClass$1(policy_id, ScriptHash);
    const ret = wasm$1.multiasset_get(this.__wbg_ptr, policy_id.__wbg_ptr);
    return ret === 0 ? undefined : Assets.__wrap(ret);
  }
  /**
   * sets the asset {asset_name} to {value} under policy {policy_id}
   * returns the previous amount if it was set, or else None (undefined in JS)
   * @param {ScriptHash} policy_id
   * @param {AssetName} asset_name
   * @param {BigNum} value
   * @returns {BigNum | undefined}
   */
  set_asset(policy_id, asset_name, value) {
    _assertClass$1(policy_id, ScriptHash);
    _assertClass$1(asset_name, AssetName);
    _assertClass$1(value, BigNum$1);
    const ret = wasm$1.multiasset_set_asset(this.__wbg_ptr, policy_id.__wbg_ptr, asset_name.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * returns the amount of asset {asset_name} under policy {policy_id}
   * If such an asset does not exist, 0 is returned.
   * @param {ScriptHash} policy_id
   * @param {AssetName} asset_name
   * @returns {BigNum}
   */
  get_asset(policy_id, asset_name) {
    _assertClass$1(policy_id, ScriptHash);
    _assertClass$1(asset_name, AssetName);
    const ret = wasm$1.multiasset_get_asset(this.__wbg_ptr, policy_id.__wbg_ptr, asset_name.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * returns all policy IDs used by assets in this multiasset
   * @returns {ScriptHashes}
   */
  keys() {
    const ret = wasm$1.multiasset_keys(this.__wbg_ptr);
    return ScriptHashes.__wrap(ret);
  }
  /**
   * removes an asset from the list if the result is 0 or less
   * does not modify this object, instead the result is returned
   * @param {MultiAsset} rhs_ma
   * @returns {MultiAsset}
   */
  sub(rhs_ma) {
    _assertClass$1(rhs_ma, MultiAsset);
    const ret = wasm$1.multiasset_sub(this.__wbg_ptr, rhs_ma.__wbg_ptr);
    return MultiAsset.__wrap(ret);
  }
}

const MultiHostNameFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_multihostname_free(ptr >>> 0));
/**
 */
class MultiHostName {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(MultiHostName.prototype);
    obj.__wbg_ptr = ptr;
    MultiHostNameFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    MultiHostNameFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_multihostname_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multihostname_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {MultiHostName}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.multihostname_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MultiHostName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multihostname_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {MultiHostName}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.multihostname_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MultiHostName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multihostname_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.multihostname_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {MultiHostName}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.multihostname_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MultiHostName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {DNSRecordSRV}
   */
  dns_name() {
    const ret = wasm$1.multihostname_dns_name(this.__wbg_ptr);
    return DNSRecordSRV.__wrap(ret);
  }
  /**
   * @param {DNSRecordSRV} dns_name
   * @returns {MultiHostName}
   */
  static new(dns_name) {
    _assertClass$1(dns_name, DNSRecordSRV);
    const ret = wasm$1.multihostname_dns_name(dns_name.__wbg_ptr);
    return MultiHostName.__wrap(ret);
  }
}

const NativeScriptFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_nativescript_free(ptr >>> 0));
/**
 */
class NativeScript {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(NativeScript.prototype);
    obj.__wbg_ptr = ptr;
    NativeScriptFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NativeScriptFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_nativescript_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescript_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NativeScript}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nativescript_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NativeScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescript_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {NativeScript}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nativescript_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NativeScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescript_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescript_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {NativeScript}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nativescript_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NativeScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {ScriptHash}
   */
  hash() {
    const ret = wasm$1.nativescript_hash(this.__wbg_ptr);
    return ScriptHash.__wrap(ret);
  }
  /**
   * @param {ScriptPubkey} script_pubkey
   * @returns {NativeScript}
   */
  static new_script_pubkey(script_pubkey) {
    _assertClass$1(script_pubkey, ScriptPubkey);
    const ret = wasm$1.nativescript_new_script_pubkey(script_pubkey.__wbg_ptr);
    return NativeScript.__wrap(ret);
  }
  /**
   * @param {ScriptAll} script_all
   * @returns {NativeScript}
   */
  static new_script_all(script_all) {
    _assertClass$1(script_all, ScriptAll);
    const ret = wasm$1.nativescript_new_script_all(script_all.__wbg_ptr);
    return NativeScript.__wrap(ret);
  }
  /**
   * @param {ScriptAny} script_any
   * @returns {NativeScript}
   */
  static new_script_any(script_any) {
    _assertClass$1(script_any, ScriptAny);
    const ret = wasm$1.nativescript_new_script_any(script_any.__wbg_ptr);
    return NativeScript.__wrap(ret);
  }
  /**
   * @param {ScriptNOfK} script_n_of_k
   * @returns {NativeScript}
   */
  static new_script_n_of_k(script_n_of_k) {
    _assertClass$1(script_n_of_k, ScriptNOfK);
    const ret = wasm$1.nativescript_new_script_n_of_k(script_n_of_k.__wbg_ptr);
    return NativeScript.__wrap(ret);
  }
  /**
   * @param {TimelockStart} timelock_start
   * @returns {NativeScript}
   */
  static new_timelock_start(timelock_start) {
    _assertClass$1(timelock_start, TimelockStart);
    const ret = wasm$1.nativescript_new_timelock_start(timelock_start.__wbg_ptr);
    return NativeScript.__wrap(ret);
  }
  /**
   * @param {TimelockExpiry} timelock_expiry
   * @returns {NativeScript}
   */
  static new_timelock_expiry(timelock_expiry) {
    _assertClass$1(timelock_expiry, TimelockExpiry);
    const ret = wasm$1.nativescript_new_timelock_expiry(timelock_expiry.__wbg_ptr);
    return NativeScript.__wrap(ret);
  }
  /**
   * @returns {NativeScriptKind}
   */
  kind() {
    const ret = wasm$1.nativescript_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {ScriptPubkey | undefined}
   */
  as_script_pubkey() {
    const ret = wasm$1.nativescript_as_script_pubkey(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptPubkey.__wrap(ret);
  }
  /**
   * @returns {ScriptAll | undefined}
   */
  as_script_all() {
    const ret = wasm$1.nativescript_as_script_all(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptAll.__wrap(ret);
  }
  /**
   * @returns {ScriptAny | undefined}
   */
  as_script_any() {
    const ret = wasm$1.nativescript_as_script_any(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptAny.__wrap(ret);
  }
  /**
   * @returns {ScriptNOfK | undefined}
   */
  as_script_n_of_k() {
    const ret = wasm$1.nativescript_as_script_n_of_k(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptNOfK.__wrap(ret);
  }
  /**
   * @returns {TimelockStart | undefined}
   */
  as_timelock_start() {
    const ret = wasm$1.nativescript_as_timelock_start(this.__wbg_ptr);
    return ret === 0 ? undefined : TimelockStart.__wrap(ret);
  }
  /**
   * @returns {TimelockExpiry | undefined}
   */
  as_timelock_expiry() {
    const ret = wasm$1.nativescript_as_timelock_expiry(this.__wbg_ptr);
    return ret === 0 ? undefined : TimelockExpiry.__wrap(ret);
  }
  /**
   * Returns a set of Ed25519KeyHashes
   * contained within this script recursively on any depth level.
   * The order of the keys in the result is not determined in any way.
   * @returns {Ed25519KeyHashes}
   */
  get_required_signers() {
    const ret = wasm$1.nativescript_get_required_signers(this.__wbg_ptr);
    return Ed25519KeyHashes.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_nativescriptsource_free(ptr >>> 0));

const NativeScriptsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_nativescripts_free(ptr >>> 0));
/**
 */
class NativeScripts {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(NativeScripts.prototype);
    obj.__wbg_ptr = ptr;
    NativeScriptsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NativeScriptsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_nativescripts_free(ptr);
  }
  /**
   * @returns {NativeScripts}
   */
  static new() {
    const ret = wasm$1.nativescripts_new();
    return NativeScripts.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.ed25519keyhashes_len(this.__wbg_ptr); } else {
      ret = wasm$1.nativescripts_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {NativeScript}
   */
  get(index) {
    const ret = wasm$1.nativescripts_get(this.__wbg_ptr, index);
    return NativeScript.__wrap(ret);
  }
  /**
   * @param {NativeScript} elem
   */
  add(elem) {
    _assertClass$1(elem, NativeScript);
    wasm$1.nativescripts_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescripts_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NativeScripts}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nativescripts_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NativeScripts.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescripts_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {NativeScripts}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nativescripts_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NativeScripts.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescripts_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nativescripts_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {NativeScripts}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nativescripts_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NativeScripts.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const NetworkIdFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_networkid_free(ptr >>> 0));
/**
 */
class NetworkId {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(NetworkId.prototype);
    obj.__wbg_ptr = ptr;
    NetworkIdFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NetworkIdFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_networkid_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.networkid_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NetworkId}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.networkid_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NetworkId.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.networkid_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {NetworkId}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.networkid_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NetworkId.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.networkid_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.networkid_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {NetworkId}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.networkid_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NetworkId.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {NetworkId}
   */
  static testnet() {
    const ret = wasm$1.networkid_testnet();
    return NetworkId.__wrap(ret);
  }
  /**
   * @returns {NetworkId}
   */
  static mainnet() {
    const ret = wasm$1.networkid_mainnet();
    return NetworkId.__wrap(ret);
  }
  /**
   * @returns {NetworkIdKind}
   */
  kind() {
    const ret = wasm$1.networkid_kind(this.__wbg_ptr);
    return ret;
  }
}

const NetworkInfoFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_networkinfo_free(ptr >>> 0));
/**
 */
class NetworkInfo {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(NetworkInfo.prototype);
    obj.__wbg_ptr = ptr;
    NetworkInfoFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NetworkInfoFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_networkinfo_free(ptr);
  }
  /**
   * @param {number} network_id
   * @param {number} protocol_magic
   * @returns {NetworkInfo}
   */
  static new(network_id, protocol_magic) {
    const ret = wasm$1.networkinfo_new(network_id, protocol_magic);
    return NetworkInfo.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  network_id() {
    const ret = wasm$1.networkinfo_network_id(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {number}
   */
  protocol_magic() {
    const ret = wasm$1.networkinfo_protocol_magic(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {NetworkInfo}
   */
  static testnet_preview() {
    const ret = wasm$1.networkinfo_testnet_preview();
    return NetworkInfo.__wrap(ret);
  }
  /**
   * @returns {NetworkInfo}
   */
  static testnet_preprod() {
    const ret = wasm$1.networkinfo_testnet_preprod();
    return NetworkInfo.__wrap(ret);
  }
  /**
   * @returns {NetworkInfo}
   */
  static mainnet() {
    const ret = wasm$1.networkinfo_mainnet();
    return NetworkInfo.__wrap(ret);
  }
}

const NewConstitutionActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_newconstitutionaction_free(ptr >>> 0));
/**
 */
class NewConstitutionAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(NewConstitutionAction.prototype);
    obj.__wbg_ptr = ptr;
    NewConstitutionActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NewConstitutionActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_newconstitutionaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.newconstitutionaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NewConstitutionAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.newconstitutionaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NewConstitutionAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.newconstitutionaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {NewConstitutionAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.newconstitutionaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NewConstitutionAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.newconstitutionaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.newconstitutionaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {NewConstitutionAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.newconstitutionaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NewConstitutionAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceActionId | undefined}
   */
  gov_action_id() {
    const ret = wasm$1.hardforkinitiationaction_gov_action_id(this.__wbg_ptr);
    return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);
  }
  /**
   * @returns {Constitution}
   */
  constitution() {
    const ret = wasm$1.newconstitutionaction_constitution(this.__wbg_ptr);
    return Constitution.__wrap(ret);
  }
  /**
   * @param {Constitution} constitution
   * @returns {NewConstitutionAction}
   */
  static new(constitution) {
    _assertClass$1(constitution, Constitution);
    const ret = wasm$1.newconstitutionaction_new(constitution.__wbg_ptr);
    return NewConstitutionAction.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} gov_action_id
   * @param {Constitution} constitution
   * @returns {NewConstitutionAction}
   */
  static new_with_action_id(gov_action_id, constitution) {
    _assertClass$1(gov_action_id, GovernanceActionId);
    _assertClass$1(constitution, Constitution);
    const ret = wasm$1.newconstitutionaction_new_with_action_id(gov_action_id.__wbg_ptr, constitution.__wbg_ptr);
    return NewConstitutionAction.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_hash() {
    const ret = wasm$1.newconstitutionaction_has_script_hash(this.__wbg_ptr);
    return ret !== 0;
  }
}

const NoConfidenceActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_noconfidenceaction_free(ptr >>> 0));
/**
 */
class NoConfidenceAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(NoConfidenceAction.prototype);
    obj.__wbg_ptr = ptr;
    NoConfidenceActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NoConfidenceActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_noconfidenceaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.noconfidenceaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {NoConfidenceAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.noconfidenceaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NoConfidenceAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.noconfidenceaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {NoConfidenceAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.noconfidenceaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NoConfidenceAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.noconfidenceaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.noconfidenceaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {NoConfidenceAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.noconfidenceaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return NoConfidenceAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceActionId | undefined}
   */
  gov_action_id() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.noconfidenceaction_gov_action_id(this.__wbg_ptr); } else {
      ret = wasm$1.hardforkinitiationaction_gov_action_id(this.__wbg_ptr); }
    return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);
  }
  /**
   * @returns {NoConfidenceAction}
   */
  static new() {
    const ret = wasm$1.noconfidenceaction_new();
    return NoConfidenceAction.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} gov_action_id
   * @returns {NoConfidenceAction}
   */
  static new_with_action_id(gov_action_id) {
    _assertClass$1(gov_action_id, GovernanceActionId);
    const ret = wasm$1.noconfidenceaction_new_with_action_id(gov_action_id.__wbg_ptr);
    return NoConfidenceAction.__wrap(ret);
  }
}

const NonceFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_nonce_free(ptr >>> 0));
/**
 */
class Nonce {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Nonce.prototype);
    obj.__wbg_ptr = ptr;
    NonceFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    NonceFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_nonce_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nonce_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Nonce}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nonce_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Nonce.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nonce_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Nonce}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nonce_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Nonce.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nonce_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nonce_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Nonce}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nonce_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Nonce.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Nonce}
   */
  static new_identity() {
    const ret = wasm$1.nonce_new_identity();
    return Nonce.__wrap(ret);
  }
  /**
   * @param {Uint8Array} hash
   * @returns {Nonce}
   */
  static new_from_hash(hash) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(hash, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.nonce_new_from_hash(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Nonce.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array | undefined}
   */
  get_hash() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.nonce_get_hash(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      let v1;
      if (r0 !== 0) {
        v1 = getArrayU8FromWasm0$1(r0, r1).slice();
        wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_operationalcert_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_outputdatum_free(ptr >>> 0));

const ParameterChangeActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_parameterchangeaction_free(ptr >>> 0));
/**
 */
class ParameterChangeAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ParameterChangeAction.prototype);
    obj.__wbg_ptr = ptr;
    ParameterChangeActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ParameterChangeActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_parameterchangeaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.parameterchangeaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ParameterChangeAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.parameterchangeaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ParameterChangeAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.parameterchangeaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ParameterChangeAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.parameterchangeaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ParameterChangeAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.parameterchangeaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.parameterchangeaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ParameterChangeAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.parameterchangeaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ParameterChangeAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceActionId | undefined}
   */
  gov_action_id() {
    const ret = wasm$1.parameterchangeaction_gov_action_id(this.__wbg_ptr);
    return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);
  }
  /**
   * @returns {ProtocolParamUpdate}
   */
  protocol_param_updates() {
    const ret = wasm$1.parameterchangeaction_protocol_param_updates(this.__wbg_ptr);
    return ProtocolParamUpdate.__wrap(ret);
  }
  /**
   * @returns {ScriptHash | undefined}
   */
  policy_hash() {
    const ret = wasm$1.parameterchangeaction_policy_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptHash.__wrap(ret);
  }
  /**
   * @param {ProtocolParamUpdate} protocol_param_updates
   * @returns {ParameterChangeAction}
   */
  static new(protocol_param_updates) {
    _assertClass$1(protocol_param_updates, ProtocolParamUpdate);
    const ret = wasm$1.parameterchangeaction_new(protocol_param_updates.__wbg_ptr);
    return ParameterChangeAction.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} gov_action_id
   * @param {ProtocolParamUpdate} protocol_param_updates
   * @returns {ParameterChangeAction}
   */
  static new_with_action_id(gov_action_id, protocol_param_updates) {
    _assertClass$1(gov_action_id, GovernanceActionId);
    _assertClass$1(protocol_param_updates, ProtocolParamUpdate);
    const ret = wasm$1.parameterchangeaction_new_with_action_id(gov_action_id.__wbg_ptr, protocol_param_updates.__wbg_ptr);
    return ParameterChangeAction.__wrap(ret);
  }
  /**
   * @param {ProtocolParamUpdate} protocol_param_updates
   * @param {ScriptHash} policy_hash
   * @returns {ParameterChangeAction}
   */
  static new_with_policy_hash(protocol_param_updates, policy_hash) {
    _assertClass$1(protocol_param_updates, ProtocolParamUpdate);
    _assertClass$1(policy_hash, ScriptHash);
    const ret = wasm$1.parameterchangeaction_new_with_policy_hash(protocol_param_updates.__wbg_ptr, policy_hash.__wbg_ptr);
    return ParameterChangeAction.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} gov_action_id
   * @param {ProtocolParamUpdate} protocol_param_updates
   * @param {ScriptHash} policy_hash
   * @returns {ParameterChangeAction}
   */
  static new_with_policy_hash_and_action_id(gov_action_id, protocol_param_updates, policy_hash) {
    _assertClass$1(gov_action_id, GovernanceActionId);
    _assertClass$1(protocol_param_updates, ProtocolParamUpdate);
    _assertClass$1(policy_hash, ScriptHash);
    const ret = wasm$1.parameterchangeaction_new_with_policy_hash_and_action_id(gov_action_id.__wbg_ptr, protocol_param_updates.__wbg_ptr, policy_hash.__wbg_ptr);
    return ParameterChangeAction.__wrap(ret);
  }
}

const PlutusDataFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutusdata_free(ptr >>> 0));
/**
 */
class PlutusData {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PlutusData.prototype);
    obj.__wbg_ptr = ptr;
    PlutusDataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PlutusDataFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_plutusdata_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusdata_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PlutusData}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusdata_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusdata_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PlutusData}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusdata_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {ConstrPlutusData} constr_plutus_data
   * @returns {PlutusData}
   */
  static new_constr_plutus_data(constr_plutus_data) {
    _assertClass$1(constr_plutus_data, ConstrPlutusData);
    const ret = wasm$1.plutusdata_new_constr_plutus_data(constr_plutus_data.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * Same as `.new_constr_plutus_data` but creates constr with empty data list
   * @param {BigNum} alternative
   * @returns {PlutusData}
   */
  static new_empty_constr_plutus_data(alternative) {
    _assertClass$1(alternative, BigNum$1);
    const ret = wasm$1.plutusdata_new_empty_constr_plutus_data(alternative.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * @param {BigNum} alternative
   * @param {PlutusData} plutus_data
   * @returns {PlutusData}
   */
  static new_single_value_constr_plutus_data(alternative, plutus_data) {
    _assertClass$1(alternative, BigNum$1);
    _assertClass$1(plutus_data, PlutusData);
    const ret = wasm$1.plutusdata_new_single_value_constr_plutus_data(alternative.__wbg_ptr, plutus_data.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * @param {PlutusMap} map
   * @returns {PlutusData}
   */
  static new_map(map) {
    _assertClass$1(map, PlutusMap);
    const ret = wasm$1.plutusdata_new_map(map.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * @param {PlutusList} list
   * @returns {PlutusData}
   */
  static new_list(list) {
    _assertClass$1(list, PlutusList);
    const ret = wasm$1.plutusdata_new_list(list.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * @param {BigInt} integer
   * @returns {PlutusData}
   */
  static new_integer(integer) {
    _assertClass$1(integer, BigInt$1);
    const ret = wasm$1.plutusdata_new_integer(integer.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PlutusData}
   */
  static new_bytes(bytes) {
    const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.plutusdata_new_bytes(ptr0, len0);
    return PlutusData.__wrap(ret);
  }
  /**
   * @returns {PlutusDataKind}
   */
  kind() {
    const ret = wasm$1.plutusdata_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {ConstrPlutusData | undefined}
   */
  as_constr_plutus_data() {
    const ret = wasm$1.plutusdata_as_constr_plutus_data(this.__wbg_ptr);
    return ret === 0 ? undefined : ConstrPlutusData.__wrap(ret);
  }
  /**
   * @returns {PlutusMap | undefined}
   */
  as_map() {
    const ret = wasm$1.plutusdata_as_map(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusMap.__wrap(ret);
  }
  /**
   * @returns {PlutusList | undefined}
   */
  as_list() {
    const ret = wasm$1.plutusdata_as_list(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusList.__wrap(ret);
  }
  /**
   * @returns {BigInt | undefined}
   */
  as_integer() {
    const ret = wasm$1.plutusdata_as_integer(this.__wbg_ptr);
    return ret === 0 ? undefined : BigInt$1.__wrap(ret);
  }
  /**
   * @returns {Uint8Array | undefined}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusdata_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      let v1;
      if (r0 !== 0) {
        v1 = getArrayU8FromWasm0$1(r0, r1).slice();
        wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      }
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {PlutusDatumSchema} schema
   * @returns {string}
   */
  to_json(schema) {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.decode_plutus_datum_to_json_str(retptr, this.__wbg_ptr, schema);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @param {string} json
   * @param {PlutusDatumSchema} schema
   * @returns {PlutusData}
   */
  static from_json(json, schema) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.encode_json_str_to_plutus_datum(retptr, ptr0, len0, schema);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Address} address
   * @returns {PlutusData}
   */
  static from_address(address) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(address, Address);
      wasm$1.plutusdata_from_address(retptr, address.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusData.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /** VERSION_13_2_0
   * @param {NetworkInfo} network
   * @returns {Address}
   */
  as_address(network) {
    if (version$2 === VERSION_12_1_1$1) { throw NOT_IMPLEMENTED }
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(network, NetworkInfo);
      wasm$1.plutusdata_as_address(retptr, this.__wbg_ptr, network.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Address.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const PlutusListFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutuslist_free(ptr >>> 0));
/**
 */
class PlutusList {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PlutusList.prototype);
    obj.__wbg_ptr = ptr;
    PlutusListFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PlutusListFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_plutuslist_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutuslist_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PlutusList}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutuslist_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusList.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutuslist_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PlutusList}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutuslist_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusList.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PlutusList}
   */
  static new() {
    const ret = wasm$1.plutuslist_new();
    return PlutusList.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.costmdls_len(this.__wbg_ptr); } else {
      ret = wasm$1.plutuslist_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {PlutusData}
   */
  get(index) {
    const ret = wasm$1.plutuslist_get(this.__wbg_ptr, index);
    return PlutusData.__wrap(ret);
  }
  /**
   * @param {PlutusData} elem
   */
  add(elem) {
    _assertClass$1(elem, PlutusData);
    wasm$1.plutuslist_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const PlutusMapFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutusmap_free(ptr >>> 0));
/**
 */
class PlutusMap {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PlutusMap.prototype);
    obj.__wbg_ptr = ptr;
    PlutusMapFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PlutusMapFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_plutusmap_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusmap_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PlutusMap}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusmap_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusMap.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusmap_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PlutusMap}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusmap_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusMap.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PlutusMap}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.mirtostakecredentials_new(); } else {
      ret = wasm$1.plutusmap_new(); }
    return PlutusMap.__wrap(ret);
  }
  /**
   * Return count ok different keys in the map.
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.mirtostakecredentials_len(this.__wbg_ptr); } else {
      ret = wasm$1.plutusmap_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * Returns the previous value associated with the key, if any.
   * Replace the values associated with the key.
   * @param {PlutusData} key
   * @param {PlutusMapValues} values
   * @returns {PlutusMapValues | undefined}
   */
  insert(key, values) {
    _assertClass$1(key, PlutusData);
    _assertClass$1(values, PlutusMapValues);
    const ret = wasm$1.plutusmap_insert(this.__wbg_ptr, key.__wbg_ptr, values.__wbg_ptr);
    return ret === 0 ? undefined : PlutusMapValues.__wrap(ret);
  }
  /**
   * @param {PlutusData} key
   * @returns {PlutusMapValues | undefined}
   */
  get(key) {
    _assertClass$1(key, PlutusData);
    const ret = wasm$1.plutusmap_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : PlutusMapValues.__wrap(ret);
  }
  /**
   * @returns {PlutusList}
   */
  keys() {
    const ret = wasm$1.plutusmap_keys(this.__wbg_ptr);
    return PlutusList.__wrap(ret);
  }
}

const PlutusMapValuesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutusmapvalues_free(ptr >>> 0));
/**
 */
class PlutusMapValues {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PlutusMapValues.prototype);
    obj.__wbg_ptr = ptr;
    PlutusMapValuesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PlutusMapValuesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_plutusmapvalues_free(ptr);
  }
  /**
   * @returns {PlutusMapValues}
   */
  static new() {
    const ret = wasm$1.plutusmapvalues_new();
    return PlutusMapValues.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.costmdls_len(this.__wbg_ptr); } else {
      ret = wasm$1.plutuslist_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {PlutusData | undefined}
   */
  get(index) {
    const ret = wasm$1.plutusmapvalues_get(this.__wbg_ptr, index);
    return ret === 0 ? undefined : PlutusData.__wrap(ret);
  }
  /**
   * @param {PlutusData} elem
   */
  add(elem) {
    _assertClass$1(elem, PlutusData);
    wasm$1.plutusmapvalues_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const PlutusScriptFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutusscript_free(ptr >>> 0));
/**
 */
class PlutusScript {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PlutusScript.prototype);
    obj.__wbg_ptr = ptr;
    PlutusScriptFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PlutusScriptFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_plutusscript_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusscript_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PlutusScript}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscript_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusscript_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PlutusScript}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscript_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   *
   *     * Creates a new Plutus script from the RAW bytes of the compiled script.
   *     * This does NOT include any CBOR encoding around these bytes (e.g. from "cborBytes" in cardano-cli)
   *     * If you creating this from those you should use PlutusScript::from_bytes() instead.
   *
   * @param {Uint8Array} bytes
   * @returns {PlutusScript}
   */
  static new(bytes) {
    const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.plutusscript_new(ptr0, len0);
    return PlutusScript.__wrap(ret);
  }
  /**
   *
   *     * Creates a new Plutus script from the RAW bytes of the compiled script.
   *     * This does NOT include any CBOR encoding around these bytes (e.g. from "cborBytes" in cardano-cli)
   *     * If you creating this from those you should use PlutusScript::from_bytes() instead.
   *
   * @param {Uint8Array} bytes
   * @returns {PlutusScript}
   */
  static new_v2(bytes) {
    const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.plutusscript_new_v2(ptr0, len0);
    return PlutusScript.__wrap(ret);
  }
  /**
   *
   *     * Creates a new Plutus script from the RAW bytes of the compiled script.
   *     * This does NOT include any CBOR encoding around these bytes (e.g. from "cborBytes" in cardano-cli)
   *     * If you creating this from those you should use PlutusScript::from_bytes() instead.
   *
   * @param {Uint8Array} bytes
   * @returns {PlutusScript}
   */
  static new_v3(bytes) {
    const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.plutusscript_new_v3(ptr0, len0);
    return PlutusScript.__wrap(ret);
  }
  /**
   *
   *     * Creates a new Plutus script from the RAW bytes of the compiled script.
   *     * This does NOT include any CBOR encoding around these bytes (e.g. from "cborBytes" in cardano-cli)
   *     * If you creating this from those you should use PlutusScript::from_bytes() instead.
   *
   * @param {Uint8Array} bytes
   * @param {Language} language
   * @returns {PlutusScript}
   */
  static new_with_version(bytes, language) {
    const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    _assertClass$1(language, Language);
    const ret = wasm$1.plutusscript_new_with_version(ptr0, len0, language.__wbg_ptr);
    return PlutusScript.__wrap(ret);
  }
  /**
   *
   *     * The raw bytes of this compiled Plutus script.
   *     * If you need "cborBytes" for cardano-cli use PlutusScript::to_bytes() instead.
   *
   * @returns {Uint8Array}
   */
  bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      if (version$2 === VERSION_12_1_1$1) { wasm$1.plutusscript_bytes(retptr, this.__wbg_ptr); } else {
        wasm$1.bootstrapwitness_chain_code(retptr, this.__wbg_ptr); }
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Same as `.from_bytes` but will consider the script as requiring the Plutus Language V2
   * @param {Uint8Array} bytes
   * @returns {PlutusScript}
   */
  static from_bytes_v2(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscript_from_bytes_v2(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Same as `.from_bytes` but will consider the script as requiring the Plutus Language V3
   * @param {Uint8Array} bytes
   * @returns {PlutusScript}
   */
  static from_bytes_v3(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscript_from_bytes_v3(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Same as `.from_bytes` but will consider the script as requiring the specified language version
   * @param {Uint8Array} bytes
   * @param {Language} language
   * @returns {PlutusScript}
   */
  static from_bytes_with_version(bytes, language) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      _assertClass$1(language, Language);
      wasm$1.plutusscript_from_bytes_with_version(retptr, ptr0, len0, language.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * Same as .from_hex but will consider the script as requiring the specified language version
   * @param {string} hex_str
   * @param {Language} language
   * @returns {PlutusScript}
   */
  static from_hex_with_version(hex_str, language) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      _assertClass$1(language, Language);
      wasm$1.plutusscript_from_hex_with_version(retptr, ptr0, len0, language.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScript.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {ScriptHash}
   */
  hash() {
    const ret = wasm$1.plutusscript_hash(this.__wbg_ptr);
    return ScriptHash.__wrap(ret);
  }
  /**
   * @returns {Language}
   */
  language_version() {
    const ret = wasm$1.plutusscript_language_version(this.__wbg_ptr);
    return Language.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutusscriptsource_free(ptr >>> 0));

const PlutusScriptsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutusscripts_free(ptr >>> 0));
/**
 */
class PlutusScripts {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PlutusScripts.prototype);
    obj.__wbg_ptr = ptr;
    PlutusScriptsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PlutusScriptsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_plutusscripts_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusscripts_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PlutusScripts}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscripts_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScripts.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusscripts_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PlutusScripts}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscripts_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScripts.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusscripts_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.plutusscripts_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {PlutusScripts}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.plutusscripts_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PlutusScripts.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PlutusScripts}
   */
  static new() {
    const ret = wasm$1.plutusscripts_new();
    return PlutusScripts.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.plutusscripts_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {PlutusScript}
   */
  get(index) {
    const ret = wasm$1.plutusscripts_get(this.__wbg_ptr, index);
    return PlutusScript.__wrap(ret);
  }
  /**
   * @param {PlutusScript} elem
   */
  add(elem) {
    _assertClass$1(elem, PlutusScript);
    wasm$1.plutusscripts_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutuswitness_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_plutuswitnesses_free(ptr >>> 0));

const PointerFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_pointer_free(ptr >>> 0));
/**
 */
class Pointer {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Pointer.prototype);
    obj.__wbg_ptr = ptr;
    PointerFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PointerFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_pointer_free(ptr);
  }
  /**
   * !!! DEPRECATED !!!
   * This constructor uses outdated slot number format for the ttl value, tx_index and cert_index.
   * Use `.new_pointer` instead
   * @param {number} slot
   * @param {number} tx_index
   * @param {number} cert_index
   * @returns {Pointer}
   */
  static new(slot, tx_index, cert_index) {
    const ret = wasm$1.pointer_new(slot, tx_index, cert_index);
    return Pointer.__wrap(ret);
  }
  /**
   * @param {BigNum} slot
   * @param {BigNum} tx_index
   * @param {BigNum} cert_index
   * @returns {Pointer}
   */
  static new_pointer(slot, tx_index, cert_index) {
    _assertClass$1(slot, BigNum$1);
    _assertClass$1(tx_index, BigNum$1);
    _assertClass$1(cert_index, BigNum$1);
    const ret = wasm$1.pointer_new_pointer(slot.__wbg_ptr, tx_index.__wbg_ptr, cert_index.__wbg_ptr);
    return Pointer.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  slot() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.pointer_slot(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  tx_index() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.pointer_tx_index(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  cert_index() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.pointer_cert_index(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum}
   */
  slot_bignum() {
    const ret = wasm$1.pointer_slot_bignum(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  tx_index_bignum() {
    const ret = wasm$1.pointer_tx_index_bignum(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  cert_index_bignum() {
    const ret = wasm$1.pointer_cert_index_bignum(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
}

const PointerAddressFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_pointeraddress_free(ptr >>> 0));
/**
 */
class PointerAddress {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PointerAddress.prototype);
    obj.__wbg_ptr = ptr;
    PointerAddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PointerAddressFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_pointeraddress_free(ptr);
  }
  /**
   * @param {number} network
   * @param {Credential} payment
   * @param {Pointer} stake
   * @returns {PointerAddress}
   */
  static new(network, payment, stake) {
    _assertClass$1(payment, Credential);
    _assertClass$1(stake, Pointer);
    const ret = wasm$1.pointeraddress_new(network, payment.__wbg_ptr, stake.__wbg_ptr);
    return PointerAddress.__wrap(ret);
  }
  /**
   * @returns {Credential}
   */
  payment_cred() {
    const ret = wasm$1.pointeraddress_payment_cred(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Pointer}
   */
  stake_pointer() {
    const ret = wasm$1.pointeraddress_stake_pointer(this.__wbg_ptr);
    return Pointer.__wrap(ret);
  }
  /**
   * @returns {Address}
   */
  to_address() {
    const ret = wasm$1.pointeraddress_to_address(this.__wbg_ptr);
    return Address.__wrap(ret);
  }
  /**
   * @param {Address} addr
   * @returns {PointerAddress | undefined}
   */
  static from_address(addr) {
    _assertClass$1(addr, Address);
    const ret = wasm$1.pointeraddress_from_address(addr.__wbg_ptr);
    return ret === 0 ? undefined : PointerAddress.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  network_id() {
    const ret = wasm$1.pointeraddress_network_id(this.__wbg_ptr);
    return ret;
  }
}

const PoolMetadataFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_poolmetadata_free(ptr >>> 0));
/**
 */
class PoolMetadata {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PoolMetadata.prototype);
    obj.__wbg_ptr = ptr;
    PoolMetadataFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PoolMetadataFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_poolmetadata_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolmetadata_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PoolMetadata}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolmetadata_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolMetadata.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolmetadata_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PoolMetadata}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolmetadata_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolMetadata.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolmetadata_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolmetadata_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {PoolMetadata}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolmetadata_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolMetadata.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {URL}
   */
  url() {
    const ret = wasm$1.multihostname_dns_name(this.__wbg_ptr);
    return URL$1.__wrap(ret);
  }
  /**
   * @returns {PoolMetadataHash}
   */
  pool_metadata_hash() {
    const ret = wasm$1.poolmetadata_pool_metadata_hash(this.__wbg_ptr);
    return PoolMetadataHash.__wrap(ret);
  }
  /**
   * @param {URL} url
   * @param {PoolMetadataHash} pool_metadata_hash
   * @returns {PoolMetadata}
   */
  static new(url, pool_metadata_hash) {
    _assertClass$1(url, URL$1);
    _assertClass$1(pool_metadata_hash, PoolMetadataHash);
    const ret = wasm$1.poolmetadata_new(url.__wbg_ptr, pool_metadata_hash.__wbg_ptr);
    return PoolMetadata.__wrap(ret);
  }
}

const PoolMetadataHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_poolmetadatahash_free(ptr >>> 0));
/**
 */
class PoolMetadataHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PoolMetadataHash.prototype);
    obj.__wbg_ptr = ptr;
    PoolMetadataHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PoolMetadataHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_poolmetadatahash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PoolMetadataHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolmetadatahash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolMetadataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {PoolMetadataHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolmetadatahash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolMetadataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {PoolMetadataHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolmetadatahash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolMetadataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const PoolParamsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_poolparams_free(ptr >>> 0));
/**
 */
class PoolParams {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PoolParams.prototype);
    obj.__wbg_ptr = ptr;
    PoolParamsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PoolParamsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_poolparams_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolparams_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PoolParams}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolparams_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolParams.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolparams_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PoolParams}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolparams_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolParams.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolparams_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolparams_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {PoolParams}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolparams_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolParams.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  operator() {
    const ret = wasm$1.poolparams_operator(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {VRFKeyHash}
   */
  vrf_keyhash() {
    const ret = wasm$1.poolparams_vrf_keyhash(this.__wbg_ptr);
    return VRFKeyHash.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  pledge() {
    const ret = wasm$1.poolparams_pledge(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  cost() {
    const ret = wasm$1.poolparams_cost(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  margin() {
    const ret = wasm$1.poolparams_margin(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {RewardAddress}
   */
  reward_account() {
    const ret = wasm$1.poolparams_reward_account(this.__wbg_ptr);
    return RewardAddress.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHashes}
   */
  pool_owners() {
    const ret = wasm$1.poolparams_pool_owners(this.__wbg_ptr);
    return Ed25519KeyHashes.__wrap(ret);
  }
  /**
   * @returns {Relays}
   */
  relays() {
    const ret = wasm$1.poolparams_relays(this.__wbg_ptr);
    return Relays.__wrap(ret);
  }
  /**
   * @returns {PoolMetadata | undefined}
   */
  pool_metadata() {
    const ret = wasm$1.poolparams_pool_metadata(this.__wbg_ptr);
    return ret === 0 ? undefined : PoolMetadata.__wrap(ret);
  }
  /**
   * @param {Ed25519KeyHash} operator
   * @param {VRFKeyHash} vrf_keyhash
   * @param {BigNum} pledge
   * @param {BigNum} cost
   * @param {UnitInterval} margin
   * @param {RewardAddress} reward_account
   * @param {Ed25519KeyHashes} pool_owners
   * @param {Relays} relays
   * @param {PoolMetadata | undefined} [pool_metadata]
   * @returns {PoolParams}
   */
  static new(operator, vrf_keyhash, pledge, cost, margin, reward_account, pool_owners, relays, pool_metadata) {
    _assertClass$1(operator, Ed25519KeyHash);
    _assertClass$1(vrf_keyhash, VRFKeyHash);
    _assertClass$1(pledge, BigNum$1);
    _assertClass$1(cost, BigNum$1);
    _assertClass$1(margin, UnitInterval);
    _assertClass$1(reward_account, RewardAddress);
    _assertClass$1(pool_owners, Ed25519KeyHashes);
    _assertClass$1(relays, Relays);
    let ptr0 = 0;
    if (!isLikeNone$1(pool_metadata)) {
      _assertClass$1(pool_metadata, PoolMetadata);
      ptr0 = pool_metadata.__destroy_into_raw();
    }
    const ret = wasm$1.poolparams_new(operator.__wbg_ptr, vrf_keyhash.__wbg_ptr, pledge.__wbg_ptr, cost.__wbg_ptr, margin.__wbg_ptr, reward_account.__wbg_ptr, pool_owners.__wbg_ptr, relays.__wbg_ptr, ptr0);
    return PoolParams.__wrap(ret);
  }
}

const PoolRegistrationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_poolregistration_free(ptr >>> 0));
/**
 */
class PoolRegistration {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PoolRegistration.prototype);
    obj.__wbg_ptr = ptr;
    PoolRegistrationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PoolRegistrationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_poolregistration_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolregistration_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PoolRegistration}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolregistration_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolregistration_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PoolRegistration}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolregistration_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolregistration_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolregistration_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {PoolRegistration}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolregistration_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PoolParams}
   */
  pool_params() {
    const ret = wasm$1.poolregistration_pool_params(this.__wbg_ptr);
    return PoolParams.__wrap(ret);
  }
  /**
   * @param {PoolParams} pool_params
   * @returns {PoolRegistration}
   */
  static new(pool_params) {
    _assertClass$1(pool_params, PoolParams);
    const ret = wasm$1.poolregistration_new(pool_params.__wbg_ptr);
    return PoolRegistration.__wrap(ret);
  }
}

const PoolRetirementFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_poolretirement_free(ptr >>> 0));
/**
 */
class PoolRetirement {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PoolRetirement.prototype);
    obj.__wbg_ptr = ptr;
    PoolRetirementFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PoolRetirementFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_poolretirement_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolretirement_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PoolRetirement}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolretirement_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolRetirement.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolretirement_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PoolRetirement}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolretirement_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolRetirement.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolretirement_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolretirement_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {PoolRetirement}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolretirement_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolRetirement.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash() {
    const ret = wasm$1.poolretirement_pool_keyhash(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  epoch() {
    const ret = wasm$1.poolretirement_epoch(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {Ed25519KeyHash} pool_keyhash
   * @param {number} epoch
   * @returns {PoolRetirement}
   */
  static new(pool_keyhash, epoch) {
    _assertClass$1(pool_keyhash, Ed25519KeyHash);
    const ret = wasm$1.poolretirement_new(pool_keyhash.__wbg_ptr, epoch);
    return PoolRetirement.__wrap(ret);
  }
}

const PoolVotingThresholdsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_poolvotingthresholds_free(ptr >>> 0));
/**
 */
class PoolVotingThresholds {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PoolVotingThresholds.prototype);
    obj.__wbg_ptr = ptr;
    PoolVotingThresholdsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PoolVotingThresholdsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_poolvotingthresholds_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolvotingthresholds_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PoolVotingThresholds}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolvotingthresholds_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolVotingThresholds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolvotingthresholds_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {PoolVotingThresholds}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolvotingthresholds_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolVotingThresholds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolvotingthresholds_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.poolvotingthresholds_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {PoolVotingThresholds}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.poolvotingthresholds_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PoolVotingThresholds.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {UnitInterval} motion_no_confidence
   * @param {UnitInterval} committee_normal
   * @param {UnitInterval} committee_no_confidence
   * @param {UnitInterval} hard_fork_initiation
   * @param {UnitInterval} security_relevant_threshold
   * @returns {PoolVotingThresholds}
   */
  static new(motion_no_confidence, committee_normal, committee_no_confidence, hard_fork_initiation, security_relevant_threshold) {
    _assertClass$1(motion_no_confidence, UnitInterval);
    _assertClass$1(committee_normal, UnitInterval);
    _assertClass$1(committee_no_confidence, UnitInterval);
    _assertClass$1(hard_fork_initiation, UnitInterval);
    _assertClass$1(security_relevant_threshold, UnitInterval);
    const ret = wasm$1.poolvotingthresholds_new(motion_no_confidence.__wbg_ptr, committee_normal.__wbg_ptr, committee_no_confidence.__wbg_ptr, hard_fork_initiation.__wbg_ptr, security_relevant_threshold.__wbg_ptr);
    return PoolVotingThresholds.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  motion_no_confidence() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.drepvotingthresholds_motion_no_confidence(this.__wbg_ptr); } else {
      ret = wasm$1.committee_quorum_threshold(this.__wbg_ptr); }
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  committee_normal() {
    const ret = wasm$1.drepvotingthresholds_committee_normal(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  committee_no_confidence() {
    const ret = wasm$1.drepvotingthresholds_committee_no_confidence(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  hard_fork_initiation() {
    const ret = wasm$1.drepvotingthresholds_update_constitution(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
  /**
   * @returns {UnitInterval}
   */
  security_relevant_threshold() {
    const ret = wasm$1.drepvotingthresholds_hard_fork_initiation(this.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
}

const PrivateKeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_privatekey_free(ptr >>> 0));
/**
 */
class PrivateKey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PrivateKey.prototype);
    obj.__wbg_ptr = ptr;
    PrivateKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PrivateKeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_privatekey_free(ptr);
  }
  /**
   * @param {string} hex_str
   * @returns {PrivateKey}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.privatekey_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.privatekey_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {Uint8Array} message
   * @returns {Ed25519Signature}
   */
  sign(message) {
    const ptr0 = passArray8ToWasm0$1(message, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    const ret = wasm$1.privatekey_sign(this.__wbg_ptr, ptr0, len0);
    return Ed25519Signature.__wrap(ret);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PrivateKey}
   */
  static from_normal_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.privatekey_from_normal_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PrivateKey}
   */
  static from_extended_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.privatekey_from_extended_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.privatekey_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_bech32() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.privatekey_to_bech32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Get private key from its bech32 representation
   * ```javascript
   * PrivateKey.from_bech32(&#39;ed25519_sk1ahfetf02qwwg4dkq7mgp4a25lx5vh9920cr5wnxmpzz9906qvm8qwvlts0&#39;);
   * ```
   * For an extended 25519 key
   * ```javascript
   * PrivateKey.from_bech32(&#39;ed25519e_sk1gqwl4szuwwh6d0yk3nsqcc6xxc3fpvjlevgwvt60df59v8zd8f8prazt8ln3lmz096ux3xvhhvm3ca9wj2yctdh3pnw0szrma07rt5gl748fp&#39;);
   * ```
   * @param {string} bech32_str
   * @returns {PrivateKey}
   */
  static from_bech32(bech32_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech32_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.privatekey_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PrivateKey}
   */
  static generate_ed25519extended() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.privatekey_generate_ed25519extended(retptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PrivateKey}
   */
  static generate_ed25519() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.privatekey_generate_ed25519(retptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PrivateKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {PublicKey}
   */
  to_public() {
    const ret = wasm$1.privatekey_to_public(this.__wbg_ptr);
    return PublicKey.__wrap(ret);
  }
}

const ProposedProtocolParameterUpdatesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_proposedprotocolparameterupdates_free(ptr >>> 0));
/**
 */
class ProposedProtocolParameterUpdates {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ProposedProtocolParameterUpdates.prototype);
    obj.__wbg_ptr = ptr;
    ProposedProtocolParameterUpdatesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ProposedProtocolParameterUpdatesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_proposedprotocolparameterupdates_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.proposedprotocolparameterupdates_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ProposedProtocolParameterUpdates}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.proposedprotocolparameterupdates_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProposedProtocolParameterUpdates.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.proposedprotocolparameterupdates_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ProposedProtocolParameterUpdates}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.proposedprotocolparameterupdates_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProposedProtocolParameterUpdates.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.proposedprotocolparameterupdates_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.proposedprotocolparameterupdates_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ProposedProtocolParameterUpdates}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.proposedprotocolparameterupdates_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProposedProtocolParameterUpdates.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {ProposedProtocolParameterUpdates}
   */
  static new() {
    const ret = wasm$1.auxiliarydataset_new();
    return ProposedProtocolParameterUpdates.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.auxiliarydataset_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {GenesisHash} key
   * @param {ProtocolParamUpdate} value
   * @returns {ProtocolParamUpdate | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, GenesisHash);
    _assertClass$1(value, ProtocolParamUpdate);
    const ret = wasm$1.proposedprotocolparameterupdates_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);
  }
  /**
   * @param {GenesisHash} key
   * @returns {ProtocolParamUpdate | undefined}
   */
  get(key) {
    _assertClass$1(key, GenesisHash);
    const ret = wasm$1.proposedprotocolparameterupdates_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : ProtocolParamUpdate.__wrap(ret);
  }
  /**
   * @returns {GenesisHashes}
   */
  keys() {
    const ret = wasm$1.proposedprotocolparameterupdates_keys(this.__wbg_ptr);
    return GenesisHashes.__wrap(ret);
  }
}

const ProtocolParamUpdateFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_protocolparamupdate_free(ptr >>> 0));
/**
 */
class ProtocolParamUpdate {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ProtocolParamUpdate.prototype);
    obj.__wbg_ptr = ptr;
    ProtocolParamUpdateFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ProtocolParamUpdateFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_protocolparamupdate_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ProtocolParamUpdate}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.protocolparamupdate_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProtocolParamUpdate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ProtocolParamUpdate}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.protocolparamupdate_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProtocolParamUpdate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ProtocolParamUpdate}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.protocolparamupdate_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProtocolParamUpdate.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} minfee_a
   */
  set_minfee_a(minfee_a) {
    _assertClass$1(minfee_a, BigNum$1);
    wasm$1.protocolparamupdate_set_minfee_a(this.__wbg_ptr, minfee_a.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  minfee_a() {
    const ret = wasm$1.protocolparamupdate_minfee_a(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} minfee_b
   */
  set_minfee_b(minfee_b) {
    _assertClass$1(minfee_b, BigNum$1);
    wasm$1.protocolparamupdate_set_minfee_b(this.__wbg_ptr, minfee_b.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  minfee_b() {
    const ret = wasm$1.protocolparamupdate_minfee_b(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {number} max_block_body_size
   */
  set_max_block_body_size(max_block_body_size) {
    wasm$1.protocolparamupdate_set_max_block_body_size(this.__wbg_ptr, max_block_body_size);
  }
  /**
   * @returns {number | undefined}
   */
  max_block_body_size() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_max_block_body_size(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} max_tx_size
   */
  set_max_tx_size(max_tx_size) {
    wasm$1.protocolparamupdate_set_max_tx_size(this.__wbg_ptr, max_tx_size);
  }
  /**
   * @returns {number | undefined}
   */
  max_tx_size() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_max_tx_size(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} max_block_header_size
   */
  set_max_block_header_size(max_block_header_size) {
    wasm$1.protocolparamupdate_set_max_block_header_size(this.__wbg_ptr, max_block_header_size);
  }
  /**
   * @returns {number | undefined}
   */
  max_block_header_size() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_max_block_header_size(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} key_deposit
   */
  set_key_deposit(key_deposit) {
    _assertClass$1(key_deposit, BigNum$1);
    wasm$1.protocolparamupdate_set_key_deposit(this.__wbg_ptr, key_deposit.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  key_deposit() {
    const ret = wasm$1.protocolparamupdate_key_deposit(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} pool_deposit
   */
  set_pool_deposit(pool_deposit) {
    _assertClass$1(pool_deposit, BigNum$1);
    wasm$1.protocolparamupdate_set_pool_deposit(this.__wbg_ptr, pool_deposit.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  pool_deposit() {
    const ret = wasm$1.protocolparamupdate_pool_deposit(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {number} max_epoch
   */
  set_max_epoch(max_epoch) {
    wasm$1.protocolparamupdate_set_max_epoch(this.__wbg_ptr, max_epoch);
  }
  /**
   * @returns {number | undefined}
   */
  max_epoch() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_max_epoch(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} n_opt
   */
  set_n_opt(n_opt) {
    wasm$1.protocolparamupdate_set_n_opt(this.__wbg_ptr, n_opt);
  }
  /**
   * @returns {number | undefined}
   */
  n_opt() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_n_opt(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {UnitInterval} pool_pledge_influence
   */
  set_pool_pledge_influence(pool_pledge_influence) {
    _assertClass$1(pool_pledge_influence, UnitInterval);
    wasm$1.protocolparamupdate_set_pool_pledge_influence(this.__wbg_ptr, pool_pledge_influence.__wbg_ptr);
  }
  /**
   * @returns {UnitInterval | undefined}
   */
  pool_pledge_influence() {
    const ret = wasm$1.protocolparamupdate_pool_pledge_influence(this.__wbg_ptr);
    return ret === 0 ? undefined : UnitInterval.__wrap(ret);
  }
  /**
   * @param {UnitInterval} expansion_rate
   */
  set_expansion_rate(expansion_rate) {
    _assertClass$1(expansion_rate, UnitInterval);
    wasm$1.protocolparamupdate_set_expansion_rate(this.__wbg_ptr, expansion_rate.__wbg_ptr);
  }
  /**
   * @returns {UnitInterval | undefined}
   */
  expansion_rate() {
    const ret = wasm$1.protocolparamupdate_expansion_rate(this.__wbg_ptr);
    return ret === 0 ? undefined : UnitInterval.__wrap(ret);
  }
  /**
   * @param {UnitInterval} treasury_growth_rate
   */
  set_treasury_growth_rate(treasury_growth_rate) {
    _assertClass$1(treasury_growth_rate, UnitInterval);
    wasm$1.protocolparamupdate_set_treasury_growth_rate(this.__wbg_ptr, treasury_growth_rate.__wbg_ptr);
  }
  /**
   * @returns {UnitInterval | undefined}
   */
  treasury_growth_rate() {
    const ret = wasm$1.protocolparamupdate_treasury_growth_rate(this.__wbg_ptr);
    return ret === 0 ? undefined : UnitInterval.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Since babbage era this param is outdated. But this param you can meet in a pre-babbage block.
   * @returns {UnitInterval | undefined}
   */
  d() {
    const ret = wasm$1.protocolparamupdate_d(this.__wbg_ptr);
    return ret === 0 ? undefined : UnitInterval.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Since babbage era this param is outdated. But this param you can meet in a pre-babbage block.
   * @returns {Nonce | undefined}
   */
  extra_entropy() {
    const ret = wasm$1.protocolparamupdate_extra_entropy(this.__wbg_ptr);
    return ret === 0 ? undefined : Nonce.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Since conway era this param is outdated. But this param you can meet in a pre-conway block.
   * @param {ProtocolVersion} protocol_version
   */
  set_protocol_version(protocol_version) {
    _assertClass$1(protocol_version, ProtocolVersion);
    wasm$1.protocolparamupdate_set_protocol_version(this.__wbg_ptr, protocol_version.__wbg_ptr);
  }
  /**
   * @returns {ProtocolVersion | undefined}
   */
  protocol_version() {
    const ret = wasm$1.protocolparamupdate_protocol_version(this.__wbg_ptr);
    return ret === 0 ? undefined : ProtocolVersion.__wrap(ret);
  }
  /**
   * @param {BigNum} min_pool_cost
   */
  set_min_pool_cost(min_pool_cost) {
    _assertClass$1(min_pool_cost, BigNum$1);
    wasm$1.protocolparamupdate_set_min_pool_cost(this.__wbg_ptr, min_pool_cost.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  min_pool_cost() {
    const ret = wasm$1.protocolparamupdate_min_pool_cost(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} ada_per_utxo_byte
   */
  set_ada_per_utxo_byte(ada_per_utxo_byte) {
    _assertClass$1(ada_per_utxo_byte, BigNum$1);
    wasm$1.protocolparamupdate_set_ada_per_utxo_byte(this.__wbg_ptr, ada_per_utxo_byte.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  ada_per_utxo_byte() {
    const ret = wasm$1.protocolparamupdate_ada_per_utxo_byte(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {Costmdls} cost_models
   */
  set_cost_models(cost_models) {
    _assertClass$1(cost_models, Costmdls);
    wasm$1.protocolparamupdate_set_cost_models(this.__wbg_ptr, cost_models.__wbg_ptr);
  }
  /**
   * @returns {Costmdls | undefined}
   */
  cost_models() {
    const ret = wasm$1.protocolparamupdate_cost_models(this.__wbg_ptr);
    return ret === 0 ? undefined : Costmdls.__wrap(ret);
  }
  /**
   * @param {ExUnitPrices} execution_costs
   */
  set_execution_costs(execution_costs) {
    _assertClass$1(execution_costs, ExUnitPrices);
    wasm$1.protocolparamupdate_set_execution_costs(this.__wbg_ptr, execution_costs.__wbg_ptr);
  }
  /**
   * @returns {ExUnitPrices | undefined}
   */
  execution_costs() {
    const ret = wasm$1.protocolparamupdate_execution_costs(this.__wbg_ptr);
    return ret === 0 ? undefined : ExUnitPrices.__wrap(ret);
  }
  /**
   * @param {ExUnits} max_tx_ex_units
   */
  set_max_tx_ex_units(max_tx_ex_units) {
    _assertClass$1(max_tx_ex_units, ExUnits);
    wasm$1.protocolparamupdate_set_max_tx_ex_units(this.__wbg_ptr, max_tx_ex_units.__wbg_ptr);
  }
  /**
   * @returns {ExUnits | undefined}
   */
  max_tx_ex_units() {
    const ret = wasm$1.protocolparamupdate_max_tx_ex_units(this.__wbg_ptr);
    return ret === 0 ? undefined : ExUnits.__wrap(ret);
  }
  /**
   * @param {ExUnits} max_block_ex_units
   */
  set_max_block_ex_units(max_block_ex_units) {
    _assertClass$1(max_block_ex_units, ExUnits);
    wasm$1.protocolparamupdate_set_max_block_ex_units(this.__wbg_ptr, max_block_ex_units.__wbg_ptr);
  }
  /**
   * @returns {ExUnits | undefined}
   */
  max_block_ex_units() {
    const ret = wasm$1.protocolparamupdate_max_block_ex_units(this.__wbg_ptr);
    return ret === 0 ? undefined : ExUnits.__wrap(ret);
  }
  /**
   * @param {number} max_value_size
   */
  set_max_value_size(max_value_size) {
    wasm$1.protocolparamupdate_set_max_value_size(this.__wbg_ptr, max_value_size);
  }
  /**
   * @returns {number | undefined}
   */
  max_value_size() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_max_value_size(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} collateral_percentage
   */
  set_collateral_percentage(collateral_percentage) {
    wasm$1.protocolparamupdate_set_collateral_percentage(this.__wbg_ptr, collateral_percentage);
  }
  /**
   * @returns {number | undefined}
   */
  collateral_percentage() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_collateral_percentage(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} max_collateral_inputs
   */
  set_max_collateral_inputs(max_collateral_inputs) {
    wasm$1.protocolparamupdate_set_max_collateral_inputs(this.__wbg_ptr, max_collateral_inputs);
  }
  /**
   * @returns {number | undefined}
   */
  max_collateral_inputs() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_max_collateral_inputs(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {PoolVotingThresholds} pool_voting_thresholds
   */
  set_pool_voting_thresholds(pool_voting_thresholds) {
    _assertClass$1(pool_voting_thresholds, PoolVotingThresholds);
    wasm$1.protocolparamupdate_set_pool_voting_thresholds(this.__wbg_ptr, pool_voting_thresholds.__wbg_ptr);
  }
  /**
   * @returns {PoolVotingThresholds | undefined}
   */
  pool_voting_thresholds() {
    const ret = wasm$1.protocolparamupdate_pool_voting_thresholds(this.__wbg_ptr);
    return ret === 0 ? undefined : PoolVotingThresholds.__wrap(ret);
  }
  /**
   * @param {DRepVotingThresholds} drep_voting_thresholds
   */
  set_drep_voting_thresholds(drep_voting_thresholds) {
    _assertClass$1(drep_voting_thresholds, DRepVotingThresholds);
    wasm$1.protocolparamupdate_set_drep_voting_thresholds(this.__wbg_ptr, drep_voting_thresholds.__wbg_ptr);
  }
  /**
   * @returns {DRepVotingThresholds | undefined}
   */
  drep_voting_thresholds() {
    const ret = wasm$1.protocolparamupdate_drep_voting_thresholds(this.__wbg_ptr);
    return ret === 0 ? undefined : DRepVotingThresholds.__wrap(ret);
  }
  /**
   * @param {number} min_committee_size
   */
  set_min_committee_size(min_committee_size) {
    wasm$1.protocolparamupdate_set_min_committee_size(this.__wbg_ptr, min_committee_size);
  }
  /**
   * @returns {number | undefined}
   */
  min_committee_size() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_min_committee_size(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} committee_term_limit
   */
  set_committee_term_limit(committee_term_limit) {
    wasm$1.protocolparamupdate_set_committee_term_limit(this.__wbg_ptr, committee_term_limit);
  }
  /**
   * @returns {number | undefined}
   */
  committee_term_limit() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_committee_term_limit(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {number} governance_action_validity_period
   */
  set_governance_action_validity_period(governance_action_validity_period) {
    wasm$1.protocolparamupdate_set_governance_action_validity_period(this.__wbg_ptr, governance_action_validity_period);
  }
  /**
   * @returns {number | undefined}
   */
  governance_action_validity_period() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_governance_action_validity_period(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} governance_action_deposit
   */
  set_governance_action_deposit(governance_action_deposit) {
    _assertClass$1(governance_action_deposit, BigNum$1);
    wasm$1.protocolparamupdate_set_governance_action_deposit(this.__wbg_ptr, governance_action_deposit.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  governance_action_deposit() {
    const ret = wasm$1.protocolparamupdate_governance_action_deposit(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} drep_deposit
   */
  set_drep_deposit(drep_deposit) {
    _assertClass$1(drep_deposit, BigNum$1);
    wasm$1.protocolparamupdate_set_drep_deposit(this.__wbg_ptr, drep_deposit.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  drep_deposit() {
    const ret = wasm$1.protocolparamupdate_drep_deposit(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {number} drep_inactivity_period
   */
  set_drep_inactivity_period(drep_inactivity_period) {
    wasm$1.protocolparamupdate_set_drep_inactivity_period(this.__wbg_ptr, drep_inactivity_period);
  }
  /**
   * @returns {number | undefined}
   */
  drep_inactivity_period() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolparamupdate_drep_inactivity_period(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {UnitInterval} ref_script_coins_per_byte
   */
  set_ref_script_coins_per_byte(ref_script_coins_per_byte) {
    _assertClass$1(ref_script_coins_per_byte, UnitInterval);
    wasm$1.protocolparamupdate_set_ref_script_coins_per_byte(this.__wbg_ptr, ref_script_coins_per_byte.__wbg_ptr);
  }
  /**
   * @returns {UnitInterval | undefined}
   */
  ref_script_coins_per_byte() {
    const ret = wasm$1.protocolparamupdate_ref_script_coins_per_byte(this.__wbg_ptr);
    return ret === 0 ? undefined : UnitInterval.__wrap(ret);
  }
  /**
   * @returns {ProtocolParamUpdate}
   */
  static new() {
    const ret = wasm$1.protocolparamupdate_new();
    return ProtocolParamUpdate.__wrap(ret);
  }
}

const ProtocolVersionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_protocolversion_free(ptr >>> 0));
/**
 */
class ProtocolVersion {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ProtocolVersion.prototype);
    obj.__wbg_ptr = ptr;
    ProtocolVersionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ProtocolVersionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_protocolversion_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolversion_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ProtocolVersion}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.protocolversion_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProtocolVersion.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolversion_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ProtocolVersion}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.protocolversion_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProtocolVersion.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolversion_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.protocolversion_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ProtocolVersion}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.protocolversion_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ProtocolVersion.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  major() {
    const ret = wasm$1.protocolversion_major(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {number}
   */
  minor() {
    const ret = wasm$1.protocolversion_minor(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} major
   * @param {number} minor
   * @returns {ProtocolVersion}
   */
  static new(major, minor) {
    const ret = wasm$1.protocolversion_new(major, minor);
    return ProtocolVersion.__wrap(ret);
  }
}

const PublicKeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_publickey_free(ptr >>> 0));
/**
 * ED25519 key used as public key
 */
class PublicKey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(PublicKey.prototype);
    obj.__wbg_ptr = ptr;
    PublicKeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    PublicKeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_publickey_free(ptr);
  }
  /**
   * @param {string} hex_str
   * @returns {PublicKey}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.publickey_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.publickey_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  hash() {
    const ret = wasm$1.publickey_hash(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @param {Uint8Array} data
   * @param {Ed25519Signature} signature
   * @returns {boolean}
   */
  verify(data, signature) {
    const ptr0 = passArray8ToWasm0$1(data, wasm$1.__wbindgen_malloc);
    const len0 = WASM_VECTOR_LEN$1;
    _assertClass$1(signature, Ed25519Signature);
    const ret = wasm$1.publickey_verify(this.__wbg_ptr, ptr0, len0, signature.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {PublicKey}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.publickey_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.publickey_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_bech32() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.publickey_to_bech32(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * Get public key from its bech32 representation
   * Example:
   * ```javascript
   * const pkey = PublicKey.from_bech32(&#39;ed25519_pk1dgaagyh470y66p899txcl3r0jaeaxu6yd7z2dxyk55qcycdml8gszkxze2&#39;);
   * ```
   * @param {string} bech32_str
   * @returns {PublicKey}
   */
  static from_bech32(bech32_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech32_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.publickey_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return PublicKey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_publickeys_free(ptr >>> 0));

const RedeemerFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_redeemer_free(ptr >>> 0));
/**
 */
class Redeemer {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Redeemer.prototype);
    obj.__wbg_ptr = ptr;
    RedeemerFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RedeemerFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_redeemer_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemer_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Redeemer}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemer_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Redeemer.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemer_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Redeemer}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemer_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Redeemer.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemer_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemer_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Redeemer}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemer_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Redeemer.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {RedeemerTag}
   */
  tag() {
    const ret = wasm$1.redeemer_tag(this.__wbg_ptr);
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  index() {
    const ret = wasm$1.redeemer_index(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {PlutusData}
   */
  data() {
    const ret = wasm$1.redeemer_data(this.__wbg_ptr);
    return PlutusData.__wrap(ret);
  }
  /**
   * @returns {ExUnits}
   */
  ex_units() {
    const ret = wasm$1.redeemer_ex_units(this.__wbg_ptr);
    return ExUnits.__wrap(ret);
  }
  /**
   * @param {RedeemerTag} tag
   * @param {BigNum} index
   * @param {PlutusData} data
   * @param {ExUnits} ex_units
   * @returns {Redeemer}
   */
  static new(tag, index, data, ex_units) {
    _assertClass$1(tag, RedeemerTag);
    _assertClass$1(index, BigNum$1);
    _assertClass$1(data, PlutusData);
    _assertClass$1(ex_units, ExUnits);
    const ret = wasm$1.redeemer_new(tag.__wbg_ptr, index.__wbg_ptr, data.__wbg_ptr, ex_units.__wbg_ptr);
    return Redeemer.__wrap(ret);
  }
}

const RedeemerTagFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_redeemertag_free(ptr >>> 0));
/**
 */
class RedeemerTag {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RedeemerTag.prototype);
    obj.__wbg_ptr = ptr;
    RedeemerTagFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RedeemerTagFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_redeemertag_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemertag_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {RedeemerTag}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemertag_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return RedeemerTag.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemertag_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {RedeemerTag}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemertag_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return RedeemerTag.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemertag_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemertag_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {RedeemerTag}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemertag_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return RedeemerTag.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {RedeemerTag}
   */
  static new_spend() {
    const ret = wasm$1.redeemertag_new_spend();
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {RedeemerTag}
   */
  static new_mint() {
    const ret = wasm$1.redeemertag_new_mint();
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {RedeemerTag}
   */
  static new_cert() {
    const ret = wasm$1.redeemertag_new_cert();
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {RedeemerTag}
   */
  static new_reward() {
    const ret = wasm$1.redeemertag_new_reward();
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {RedeemerTag}
   */
  static new_vote() {
    const ret = wasm$1.redeemertag_new_vote();
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {RedeemerTag}
   */
  static new_voting_proposal() {
    const ret = wasm$1.redeemertag_new_voting_proposal();
    return RedeemerTag.__wrap(ret);
  }
  /**
   * @returns {RedeemerTagKind}
   */
  kind() {
    const ret = wasm$1.redeemertag_kind(this.__wbg_ptr);
    return ret;
  }
}

const RedeemersFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_redeemers_free(ptr >>> 0));
/**
 */
class Redeemers {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Redeemers.prototype);
    obj.__wbg_ptr = ptr;
    RedeemersFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RedeemersFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_redeemers_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemers_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Redeemers}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemers_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Redeemers.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemers_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Redeemers}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemers_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Redeemers.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemers_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemers_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Redeemers}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.redeemers_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Redeemers.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Redeemers}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.plutuslist_new(); } else {
      ret = wasm$1.nativescripts_new(); }
    return Redeemers.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.costmdls_len(this.__wbg_ptr); } else {
      ret = wasm$1.nativescripts_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Redeemer}
   */
  get(index) {
    const ret = wasm$1.redeemers_get(this.__wbg_ptr, index);
    return Redeemer.__wrap(ret);
  }
  /**
   * @param {Redeemer} elem
   */
  add(elem) {
    _assertClass$1(elem, Redeemer);
    wasm$1.redeemers_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
  /** VERSION_13_2_0
   * WARNING: This function will be removed in after next hard fork
   * @returns {CborContainerType}
   */
  get_container_type() {
    if (version$2 === VERSION_12_1_1$1) { throw NOT_IMPLEMENTED }
    const ret = wasm$1.redeemers_get_container_type(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {ExUnits}
   */
  total_ex_units() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.redeemers_total_ex_units(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ExUnits.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const RelayFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_relay_free(ptr >>> 0));
/**
 */
class Relay {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Relay.prototype);
    obj.__wbg_ptr = ptr;
    RelayFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RelayFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_relay_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relay_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Relay}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.relay_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Relay.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relay_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Relay}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.relay_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Relay.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relay_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relay_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Relay}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.relay_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Relay.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {SingleHostAddr} single_host_addr
   * @returns {Relay}
   */
  static new_single_host_addr(single_host_addr) {
    _assertClass$1(single_host_addr, SingleHostAddr);
    const ret = wasm$1.relay_new_single_host_addr(single_host_addr.__wbg_ptr);
    return Relay.__wrap(ret);
  }
  /**
   * @param {SingleHostName} single_host_name
   * @returns {Relay}
   */
  static new_single_host_name(single_host_name) {
    _assertClass$1(single_host_name, SingleHostName);
    const ret = wasm$1.relay_new_single_host_name(single_host_name.__wbg_ptr);
    return Relay.__wrap(ret);
  }
  /**
   * @param {MultiHostName} multi_host_name
   * @returns {Relay}
   */
  static new_multi_host_name(multi_host_name) {
    _assertClass$1(multi_host_name, MultiHostName);
    const ret = wasm$1.relay_new_multi_host_name(multi_host_name.__wbg_ptr);
    return Relay.__wrap(ret);
  }
  /**
   * @returns {RelayKind}
   */
  kind() {
    const ret = wasm$1.relay_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {SingleHostAddr | undefined}
   */
  as_single_host_addr() {
    const ret = wasm$1.relay_as_single_host_addr(this.__wbg_ptr);
    return ret === 0 ? undefined : SingleHostAddr.__wrap(ret);
  }
  /**
   * @returns {SingleHostName | undefined}
   */
  as_single_host_name() {
    const ret = wasm$1.relay_as_single_host_name(this.__wbg_ptr);
    return ret === 0 ? undefined : SingleHostName.__wrap(ret);
  }
  /**
   * @returns {MultiHostName | undefined}
   */
  as_multi_host_name() {
    const ret = wasm$1.relay_as_multi_host_name(this.__wbg_ptr);
    return ret === 0 ? undefined : MultiHostName.__wrap(ret);
  }
}

const RelaysFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_relays_free(ptr >>> 0));
/**
 */
class Relays {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Relays.prototype);
    obj.__wbg_ptr = ptr;
    RelaysFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RelaysFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_relays_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relays_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Relays}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.relays_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Relays.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relays_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Relays}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.relays_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Relays.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relays_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.relays_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Relays}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.relays_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Relays.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Relays}
   */
  static new() {
    const ret = wasm$1.relays_new();
    return Relays.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.relays_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Relay}
   */
  get(index) {
    const ret = wasm$1.relays_get(this.__wbg_ptr, index);
    return Relay.__wrap(ret);
  }
  /**
   * @param {Relay} elem
   */
  add(elem) {
    _assertClass$1(elem, Relay);
    wasm$1.relays_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const RewardAddressFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_rewardaddress_free(ptr >>> 0));
/**
 */
class RewardAddress {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RewardAddress.prototype);
    obj.__wbg_ptr = ptr;
    RewardAddressFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RewardAddressFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_rewardaddress_free(ptr);
  }
  /**
   * @param {number} network
   * @param {Credential} payment
   * @returns {RewardAddress}
   */
  static new(network, payment) {
    _assertClass$1(payment, Credential);
    const ret = wasm$1.enterpriseaddress_new(network, payment.__wbg_ptr);
    return RewardAddress.__wrap(ret);
  }
  /**
   * @returns {Credential}
   */
  payment_cred() {
    const ret = wasm$1.baseaddress_payment_cred(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Address}
   */
  to_address() {
    const ret = wasm$1.rewardaddress_to_address(this.__wbg_ptr);
    return Address.__wrap(ret);
  }
  /**
   * @param {Address} addr
   * @returns {RewardAddress | undefined}
   */
  static from_address(addr) {
    _assertClass$1(addr, Address);
    const ret = wasm$1.rewardaddress_from_address(addr.__wbg_ptr);
    return ret === 0 ? undefined : RewardAddress.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  network_id() {
    const ret = wasm$1.enterpriseaddress_network_id(this.__wbg_ptr);
    return ret;
  }
}

const RewardAddressesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_rewardaddresses_free(ptr >>> 0));
/**
 */
class RewardAddresses {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(RewardAddresses.prototype);
    obj.__wbg_ptr = ptr;
    RewardAddressesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    RewardAddressesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_rewardaddresses_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.rewardaddresses_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {RewardAddresses}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.rewardaddresses_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return RewardAddresses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.rewardaddresses_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {RewardAddresses}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.rewardaddresses_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return RewardAddresses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.rewardaddresses_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.rewardaddresses_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {RewardAddresses}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.rewardaddresses_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return RewardAddresses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {RewardAddresses}
   */
  static new() {
    const ret = wasm$1.genesishashes_new();
    return RewardAddresses.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {RewardAddress}
   */
  get(index) {
    const ret = wasm$1.rewardaddresses_get(this.__wbg_ptr, index);
    return RewardAddress.__wrap(ret);
  }
  /**
   * @param {RewardAddress} elem
   */
  add(elem) {
    _assertClass$1(elem, RewardAddress);
    wasm$1.rewardaddresses_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const ScriptAllFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scriptall_free(ptr >>> 0));
/**
 */
class ScriptAll {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptAll.prototype);
    obj.__wbg_ptr = ptr;
    ScriptAllFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptAllFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scriptall_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptall_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptAll}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptall_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptAll.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptall_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ScriptAll}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptall_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptAll.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptall_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptall_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ScriptAll}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptall_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptAll.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {NativeScripts}
   */
  native_scripts() {
    const ret = wasm$1.scriptall_native_scripts(this.__wbg_ptr);
    return NativeScripts.__wrap(ret);
  }
  /**
   * @param {NativeScripts} native_scripts
   * @returns {ScriptAll}
   */
  static new(native_scripts) {
    _assertClass$1(native_scripts, NativeScripts);
    const ret = wasm$1.scriptall_new(native_scripts.__wbg_ptr);
    return ScriptAll.__wrap(ret);
  }
}

const ScriptAnyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scriptany_free(ptr >>> 0));
/**
 */
class ScriptAny {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptAny.prototype);
    obj.__wbg_ptr = ptr;
    ScriptAnyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptAnyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scriptany_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptany_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptAny}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptany_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptAny.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptany_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ScriptAny}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptany_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptAny.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptany_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptany_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ScriptAny}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptany_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptAny.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {NativeScripts}
   */
  native_scripts() {
    const ret = wasm$1.scriptall_native_scripts(this.__wbg_ptr);
    return NativeScripts.__wrap(ret);
  }
  /**
   * @param {NativeScripts} native_scripts
   * @returns {ScriptAny}
   */
  static new(native_scripts) {
    _assertClass$1(native_scripts, NativeScripts);
    const ret = wasm$1.scriptall_new(native_scripts.__wbg_ptr);
    return ScriptAny.__wrap(ret);
  }
}

const ScriptDataHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scriptdatahash_free(ptr >>> 0));
/**
 */
class ScriptDataHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptDataHash.prototype);
    obj.__wbg_ptr = ptr;
    ScriptDataHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptDataHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scriptdatahash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptDataHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptdatahash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {ScriptDataHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptdatahash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {ScriptDataHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptdatahash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptDataHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const ScriptHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scripthash_free(ptr >>> 0));
/**
 */
class ScriptHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptHash.prototype);
    obj.__wbg_ptr = ptr;
    ScriptHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scripthash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scripthash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.ed25519keyhash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {ScriptHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scripthash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.ed25519keyhash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {ScriptHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scripthash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const ScriptHashesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scripthashes_free(ptr >>> 0));
/**
 */
class ScriptHashes {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptHashes.prototype);
    obj.__wbg_ptr = ptr;
    ScriptHashesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptHashesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scripthashes_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scripthashes_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptHashes}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scripthashes_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scripthashes_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ScriptHashes}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scripthashes_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scripthashes_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scripthashes_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ScriptHashes}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scripthashes_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptHashes.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {ScriptHashes}
   */
  static new() {
    const ret = wasm$1.genesishashes_new();
    return ScriptHashes.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {ScriptHash}
   */
  get(index) {
    const ret = wasm$1.scripthashes_get(this.__wbg_ptr, index);
    return ScriptHash.__wrap(ret);
  }
  /**
   * @param {ScriptHash} elem
   */
  add(elem) {
    _assertClass$1(elem, ScriptHash);
    wasm$1.scripthashes_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const ScriptNOfKFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scriptnofk_free(ptr >>> 0));
/**
 */
class ScriptNOfK {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptNOfK.prototype);
    obj.__wbg_ptr = ptr;
    ScriptNOfKFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptNOfKFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scriptnofk_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptnofk_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptNOfK}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptnofk_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptNOfK.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptnofk_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ScriptNOfK}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptnofk_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptNOfK.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptnofk_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptnofk_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ScriptNOfK}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptnofk_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptNOfK.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  n() {
    const ret = wasm$1.scriptnofk_n(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @returns {NativeScripts}
   */
  native_scripts() {
    const ret = wasm$1.scriptall_native_scripts(this.__wbg_ptr);
    return NativeScripts.__wrap(ret);
  }
  /**
   * @param {number} n
   * @param {NativeScripts} native_scripts
   * @returns {ScriptNOfK}
   */
  static new(n, native_scripts) {
    _assertClass$1(native_scripts, NativeScripts);
    const ret = wasm$1.scriptnofk_new(n, native_scripts.__wbg_ptr);
    return ScriptNOfK.__wrap(ret);
  }
}

const ScriptPubkeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scriptpubkey_free(ptr >>> 0));
/**
 */
class ScriptPubkey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptPubkey.prototype);
    obj.__wbg_ptr = ptr;
    ScriptPubkeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptPubkeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scriptpubkey_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptpubkey_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptPubkey}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptpubkey_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptPubkey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptpubkey_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ScriptPubkey}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptpubkey_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptPubkey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptpubkey_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptpubkey_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ScriptPubkey}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptpubkey_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptPubkey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  addr_keyhash() {
    const ret = wasm$1.scriptpubkey_addr_keyhash(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @param {Ed25519KeyHash} addr_keyhash
   * @returns {ScriptPubkey}
   */
  static new(addr_keyhash) {
    _assertClass$1(addr_keyhash, Ed25519KeyHash);
    const ret = wasm$1.scriptpubkey_new(addr_keyhash.__wbg_ptr);
    return ScriptPubkey.__wrap(ret);
  }
}

const ScriptRefFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_scriptref_free(ptr >>> 0));
/**
 */
class ScriptRef {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(ScriptRef.prototype);
    obj.__wbg_ptr = ptr;
    ScriptRefFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ScriptRefFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_scriptref_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptref_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {ScriptRef}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptref_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptRef.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptref_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {ScriptRef}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptref_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptRef.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptref_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptref_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {ScriptRef}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.scriptref_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return ScriptRef.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {NativeScript} native_script
   * @returns {ScriptRef}
   */
  static new_native_script(native_script) {
    _assertClass$1(native_script, NativeScript);
    const ret = wasm$1.scriptref_new_native_script(native_script.__wbg_ptr);
    return ScriptRef.__wrap(ret);
  }
  /**
   * @param {PlutusScript} plutus_script
   * @returns {ScriptRef}
   */
  static new_plutus_script(plutus_script) {
    _assertClass$1(plutus_script, PlutusScript);
    const ret = wasm$1.scriptref_new_plutus_script(plutus_script.__wbg_ptr);
    return ScriptRef.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  is_native_script() {
    const ret = wasm$1.scriptref_is_native_script(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {boolean}
   */
  is_plutus_script() {
    const ret = wasm$1.scriptref_is_plutus_script(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {NativeScript | undefined}
   */
  native_script() {
    const ret = wasm$1.scriptref_native_script(this.__wbg_ptr);
    return ret === 0 ? undefined : NativeScript.__wrap(ret);
  }
  /**
   * @returns {PlutusScript | undefined}
   */
  plutus_script() {
    const ret = wasm$1.scriptref_plutus_script(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusScript.__wrap(ret);
  }
  /**
   * Return bytes array of script ref struct but without wrapping into CBOR array under the tag
   * to_bytes returns "#6.24(bytes .cbor script)" from CDDL
   * to_unwrapped_bytes return "script" from CDDL
   * @returns {Uint8Array}
   */
  to_unwrapped_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.scriptref_to_unwrapped_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const SingleHostAddrFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_singlehostaddr_free(ptr >>> 0));
/**
 */
class SingleHostAddr {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(SingleHostAddr.prototype);
    obj.__wbg_ptr = ptr;
    SingleHostAddrFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    SingleHostAddrFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_singlehostaddr_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostaddr_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {SingleHostAddr}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.singlehostaddr_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return SingleHostAddr.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostaddr_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {SingleHostAddr}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.singlehostaddr_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return SingleHostAddr.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostaddr_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostaddr_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {SingleHostAddr}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.singlehostaddr_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return SingleHostAddr.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number | undefined}
   */
  port() {
    const ret = wasm$1.singlehostaddr_port(this.__wbg_ptr);
    return ret === 0xFFFFFF ? undefined : ret;
  }
  /**
   * @returns {Ipv4 | undefined}
   */
  ipv4() {
    const ret = wasm$1.singlehostaddr_ipv4(this.__wbg_ptr);
    return ret === 0 ? undefined : Ipv4.__wrap(ret);
  }
  /**
   * @returns {Ipv6 | undefined}
   */
  ipv6() {
    const ret = wasm$1.singlehostaddr_ipv6(this.__wbg_ptr);
    return ret === 0 ? undefined : Ipv6.__wrap(ret);
  }
  /**
   * @param {number | undefined} [port]
   * @param {Ipv4 | undefined} [ipv4]
   * @param {Ipv6 | undefined} [ipv6]
   * @returns {SingleHostAddr}
   */
  static new(port, ipv4, ipv6) {
    let ptr0 = 0;
    if (!isLikeNone$1(ipv4)) {
      _assertClass$1(ipv4, Ipv4);
      ptr0 = ipv4.__destroy_into_raw();
    }
    let ptr1 = 0;
    if (!isLikeNone$1(ipv6)) {
      _assertClass$1(ipv6, Ipv6);
      ptr1 = ipv6.__destroy_into_raw();
    }
    const ret = wasm$1.singlehostaddr_new(isLikeNone$1(port) ? 0xFFFFFF : port, ptr0, ptr1);
    return SingleHostAddr.__wrap(ret);
  }
}

const SingleHostNameFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_singlehostname_free(ptr >>> 0));
/**
 */
class SingleHostName {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(SingleHostName.prototype);
    obj.__wbg_ptr = ptr;
    SingleHostNameFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    SingleHostNameFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_singlehostname_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostname_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {SingleHostName}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.singlehostname_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return SingleHostName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostname_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {SingleHostName}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.singlehostname_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return SingleHostName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostname_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.singlehostname_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {SingleHostName}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.singlehostname_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return SingleHostName.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number | undefined}
   */
  port() {
    const ret = wasm$1.singlehostname_port(this.__wbg_ptr);
    return ret === 0xFFFFFF ? undefined : ret;
  }
  /**
   * @returns {DNSRecordAorAAAA}
   */
  dns_name() {
    const ret = wasm$1.multihostname_dns_name(this.__wbg_ptr);
    return DNSRecordAorAAAA.__wrap(ret);
  }
  /**
   * @param {number | undefined} port
   * @param {DNSRecordAorAAAA} dns_name
   * @returns {SingleHostName}
   */
  static new(port, dns_name) {
    _assertClass$1(dns_name, DNSRecordAorAAAA);
    const ret = wasm$1.singlehostname_new(isLikeNone$1(port) ? 0xFFFFFF : port, dns_name.__wbg_ptr);
    return SingleHostName.__wrap(ret);
  }
}

const StakeAndVoteDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_stakeandvotedelegation_free(ptr >>> 0));
/**
 */
class StakeAndVoteDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(StakeAndVoteDelegation.prototype);
    obj.__wbg_ptr = ptr;
    StakeAndVoteDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    StakeAndVoteDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_stakeandvotedelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeandvotedelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakeAndVoteDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeandvotedelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeAndVoteDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeandvotedelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {StakeAndVoteDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeandvotedelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeAndVoteDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeandvotedelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeandvotedelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {StakeAndVoteDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeandvotedelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeAndVoteDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    const ret = wasm$1.stakeandvotedelegation_stake_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash() {
    const ret = wasm$1.stakeandvotedelegation_pool_keyhash(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {DRep}
   */
  drep() {
    const ret = wasm$1.stakeandvotedelegation_drep(this.__wbg_ptr);
    return DRep.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {Ed25519KeyHash} pool_keyhash
   * @param {DRep} drep
   * @returns {StakeAndVoteDelegation}
   */
  static new(stake_credential, pool_keyhash, drep) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(pool_keyhash, Ed25519KeyHash);
    _assertClass$1(drep, DRep);
    const ret = wasm$1.stakeandvotedelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr, drep.__wbg_ptr);
    return StakeAndVoteDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.stakeandvotedelegation_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const StakeDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_stakedelegation_free(ptr >>> 0));
/**
 */
class StakeDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(StakeDelegation.prototype);
    obj.__wbg_ptr = ptr;
    StakeDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    StakeDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_stakedelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakedelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakeDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakedelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakedelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {StakeDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakedelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakedelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakedelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {StakeDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakedelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.stakedelegation_stake_credential(this.__wbg_ptr); } else {
      ret = wasm$1.stakeandvotedelegation_stake_credential(this.__wbg_ptr); }
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash() {
    const ret = wasm$1.stakedelegation_pool_keyhash(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {Ed25519KeyHash} pool_keyhash
   * @returns {StakeDelegation}
   */
  static new(stake_credential, pool_keyhash) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(pool_keyhash, Ed25519KeyHash);
    const ret = wasm$1.stakedelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr);
    return StakeDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.stakedelegation_has_script_credentials(this.__wbg_ptr); } else {
      ret = wasm$1.stakeandvotedelegation_has_script_credentials(this.__wbg_ptr); }
    return ret !== 0;
  }
}

const StakeDeregistrationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_stakederegistration_free(ptr >>> 0));
/**
 */
class StakeDeregistration {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(StakeDeregistration.prototype);
    obj.__wbg_ptr = ptr;
    StakeDeregistrationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    StakeDeregistrationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_stakederegistration_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakederegistration_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakeDeregistration}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakederegistration_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeDeregistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakederegistration_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {StakeDeregistration}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakederegistration_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeDeregistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakederegistration_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakederegistration_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {StakeDeregistration}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakederegistration_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeDeregistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    const ret = wasm$1.stakederegistration_stake_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {BigNum | undefined}
   */
  coin() {
    const ret = wasm$1.stakederegistration_coin(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @returns {StakeDeregistration}
   */
  static new(stake_credential) {
    _assertClass$1(stake_credential, Credential);
    const ret = wasm$1.stakederegistration_new(stake_credential.__wbg_ptr);
    return StakeDeregistration.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {BigNum} coin
   * @returns {StakeDeregistration}
   */
  static new_with_explicit_refund(stake_credential, coin) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.stakederegistration_new_with_explicit_refund(stake_credential.__wbg_ptr, coin.__wbg_ptr);
    return StakeDeregistration.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.stakederegistration_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const StakeRegistrationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_stakeregistration_free(ptr >>> 0));
/**
 */
class StakeRegistration {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(StakeRegistration.prototype);
    obj.__wbg_ptr = ptr;
    StakeRegistrationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    StakeRegistrationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_stakeregistration_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistration_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakeRegistration}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeregistration_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistration_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {StakeRegistration}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeregistration_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistration_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistration_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {StakeRegistration}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeregistration_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeRegistration.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    const ret = wasm$1.stakeregistration_stake_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {BigNum | undefined}
   */
  coin() {
    const ret = wasm$1.stakeregistration_coin(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @returns {StakeRegistration}
   */
  static new(stake_credential) {
    _assertClass$1(stake_credential, Credential);
    const ret = wasm$1.stakeregistration_new(stake_credential.__wbg_ptr);
    return StakeRegistration.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {BigNum} coin
   * @returns {StakeRegistration}
   */
  static new_with_explicit_deposit(stake_credential, coin) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.stakeregistration_new_with_explicit_deposit(stake_credential.__wbg_ptr, coin.__wbg_ptr);
    return StakeRegistration.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.stakeregistration_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const StakeRegistrationAndDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_stakeregistrationanddelegation_free(ptr >>> 0));
/**
 */
class StakeRegistrationAndDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(StakeRegistrationAndDelegation.prototype);
    obj.__wbg_ptr = ptr;
    StakeRegistrationAndDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    StakeRegistrationAndDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_stakeregistrationanddelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistrationanddelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakeRegistrationAndDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeregistrationanddelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistrationanddelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {StakeRegistrationAndDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeregistrationanddelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistrationanddelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakeregistrationanddelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {StakeRegistrationAndDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakeregistrationanddelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    const ret = wasm$1.stakeregistrationanddelegation_stake_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash() {
    const ret = wasm$1.stakeregistrationanddelegation_pool_keyhash(this.__wbg_ptr);
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  coin() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.stakeregistrationanddelegation_coin(this.__wbg_ptr); } else {
      ret = wasm$1.drepderegistration_coin(this.__wbg_ptr); }
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {Ed25519KeyHash} pool_keyhash
   * @param {BigNum} coin
   * @returns {StakeRegistrationAndDelegation}
   */
  static new(stake_credential, pool_keyhash, coin) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(pool_keyhash, Ed25519KeyHash);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.stakeregistrationanddelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr, coin.__wbg_ptr);
    return StakeRegistrationAndDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.stakeregistrationanddelegation_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

const StakeVoteRegistrationAndDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_stakevoteregistrationanddelegation_free(ptr >>> 0));
/**
 */
class StakeVoteRegistrationAndDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(StakeVoteRegistrationAndDelegation.prototype);
    obj.__wbg_ptr = ptr;
    StakeVoteRegistrationAndDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    StakeVoteRegistrationAndDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_stakevoteregistrationanddelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakevoteregistrationanddelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {StakeVoteRegistrationAndDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakevoteregistrationanddelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeVoteRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakevoteregistrationanddelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {StakeVoteRegistrationAndDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakevoteregistrationanddelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeVoteRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakevoteregistrationanddelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.stakevoteregistrationanddelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {StakeVoteRegistrationAndDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.stakevoteregistrationanddelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return StakeVoteRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    const ret = wasm$1.stakevoteregistrationanddelegation_stake_credential(this.__wbg_ptr);
    return Credential.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHash}
   */
  pool_keyhash() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.stakevoteregistrationanddelegation_pool_keyhash(this.__wbg_ptr); } else {
      ret = wasm$1.stakeregistrationanddelegation_pool_keyhash(this.__wbg_ptr); }
    return Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {DRep}
   */
  drep() {
    const ret = wasm$1.stakevoteregistrationanddelegation_drep(this.__wbg_ptr);
    return DRep.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  coin() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.stakevoteregistrationanddelegation_coin(this.__wbg_ptr); } else {
      ret = wasm$1.drepderegistration_coin(this.__wbg_ptr); }
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {Ed25519KeyHash} pool_keyhash
   * @param {DRep} drep
   * @param {BigNum} coin
   * @returns {StakeVoteRegistrationAndDelegation}
   */
  static new(stake_credential, pool_keyhash, drep, coin) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(pool_keyhash, Ed25519KeyHash);
    _assertClass$1(drep, DRep);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.stakevoteregistrationanddelegation_new(stake_credential.__wbg_ptr, pool_keyhash.__wbg_ptr, drep.__wbg_ptr, coin.__wbg_ptr);
    return StakeVoteRegistrationAndDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.stakevoteregistrationanddelegation_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_strings_free(ptr >>> 0));

const TimelockExpiryFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_timelockexpiry_free(ptr >>> 0));
/**
 */
class TimelockExpiry {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TimelockExpiry.prototype);
    obj.__wbg_ptr = ptr;
    TimelockExpiryFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TimelockExpiryFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_timelockexpiry_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockexpiry_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TimelockExpiry}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.timelockexpiry_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TimelockExpiry.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockexpiry_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TimelockExpiry}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.timelockexpiry_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TimelockExpiry.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockexpiry_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockexpiry_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TimelockExpiry}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.timelockexpiry_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TimelockExpiry.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {number}
   */
  slot() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockexpiry_slot(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum}
   */
  slot_bignum() {
    const ret = wasm$1.timelockexpiry_slot_bignum(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * This constructor uses outdated slot number format.
   * Use `.new_timelockexpiry` instead
   * @param {number} slot
   * @returns {TimelockExpiry}
   */
  static new(slot) {
    const ret = wasm$1.timelockexpiry_new(slot);
    return TimelockExpiry.__wrap(ret);
  }
  /**
   * @param {BigNum} slot
   * @returns {TimelockExpiry}
   */
  static new_timelockexpiry(slot) {
    _assertClass$1(slot, BigNum$1);
    const ret = wasm$1.timelockexpiry_new_timelockexpiry(slot.__wbg_ptr);
    return TimelockExpiry.__wrap(ret);
  }
}

const TimelockStartFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_timelockstart_free(ptr >>> 0));
/**
 */
class TimelockStart {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TimelockStart.prototype);
    obj.__wbg_ptr = ptr;
    TimelockStartFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TimelockStartFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_timelockstart_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockstart_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TimelockStart}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.timelockstart_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TimelockStart.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockstart_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TimelockStart}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.timelockstart_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TimelockStart.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockstart_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockstart_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TimelockStart}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.timelockstart_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TimelockStart.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * !!! DEPRECATED !!!
   * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.
   * Otherwise will just raise an error.
   * Use `.slot_bignum` instead
   * @returns {number}
   */
  slot() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.timelockexpiry_slot(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return r0 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum}
   */
  slot_bignum() {
    const ret = wasm$1.timelockexpiry_slot_bignum(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * This constructor uses outdated slot number format.
   * Use `.new_timelockstart` instead.
   * @param {number} slot
   * @returns {TimelockStart}
   */
  static new(slot) {
    const ret = wasm$1.timelockexpiry_new(slot);
    return TimelockStart.__wrap(ret);
  }
  /**
   * @param {BigNum} slot
   * @returns {TimelockStart}
   */
  static new_timelockstart(slot) {
    _assertClass$1(slot, BigNum$1);
    const ret = wasm$1.timelockexpiry_new_timelockexpiry(slot.__wbg_ptr);
    return TimelockStart.__wrap(ret);
  }
}

const TransactionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transaction_free(ptr >>> 0));
/**
 */
class Transaction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Transaction.prototype);
    obj.__wbg_ptr = ptr;
    TransactionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Transaction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Transaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Transaction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Transaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Transaction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Transaction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionBody}
   */
  body() {
    const ret = wasm$1.transaction_body(this.__wbg_ptr);
    return TransactionBody.__wrap(ret);
  }
  /**
   * @returns {TransactionWitnessSet}
   */
  witness_set() {
    const ret = wasm$1.transaction_witness_set(this.__wbg_ptr);
    return TransactionWitnessSet.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  is_valid() {
    const ret = wasm$1.transaction_is_valid(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {AuxiliaryData | undefined}
   */
  auxiliary_data() {
    const ret = wasm$1.transaction_auxiliary_data(this.__wbg_ptr);
    return ret === 0 ? undefined : AuxiliaryData.__wrap(ret);
  }
  /**
   * @param {boolean} valid
   */
  set_is_valid(valid) {
    wasm$1.transaction_set_is_valid(this.__wbg_ptr, valid);
  }
  /**
   * @param {TransactionBody} body
   * @param {TransactionWitnessSet} witness_set
   * @param {AuxiliaryData | undefined} [auxiliary_data]
   * @returns {Transaction}
   */
  static new(body, witness_set, auxiliary_data) {
    _assertClass$1(body, TransactionBody);
    _assertClass$1(witness_set, TransactionWitnessSet);
    let ptr0 = 0;
    if (!isLikeNone$1(auxiliary_data)) {
      _assertClass$1(auxiliary_data, AuxiliaryData);
      ptr0 = auxiliary_data.__destroy_into_raw();
    }
    const ret = wasm$1.transaction_new(body.__wbg_ptr, witness_set.__wbg_ptr, ptr0);
    return Transaction.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbatch_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbatchlist_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbodies_free(ptr >>> 0));

const TransactionBodyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbody_free(ptr >>> 0));
/**
 */
class TransactionBody {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionBody.prototype);
    obj.__wbg_ptr = ptr;
    TransactionBodyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionBodyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionbody_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionbody_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionBody}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionbody_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionBody.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionbody_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionBody}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionbody_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionBody.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionbody_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionbody_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionBody}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionbody_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionBody.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionInputs}
   */
  inputs() {
    const ret = wasm$1.transactionbody_inputs(this.__wbg_ptr);
    return TransactionInputs.__wrap(ret);
  }
  /**
   * @returns {TransactionOutputs}
   */
  outputs() {
    const ret = wasm$1.transactionbody_outputs(this.__wbg_ptr);
    return TransactionOutputs.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  fee() {
    const ret = wasm$1.transactionbody_fee(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Returns a Slot32 (u32) value in case the underlying original BigNum (u64) value is within the limits.
   * Otherwise will just raise an error.
   * @returns {number | undefined}
   */
  ttl() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionbody_ttl(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      if (r3) {
        throw takeObject$1(r2);
      }
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum | undefined}
   */
  ttl_bignum() {
    const ret = wasm$1.transactionbody_ttl_bignum(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} ttl
   */
  set_ttl(ttl) {
    _assertClass$1(ttl, BigNum$1);
    if (version$2 === VERSION_12_1_1$1) { wasm$1.transactionbody_set_ttl(this.__wbg_ptr, ttl.__wbg_ptr); } else {
      wasm$1.protocolparamupdate_set_minfee_a(this.__wbg_ptr, ttl.__wbg_ptr); }
  }
  /**
   */
  remove_ttl() {
    wasm$1.transactionbody_remove_ttl(this.__wbg_ptr);
  }
  /**
   * @param {Certificates} certs
   */
  set_certs(certs) {
    _assertClass$1(certs, Certificates);
    wasm$1.transactionbody_set_certs(this.__wbg_ptr, certs.__wbg_ptr);
  }
  /**
   * @returns {Certificates | undefined}
   */
  certs() {
    const ret = wasm$1.transactionbody_certs(this.__wbg_ptr);
    return ret === 0 ? undefined : Certificates.__wrap(ret);
  }
  /**
   * @param {Withdrawals} withdrawals
   */
  set_withdrawals(withdrawals) {
    _assertClass$1(withdrawals, Withdrawals);
    wasm$1.transactionbody_set_withdrawals(this.__wbg_ptr, withdrawals.__wbg_ptr);
  }
  /**
   * @returns {Withdrawals | undefined}
   */
  withdrawals() {
    const ret = wasm$1.transactionbody_withdrawals(this.__wbg_ptr);
    return ret === 0 ? undefined : Withdrawals.__wrap(ret);
  }
  /**
   * @param {Update} update
   */
  set_update(update) {
    _assertClass$1(update, Update);
    wasm$1.transactionbody_set_update(this.__wbg_ptr, update.__wbg_ptr);
  }
  /**
   * @returns {Update | undefined}
   */
  update() {
    const ret = wasm$1.transactionbody_update(this.__wbg_ptr);
    return ret === 0 ? undefined : Update.__wrap(ret);
  }
  /**
   * @param {AuxiliaryDataHash} auxiliary_data_hash
   */
  set_auxiliary_data_hash(auxiliary_data_hash) {
    _assertClass$1(auxiliary_data_hash, AuxiliaryDataHash);
    wasm$1.transactionbody_set_auxiliary_data_hash(this.__wbg_ptr, auxiliary_data_hash.__wbg_ptr);
  }
  /**
   * @returns {AuxiliaryDataHash | undefined}
   */
  auxiliary_data_hash() {
    const ret = wasm$1.transactionbody_auxiliary_data_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : AuxiliaryDataHash.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Uses outdated slot number format.
   * @param {number} validity_start_interval
   */
  set_validity_start_interval(validity_start_interval) {
    wasm$1.transactionbody_set_validity_start_interval(this.__wbg_ptr, validity_start_interval);
  }
  /**
   * @param {BigNum} validity_start_interval
   */
  set_validity_start_interval_bignum(validity_start_interval) {
    _assertClass$1(validity_start_interval, BigNum$1);
    if (version$2 === VERSION_12_1_1$1) { wasm$1.transactionbody_set_validity_start_interval_bignum(this.__wbg_ptr, validity_start_interval.__wbg_ptr); } else {
      wasm$1.protocolparamupdate_set_minfee_b(this.__wbg_ptr, validity_start_interval.__wbg_ptr); }
  }
  /**
   * @returns {BigNum | undefined}
   */
  validity_start_interval_bignum() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.transactionbody_validity_start_interval_bignum(this.__wbg_ptr); } else {
      ret = wasm$1.protocolparamupdate_minfee_b(this.__wbg_ptr); }
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * Returns a Option<Slot32> (u32) value in case the underlying original Option<BigNum> (u64) value is within the limits.
   * Otherwise will just raise an error.
   * Use `.validity_start_interval_bignum` instead.
   * @returns {number | undefined}
   */
  validity_start_interval() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionbody_validity_start_interval(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      if (r3) {
        throw takeObject$1(r2);
      }
      return r0 === 0 ? undefined : r1 >>> 0;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Mint} mint
   */
  set_mint(mint) {
    _assertClass$1(mint, Mint);
    wasm$1.transactionbody_set_mint(this.__wbg_ptr, mint.__wbg_ptr);
  }
  /**
   * @returns {Mint | undefined}
   */
  mint() {
    const ret = wasm$1.transactionbody_mint(this.__wbg_ptr);
    return ret === 0 ? undefined : Mint.__wrap(ret);
  }
  /**
   * @param {TransactionInputs} reference_inputs
   */
  set_reference_inputs(reference_inputs) {
    _assertClass$1(reference_inputs, TransactionInputs);
    wasm$1.transactionbody_set_reference_inputs(this.__wbg_ptr, reference_inputs.__wbg_ptr);
  }
  /**
   * @returns {TransactionInputs | undefined}
   */
  reference_inputs() {
    const ret = wasm$1.transactionbody_reference_inputs(this.__wbg_ptr);
    return ret === 0 ? undefined : TransactionInputs.__wrap(ret);
  }
  /**
   * @param {ScriptDataHash} script_data_hash
   */
  set_script_data_hash(script_data_hash) {
    _assertClass$1(script_data_hash, ScriptDataHash);
    wasm$1.transactionbody_set_script_data_hash(this.__wbg_ptr, script_data_hash.__wbg_ptr);
  }
  /**
   * @returns {ScriptDataHash | undefined}
   */
  script_data_hash() {
    const ret = wasm$1.transactionbody_script_data_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptDataHash.__wrap(ret);
  }
  /**
   * @param {TransactionInputs} collateral
   */
  set_collateral(collateral) {
    _assertClass$1(collateral, TransactionInputs);
    wasm$1.transactionbody_set_collateral(this.__wbg_ptr, collateral.__wbg_ptr);
  }
  /**
   * @returns {TransactionInputs | undefined}
   */
  collateral() {
    const ret = wasm$1.transactionbody_collateral(this.__wbg_ptr);
    return ret === 0 ? undefined : TransactionInputs.__wrap(ret);
  }
  /**
   * @param {Ed25519KeyHashes} required_signers
   */
  set_required_signers(required_signers) {
    _assertClass$1(required_signers, Ed25519KeyHashes);
    wasm$1.transactionbody_set_required_signers(this.__wbg_ptr, required_signers.__wbg_ptr);
  }
  /**
   * @returns {Ed25519KeyHashes | undefined}
   */
  required_signers() {
    const ret = wasm$1.transactionbody_required_signers(this.__wbg_ptr);
    return ret === 0 ? undefined : Ed25519KeyHashes.__wrap(ret);
  }
  /**
   * @param {NetworkId} network_id
   */
  set_network_id(network_id) {
    _assertClass$1(network_id, NetworkId);
    wasm$1.transactionbody_set_network_id(this.__wbg_ptr, network_id.__wbg_ptr);
  }
  /**
   * @returns {NetworkId | undefined}
   */
  network_id() {
    const ret = wasm$1.transactionbody_network_id(this.__wbg_ptr);
    return ret === 0 ? undefined : NetworkId.__wrap(ret);
  }
  /**
   * @param {TransactionOutput} collateral_return
   */
  set_collateral_return(collateral_return) {
    _assertClass$1(collateral_return, TransactionOutput);
    wasm$1.transactionbody_set_collateral_return(this.__wbg_ptr, collateral_return.__wbg_ptr);
  }
  /**
   * @returns {TransactionOutput | undefined}
   */
  collateral_return() {
    const ret = wasm$1.transactionbody_collateral_return(this.__wbg_ptr);
    return ret === 0 ? undefined : TransactionOutput.__wrap(ret);
  }
  /**
   * @param {BigNum} total_collateral
   */
  set_total_collateral(total_collateral) {
    _assertClass$1(total_collateral, BigNum$1);
    if (version$2 === VERSION_12_1_1$1) { wasm$1.transactionbody_set_total_collateral(this.__wbg_ptr, total_collateral.__wbg_ptr); } else {
      wasm$1.protocolparamupdate_set_key_deposit(this.__wbg_ptr, total_collateral.__wbg_ptr); }
  }
  /**
   * @returns {BigNum | undefined}
   */
  total_collateral() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.transactionbody_total_collateral(this.__wbg_ptr); } else {
      ret = wasm$1.protocolparamupdate_key_deposit(this.__wbg_ptr); }
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {VotingProcedures} voting_procedures
   */
  set_voting_procedures(voting_procedures) {
    _assertClass$1(voting_procedures, VotingProcedures);
    wasm$1.transactionbody_set_voting_procedures(this.__wbg_ptr, voting_procedures.__wbg_ptr);
  }
  /**
   * @returns {VotingProcedures | undefined}
   */
  voting_procedures() {
    const ret = wasm$1.transactionbody_voting_procedures(this.__wbg_ptr);
    return ret === 0 ? undefined : VotingProcedures.__wrap(ret);
  }
  /**
   * @param {VotingProposals} voting_proposals
   */
  set_voting_proposals(voting_proposals) {
    _assertClass$1(voting_proposals, VotingProposals);
    wasm$1.transactionbody_set_voting_proposals(this.__wbg_ptr, voting_proposals.__wbg_ptr);
  }
  /**
   * @returns {VotingProposals | undefined}
   */
  voting_proposals() {
    const ret = wasm$1.transactionbody_voting_proposals(this.__wbg_ptr);
    return ret === 0 ? undefined : VotingProposals.__wrap(ret);
  }
  /**
   * @param {BigNum} donation
   */
  set_donation(donation) {
    _assertClass$1(donation, BigNum$1);
    if (version$2 === VERSION_12_1_1$1) { wasm$1.transactionbody_set_donation(this.__wbg_ptr, donation.__wbg_ptr); } else {
      wasm$1.protocolparamupdate_set_pool_deposit(this.__wbg_ptr, donation.__wbg_ptr); }
  }
  /**
   * @returns {BigNum | undefined}
   */
  donation() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.transactionbody_donation(this.__wbg_ptr); } else {
      ret = wasm$1.protocolparamupdate_pool_deposit(this.__wbg_ptr); }
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} current_treasury_value
   */
  set_current_treasury_value(current_treasury_value) {
    _assertClass$1(current_treasury_value, BigNum$1);
    wasm$1.transactionbody_set_current_treasury_value(this.__wbg_ptr, current_treasury_value.__wbg_ptr);
  }
  /**
   * @returns {BigNum | undefined}
   */
  current_treasury_value() {
    const ret = wasm$1.transactionbody_current_treasury_value(this.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * !!! DEPRECATED !!!
   * This constructor uses outdated slot number format for the ttl value.
   * Use `.new_tx_body` and then `.set_ttl` instead
   * @param {TransactionInputs} inputs
   * @param {TransactionOutputs} outputs
   * @param {BigNum} fee
   * @param {number | undefined} [ttl]
   * @returns {TransactionBody}
   */
  static new(inputs, outputs, fee, ttl) {
    _assertClass$1(inputs, TransactionInputs);
    _assertClass$1(outputs, TransactionOutputs);
    _assertClass$1(fee, BigNum$1);
    const ret = wasm$1.transactionbody_new(inputs.__wbg_ptr, outputs.__wbg_ptr, fee.__wbg_ptr, !isLikeNone$1(ttl), isLikeNone$1(ttl) ? 0 : ttl);
    return TransactionBody.__wrap(ret);
  }
  /**
   * Returns a new TransactionBody.
   * In the new version of "new" we removed optional ttl for support it by wasm_bingen.
   * Your can use "set_ttl" and "remove_ttl" to set a new value for ttl or set it as None.
   * @param {TransactionInputs} inputs
   * @param {TransactionOutputs} outputs
   * @param {BigNum} fee
   * @returns {TransactionBody}
   */
  static new_tx_body(inputs, outputs, fee) {
    _assertClass$1(inputs, TransactionInputs);
    _assertClass$1(outputs, TransactionOutputs);
    _assertClass$1(fee, BigNum$1);
    const ret = wasm$1.transactionbody_new_tx_body(inputs.__wbg_ptr, outputs.__wbg_ptr, fee.__wbg_ptr);
    return TransactionBody.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbuilder_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbuilderconfig_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionbuilderconfigbuilder_free(ptr >>> 0));

const TransactionHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionhash_free(ptr >>> 0));
/**
 */
class TransactionHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionHash.prototype);
    obj.__wbg_ptr = ptr;
    TransactionHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionhash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionhash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {TransactionHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionhash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {TransactionHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionhash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

const TransactionInputFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactioninput_free(ptr >>> 0));
/**
 */
class TransactionInput {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionInput.prototype);
    obj.__wbg_ptr = ptr;
    TransactionInputFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionInputFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactioninput_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninput_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionInput}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactioninput_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionInput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninput_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionInput}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactioninput_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionInput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninput_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninput_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionInput}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactioninput_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionInput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionHash}
   */
  transaction_id() {
    const ret = wasm$1.transactioninput_transaction_id(this.__wbg_ptr);
    return TransactionHash.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  index() {
    const ret = wasm$1.transactioninput_index(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {TransactionHash} transaction_id
   * @param {number} index
   * @returns {TransactionInput}
   */
  static new(transaction_id, index) {
    _assertClass$1(transaction_id, TransactionHash);
    const ret = wasm$1.transactioninput_new(transaction_id.__wbg_ptr, index);
    return TransactionInput.__wrap(ret);
  }
}

const TransactionInputsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactioninputs_free(ptr >>> 0));
/**
 */
class TransactionInputs {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionInputs.prototype);
    obj.__wbg_ptr = ptr;
    TransactionInputsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionInputsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactioninputs_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninputs_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionInputs}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactioninputs_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionInputs.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninputs_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionInputs}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactioninputs_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionInputs.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninputs_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactioninputs_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionInputs}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactioninputs_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionInputs.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionInputs}
   */
  static new() {
    const ret = wasm$1.transactioninputs_new();
    return TransactionInputs.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.ed25519keyhashes_len(this.__wbg_ptr); } else {
      ret = wasm$1.costmdls_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {TransactionInput}
   */
  get(index) {
    const ret = wasm$1.transactioninputs_get(this.__wbg_ptr, index);
    return TransactionInput.__wrap(ret);
  }
  /**
   * Add a new `TransactionInput` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {TransactionInput} input
   * @returns {boolean}
   */
  add(input) {
    _assertClass$1(input, TransactionInput);
    const ret = wasm$1.transactioninputs_add(this.__wbg_ptr, input.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {TransactionInputs | undefined}
   */
  to_option() {
    const ret = wasm$1.transactioninputs_to_option(this.__wbg_ptr);
    return ret === 0 ? undefined : TransactionInputs.__wrap(ret);
  }
}

const TransactionMetadatumFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionmetadatum_free(ptr >>> 0));
/**
 */
class TransactionMetadatum {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionMetadatum.prototype);
    obj.__wbg_ptr = ptr;
    TransactionMetadatumFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionMetadatumFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionmetadatum_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatum}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionmetadatum_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionMetadatum}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionmetadatum_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {MetadataMap} map
   * @returns {TransactionMetadatum}
   */
  static new_map(map) {
    _assertClass$1(map, MetadataMap);
    const ret = wasm$1.transactionmetadatum_new_map(map.__wbg_ptr);
    return TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {MetadataList} list
   * @returns {TransactionMetadatum}
   */
  static new_list(list) {
    _assertClass$1(list, MetadataList);
    const ret = wasm$1.transactionmetadatum_new_list(list.__wbg_ptr);
    return TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {Int} int
   * @returns {TransactionMetadatum}
   */
  static new_int(int) {
    _assertClass$1(int, Int$1);
    const ret = wasm$1.transactionmetadatum_new_int(int.__wbg_ptr);
    return TransactionMetadatum.__wrap(ret);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatum}
   */
  static new_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionmetadatum_new_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} text
   * @returns {TransactionMetadatum}
   */
  static new_text(text) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(text, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionmetadatum_new_text(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatum.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionMetadatumKind}
   */
  kind() {
    const ret = wasm$1.transactionmetadatum_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {MetadataMap}
   */
  as_map() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_as_map(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MetadataMap.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {MetadataList}
   */
  as_list() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_as_list(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return MetadataList.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Int}
   */
  as_int() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_as_int(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Int$1.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  as_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_as_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      if (r3) {
        throw takeObject$1(r2);
      }
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  as_text() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatum_as_text(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
}

const TransactionMetadatumLabelsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionmetadatumlabels_free(ptr >>> 0));
/**
 */
class TransactionMetadatumLabels {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionMetadatumLabels.prototype);
    obj.__wbg_ptr = ptr;
    TransactionMetadatumLabelsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionMetadatumLabelsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionmetadatumlabels_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatumlabels_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionMetadatumLabels}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionmetadatumlabels_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatumLabels.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionmetadatumlabels_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionMetadatumLabels}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionmetadatumlabels_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionMetadatumLabels.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionMetadatumLabels}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.metadatalist_new(); } else {
      ret = wasm$1.fixedtransactionbodies_new(); }
    return TransactionMetadatumLabels.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.metadatalist_len(this.__wbg_ptr); } else {
      ret = wasm$1.fixedtransactionbodies_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {BigNum}
   */
  get(index) {
    const ret = wasm$1.transactionmetadatumlabels_get(this.__wbg_ptr, index);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} elem
   */
  add(elem) {
    _assertClass$1(elem, BigNum$1);
    wasm$1.transactionmetadatumlabels_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const TransactionOutputFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionoutput_free(ptr >>> 0));
/**
 */
class TransactionOutput {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionOutput.prototype);
    obj.__wbg_ptr = ptr;
    TransactionOutputFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionOutputFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionoutput_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutput_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionOutput}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionoutput_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionOutput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutput_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionOutput}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionoutput_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionOutput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutput_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutput_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionOutput}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionoutput_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionOutput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Address}
   */
  address() {
    const ret = wasm$1.transactionoutput_address(this.__wbg_ptr);
    return Address.__wrap(ret);
  }
  /**
   * @returns {Value}
   */
  amount() {
    const ret = wasm$1.transactionoutput_amount(this.__wbg_ptr);
    return Value.__wrap(ret);
  }
  /**
   * @returns {DataHash | undefined}
   */
  data_hash() {
    const ret = wasm$1.transactionoutput_data_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : DataHash.__wrap(ret);
  }
  /**
   * @returns {PlutusData | undefined}
   */
  plutus_data() {
    const ret = wasm$1.transactionoutput_plutus_data(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusData.__wrap(ret);
  }
  /**
   * @returns {ScriptRef | undefined}
   */
  script_ref() {
    const ret = wasm$1.transactionoutput_script_ref(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptRef.__wrap(ret);
  }
  /**
   * @param {ScriptRef} script_ref
   */
  set_script_ref(script_ref) {
    _assertClass$1(script_ref, ScriptRef);
    wasm$1.transactionoutput_set_script_ref(this.__wbg_ptr, script_ref.__wbg_ptr);
  }
  /**
   * @param {PlutusData} data
   */
  set_plutus_data(data) {
    _assertClass$1(data, PlutusData);
    wasm$1.transactionoutput_set_plutus_data(this.__wbg_ptr, data.__wbg_ptr);
  }
  /**
   * @param {DataHash} data_hash
   */
  set_data_hash(data_hash) {
    _assertClass$1(data_hash, DataHash);
    wasm$1.transactionoutput_set_data_hash(this.__wbg_ptr, data_hash.__wbg_ptr);
  }
  /**
   * @returns {boolean}
   */
  has_plutus_data() {
    const ret = wasm$1.transactionoutput_has_plutus_data(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {boolean}
   */
  has_data_hash() {
    const ret = wasm$1.transactionoutput_has_data_hash(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {boolean}
   */
  has_script_ref() {
    const ret = wasm$1.transactionoutput_has_script_ref(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @param {Address} address
   * @param {Value} amount
   * @returns {TransactionOutput}
   */
  static new(address, amount) {
    _assertClass$1(address, Address);
    _assertClass$1(amount, Value);
    const ret = wasm$1.transactionoutput_new(address.__wbg_ptr, amount.__wbg_ptr);
    return TransactionOutput.__wrap(ret);
  }
  /**
   * @returns {CborContainerType | undefined}
   */
  serialization_format() {
    const ret = wasm$1.transactionoutput_serialization_format(this.__wbg_ptr);
    return ret === 2 ? undefined : ret;
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionoutputamountbuilder_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionoutputbuilder_free(ptr >>> 0));

const TransactionOutputsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionoutputs_free(ptr >>> 0));
/**
 */
class TransactionOutputs {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionOutputs.prototype);
    obj.__wbg_ptr = ptr;
    TransactionOutputsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionOutputsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionoutputs_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutputs_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionOutputs}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionoutputs_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionOutputs.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutputs_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionOutputs}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionoutputs_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionOutputs.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutputs_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionoutputs_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionOutputs}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionoutputs_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionOutputs.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TransactionOutputs}
   */
  static new() {
    const ret = wasm$1.transactionoutputs_new();
    return TransactionOutputs.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.assetnames_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {TransactionOutput}
   */
  get(index) {
    const ret = wasm$1.transactionoutputs_get(this.__wbg_ptr, index);
    return TransactionOutput.__wrap(ret);
  }
  /**
   * @param {TransactionOutput} elem
   */
  add(elem) {
    _assertClass$1(elem, TransactionOutput);
    wasm$1.transactionoutputs_add(this.__wbg_ptr, elem.__wbg_ptr);
  }
}

const TransactionUnspentOutputFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionunspentoutput_free(ptr >>> 0));
/**
 */
class TransactionUnspentOutput {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionUnspentOutput.prototype);
    obj.__wbg_ptr = ptr;
    TransactionUnspentOutputFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionUnspentOutputFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionunspentoutput_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionunspentoutput_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionUnspentOutput}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionunspentoutput_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionUnspentOutput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionunspentoutput_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionUnspentOutput}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionunspentoutput_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionUnspentOutput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionunspentoutput_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionunspentoutput_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionUnspentOutput}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionunspentoutput_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionUnspentOutput.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {TransactionInput} input
   * @param {TransactionOutput} output
   * @returns {TransactionUnspentOutput}
   */
  static new(input, output) {
    _assertClass$1(input, TransactionInput);
    _assertClass$1(output, TransactionOutput);
    const ret = wasm$1.transactionunspentoutput_new(input.__wbg_ptr, output.__wbg_ptr);
    return TransactionUnspentOutput.__wrap(ret);
  }
  /**
   * @returns {TransactionInput}
   */
  input() {
    const ret = wasm$1.transactionunspentoutput_input(this.__wbg_ptr);
    return TransactionInput.__wrap(ret);
  }
  /**
   * @returns {TransactionOutput}
   */
  output() {
    const ret = wasm$1.transactionunspentoutput_output(this.__wbg_ptr);
    return TransactionOutput.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionunspentoutputs_free(ptr >>> 0));

const TransactionWitnessSetFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionwitnessset_free(ptr >>> 0));
/**
 */
class TransactionWitnessSet {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TransactionWitnessSet.prototype);
    obj.__wbg_ptr = ptr;
    TransactionWitnessSetFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TransactionWitnessSetFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_transactionwitnessset_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionwitnessset_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TransactionWitnessSet}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionwitnessset_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionWitnessSet.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionwitnessset_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TransactionWitnessSet}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionwitnessset_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionWitnessSet.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionwitnessset_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.transactionwitnessset_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TransactionWitnessSet}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.transactionwitnessset_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TransactionWitnessSet.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Vkeywitnesses} vkeys
   */
  set_vkeys(vkeys) {
    _assertClass$1(vkeys, Vkeywitnesses);
    wasm$1.transactionwitnessset_set_vkeys(this.__wbg_ptr, vkeys.__wbg_ptr);
  }
  /**
   * @returns {Vkeywitnesses | undefined}
   */
  vkeys() {
    const ret = wasm$1.transactionwitnessset_vkeys(this.__wbg_ptr);
    return ret === 0 ? undefined : Vkeywitnesses.__wrap(ret);
  }
  /**
   * @param {NativeScripts} native_scripts
   */
  set_native_scripts(native_scripts) {
    _assertClass$1(native_scripts, NativeScripts);
    wasm$1.transactionwitnessset_set_native_scripts(this.__wbg_ptr, native_scripts.__wbg_ptr);
  }
  /**
   * @returns {NativeScripts | undefined}
   */
  native_scripts() {
    const ret = wasm$1.transactionwitnessset_native_scripts(this.__wbg_ptr);
    return ret === 0 ? undefined : NativeScripts.__wrap(ret);
  }
  /**
   * @param {BootstrapWitnesses} bootstraps
   */
  set_bootstraps(bootstraps) {
    _assertClass$1(bootstraps, BootstrapWitnesses);
    wasm$1.transactionwitnessset_set_bootstraps(this.__wbg_ptr, bootstraps.__wbg_ptr);
  }
  /**
   * @returns {BootstrapWitnesses | undefined}
   */
  bootstraps() {
    const ret = wasm$1.transactionwitnessset_bootstraps(this.__wbg_ptr);
    return ret === 0 ? undefined : BootstrapWitnesses.__wrap(ret);
  }
  /**
   * @param {PlutusScripts} plutus_scripts
   */
  set_plutus_scripts(plutus_scripts) {
    _assertClass$1(plutus_scripts, PlutusScripts);
    wasm$1.transactionwitnessset_set_plutus_scripts(this.__wbg_ptr, plutus_scripts.__wbg_ptr);
  }
  /**
   * @returns {PlutusScripts | undefined}
   */
  plutus_scripts() {
    const ret = wasm$1.transactionwitnessset_plutus_scripts(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusScripts.__wrap(ret);
  }
  /**
   * @param {PlutusList} plutus_data
   */
  set_plutus_data(plutus_data) {
    _assertClass$1(plutus_data, PlutusList);
    wasm$1.transactionwitnessset_set_plutus_data(this.__wbg_ptr, plutus_data.__wbg_ptr);
  }
  /**
   * @returns {PlutusList | undefined}
   */
  plutus_data() {
    const ret = wasm$1.transactionwitnessset_plutus_data(this.__wbg_ptr);
    return ret === 0 ? undefined : PlutusList.__wrap(ret);
  }
  /**
   * @param {Redeemers} redeemers
   */
  set_redeemers(redeemers) {
    _assertClass$1(redeemers, Redeemers);
    wasm$1.transactionwitnessset_set_redeemers(this.__wbg_ptr, redeemers.__wbg_ptr);
  }
  /**
   * @returns {Redeemers | undefined}
   */
  redeemers() {
    const ret = wasm$1.transactionwitnessset_redeemers(this.__wbg_ptr);
    return ret === 0 ? undefined : Redeemers.__wrap(ret);
  }
  /**
   * @returns {TransactionWitnessSet}
   */
  static new() {
    const ret = wasm$1.transactionwitnessset_new();
    return TransactionWitnessSet.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_transactionwitnesssets_free(ptr >>> 0));

const TreasuryWithdrawalsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_treasurywithdrawals_free(ptr >>> 0));
/**
 */
class TreasuryWithdrawals {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TreasuryWithdrawals.prototype);
    obj.__wbg_ptr = ptr;
    TreasuryWithdrawalsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TreasuryWithdrawalsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_treasurywithdrawals_free(ptr);
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.treasurywithdrawals_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.treasurywithdrawals_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TreasuryWithdrawals}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.treasurywithdrawals_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TreasuryWithdrawals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TreasuryWithdrawals}
   */
  static new() {
    const ret = wasm$1.treasurywithdrawals_new();
    return TreasuryWithdrawals.__wrap(ret);
  }
  /**
   * @param {RewardAddress} key
   * @returns {BigNum | undefined}
   */
  get(key) {
    _assertClass$1(key, RewardAddress);
    const ret = wasm$1.treasurywithdrawals_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {RewardAddress} key
   * @param {BigNum} value
   */
  insert(key, value) {
    _assertClass$1(key, RewardAddress);
    _assertClass$1(value, BigNum$1);
    wasm$1.treasurywithdrawals_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
  }
  /**
   * @returns {RewardAddresses}
   */
  keys() {
    const ret = wasm$1.treasurywithdrawals_keys(this.__wbg_ptr);
    return RewardAddresses.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.relays_len(this.__wbg_ptr); } else {
      ret = wasm$1.plutuswitnesses_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
}

const TreasuryWithdrawalsActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_treasurywithdrawalsaction_free(ptr >>> 0));
/**
 */
class TreasuryWithdrawalsAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(TreasuryWithdrawalsAction.prototype);
    obj.__wbg_ptr = ptr;
    TreasuryWithdrawalsActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    TreasuryWithdrawalsActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_treasurywithdrawalsaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.treasurywithdrawalsaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {TreasuryWithdrawalsAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.treasurywithdrawalsaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TreasuryWithdrawalsAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.treasurywithdrawalsaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {TreasuryWithdrawalsAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.treasurywithdrawalsaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TreasuryWithdrawalsAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.treasurywithdrawalsaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.treasurywithdrawalsaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {TreasuryWithdrawalsAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.treasurywithdrawalsaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return TreasuryWithdrawalsAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {TreasuryWithdrawals}
   */
  withdrawals() {
    const ret = wasm$1.treasurywithdrawalsaction_withdrawals(this.__wbg_ptr);
    return TreasuryWithdrawals.__wrap(ret);
  }
  /**
   * @returns {ScriptHash | undefined}
   */
  policy_hash() {
    const ret = wasm$1.treasurywithdrawalsaction_policy_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : ScriptHash.__wrap(ret);
  }
  /**
   * @param {TreasuryWithdrawals} withdrawals
   * @returns {TreasuryWithdrawalsAction}
   */
  static new(withdrawals) {
    _assertClass$1(withdrawals, TreasuryWithdrawals);
    const ret = wasm$1.treasurywithdrawalsaction_new(withdrawals.__wbg_ptr);
    return TreasuryWithdrawalsAction.__wrap(ret);
  }
  /**
   * @param {TreasuryWithdrawals} withdrawals
   * @param {ScriptHash} policy_hash
   * @returns {TreasuryWithdrawalsAction}
   */
  static new_with_policy_hash(withdrawals, policy_hash) {
    _assertClass$1(withdrawals, TreasuryWithdrawals);
    _assertClass$1(policy_hash, ScriptHash);
    const ret = wasm$1.treasurywithdrawalsaction_new_with_policy_hash(withdrawals.__wbg_ptr, policy_hash.__wbg_ptr);
    return TreasuryWithdrawalsAction.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_txbuilderconstants_free(ptr >>> 0));

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_txinputsbuilder_free(ptr >>> 0));

const URLFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_url_free(ptr >>> 0));
/**
 */
let URL$1 = class URL {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(URL.prototype);
    obj.__wbg_ptr = ptr;
    URLFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    URLFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_url_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.url_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {URL}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.url_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return URL.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.url_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {URL}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.url_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return URL.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {URL}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.url_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return URL.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} url
   * @returns {URL}
   */
  static new(url) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(url, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.url_new(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return URL.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  url() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.dnsrecordaoraaaa_record(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
};

const UnitIntervalFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_unitinterval_free(ptr >>> 0));
/**
 */
class UnitInterval {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(UnitInterval.prototype);
    obj.__wbg_ptr = ptr;
    UnitIntervalFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    UnitIntervalFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_unitinterval_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.unitinterval_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {UnitInterval}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.unitinterval_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return UnitInterval.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.unitinterval_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {UnitInterval}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.unitinterval_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return UnitInterval.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.unitinterval_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.unitinterval_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {UnitInterval}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.unitinterval_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return UnitInterval.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {BigNum}
   */
  numerator() {
    const ret = wasm$1.datacost_coins_per_byte(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  denominator() {
    const ret = wasm$1.unitinterval_denominator(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} numerator
   * @param {BigNum} denominator
   * @returns {UnitInterval}
   */
  static new(numerator, denominator) {
    _assertClass$1(numerator, BigNum$1);
    _assertClass$1(denominator, BigNum$1);
    const ret = wasm$1.unitinterval_new(numerator.__wbg_ptr, denominator.__wbg_ptr);
    return UnitInterval.__wrap(ret);
  }
}

const UpdateFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_update_free(ptr >>> 0));
/**
 */
class Update {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Update.prototype);
    obj.__wbg_ptr = ptr;
    UpdateFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    UpdateFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_update_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.update_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Update}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.update_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Update.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.update_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Update}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.update_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Update.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.update_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.update_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Update}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.update_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Update.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {ProposedProtocolParameterUpdates}
   */
  proposed_protocol_parameter_updates() {
    const ret = wasm$1.update_proposed_protocol_parameter_updates(this.__wbg_ptr);
    return ProposedProtocolParameterUpdates.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  epoch() {
    const ret = wasm$1.update_epoch(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {ProposedProtocolParameterUpdates} proposed_protocol_parameter_updates
   * @param {number} epoch
   * @returns {Update}
   */
  static new(proposed_protocol_parameter_updates, epoch) {
    _assertClass$1(proposed_protocol_parameter_updates, ProposedProtocolParameterUpdates);
    const ret = wasm$1.update_new(proposed_protocol_parameter_updates.__wbg_ptr, epoch);
    return Update.__wrap(ret);
  }
}

const UpdateCommitteeActionFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_updatecommitteeaction_free(ptr >>> 0));
/**
 */
class UpdateCommitteeAction {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(UpdateCommitteeAction.prototype);
    obj.__wbg_ptr = ptr;
    UpdateCommitteeActionFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    UpdateCommitteeActionFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_updatecommitteeaction_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.updatecommitteeaction_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {UpdateCommitteeAction}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.updatecommitteeaction_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return UpdateCommitteeAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.updatecommitteeaction_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {UpdateCommitteeAction}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.updatecommitteeaction_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return UpdateCommitteeAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.updatecommitteeaction_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.updatecommitteeaction_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {UpdateCommitteeAction}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.updatecommitteeaction_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return UpdateCommitteeAction.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceActionId | undefined}
   */
  gov_action_id() {
    const ret = wasm$1.updatecommitteeaction_gov_action_id(this.__wbg_ptr);
    return ret === 0 ? undefined : GovernanceActionId.__wrap(ret);
  }
  /**
   * @returns {Committee}
   */
  committee() {
    const ret = wasm$1.updatecommitteeaction_committee(this.__wbg_ptr);
    return Committee.__wrap(ret);
  }
  /**
   * @returns {Credentials}
   */
  members_to_remove() {
    const ret = wasm$1.updatecommitteeaction_members_to_remove(this.__wbg_ptr);
    return Credentials.__wrap(ret);
  }
  /**
   * @param {Committee} committee
   * @param {Credentials} members_to_remove
   * @returns {UpdateCommitteeAction}
   */
  static new(committee, members_to_remove) {
    _assertClass$1(committee, Committee);
    _assertClass$1(members_to_remove, Credentials);
    const ret = wasm$1.updatecommitteeaction_new(committee.__wbg_ptr, members_to_remove.__wbg_ptr);
    return UpdateCommitteeAction.__wrap(ret);
  }
  /**
   * @param {GovernanceActionId} gov_action_id
   * @param {Committee} committee
   * @param {Credentials} members_to_remove
   * @returns {UpdateCommitteeAction}
   */
  static new_with_action_id(gov_action_id, committee, members_to_remove) {
    _assertClass$1(gov_action_id, GovernanceActionId);
    _assertClass$1(committee, Committee);
    _assertClass$1(members_to_remove, Credentials);
    const ret = wasm$1.updatecommitteeaction_new_with_action_id(gov_action_id.__wbg_ptr, committee.__wbg_ptr, members_to_remove.__wbg_ptr);
    return UpdateCommitteeAction.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vrfcert_free(ptr >>> 0));

const VRFKeyHashFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vrfkeyhash_free(ptr >>> 0));
/**
 */
class VRFKeyHash {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VRFKeyHash.prototype);
    obj.__wbg_ptr = ptr;
    VRFKeyHashFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VRFKeyHashFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_vrfkeyhash_free(ptr);
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VRFKeyHash}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vrfkeyhash_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VRFKeyHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} prefix
   * @returns {string}
   */
  to_bech32(prefix) {
    let deferred3_0;
    let deferred3_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(prefix, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.anchordatahash_to_bech32(retptr, this.__wbg_ptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr2 = r0;
      var len2 = r1;
      if (r3) {
        ptr2 = 0; len2 = 0;
        throw takeObject$1(r2);
      }
      deferred3_0 = ptr2;
      deferred3_1 = len2;
      return getStringFromWasm0$1(ptr2, len2);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred3_0, deferred3_1, 1);
    }
  }
  /**
   * @param {string} bech_str
   * @returns {VRFKeyHash}
   */
  static from_bech32(bech_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(bech_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vrfkeyhash_from_bech32(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VRFKeyHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.anchordatahash_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex
   * @returns {VRFKeyHash}
   */
  static from_hex(hex) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vrfkeyhash_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VRFKeyHash.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vrfvkey_free(ptr >>> 0));

const ValueFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_value_free(ptr >>> 0));
/**
 */
class Value {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Value.prototype);
    obj.__wbg_ptr = ptr;
    ValueFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    ValueFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_value_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.value_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Value}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.value_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Value.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.value_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Value}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.value_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Value.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.value_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.value_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Value}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.value_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Value.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {BigNum} coin
   * @returns {Value}
   */
  static new(coin) {
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.value_new(coin.__wbg_ptr);
    return Value.__wrap(ret);
  }
  /**
   * @param {MultiAsset} multiasset
   * @returns {Value}
   */
  static new_from_assets(multiasset) {
    _assertClass$1(multiasset, MultiAsset);
    const ret = wasm$1.value_new_from_assets(multiasset.__wbg_ptr);
    return Value.__wrap(ret);
  }
  /**
   * @param {BigNum} coin
   * @param {MultiAsset} multiasset
   * @returns {Value}
   */
  static new_with_assets(coin, multiasset) {
    _assertClass$1(coin, BigNum$1);
    _assertClass$1(multiasset, MultiAsset);
    const ret = wasm$1.value_new_with_assets(coin.__wbg_ptr, multiasset.__wbg_ptr);
    return Value.__wrap(ret);
  }
  /**
   * @returns {Value}
   */
  static zero() {
    const ret = wasm$1.value_zero();
    return Value.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  is_zero() {
    const ret = wasm$1.value_is_zero(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {BigNum}
   */
  coin() {
    const ret = wasm$1.value_coin(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {BigNum} coin
   */
  set_coin(coin) {
    _assertClass$1(coin, BigNum$1);
    wasm$1.value_set_coin(this.__wbg_ptr, coin.__wbg_ptr);
  }
  /**
   * @returns {MultiAsset | undefined}
   */
  multiasset() {
    const ret = wasm$1.value_multiasset(this.__wbg_ptr);
    return ret === 0 ? undefined : MultiAsset.__wrap(ret);
  }
  /**
   * @param {MultiAsset} multiasset
   */
  set_multiasset(multiasset) {
    _assertClass$1(multiasset, MultiAsset);
    wasm$1.value_set_multiasset(this.__wbg_ptr, multiasset.__wbg_ptr);
  }
  /**
   * @param {Value} rhs
   * @returns {Value}
   */
  checked_add(rhs) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(rhs, Value);
      wasm$1.value_checked_add(retptr, this.__wbg_ptr, rhs.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Value.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Value} rhs_value
   * @returns {Value}
   */
  checked_sub(rhs_value) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      _assertClass$1(rhs_value, Value);
      wasm$1.value_checked_sub(retptr, this.__wbg_ptr, rhs_value.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Value.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Value} rhs_value
   * @returns {Value}
   */
  clamped_sub(rhs_value) {
    _assertClass$1(rhs_value, Value);
    const ret = wasm$1.value_clamped_sub(this.__wbg_ptr, rhs_value.__wbg_ptr);
    return Value.__wrap(ret);
  }
  /**
   * note: values are only partially comparable
   * @param {Value} rhs_value
   * @returns {number | undefined}
   */
  compare(rhs_value) {
    _assertClass$1(rhs_value, Value);
    const ret = wasm$1.value_compare(this.__wbg_ptr, rhs_value.__wbg_ptr);
    return ret === 0xFFFFFF ? undefined : ret;
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_versionedblock_free(ptr >>> 0));

const VkeyFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vkey_free(ptr >>> 0));
/**
 */
class Vkey {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Vkey.prototype);
    obj.__wbg_ptr = ptr;
    VkeyFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VkeyFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_vkey_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkey_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Vkey}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkey_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkey_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Vkey}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkey_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkey_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkey_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Vkey}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkey_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkey.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {PublicKey} pk
   * @returns {Vkey}
   */
  static new(pk) {
    _assertClass$1(pk, PublicKey);
    const ret = wasm$1.vkey_new(pk.__wbg_ptr);
    return Vkey.__wrap(ret);
  }
  /**
   * @returns {PublicKey}
   */
  public_key() {
    const ret = wasm$1.vkey_public_key(this.__wbg_ptr);
    return PublicKey.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vkeys_free(ptr >>> 0));

const VkeywitnessFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vkeywitness_free(ptr >>> 0));
/**
 */
class Vkeywitness {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Vkeywitness.prototype);
    obj.__wbg_ptr = ptr;
    VkeywitnessFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VkeywitnessFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_vkeywitness_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitness_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Vkeywitness}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkeywitness_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkeywitness.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitness_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Vkeywitness}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkeywitness_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkeywitness.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitness_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitness_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Vkeywitness}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkeywitness_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkeywitness.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Vkey} vkey
   * @param {Ed25519Signature} signature
   * @returns {Vkeywitness}
   */
  static new(vkey, signature) {
    _assertClass$1(vkey, Vkey);
    _assertClass$1(signature, Ed25519Signature);
    const ret = wasm$1.vkeywitness_new(vkey.__wbg_ptr, signature.__wbg_ptr);
    return Vkeywitness.__wrap(ret);
  }
  /**
   * @returns {Vkey}
   */
  vkey() {
    const ret = wasm$1.vkeywitness_vkey(this.__wbg_ptr);
    return Vkey.__wrap(ret);
  }
  /**
   * @returns {Ed25519Signature}
   */
  signature() {
    const ret = wasm$1.vkeywitness_signature(this.__wbg_ptr);
    return Ed25519Signature.__wrap(ret);
  }
}

const VkeywitnessesFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_vkeywitnesses_free(ptr >>> 0));
/**
 */
class Vkeywitnesses {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Vkeywitnesses.prototype);
    obj.__wbg_ptr = ptr;
    VkeywitnessesFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VkeywitnessesFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_vkeywitnesses_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitnesses_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Vkeywitnesses}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkeywitnesses_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkeywitnesses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitnesses_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Vkeywitnesses}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkeywitnesses_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkeywitnesses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitnesses_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.vkeywitnesses_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Vkeywitnesses}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.vkeywitnesses_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Vkeywitnesses.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Vkeywitnesses}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.vkeywitnesses_new(); } else {
      ret = wasm$1.bootstrapwitnesses_new(); }
    return Vkeywitnesses.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.relays_len(this.__wbg_ptr); } else {
      ret = wasm$1.bootstrapwitnesses_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {Vkeywitness}
   */
  get(index) {
    const ret = wasm$1.vkeywitnesses_get(this.__wbg_ptr, index);
    return Vkeywitness.__wrap(ret);
  }
  /**
   * Add a new `Vkeywitness` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {Vkeywitness} witness
   * @returns {boolean}
   */
  add(witness) {
    _assertClass$1(witness, Vkeywitness);
    const ret = wasm$1.vkeywitnesses_add(this.__wbg_ptr, witness.__wbg_ptr);
    return ret !== 0;
  }
}

const VoteDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votedelegation_free(ptr >>> 0));
/**
 */
class VoteDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VoteDelegation.prototype);
    obj.__wbg_ptr = ptr;
    VoteDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VoteDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_votedelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votedelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VoteDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votedelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VoteDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votedelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {VoteDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votedelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VoteDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votedelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votedelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {VoteDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votedelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VoteDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.votedelegation_stake_credential(this.__wbg_ptr); } else {
      ret = wasm$1.stakeandvotedelegation_stake_credential(this.__wbg_ptr); }
    return Credential.__wrap(ret);
  }
  /**
   * @returns {DRep}
   */
  drep() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.votedelegation_drep(this.__wbg_ptr); } else {
      ret = wasm$1.stakeandvotedelegation_drep(this.__wbg_ptr); }
    return DRep.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {DRep} drep
   * @returns {VoteDelegation}
   */
  static new(stake_credential, drep) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(drep, DRep);
    const ret = wasm$1.votedelegation_new(stake_credential.__wbg_ptr, drep.__wbg_ptr);
    return VoteDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.votedelegation_has_script_credentials(this.__wbg_ptr); } else {
      ret = wasm$1.stakeandvotedelegation_has_script_credentials(this.__wbg_ptr); }
    return ret !== 0;
  }
}

const VoteRegistrationAndDelegationFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_voteregistrationanddelegation_free(ptr >>> 0));
/**
 */
class VoteRegistrationAndDelegation {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VoteRegistrationAndDelegation.prototype);
    obj.__wbg_ptr = ptr;
    VoteRegistrationAndDelegationFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VoteRegistrationAndDelegationFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_voteregistrationanddelegation_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voteregistrationanddelegation_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VoteRegistrationAndDelegation}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voteregistrationanddelegation_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VoteRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voteregistrationanddelegation_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {VoteRegistrationAndDelegation}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voteregistrationanddelegation_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VoteRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voteregistrationanddelegation_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voteregistrationanddelegation_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {VoteRegistrationAndDelegation}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voteregistrationanddelegation_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VoteRegistrationAndDelegation.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Credential}
   */
  stake_credential() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.voteregistrationanddelegation_stake_credential(this.__wbg_ptr); } else {
      ret = wasm$1.drepderegistration_voting_credential(this.__wbg_ptr); }
    return Credential.__wrap(ret);
  }
  /**
   * @returns {DRep}
   */
  drep() {
    const ret = wasm$1.voteregistrationanddelegation_drep(this.__wbg_ptr);
    return DRep.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  coin() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.stakevoteregistrationanddelegation_coin(this.__wbg_ptr); } else {
      ret = wasm$1.drepderegistration_coin(this.__wbg_ptr); }
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {Credential} stake_credential
   * @param {DRep} drep
   * @param {BigNum} coin
   * @returns {VoteRegistrationAndDelegation}
   */
  static new(stake_credential, drep, coin) {
    _assertClass$1(stake_credential, Credential);
    _assertClass$1(drep, DRep);
    _assertClass$1(coin, BigNum$1);
    const ret = wasm$1.voteregistrationanddelegation_new(stake_credential.__wbg_ptr, drep.__wbg_ptr, coin.__wbg_ptr);
    return VoteRegistrationAndDelegation.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.voteregistrationanddelegation_has_script_credentials(this.__wbg_ptr); } else {
      ret = wasm$1.drepderegistration_has_script_credentials(this.__wbg_ptr); }
    return ret !== 0;
  }
}

const VoterFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_voter_free(ptr >>> 0));
/**
 */
class Voter {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Voter.prototype);
    obj.__wbg_ptr = ptr;
    VoterFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VoterFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_voter_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voter_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Voter}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voter_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Voter.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voter_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Voter}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voter_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Voter.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voter_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voter_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Voter}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voter_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Voter.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Credential} cred
   * @returns {Voter}
   */
  static new_constitutional_committee_hot_credential(cred) {
    _assertClass$1(cred, Credential);
    const ret = wasm$1.voter_new_constitutional_committee_hot_credential(cred.__wbg_ptr);
    return Voter.__wrap(ret);
  }
  /**
   * @param {Credential} cred
   * @returns {Voter}
   */
  static new_drep_credential(cred) {
    _assertClass$1(cred, Credential);
    const ret = wasm$1.voter_new_drep_credential(cred.__wbg_ptr);
    return Voter.__wrap(ret);
  }
  /**
   * @param {Ed25519KeyHash} key_hash
   * @returns {Voter}
   */
  static new_stake_pool_key_hash(key_hash) {
    _assertClass$1(key_hash, Ed25519KeyHash);
    const ret = wasm$1.voter_new_stake_pool_key_hash(key_hash.__wbg_ptr);
    return Voter.__wrap(ret);
  }
  /**
   * @returns {VoterKind}
   */
  kind() {
    const ret = wasm$1.voter_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {Credential | undefined}
   */
  to_constitutional_committee_hot_credential() {
    const ret = wasm$1.voter_to_constitutional_committee_hot_credential(this.__wbg_ptr);
    return ret === 0 ? undefined : Credential.__wrap(ret);
  }
  /**
   * @returns {Credential | undefined}
   */
  to_drep_credential() {
    const ret = wasm$1.voter_to_drep_credential(this.__wbg_ptr);
    return ret === 0 ? undefined : Credential.__wrap(ret);
  }
  /**
   * @returns {Ed25519KeyHash | undefined}
   */
  to_stake_pool_key_hash() {
    const ret = wasm$1.voter_to_stake_pool_key_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
  }
  /**
   * @returns {boolean}
   */
  has_script_credentials() {
    const ret = wasm$1.voter_has_script_credentials(this.__wbg_ptr);
    return ret !== 0;
  }
  /**
   * @returns {Ed25519KeyHash | undefined}
   */
  to_key_hash() {
    const ret = wasm$1.voter_to_key_hash(this.__wbg_ptr);
    return ret === 0 ? undefined : Ed25519KeyHash.__wrap(ret);
  }
}

const VotersFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_voters_free(ptr >>> 0));
/**
 */
class Voters {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Voters.prototype);
    obj.__wbg_ptr = ptr;
    VotersFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VotersFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_voters_free(ptr);
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voters_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.voters_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Voters}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.voters_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Voters.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Voters}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.voters_new(); } else {
      ret = wasm$1.languages_new(); }
    return Voters.__wrap(ret);
  }
  /**
   * @param {Voter} voter
   */
  add(voter) {
    _assertClass$1(voter, Voter);
    wasm$1.voters_add(this.__wbg_ptr, voter.__wbg_ptr);
  }
  /**
   * @param {number} index
   * @returns {Voter | undefined}
   */
  get(index) {
    const ret = wasm$1.voters_get(this.__wbg_ptr, index);
    return ret === 0 ? undefined : Voter.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.metadatalist_len(this.__wbg_ptr); } else {
      ret = wasm$1.costmdls_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votingbuilder_free(ptr >>> 0));

const VotingProcedureFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votingprocedure_free(ptr >>> 0));
/**
 */
class VotingProcedure {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VotingProcedure.prototype);
    obj.__wbg_ptr = ptr;
    VotingProcedureFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VotingProcedureFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_votingprocedure_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedure_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VotingProcedure}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingprocedure_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProcedure.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedure_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {VotingProcedure}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingprocedure_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProcedure.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedure_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedure_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {VotingProcedure}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingprocedure_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProcedure.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {VoteKind} vote
   * @returns {VotingProcedure}
   */
  static new(vote) {
    const ret = wasm$1.votingprocedure_new(vote);
    return VotingProcedure.__wrap(ret);
  }
  /**
   * @param {VoteKind} vote
   * @param {Anchor} anchor
   * @returns {VotingProcedure}
   */
  static new_with_anchor(vote, anchor) {
    _assertClass$1(anchor, Anchor);
    const ret = wasm$1.votingprocedure_new_with_anchor(vote, anchor.__wbg_ptr);
    return VotingProcedure.__wrap(ret);
  }
  /**
   * @returns {VoteKind}
   */
  vote_kind() {
    const ret = wasm$1.votingprocedure_vote_kind(this.__wbg_ptr);
    return ret;
  }
  /**
   * @returns {Anchor | undefined}
   */
  anchor() {
    const ret = wasm$1.drepupdate_anchor(this.__wbg_ptr);
    return ret === 0 ? undefined : Anchor.__wrap(ret);
  }
}

const VotingProceduresFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votingprocedures_free(ptr >>> 0));
/**
 */
class VotingProcedures {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VotingProcedures.prototype);
    obj.__wbg_ptr = ptr;
    VotingProceduresFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VotingProceduresFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_votingprocedures_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedures_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VotingProcedures}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingprocedures_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProcedures.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedures_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {VotingProcedures}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingprocedures_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProcedures.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedures_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingprocedures_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {VotingProcedures}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingprocedures_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProcedures.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {VotingProcedures}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.votingbuilder_new(); } else {
      ret = wasm$1.votingprocedures_new(); }
    return VotingProcedures.__wrap(ret);
  }
  /**
   * @param {Voter} voter
   * @param {GovernanceActionId} governance_action_id
   * @param {VotingProcedure} voting_procedure
   */
  insert(voter, governance_action_id, voting_procedure) {
    _assertClass$1(voter, Voter);
    _assertClass$1(governance_action_id, GovernanceActionId);
    _assertClass$1(voting_procedure, VotingProcedure);
    wasm$1.votingprocedures_insert(this.__wbg_ptr, voter.__wbg_ptr, governance_action_id.__wbg_ptr, voting_procedure.__wbg_ptr);
  }
  /**
   * @param {Voter} voter
   * @param {GovernanceActionId} governance_action_id
   * @returns {VotingProcedure | undefined}
   */
  get(voter, governance_action_id) {
    _assertClass$1(voter, Voter);
    _assertClass$1(governance_action_id, GovernanceActionId);
    const ret = wasm$1.votingprocedures_get(this.__wbg_ptr, voter.__wbg_ptr, governance_action_id.__wbg_ptr);
    return ret === 0 ? undefined : VotingProcedure.__wrap(ret);
  }
  /**
   * @returns {Voters}
   */
  get_voters() {
    const ret = wasm$1.votingprocedures_get_voters(this.__wbg_ptr);
    return Voters.__wrap(ret);
  }
  /**
   * @param {Voter} voter
   * @returns {GovernanceActionIds}
   */
  get_governance_action_ids_by_voter(voter) {
    _assertClass$1(voter, Voter);
    const ret = wasm$1.votingprocedures_get_governance_action_ids_by_voter(this.__wbg_ptr, voter.__wbg_ptr);
    return GovernanceActionIds.__wrap(ret);
  }
}

const VotingProposalFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votingproposal_free(ptr >>> 0));
/**
 */
class VotingProposal {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VotingProposal.prototype);
    obj.__wbg_ptr = ptr;
    VotingProposalFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VotingProposalFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_votingproposal_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposal_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VotingProposal}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingproposal_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProposal.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposal_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {VotingProposal}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingproposal_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProposal.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposal_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposal_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {VotingProposal}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingproposal_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProposal.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {GovernanceAction}
   */
  governance_action() {
    const ret = wasm$1.votingproposal_governance_action(this.__wbg_ptr);
    return GovernanceAction.__wrap(ret);
  }
  /**
   * @returns {Anchor}
   */
  anchor() {
    const ret = wasm$1.votingproposal_anchor(this.__wbg_ptr);
    return Anchor.__wrap(ret);
  }
  /**
   * @returns {RewardAddress}
   */
  reward_account() {
    const ret = wasm$1.votingproposal_reward_account(this.__wbg_ptr);
    return RewardAddress.__wrap(ret);
  }
  /**
   * @returns {BigNum}
   */
  deposit() {
    const ret = wasm$1.votingproposal_deposit(this.__wbg_ptr);
    return BigNum$1.__wrap(ret);
  }
  /**
   * @param {GovernanceAction} governance_action
   * @param {Anchor} anchor
   * @param {RewardAddress} reward_account
   * @param {BigNum} deposit
   * @returns {VotingProposal}
   */
  static new(governance_action, anchor, reward_account, deposit) {
    _assertClass$1(governance_action, GovernanceAction);
    _assertClass$1(anchor, Anchor);
    _assertClass$1(reward_account, RewardAddress);
    _assertClass$1(deposit, BigNum$1);
    const ret = wasm$1.votingproposal_new(governance_action.__wbg_ptr, anchor.__wbg_ptr, reward_account.__wbg_ptr, deposit.__wbg_ptr);
    return VotingProposal.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votingproposalbuilder_free(ptr >>> 0));

const VotingProposalsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_votingproposals_free(ptr >>> 0));
/**
 */
class VotingProposals {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(VotingProposals.prototype);
    obj.__wbg_ptr = ptr;
    VotingProposalsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    VotingProposalsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_votingproposals_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposals_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {VotingProposals}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingproposals_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProposals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposals_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {VotingProposals}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingproposals_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProposals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposals_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.votingproposals_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {VotingProposals}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.votingproposals_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return VotingProposals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {VotingProposals}
   */
  static new() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.votingproposals_new(); } else {
      ret = wasm$1.credentials_new(); }
    return VotingProposals.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    let ret;
    if (version$2 === VERSION_12_1_1$1) { ret = wasm$1.governanceactionids_len(this.__wbg_ptr); } else {
      ret = wasm$1.credentials_len(this.__wbg_ptr); }
    return ret >>> 0;
  }
  /**
   * @param {number} index
   * @returns {VotingProposal}
   */
  get(index) {
    const ret = wasm$1.votingproposals_get(this.__wbg_ptr, index);
    return VotingProposal.__wrap(ret);
  }
  /**
   * Add a new `VotingProposal` to the set.
   * Returns `true` if the element was not already present in the set.
   * @param {VotingProposal} proposal
   * @returns {boolean}
   */
  add(proposal) {
    _assertClass$1(proposal, VotingProposal);
    const ret = wasm$1.votingproposals_add(this.__wbg_ptr, proposal.__wbg_ptr);
    return ret !== 0;
  }
  /** VERSION_13_2_0
   * @param {VotingProposal} elem
   * @returns {boolean}
   */
  contains(elem) {
    if (version$2 === VERSION_12_1_1$1) { throw NOT_IMPLEMENTED }
    _assertClass$1(elem, VotingProposal);
    const ret = wasm$1.votingproposals_contains(this.__wbg_ptr, elem.__wbg_ptr);
    return ret !== 0;
  }
  /** VERSION_13_2_0
   * @returns {VotingProposals | undefined}
   */
  to_option() {
    if (version$2 === VERSION_12_1_1$1) { throw NOT_IMPLEMENTED }
    const ret = wasm$1.votingproposals_to_option(this.__wbg_ptr);
    return ret === 0 ? undefined : VotingProposals.__wrap(ret);
  }
}

const WithdrawalsFinalization = (typeof FinalizationRegistry === 'undefined')
  ? { register: () => {}, unregister: () => {} }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_withdrawals_free(ptr >>> 0));
/**
 */
class Withdrawals {

  static __wrap(ptr) {
    ptr = ptr >>> 0;
    const obj = Object.create(Withdrawals.prototype);
    obj.__wbg_ptr = ptr;
    WithdrawalsFinalization.register(obj, obj.__wbg_ptr, obj);
    return obj;
  }

  __destroy_into_raw() {
    const ptr = this.__wbg_ptr;
    this.__wbg_ptr = 0;
    WithdrawalsFinalization.unregister(this);
    return ptr;
  }

  free() {
    const ptr = this.__destroy_into_raw();
    wasm$1.__wbg_withdrawals_free(ptr);
  }
  /**
   * @returns {Uint8Array}
   */
  to_bytes() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.withdrawals_to_bytes(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var v1 = getArrayU8FromWasm0$1(r0, r1).slice();
      wasm$1.__wbindgen_free(r0, r1 * 1, 1);
      return v1;
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {Uint8Array} bytes
   * @returns {Withdrawals}
   */
  static from_bytes(bytes) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passArray8ToWasm0$1(bytes, wasm$1.__wbindgen_malloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.withdrawals_from_bytes(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Withdrawals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_hex() {
    let deferred1_0;
    let deferred1_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.withdrawals_to_hex(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      deferred1_0 = r0;
      deferred1_1 = r1;
      return getStringFromWasm0$1(r0, r1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred1_0, deferred1_1, 1);
    }
  }
  /**
   * @param {string} hex_str
   * @returns {Withdrawals}
   */
  static from_hex(hex_str) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(hex_str, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.withdrawals_from_hex(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Withdrawals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {string}
   */
  to_json() {
    let deferred2_0;
    let deferred2_1;
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.withdrawals_to_json(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      var r3 = getInt32Memory0$1()[retptr / 4 + 3];
      var ptr1 = r0;
      var len1 = r1;
      if (r3) {
        ptr1 = 0; len1 = 0;
        throw takeObject$1(r2);
      }
      deferred2_0 = ptr1;
      deferred2_1 = len1;
      return getStringFromWasm0$1(ptr1, len1);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
      wasm$1.__wbindgen_free(deferred2_0, deferred2_1, 1);
    }
  }
  /**
   * @returns {any}
   */
  to_js_value() {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      wasm$1.withdrawals_to_js_value(retptr, this.__wbg_ptr);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return takeObject$1(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @param {string} json
   * @returns {Withdrawals}
   */
  static from_json(json) {
    try {
      const retptr = wasm$1.__wbindgen_add_to_stack_pointer(-16);
      const ptr0 = passStringToWasm0$1(json, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
      const len0 = WASM_VECTOR_LEN$1;
      wasm$1.withdrawals_from_json(retptr, ptr0, len0);
      var r0 = getInt32Memory0$1()[retptr / 4 + 0];
      var r1 = getInt32Memory0$1()[retptr / 4 + 1];
      var r2 = getInt32Memory0$1()[retptr / 4 + 2];
      if (r2) {
        throw takeObject$1(r1);
      }
      return Withdrawals.__wrap(r0);
    } finally {
      wasm$1.__wbindgen_add_to_stack_pointer(16);
    }
  }
  /**
   * @returns {Withdrawals}
   */
  static new() {
    const ret = wasm$1.auxiliarydataset_new();
    return Withdrawals.__wrap(ret);
  }
  /**
   * @returns {number}
   */
  len() {
    const ret = wasm$1.auxiliarydataset_len(this.__wbg_ptr);
    return ret >>> 0;
  }
  /**
   * @param {RewardAddress} key
   * @param {BigNum} value
   * @returns {BigNum | undefined}
   */
  insert(key, value) {
    _assertClass$1(key, RewardAddress);
    _assertClass$1(value, BigNum$1);
    const ret = wasm$1.withdrawals_insert(this.__wbg_ptr, key.__wbg_ptr, value.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @param {RewardAddress} key
   * @returns {BigNum | undefined}
   */
  get(key) {
    _assertClass$1(key, RewardAddress);
    const ret = wasm$1.withdrawals_get(this.__wbg_ptr, key.__wbg_ptr);
    return ret === 0 ? undefined : BigNum$1.__wrap(ret);
  }
  /**
   * @returns {RewardAddresses}
   */
  keys() {
    const ret = wasm$1.withdrawals_keys(this.__wbg_ptr);
    return RewardAddresses.__wrap(ret);
  }
}

(typeof FinalizationRegistry === 'undefined')
  ? { }
  : new FinalizationRegistry(ptr => wasm$1.__wbg_withdrawalsbuilder_free(ptr >>> 0));

async function __wbg_load(module, imports) {
  if (typeof Response === 'function' && module instanceof Response) {
    if (typeof WebAssembly.instantiateStreaming === 'function') {
      try {
        return await WebAssembly.instantiateStreaming(module, imports);

      } catch (e) {
        if (module.headers.get('Content-Type') != 'application/wasm') {
          console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

        } else {
          throw e;
        }
      }
    }

    const bytes = await module.arrayBuffer();
    return await WebAssembly.instantiate(bytes, imports);

  } else {
    const instance = await WebAssembly.instantiate(module, imports);

    if (instance instanceof WebAssembly.Instance) {
      return { instance, module };

    } else {
      return instance;
    }
  }
}

function __wbg_get_imports() {
  const imports = {};
  imports.wbg = {};
  imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
    takeObject$1(arg0);
  };
  imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
    const ret = getStringFromWasm0$1(arg0, arg1);
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_number_new = function(arg0) {
    const ret = arg0;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_string_get = function(arg0, arg1) {
    const obj = getObject$1(arg1);
    const ret = typeof(obj) === 'string' ? obj : undefined;
    var ptr1 = isLikeNone$1(ret) ? 0 : passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    var len1 = WASM_VECTOR_LEN$1;
    getInt32Memory0$1()[arg0 / 4 + 1] = len1;
    getInt32Memory0$1()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_error_new = function(arg0, arg1) {
    const ret = new Error(getStringFromWasm0$1(arg0, arg1));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_object_clone_ref = function(arg0) {
    const ret = getObject$1(arg0);
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_is_object = function(arg0) {
    const val = getObject$1(arg0);
    const ret = typeof(val) === 'object' && val !== null;
    return ret;
  };
  imports.wbg.__wbg_String_91fba7ded13ba54c = function(arg0, arg1) {
    const ret = String(getObject$1(arg1));
    const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN$1;
    getInt32Memory0$1()[arg0 / 4 + 1] = len1;
    getInt32Memory0$1()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbg_set_20cbc34131e76824 = function(arg0, arg1, arg2) {
    getObject$1(arg0)[takeObject$1(arg1)] = takeObject$1(arg2);
  };
  imports.wbg.__wbg_crypto_1d1f22824a6a080c = function(arg0) {
    const ret = getObject$1(arg0).crypto;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_process_4a72847cc503995b = function(arg0) {
    const ret = getObject$1(arg0).process;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_versions_f686565e586dd935 = function(arg0) {
    const ret = getObject$1(arg0).versions;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_node_104a2ff8d6ea03a2 = function(arg0) {
    const ret = getObject$1(arg0).node;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_is_string = function(arg0) {
    const ret = typeof(getObject$1(arg0)) === 'string';
    return ret;
  };
  imports.wbg.__wbg_require_cca90b1a94a0255b = function() { return handleError(function () {
    const ret = module.require;
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbg_msCrypto_eb05e62b530a1508 = function(arg0) {
    const ret = getObject$1(arg0).msCrypto;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_randomFillSync_5c9c955aa56b6049 = function() { return handleError(function (arg0, arg1) {
    getObject$1(arg0).randomFillSync(takeObject$1(arg1));
  }, arguments) };
  imports.wbg.__wbg_getRandomValues_3aa56aa6edec874c = function() { return handleError(function (arg0, arg1) {
    getObject$1(arg0).getRandomValues(getObject$1(arg1));
  }, arguments) };
  imports.wbg.__wbg_new_16b304a2cfa7ff4a = function() {
    const ret = new Array();
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_is_function = function(arg0) {
    const ret = typeof(getObject$1(arg0)) === 'function';
    return ret;
  };
  imports.wbg.__wbg_newnoargs_e258087cd0daa0ea = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0$1(arg0, arg1));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_new_d9bc3a0147634640 = function() {
    const ret = new Map();
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_call_27c0f87801dedf93 = function() { return handleError(function (arg0, arg1) {
    const ret = getObject$1(arg0).call(getObject$1(arg1));
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbg_new_72fb9a18b5ae2624 = function() {
    const ret = new Object();
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_self_ce0dbfc45cf2f5be = function() { return handleError(function () {
    const ret = self.self;
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbg_window_c6fb939a7f436783 = function() { return handleError(function () {
    const ret = window.window;
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbg_globalThis_d1e6af4856ba331b = function() { return handleError(function () {
    const ret = globalThis.globalThis;
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbg_global_207b558942527489 = function() { return handleError(function () {
    const ret = global.global;
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbindgen_is_undefined = function(arg0) {
    const ret = getObject$1(arg0) === undefined;
    return ret;
  };
  imports.wbg.__wbg_set_d4638f722068f043 = function(arg0, arg1, arg2) {
    getObject$1(arg0)[arg1 >>> 0] = takeObject$1(arg2);
  };
  imports.wbg.__wbg_call_b3ca7c6051f9bec1 = function() { return handleError(function (arg0, arg1, arg2) {
    const ret = getObject$1(arg0).call(getObject$1(arg1), getObject$1(arg2));
    return addHeapObject$1(ret);
  }, arguments) };
  imports.wbg.__wbg_set_8417257aaedc936b = function(arg0, arg1, arg2) {
    const ret = getObject$1(arg0).set(getObject$1(arg1), getObject$1(arg2));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_buffer_12d079cc21e14bdb = function(arg0) {
    const ret = getObject$1(arg0).buffer;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_newwithbyteoffsetandlength_aa4a17c33a06e5cb = function(arg0, arg1, arg2) {
    const ret = new Uint8Array(getObject$1(arg0), arg1 >>> 0, arg2 >>> 0);
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_new_63b92bc8671ed464 = function(arg0) {
    const ret = new Uint8Array(getObject$1(arg0));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_set_a47bac70306a19a7 = function(arg0, arg1, arg2) {
    getObject$1(arg0).set(getObject$1(arg1), arg2 >>> 0);
  };
  imports.wbg.__wbg_newwithlength_e9b4878cebadb3d3 = function(arg0) {
    const ret = new Uint8Array(arg0 >>> 0);
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_subarray_a1f73cd4b5b42fe1 = function(arg0, arg1, arg2) {
    const ret = getObject$1(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_new_d87f272aec784ec0 = function(arg0, arg1) {
    const ret = new Function(getStringFromWasm0$1(arg0, arg1));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_call_eae29933372a39be = function(arg0, arg1) {
    const ret = getObject$1(arg0).call(getObject$1(arg1));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbindgen_jsval_eq = function(arg0, arg1) {
    const ret = getObject$1(arg0) === getObject$1(arg1);
    return ret;
  };
  imports.wbg.__wbg_self_e0b3266d2d9eba1a = function(arg0) {
    const ret = getObject$1(arg0).self;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_require_0993fe224bf8e202 = function(arg0, arg1) {
    const ret = require(getStringFromWasm0$1(arg0, arg1));
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_crypto_e95a6e54c5c2e37f = function(arg0) {
    const ret = getObject$1(arg0).crypto;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_getRandomValues_dc67302a7bd1aec5 = function(arg0) {
    const ret = getObject$1(arg0).getRandomValues;
    return addHeapObject$1(ret);
  };
  imports.wbg.__wbg_randomFillSync_dd2297de5917c74e = function(arg0, arg1, arg2) {
    getObject$1(arg0).randomFillSync(getArrayU8FromWasm0$1(arg1, arg2));
  };
  imports.wbg.__wbg_getRandomValues_02639197c8166a96 = function(arg0, arg1, arg2) {
    getObject$1(arg0).getRandomValues(getArrayU8FromWasm0$1(arg1, arg2));
  };
  imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
    const ret = debugString$1(getObject$1(arg1));
    const ptr1 = passStringToWasm0$1(ret, wasm$1.__wbindgen_malloc, wasm$1.__wbindgen_realloc);
    const len1 = WASM_VECTOR_LEN$1;
    getInt32Memory0$1()[arg0 / 4 + 1] = len1;
    getInt32Memory0$1()[arg0 / 4 + 0] = ptr1;
  };
  imports.wbg.__wbindgen_throw = function(arg0, arg1) {
    throw new Error(getStringFromWasm0$1(arg0, arg1));
  };
  imports.wbg.__wbindgen_memory = function() {
    const ret = wasm$1.memory;
    return addHeapObject$1(ret);
  };

  return imports;
}

function __wbg_finalize_init(instance, module) {
  wasm$1 = instance.exports;
  __wbg_init.__wbindgen_wasm_module = module;
  cachedInt32Memory0 = null;
  cachedUint8Memory0 = null;


  return wasm$1;
}

async function __wbg_init(input, _version) {
  version$2 = _version;
  if (wasm$1 !== undefined) return wasm$1;

  if (typeof input === 'undefined') {
    input = new URL$1("cardano_serialization_lib_bg.wasm", import.meta.url);
  }
  const imports = __wbg_get_imports();

  if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL$1 === 'function' && input instanceof URL$1)) {
    input = fetch(input);
  }

  const { instance, module } = await __wbg_load(await input, imports);

  return __wbg_finalize_init(instance, module);
}

const doLog$2 = false;
const storeId$a = "CSL";
globalThis["cslInitialized"] = false;
const VERSION_12_1_1 = "12.1.1";
const VERSION_13_2_0 = "13.2.0";
let CHOSEN_VERSION = VERSION_12_1_1;
const loadCSL = async (networkId) => {
  if (globalThis["localStorage"]) {
    const ep = localStorage.getItem(epochParams$1 + "_" + networkId);
    if (ep) {
      try {
        const epochParams = JSON.parse(ep);
        if (epochParams && epochParams.isAtLeastConwayEra2) {
          if (doLog$2) ;
          CHOSEN_VERSION = VERSION_13_2_0;
        }
      } catch (err) {
        console.error(err);
      }
    }
  }
  if (!__wbg_init.encrypt_with_password) {
    if (CHOSEN_VERSION === VERSION_12_1_1 && (networkId === "mainnet" || networkId === "afpm" || networkId === "afpt" || networkId === "afvm" || networkId === "afvt")) {
      console.warn("version", VERSION_12_1_1);
      globalThis["cslInitialized"] = !!await __wbg_init("/wasm/csl-v12.1.1.wasm", VERSION_12_1_1);
    } else {
      console.warn("version", VERSION_13_2_0);
      globalThis["cslInitialized"] = !!await __wbg_init("/wasm/csl-v13.2.0.wasm", VERSION_13_2_0);
    }
  } else {
    globalThis["cslInitialized"] = true;
  }
};

const freeCSLObjects = (free) => {
  for (let k = free.length - 1; k >= 0; k--) {
    try {
      free[k]?.free?.();
    } catch (e) {
    }
  }
  free.length = 0;
};
const safeFreeCSLObject = (obj) => {
  if (obj && obj.free) {
    if (obj.__wbg_ptr > 0) {
      obj.free();
    }
  }
};
const parseAddress = (addr) => {
  try {
    return Address.from_bech32(addr);
  } catch (e) {
  }
  try {
    return Address.from_bytes(toHexBuffer(addr));
  } catch (e) {
  }
  if (ByronAddress.is_valid(addr)) {
    return ByronAddress.from_base58(addr).to_address();
  }
  return null;
};
const getCSLBigNum = (num, free) => {
  let cslBigNum;
  {
    cslBigNum = BigNum$1.from_str(num.toString());
  }
  return cslBigNum;
};
const getCSLAddress = (addr, free) => {
  const cslAddress = parseAddress(addr);
  if (!cslAddress) {
    error("Error: addr cannot be parsed:", addr);
    throw new Error("Error: addr cannot be parsed: " + addr);
  }
  free?.push(cslAddress);
  return cslAddress;
};
const getCSLAddressOrNull = (addr, free) => {
  const cslAddress = parseAddress(addr);
  if (cslAddress) {
    free?.push(cslAddress);
  }
  return cslAddress;
};
const getCSLCredential = (cred, isScript, free) => {
  const cslHash = isScript ? ScriptHash.from_bytes(toHexBuffer(cred)) : Ed25519KeyHash.from_bytes(toHexBuffer(cred));
  const cslCred = isScript ? Credential.from_scripthash(cslHash) : Credential.from_keyhash(cslHash);
  safeFreeCSLObject(cslHash);
  return cslCred;
};
const getCSLTransactionOutput = (utxoCbor, free) => {
  const cslTxOutput = TransactionOutput.from_bytes(toHexArray(utxoCbor));
  return cslTxOutput;
};
const getCSLPlutusDataHash = (data, free) => {
  const cslDataHash = hash_plutus_data(data);
  const byteString = toHexString(cslDataHash.to_bytes());
  free?.push(cslDataHash);
  return byteString;
};
const getCSLVkeywitnessHash = (json) => {
  const cslVkeyWitness = Vkeywitness.from_json(json);
  const cslVkey = cslVkeyWitness.vkey();
  const cslPub = cslVkey.public_key();
  const cslHash = cslPub.hash();
  const hex = cslHash.to_hex();
  safeFreeCSLObject(cslHash);
  safeFreeCSLObject(cslPub);
  safeFreeCSLObject(cslVkey);
  safeFreeCSLObject(cslVkeyWitness);
  return hex;
};
const getCSLBip32PrivateKey = (bech32, free) => {
  const cslBip32PrivateKey = Bip32PrivateKey.from_bech32(bech32);
  free?.push(cslBip32PrivateKey);
  return cslBip32PrivateKey;
};
const getCSLBip32PublicKey = (bech32, free) => {
  const cslBip32PublicKey = Bip32PublicKey.from_bech32(bech32);
  free?.push(cslBip32PublicKey);
  return cslBip32PublicKey;
};

var dist$1 = {};

var hasRequiredDist$1;

function requireDist$1 () {
	if (hasRequiredDist$1) return dist$1;
	hasRequiredDist$1 = 1;
	Object.defineProperty(dist$1, "__esModule", { value: true });
	dist$1.bech32m = dist$1.bech32 = void 0;
	const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
	const ALPHABET_MAP = {};
	for (let z = 0; z < ALPHABET.length; z++) {
	    const x = ALPHABET.charAt(z);
	    ALPHABET_MAP[x] = z;
	}
	function polymodStep(pre) {
	    const b = pre >> 25;
	    return (((pre & 0x1ffffff) << 5) ^
	        (-((b >> 0) & 1) & 0x3b6a57b2) ^
	        (-((b >> 1) & 1) & 0x26508e6d) ^
	        (-((b >> 2) & 1) & 0x1ea119fa) ^
	        (-((b >> 3) & 1) & 0x3d4233dd) ^
	        (-((b >> 4) & 1) & 0x2a1462b3));
	}
	function prefixChk(prefix) {
	    let chk = 1;
	    for (let i = 0; i < prefix.length; ++i) {
	        const c = prefix.charCodeAt(i);
	        if (c < 33 || c > 126)
	            return 'Invalid prefix (' + prefix + ')';
	        chk = polymodStep(chk) ^ (c >> 5);
	    }
	    chk = polymodStep(chk);
	    for (let i = 0; i < prefix.length; ++i) {
	        const v = prefix.charCodeAt(i);
	        chk = polymodStep(chk) ^ (v & 0x1f);
	    }
	    return chk;
	}
	function convert(data, inBits, outBits, pad) {
	    let value = 0;
	    let bits = 0;
	    const maxV = (1 << outBits) - 1;
	    const result = [];
	    for (let i = 0; i < data.length; ++i) {
	        value = (value << inBits) | data[i];
	        bits += inBits;
	        while (bits >= outBits) {
	            bits -= outBits;
	            result.push((value >> bits) & maxV);
	        }
	    }
	    if (pad) {
	        if (bits > 0) {
	            result.push((value << (outBits - bits)) & maxV);
	        }
	    }
	    else {
	        if (bits >= inBits)
	            return 'Excess padding';
	        if ((value << (outBits - bits)) & maxV)
	            return 'Non-zero padding';
	    }
	    return result;
	}
	function toWords(bytes) {
	    return convert(bytes, 8, 5, true);
	}
	function fromWordsUnsafe(words) {
	    const res = convert(words, 5, 8, false);
	    if (Array.isArray(res))
	        return res;
	}
	function fromWords(words) {
	    const res = convert(words, 5, 8, false);
	    if (Array.isArray(res))
	        return res;
	    throw new Error(res);
	}
	function getLibraryFromEncoding(encoding) {
	    let ENCODING_CONST;
	    if (encoding === 'bech32') {
	        ENCODING_CONST = 1;
	    }
	    else {
	        ENCODING_CONST = 0x2bc830a3;
	    }
	    function encode(prefix, words, LIMIT) {
	        LIMIT = LIMIT || 90;
	        if (prefix.length + 7 + words.length > LIMIT)
	            throw new TypeError('Exceeds length limit');
	        prefix = prefix.toLowerCase();
	        // determine chk mod
	        let chk = prefixChk(prefix);
	        if (typeof chk === 'string')
	            throw new Error(chk);
	        let result = prefix + '1';
	        for (let i = 0; i < words.length; ++i) {
	            const x = words[i];
	            if (x >> 5 !== 0)
	                throw new Error('Non 5-bit word');
	            chk = polymodStep(chk) ^ x;
	            result += ALPHABET.charAt(x);
	        }
	        for (let i = 0; i < 6; ++i) {
	            chk = polymodStep(chk);
	        }
	        chk ^= ENCODING_CONST;
	        for (let i = 0; i < 6; ++i) {
	            const v = (chk >> ((5 - i) * 5)) & 0x1f;
	            result += ALPHABET.charAt(v);
	        }
	        return result;
	    }
	    function __decode(str, LIMIT) {
	        LIMIT = LIMIT || 90;
	        if (str.length < 8)
	            return str + ' too short';
	        if (str.length > LIMIT)
	            return 'Exceeds length limit';
	        // don't allow mixed case
	        const lowered = str.toLowerCase();
	        const uppered = str.toUpperCase();
	        if (str !== lowered && str !== uppered)
	            return 'Mixed-case string ' + str;
	        str = lowered;
	        const split = str.lastIndexOf('1');
	        if (split === -1)
	            return 'No separator character for ' + str;
	        if (split === 0)
	            return 'Missing prefix for ' + str;
	        const prefix = str.slice(0, split);
	        const wordChars = str.slice(split + 1);
	        if (wordChars.length < 6)
	            return 'Data too short';
	        let chk = prefixChk(prefix);
	        if (typeof chk === 'string')
	            return chk;
	        const words = [];
	        for (let i = 0; i < wordChars.length; ++i) {
	            const c = wordChars.charAt(i);
	            const v = ALPHABET_MAP[c];
	            if (v === undefined)
	                return 'Unknown character ' + c;
	            chk = polymodStep(chk) ^ v;
	            // not in the checksum?
	            if (i + 6 >= wordChars.length)
	                continue;
	            words.push(v);
	        }
	        if (chk !== ENCODING_CONST)
	            return 'Invalid checksum for ' + str;
	        return { prefix, words };
	    }
	    function decodeUnsafe(str, LIMIT) {
	        const res = __decode(str, LIMIT);
	        if (typeof res === 'object')
	            return res;
	    }
	    function decode(str, LIMIT) {
	        const res = __decode(str, LIMIT);
	        if (typeof res === 'object')
	            return res;
	        throw new Error(res);
	    }
	    return {
	        decodeUnsafe,
	        decode,
	        encode,
	        toWords,
	        fromWordsUnsafe,
	        fromWords,
	    };
	}
	dist$1.bech32 = getLibraryFromEncoding('bech32');
	dist$1.bech32m = getLibraryFromEncoding('bech32m');
	return dist$1;
}

var distExports = requireDist$1();

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 * Package binary provides functions for encoding and decoding numbers in byte arrays.
 */
/**
 * Reads 4 bytes from array starting at offset as big-endian
 * unsigned 32-bit integer and returns it.
 */
function readUint32BE(array, offset = 0) {
    return ((array[offset] << 24) |
        (array[offset + 1] << 16) |
        (array[offset + 2] << 8) |
        array[offset + 3]) >>> 0;
}
/**
 * Writes 4-byte big-endian representation of 32-bit unsigned
 * value to byte array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32BE(value, out = new Uint8Array(4), offset = 0) {
    out[offset + 0] = value >>> 24;
    out[offset + 1] = value >>> 16;
    out[offset + 2] = value >>> 8;
    out[offset + 3] = value >>> 0;
    return out;
}
/**
 * Writes 4-byte little-endian representation of 32-bit unsigned
 * value to array starting at offset.
 *
 * If byte array is not given, creates a new 4-byte one.
 *
 * Returns the output byte array.
 */
function writeUint32LE(value, out = new Uint8Array(4), offset = 0) {
    out[offset + 0] = value >>> 0;
    out[offset + 1] = value >>> 8;
    out[offset + 2] = value >>> 16;
    out[offset + 3] = value >>> 24;
    return out;
}
/**
 * Writes 8-byte little-endian representation of 64-bit unsigned
 * value to byte array starting at offset.
 *
 * Due to JavaScript limitation, supports values up to 2^53-1.
 *
 * If byte array is not given, creates a new 8-byte one.
 *
 * Returns the output byte array.
 */
function writeUint64LE(value, out = new Uint8Array(8), offset = 0) {
    writeUint32LE(value >>> 0, out, offset);
    writeUint32LE(value / 0x100000000 >>> 0, out, offset + 4);
    return out;
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 * Sets all values in the given array to zero and returns it.
 *
 * The fact that it sets bytes to zero can be relied on.
 *
 * There is no guarantee that this function makes data disappear from memory,
 * as runtime implementation can, for example, have copying garbage collector
 * that will make copies of sensitive data before we wipe it. Or that an
 * operating system will write our data to swap or sleep image. Another thing
 * is that an optimizing compiler can remove calls to this function or make it
 * no-op. There's nothing we can do with it, so we just do our best and hope
 * that everything will be okay and good will triumph over evil.
 */
function wipe(array) {
    // Right now it's similar to array.fill(0). If it turns
    // out that runtimes optimize this call away, maybe
    // we can try something else.
    for (let i = 0; i < array.length; i++) {
        array[i] = 0;
    }
    return array;
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 * Package chacha implements ChaCha stream cipher.
 */
// Number of ChaCha rounds (ChaCha20).
const ROUNDS = 20;
// Applies the ChaCha core function to 16-byte input,
// 32-byte key key, and puts the result into 64-byte array out.
function core(out, input, key) {
    let j0 = 0x61707865; // "expa"  -- ChaCha's "sigma" constant
    let j1 = 0x3320646E; // "nd 3"     for 32-byte keys
    let j2 = 0x79622D32; // "2-by"
    let j3 = 0x6B206574; // "te k"
    let j4 = (key[3] << 24) | (key[2] << 16) | (key[1] << 8) | key[0];
    let j5 = (key[7] << 24) | (key[6] << 16) | (key[5] << 8) | key[4];
    let j6 = (key[11] << 24) | (key[10] << 16) | (key[9] << 8) | key[8];
    let j7 = (key[15] << 24) | (key[14] << 16) | (key[13] << 8) | key[12];
    let j8 = (key[19] << 24) | (key[18] << 16) | (key[17] << 8) | key[16];
    let j9 = (key[23] << 24) | (key[22] << 16) | (key[21] << 8) | key[20];
    let j10 = (key[27] << 24) | (key[26] << 16) | (key[25] << 8) | key[24];
    let j11 = (key[31] << 24) | (key[30] << 16) | (key[29] << 8) | key[28];
    let j12 = (input[3] << 24) | (input[2] << 16) | (input[1] << 8) | input[0];
    let j13 = (input[7] << 24) | (input[6] << 16) | (input[5] << 8) | input[4];
    let j14 = (input[11] << 24) | (input[10] << 16) | (input[9] << 8) | input[8];
    let j15 = (input[15] << 24) | (input[14] << 16) | (input[13] << 8) | input[12];
    let x0 = j0;
    let x1 = j1;
    let x2 = j2;
    let x3 = j3;
    let x4 = j4;
    let x5 = j5;
    let x6 = j6;
    let x7 = j7;
    let x8 = j8;
    let x9 = j9;
    let x10 = j10;
    let x11 = j11;
    let x12 = j12;
    let x13 = j13;
    let x14 = j14;
    let x15 = j15;
    for (let i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> (32 - 7) | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 16) | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 12) | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 16) | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 12) | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 16) | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 12) | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 16) | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 12) | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> (32 - 8) | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> (32 - 7) | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> (32 - 8) | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> (32 - 7) | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> (32 - 8) | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> (32 - 7) | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> (32 - 8) | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> (32 - 7) | x5 << 7;
    }
    writeUint32LE(x0 + j0 | 0, out, 0);
    writeUint32LE(x1 + j1 | 0, out, 4);
    writeUint32LE(x2 + j2 | 0, out, 8);
    writeUint32LE(x3 + j3 | 0, out, 12);
    writeUint32LE(x4 + j4 | 0, out, 16);
    writeUint32LE(x5 + j5 | 0, out, 20);
    writeUint32LE(x6 + j6 | 0, out, 24);
    writeUint32LE(x7 + j7 | 0, out, 28);
    writeUint32LE(x8 + j8 | 0, out, 32);
    writeUint32LE(x9 + j9 | 0, out, 36);
    writeUint32LE(x10 + j10 | 0, out, 40);
    writeUint32LE(x11 + j11 | 0, out, 44);
    writeUint32LE(x12 + j12 | 0, out, 48);
    writeUint32LE(x13 + j13 | 0, out, 52);
    writeUint32LE(x14 + j14 | 0, out, 56);
    writeUint32LE(x15 + j15 | 0, out, 60);
}
/**
 * Encrypt src with ChaCha20 stream generated for the given 32-byte key and
 * 8-byte (as in original implementation) or 12-byte (as in RFC7539) nonce and
 * write the result into dst and return it.
 *
 * dst and src may be the same, but otherwise must not overlap.
 *
 * If nonce is 12 bytes, users should not encrypt more than 256 GiB with the
 * same key and nonce, otherwise the stream will repeat. The function will
 * throw error if counter overflows to prevent this.
 *
 * If nonce is 8 bytes, the output is practically unlimited (2^70 bytes, which
 * is more than a million petabytes). However, it is not recommended to
 * generate 8-byte nonces randomly, as the chance of collision is high.
 *
 * Never use the same key and nonce to encrypt more than one message.
 *
 * If nonceInplaceCounterLength is not 0, the nonce is assumed to be a 16-byte
 * array with stream counter in first nonceInplaceCounterLength bytes and nonce
 * in the last remaining bytes. The counter will be incremented inplace for
 * each ChaCha block. This is useful if you need to encrypt one stream of data
 * in chunks.
 */
function streamXOR(key, nonce, src, dst, nonceInplaceCounterLength = 0) {
    // We only support 256-bit keys.
    if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
    }
    if (dst.length < src.length) {
        throw new Error("ChaCha: destination is shorter than source");
    }
    let nc;
    let counterLength;
    if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
            throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        // First counterLength bytes of nc are counter, starting with zero.
        counterLength = nc.length - nonce.length;
        // Last bytes of nc after counterLength are nonce, set them.
        nc.set(nonce, counterLength);
    }
    else {
        if (nonce.length !== 16) {
            throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        // This will update passed nonce with counter inplace.
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
    }
    // Allocate temporary space for ChaCha block.
    const block = new Uint8Array(64);
    for (let i = 0; i < src.length; i += 64) {
        // Generate a block.
        core(block, nc, key);
        // XOR block bytes with src into dst.
        for (let j = i; j < i + 64 && j < src.length; j++) {
            dst[j] = src[j] ^ block[j - i];
        }
        // Increment counter.
        incrementCounter(nc, 0, counterLength);
    }
    // Cleanup temporary space.
    wipe(block);
    if (nonceInplaceCounterLength === 0) {
        // Cleanup counter.
        wipe(nc);
    }
    return dst;
}
/**
 * Generate ChaCha20 stream for the given 32-byte key and 8-byte or 12-byte
 * nonce and write it into dst and return it.
 *
 * Never use the same key and nonce to generate more than one stream.
 *
 * If nonceInplaceCounterLength is not 0, it behaves the same with respect to
 * the nonce as described in the streamXOR documentation.
 *
 * stream is like streamXOR with all-zero src.
 */
function stream(key, nonce, dst, nonceInplaceCounterLength = 0) {
    wipe(dst);
    return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
}
function incrementCounter(counter, pos, len) {
    let carry = 1;
    while (len--) {
        carry = carry + (counter[pos] & 0xff) | 0;
        counter[pos] = carry & 0xff;
        carry >>>= 8;
        pos++;
    }
    if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
    }
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 * Package constant-time provides functions for performing algorithmically constant-time operations.
 */
/**
 * NOTE! Due to the inability to guarantee real constant time evaluation of
 * anything in JavaScript VM, this is module is the best effort.
 */
/**
 * Returns resultIfOne if subject is 1, or resultIfZero if subject is 0.
 *
 * Supports only 32-bit integers, so resultIfOne or resultIfZero are not
 * integers, they'll be converted to them with bitwise operations.
 */
/**
 * Returns 1 if a and b are of equal length and their contents
 * are equal, or 0 otherwise.
 *
 * Note that unlike in equal(), zero-length inputs are considered
 * the same, so this function will return 1.
 */
function compare(a, b) {
    if (a.length !== b.length) {
        return 0;
    }
    let result = 0;
    for (let i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
    }
    return (1 & ((result - 1) >>> 8));
}
/**
 * Returns true if a and b are of equal non-zero length,
 * and their contents are equal, or false otherwise.
 *
 * Note that unlike in compare() zero-length inputs are considered
 * _not_ equal, so this function will return false.
 */
function equal(a, b) {
    if (a.length === 0 || b.length === 0) {
        return false;
    }
    return compare(a, b) !== 0;
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 * Package poly1305 implements Poly1305 one-time message authentication algorithm.
 */
const DIGEST_LENGTH$1 = 16;
// Port of Andrew Moon's Poly1305-donna-16. Public domain.
// https://github.com/floodyberry/poly1305-donna
/**
 * Poly1305 computes 16-byte authenticator of message using
 * a one-time 32-byte key.
 *
 * Important: key should be used for only one message,
 * it should never repeat.
 */
class Poly1305 {
    digestLength = DIGEST_LENGTH$1;
    _buffer = new Uint8Array(16);
    _r = new Uint16Array(10);
    _h = new Uint16Array(10);
    _pad = new Uint16Array(8);
    _leftover = 0;
    _fin = 0;
    _finished = false;
    constructor(key) {
        let t0 = key[0] | key[1] << 8;
        this._r[0] = (t0) & 0x1fff;
        let t1 = key[2] | key[3] << 8;
        this._r[1] = ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
        let t2 = key[4] | key[5] << 8;
        this._r[2] = ((t1 >>> 10) | (t2 << 6)) & 0x1f03;
        let t3 = key[6] | key[7] << 8;
        this._r[3] = ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
        let t4 = key[8] | key[9] << 8;
        this._r[4] = ((t3 >>> 4) | (t4 << 12)) & 0x00ff;
        this._r[5] = ((t4 >>> 1)) & 0x1ffe;
        let t5 = key[10] | key[11] << 8;
        this._r[6] = ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
        let t6 = key[12] | key[13] << 8;
        this._r[7] = ((t5 >>> 11) | (t6 << 5)) & 0x1f81;
        let t7 = key[14] | key[15] << 8;
        this._r[8] = ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
        this._r[9] = ((t7 >>> 5)) & 0x007f;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
    }
    _blocks(m, mpos, bytes) {
        let hibit = this._fin ? 0 : 1 << 11;
        let h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        let r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes >= 16) {
            let t0 = m[mpos + 0] | m[mpos + 1] << 8;
            h0 += (t0) & 0x1fff;
            let t1 = m[mpos + 2] | m[mpos + 3] << 8;
            h1 += ((t0 >>> 13) | (t1 << 3)) & 0x1fff;
            let t2 = m[mpos + 4] | m[mpos + 5] << 8;
            h2 += ((t1 >>> 10) | (t2 << 6)) & 0x1fff;
            let t3 = m[mpos + 6] | m[mpos + 7] << 8;
            h3 += ((t2 >>> 7) | (t3 << 9)) & 0x1fff;
            let t4 = m[mpos + 8] | m[mpos + 9] << 8;
            h4 += ((t3 >>> 4) | (t4 << 12)) & 0x1fff;
            h5 += ((t4 >>> 1)) & 0x1fff;
            let t5 = m[mpos + 10] | m[mpos + 11] << 8;
            h6 += ((t4 >>> 14) | (t5 << 2)) & 0x1fff;
            let t6 = m[mpos + 12] | m[mpos + 13] << 8;
            h7 += ((t5 >>> 11) | (t6 << 5)) & 0x1fff;
            let t7 = m[mpos + 14] | m[mpos + 15] << 8;
            h8 += ((t6 >>> 8) | (t7 << 8)) & 0x1fff;
            h9 += ((t7 >>> 5)) | hibit;
            let c = 0;
            let d0 = c;
            d0 += h0 * r0;
            d0 += h1 * (5 * r9);
            d0 += h2 * (5 * r8);
            d0 += h3 * (5 * r7);
            d0 += h4 * (5 * r6);
            c = (d0 >>> 13);
            d0 &= 0x1fff;
            d0 += h5 * (5 * r5);
            d0 += h6 * (5 * r4);
            d0 += h7 * (5 * r3);
            d0 += h8 * (5 * r2);
            d0 += h9 * (5 * r1);
            c += (d0 >>> 13);
            d0 &= 0x1fff;
            let d1 = c;
            d1 += h0 * r1;
            d1 += h1 * r0;
            d1 += h2 * (5 * r9);
            d1 += h3 * (5 * r8);
            d1 += h4 * (5 * r7);
            c = (d1 >>> 13);
            d1 &= 0x1fff;
            d1 += h5 * (5 * r6);
            d1 += h6 * (5 * r5);
            d1 += h7 * (5 * r4);
            d1 += h8 * (5 * r3);
            d1 += h9 * (5 * r2);
            c += (d1 >>> 13);
            d1 &= 0x1fff;
            let d2 = c;
            d2 += h0 * r2;
            d2 += h1 * r1;
            d2 += h2 * r0;
            d2 += h3 * (5 * r9);
            d2 += h4 * (5 * r8);
            c = (d2 >>> 13);
            d2 &= 0x1fff;
            d2 += h5 * (5 * r7);
            d2 += h6 * (5 * r6);
            d2 += h7 * (5 * r5);
            d2 += h8 * (5 * r4);
            d2 += h9 * (5 * r3);
            c += (d2 >>> 13);
            d2 &= 0x1fff;
            let d3 = c;
            d3 += h0 * r3;
            d3 += h1 * r2;
            d3 += h2 * r1;
            d3 += h3 * r0;
            d3 += h4 * (5 * r9);
            c = (d3 >>> 13);
            d3 &= 0x1fff;
            d3 += h5 * (5 * r8);
            d3 += h6 * (5 * r7);
            d3 += h7 * (5 * r6);
            d3 += h8 * (5 * r5);
            d3 += h9 * (5 * r4);
            c += (d3 >>> 13);
            d3 &= 0x1fff;
            let d4 = c;
            d4 += h0 * r4;
            d4 += h1 * r3;
            d4 += h2 * r2;
            d4 += h3 * r1;
            d4 += h4 * r0;
            c = (d4 >>> 13);
            d4 &= 0x1fff;
            d4 += h5 * (5 * r9);
            d4 += h6 * (5 * r8);
            d4 += h7 * (5 * r7);
            d4 += h8 * (5 * r6);
            d4 += h9 * (5 * r5);
            c += (d4 >>> 13);
            d4 &= 0x1fff;
            let d5 = c;
            d5 += h0 * r5;
            d5 += h1 * r4;
            d5 += h2 * r3;
            d5 += h3 * r2;
            d5 += h4 * r1;
            c = (d5 >>> 13);
            d5 &= 0x1fff;
            d5 += h5 * r0;
            d5 += h6 * (5 * r9);
            d5 += h7 * (5 * r8);
            d5 += h8 * (5 * r7);
            d5 += h9 * (5 * r6);
            c += (d5 >>> 13);
            d5 &= 0x1fff;
            let d6 = c;
            d6 += h0 * r6;
            d6 += h1 * r5;
            d6 += h2 * r4;
            d6 += h3 * r3;
            d6 += h4 * r2;
            c = (d6 >>> 13);
            d6 &= 0x1fff;
            d6 += h5 * r1;
            d6 += h6 * r0;
            d6 += h7 * (5 * r9);
            d6 += h8 * (5 * r8);
            d6 += h9 * (5 * r7);
            c += (d6 >>> 13);
            d6 &= 0x1fff;
            let d7 = c;
            d7 += h0 * r7;
            d7 += h1 * r6;
            d7 += h2 * r5;
            d7 += h3 * r4;
            d7 += h4 * r3;
            c = (d7 >>> 13);
            d7 &= 0x1fff;
            d7 += h5 * r2;
            d7 += h6 * r1;
            d7 += h7 * r0;
            d7 += h8 * (5 * r9);
            d7 += h9 * (5 * r8);
            c += (d7 >>> 13);
            d7 &= 0x1fff;
            let d8 = c;
            d8 += h0 * r8;
            d8 += h1 * r7;
            d8 += h2 * r6;
            d8 += h3 * r5;
            d8 += h4 * r4;
            c = (d8 >>> 13);
            d8 &= 0x1fff;
            d8 += h5 * r3;
            d8 += h6 * r2;
            d8 += h7 * r1;
            d8 += h8 * r0;
            d8 += h9 * (5 * r9);
            c += (d8 >>> 13);
            d8 &= 0x1fff;
            let d9 = c;
            d9 += h0 * r9;
            d9 += h1 * r8;
            d9 += h2 * r7;
            d9 += h3 * r6;
            d9 += h4 * r5;
            c = (d9 >>> 13);
            d9 &= 0x1fff;
            d9 += h5 * r4;
            d9 += h6 * r3;
            d9 += h7 * r2;
            d9 += h8 * r1;
            d9 += h9 * r0;
            c += (d9 >>> 13);
            d9 &= 0x1fff;
            c = (((c << 2) + c)) | 0;
            c = (c + d0) | 0;
            d0 = c & 0x1fff;
            c = (c >>> 13);
            d1 += c;
            h0 = d0;
            h1 = d1;
            h2 = d2;
            h3 = d3;
            h4 = d4;
            h5 = d5;
            h6 = d6;
            h7 = d7;
            h8 = d8;
            h9 = d9;
            mpos += 16;
            bytes -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
    }
    finish(mac, macpos = 0) {
        const g = new Uint16Array(10);
        let c;
        let mask;
        let f;
        let i;
        if (this._leftover) {
            i = this._leftover;
            this._buffer[i++] = 1;
            for (; i < 16; i++) {
                this._buffer[i] = 0;
            }
            this._fin = 1;
            this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        for (i = 2; i < 10; i++) {
            this._h[i] += c;
            c = this._h[i] >>> 13;
            this._h[i] &= 0x1fff;
        }
        this._h[0] += (c * 5);
        c = this._h[0] >>> 13;
        this._h[0] &= 0x1fff;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 0x1fff;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 0x1fff;
        for (i = 1; i < 10; i++) {
            g[i] = this._h[i] + c;
            c = g[i] >>> 13;
            g[i] &= 0x1fff;
        }
        g[9] -= (1 << 13);
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
            g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
            this._h[i] = (this._h[i] & mask) | g[i];
        }
        this._h[0] = ((this._h[0]) | (this._h[1] << 13)) & 0xffff;
        this._h[1] = ((this._h[1] >>> 3) | (this._h[2] << 10)) & 0xffff;
        this._h[2] = ((this._h[2] >>> 6) | (this._h[3] << 7)) & 0xffff;
        this._h[3] = ((this._h[3] >>> 9) | (this._h[4] << 4)) & 0xffff;
        this._h[4] = ((this._h[4] >>> 12) | (this._h[5] << 1) | (this._h[6] << 14)) & 0xffff;
        this._h[5] = ((this._h[6] >>> 2) | (this._h[7] << 11)) & 0xffff;
        this._h[6] = ((this._h[7] >>> 5) | (this._h[8] << 8)) & 0xffff;
        this._h[7] = ((this._h[8] >>> 8) | (this._h[9] << 5)) & 0xffff;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 0xffff;
        for (i = 1; i < 8; i++) {
            f = (((this._h[i] + this._pad[i]) | 0) + (f >>> 16)) | 0;
            this._h[i] = f & 0xffff;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
    }
    update(m) {
        let mpos = 0;
        let bytes = m.length;
        let want;
        if (this._leftover) {
            want = (16 - this._leftover);
            if (want > bytes) {
                want = bytes;
            }
            for (let i = 0; i < want; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            bytes -= want;
            mpos += want;
            this._leftover += want;
            if (this._leftover < 16) {
                return this;
            }
            this._blocks(this._buffer, 0, 16);
            this._leftover = 0;
        }
        if (bytes >= 16) {
            want = bytes - (bytes % 16);
            this._blocks(m, mpos, want);
            mpos += want;
            bytes -= want;
        }
        if (bytes) {
            for (let i = 0; i < bytes; i++) {
                this._buffer[this._leftover + i] = m[mpos + i];
            }
            this._leftover += bytes;
        }
        return this;
    }
    digest() {
        // TODO(dchest): it behaves differently than other hashes/HMAC,
        // because it throws when finished — others just return saved result.
        if (this._finished) {
            throw new Error("Poly1305 was finished");
        }
        let mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
    }
    clean() {
        wipe(this._buffer);
        wipe(this._r);
        wipe(this._h);
        wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true; // mark as finished even if not
        return this;
    }
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
const KEY_LENGTH = 32;
const NONCE_LENGTH = 12;
const TAG_LENGTH = 16;
const ZEROS = new Uint8Array(16);
/**
 * ChaCha20-Poly1305 Authenticated Encryption with Associated Data.
 *
 * Defined in RFC7539.
 */
class ChaCha20Poly1305 {
    nonceLength = NONCE_LENGTH;
    tagLength = TAG_LENGTH;
    _key;
    /**
     * Creates a new instance with the given 32-byte key.
     */
    constructor(key) {
        if (key.length !== KEY_LENGTH) {
            throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        // Copy key.
        this._key = new Uint8Array(key);
    }
    /**
     * Encrypts and authenticates plaintext, authenticates associated data,
     * and returns sealed ciphertext, which includes authentication tag.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If dst is given (it must be the size of plaintext + the size of tag
     * length) the result will be put into it. Dst and plaintext must not
     * overlap.
     */
    seal(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        const counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        // We pass full counter, which has 12-byte nonce and 4-byte block counter,
        // and it will get incremented after generating the block, which is
        // exactly what we need: we only use the first 32 bytes of 64-byte
        // ChaCha block and discard the next 32 bytes.
        const authKey = new Uint8Array(32);
        stream(this._key, counter, authKey, 4);
        // Allocate space for sealed ciphertext.
        const resultLength = plaintext.length + this.tagLength;
        let result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Encrypt plaintext.
        streamXOR(this._key, counter, plaintext, result, 4);
        // Authenticate.
        // XXX: can "simplify" here: pass full result (which is already padded
        // due to zeroes prepared for tag), and ciphertext length instead of
        // subarray of result.
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        // Cleanup.
        wipe(counter);
        return result;
    }
    /**
     * Authenticates sealed ciphertext (which includes authentication tag) and
     * associated data, decrypts ciphertext and returns decrypted plaintext.
     *
     * RFC7539 specifies 12 bytes for nonce. It may be this 12-byte nonce
     * ("IV"), or full 16-byte counter (called "32-bit fixed-common part")
     * and nonce.
     *
     * If authentication fails, it returns null.
     *
     * If dst is given (it must be of ciphertext length minus tag length),
     * the result will be put into it. Dst and plaintext must not overlap.
     */
    open(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
            throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        // Sealed ciphertext should at least contain tag.
        if (sealed.length < this.tagLength) {
            // TODO(dchest): should we throw here instead?
            return null;
        }
        // Allocate space for counter, and set nonce as last bytes of it.
        const counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        // Generate authentication key by taking first 32-bytes of stream.
        const authKey = new Uint8Array(32);
        stream(this._key, counter, authKey, 4);
        // Authenticate.
        // XXX: can simplify and avoid allocation: since authenticate()
        // already allocates tag (from Poly1305.digest(), it can return)
        // it instead of copying to calculatedTag. But then in seal()
        // we'll need to copy it.
        const calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        // Constant-time compare tags and return null if they differ.
        if (!equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
            return null;
        }
        // Allocate space for decrypted plaintext.
        const resultLength = sealed.length - this.tagLength;
        let result;
        if (dst) {
            if (dst.length !== resultLength) {
                throw new Error("ChaCha20Poly1305: incorrect destination length");
            }
            result = dst;
        }
        else {
            result = new Uint8Array(resultLength);
        }
        // Decrypt.
        streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        // Cleanup.
        wipe(counter);
        return result;
    }
    clean() {
        wipe(this._key);
        return this;
    }
    _authenticate(tagOut, authKey, ciphertext, associatedData) {
        // Initialize Poly1305 with authKey.
        const h = new Poly1305(authKey);
        // Authenticate padded associated data.
        if (associatedData) {
            h.update(associatedData);
            if (associatedData.length % 16 > 0) {
                h.update(ZEROS.subarray(associatedData.length % 16));
            }
        }
        // Authenticate padded ciphertext.
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
            h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        // Authenticate length of associated data.
        // XXX: can avoid allocation here?
        const length = new Uint8Array(8);
        if (associatedData) {
            writeUint64LE(associatedData.length, length);
        }
        h.update(length);
        // Authenticate length of ciphertext.
        writeUint64LE(ciphertext.length, length);
        h.update(length);
        // Get tag and copy it into tagOut.
        const tag = h.digest();
        for (let i = 0; i < tag.length; i++) {
            tagOut[i] = tag[i];
        }
        // Cleanup.
        h.clean();
        wipe(tag);
        wipe(length);
    }
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
function isSerializableHash(h) {
    return (typeof h.saveState !== "undefined" &&
        typeof h.restoreState !== "undefined" &&
        typeof h.cleanSavedState !== "undefined");
}
// TODO(dchest): figure out the standardized interface for XOF such as
// SHAKE and BLAKE2X.

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 *  HMAC implements hash-based message authentication algorithm.
 */
class HMAC {
    blockSize;
    digestLength;
    _inner; // inner hash
    _outer; // outer hash
    _finished = false; // true if HMAC was finalized
    // Copies of hash states after keying.
    // Need for quick reset without hashing the key again.
    _innerKeyedState;
    _outerKeyedState;
    /**
     * Constructs a new HMAC with the given Hash and secret key.
     */
    constructor(hash, key) {
        // Initialize inner and outer hashes.
        this._inner = new hash();
        this._outer = new hash();
        // Set block and digest sizes for this HMAC
        // instance to values from the hash.
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        // Pad temporary stores a key (or its hash) padded with zeroes.
        const pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
            // If key is bigger than hash block size, it must be
            // hashed and this hash is used as a key instead.
            this._inner.update(key).finish(pad).clean();
        }
        else {
            // Otherwise, copy the key into pad.
            pad.set(key);
        }
        // Now two different keys are derived from padded key
        // by xoring a different byte value to each.
        // To make inner hash key, xor byte 0x36 into pad.
        for (let i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36;
        }
        // Update inner hash with the result.
        this._inner.update(pad);
        // To make outer hash key, xor byte 0x5c into pad.
        // But since we already xored 0x36 there, we must
        // first undo this by xoring it again.
        for (let i = 0; i < pad.length; i++) {
            pad[i] ^= 0x36 ^ 0x5c;
        }
        // Update outer hash with the result.
        this._outer.update(pad);
        // Save states of both hashes, so that we can quickly restore
        // them later in reset() without the need to remember the actual
        // key and perform this initialization again.
        if (isSerializableHash(this._inner) && isSerializableHash(this._outer)) {
            this._innerKeyedState = this._inner.saveState();
            this._outerKeyedState = this._outer.saveState();
        }
        // Clean pad.
        wipe(pad);
    }
    /**
     * Returns HMAC state to the state initialized with key
     * to make it possible to run HMAC over the other data with the same
     * key without creating a new instance.
     */
    reset() {
        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {
            throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        // Restore keyed states of inner and outer hashes.
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    }
    /**
     * Cleans HMAC state.
     */
    clean() {
        if (isSerializableHash(this._inner)) {
            this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (isSerializableHash(this._outer)) {
            this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
    }
    /**
     * Updates state with provided data.
     */
    update(data) {
        this._inner.update(data);
        return this;
    }
    /**
     * Finalizes HMAC and puts the result in out.
     */
    finish(out) {
        if (this._finished) {
            // If HMAC was finalized, outer hash is also finalized,
            // so it produces the same digest it produced when it
            // was finalized.
            this._outer.finish(out);
            return this;
        }
        // Finalize inner hash and store the result temporarily.
        this._inner.finish(out);
        // Update outer hash with digest of inner hash and and finalize it.
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
    }
    /**
     * Returns the computed message authentication code.
     */
    digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    }
    /**
     * Saves HMAC state.
     * This function is needed for PBKDF2 optimization.
     */
    saveState() {
        if (!isSerializableHash(this._inner)) {
            throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
    }
    restoreState(savedState) {
        if (!isSerializableHash(this._inner) || !isSerializableHash(this._outer)) {
            throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
    }
    cleanSavedState(savedState) {
        if (!isSerializableHash(this._inner)) {
            throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
    }
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
/**
 * Derives key from password with PBKDF2 algorithm using
 * the given hash function in HMAC construction.
 */
function deriveKey(hash, password, salt, iterations, length) {
    const prf = new HMAC(hash, password);
    const dlen = prf.digestLength;
    const ctr = new Uint8Array(4);
    const t = new Uint8Array(dlen);
    const u = new Uint8Array(dlen);
    const dk = new Uint8Array(length);
    const saltedState = prf.update(salt).saveState();
    for (let i = 0; i * dlen < length; i++) {
        writeUint32BE(i + 1, ctr);
        prf.restoreState(saltedState).update(ctr).finish(u);
        for (let j = 0; j < dlen; j++) {
            t[j] = u[j];
        }
        for (let j = 2; j <= iterations; j++) {
            prf.reset().update(u).finish(u);
            for (let k = 0; k < dlen; k++) {
                t[k] ^= u[k];
            }
        }
        for (let j = 0; j < dlen && i * dlen + j < length; j++) {
            dk[i * dlen + j] = t[j];
        }
    }
    wipe(t);
    wipe(u);
    wipe(ctr);
    prf.cleanSavedState(saltedState);
    prf.clean();
    return dk;
}

// Copyright (C) 2016 Dmitry Chestnykh
// MIT License. See LICENSE file for details.
const DIGEST_LENGTH = 64;
const BLOCK_SIZE = 128;
/**
 * SHA-2-512 cryptographic hash algorithm.
 */
class SHA512 {
    /** Length of hash output */
    digestLength = DIGEST_LENGTH;
    /** Block size */
    blockSize = BLOCK_SIZE;
    // Note: Int32Array is used instead of Uint32Array for performance reasons.
    _stateHi = new Int32Array(8); // hash state, high bytes
    _stateLo = new Int32Array(8); // hash state, low bytes
    _tempHi = new Int32Array(16); // temporary state, high bytes
    _tempLo = new Int32Array(16); // temporary state, low bytes
    _buffer = new Uint8Array(256); // buffer for data to hash
    _bufferLength = 0; // number of bytes in buffer
    _bytesHashed = 0; // number of total bytes hashed
    _finished = false; // indicates whether the hash was finalized
    constructor() {
        this.reset();
    }
    _initState() {
        this._stateHi[0] = 0x6a09e667;
        this._stateHi[1] = 0xbb67ae85;
        this._stateHi[2] = 0x3c6ef372;
        this._stateHi[3] = 0xa54ff53a;
        this._stateHi[4] = 0x510e527f;
        this._stateHi[5] = 0x9b05688c;
        this._stateHi[6] = 0x1f83d9ab;
        this._stateHi[7] = 0x5be0cd19;
        this._stateLo[0] = 0xf3bcc908;
        this._stateLo[1] = 0x84caa73b;
        this._stateLo[2] = 0xfe94f82b;
        this._stateLo[3] = 0x5f1d36f1;
        this._stateLo[4] = 0xade682d1;
        this._stateLo[5] = 0x2b3e6c1f;
        this._stateLo[6] = 0xfb41bd6b;
        this._stateLo[7] = 0x137e2179;
    }
    /**
     * Resets hash state making it possible
     * to re-use this instance to hash other data.
     */
    reset() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
    }
    /**
     * Cleans internal buffers and resets hash state.
     */
    clean() {
        wipe(this._buffer);
        wipe(this._tempHi);
        wipe(this._tempLo);
        this.reset();
    }
    /**
     * Updates hash state with the given data.
     *
     * Throws error when trying to update already finalized hash:
     * instance must be reset to update it again.
     */
    update(data, dataLength = data.length) {
        if (this._finished) {
            throw new Error("SHA512: can't update because hash was finished.");
        }
        let dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
            while (this._bufferLength < BLOCK_SIZE && dataLength > 0) {
                this._buffer[this._bufferLength++] = data[dataPos++];
                dataLength--;
            }
            if (this._bufferLength === this.blockSize) {
                hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, this.blockSize);
                this._bufferLength = 0;
            }
        }
        if (dataLength >= this.blockSize) {
            dataPos = hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, data, dataPos, dataLength);
            dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
        }
        return this;
    }
    /**
     * Finalizes hash state and puts hash into out.
     * If hash was already finalized, puts the same value.
     */
    finish(out) {
        if (!this._finished) {
            const bytesHashed = this._bytesHashed;
            const left = this._bufferLength;
            const bitLenHi = (bytesHashed / 0x20000000) | 0;
            const bitLenLo = bytesHashed << 3;
            const padLength = (bytesHashed % 128 < 112) ? 128 : 256;
            this._buffer[left] = 0x80;
            for (let i = left + 1; i < padLength - 8; i++) {
                this._buffer[i] = 0;
            }
            writeUint32BE(bitLenHi, this._buffer, padLength - 8);
            writeUint32BE(bitLenLo, this._buffer, padLength - 4);
            hashBlocks(this._tempHi, this._tempLo, this._stateHi, this._stateLo, this._buffer, 0, padLength);
            this._finished = true;
        }
        for (let i = 0; i < this.digestLength / 8; i++) {
            writeUint32BE(this._stateHi[i], out, i * 8);
            writeUint32BE(this._stateLo[i], out, i * 8 + 4);
        }
        return this;
    }
    /**
     * Returns the final hash digest.
     */
    digest() {
        const out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
    }
    /**
     * Function useful for HMAC/PBKDF2 optimization. Returns hash state to be
     * used with restoreState(). Only chain value is saved, not buffers or
     * other state variables.
     */
    saveState() {
        if (this._finished) {
            throw new Error("SHA256: cannot save finished state");
        }
        return {
            stateHi: new Int32Array(this._stateHi),
            stateLo: new Int32Array(this._stateLo),
            buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : undefined,
            bufferLength: this._bufferLength,
            bytesHashed: this._bytesHashed
        };
    }
    /**
     * Function useful for HMAC/PBKDF2 optimization. Restores state saved by
     * saveState() and sets bytesHashed to the given value.
     */
    restoreState(savedState) {
        this._stateHi.set(savedState.stateHi);
        this._stateLo.set(savedState.stateLo);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
            this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
    }
    /**
     * Cleans state returned by saveState().
     */
    cleanSavedState(savedState) {
        wipe(savedState.stateHi);
        wipe(savedState.stateLo);
        if (savedState.buffer) {
            wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
    }
}
// Constants
const K = new Int32Array([
    0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
    0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
    0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
    0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
    0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
    0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
    0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
    0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
    0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
    0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
    0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
    0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
    0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
    0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
    0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
    0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
    0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
    0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
    0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
    0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
    0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
    0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
    0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
    0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
    0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
    0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
    0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
    0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
    0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
    0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
    0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
    0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
    0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
    0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
    0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
    0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
    0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
    0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
    0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
    0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]);
function hashBlocks(wh, wl, hh, hl, m, pos, len) {
    let ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
    let h, l;
    let th, tl;
    let a, b, c, d;
    while (len >= 128) {
        for (let i = 0; i < 16; i++) {
            const j = 8 * i + pos;
            wh[i] = readUint32BE(m, j);
            wl[i] = readUint32BE(m, j + 4);
        }
        for (let i = 0; i < 80; i++) {
            let bh0 = ah0;
            let bh1 = ah1;
            let bh2 = ah2;
            let bh3 = ah3;
            let bh4 = ah4;
            let bh5 = ah5;
            let bh6 = ah6;
            let bh7 = ah7;
            let bl0 = al0;
            let bl1 = al1;
            let bl2 = al2;
            let bl3 = al3;
            let bl4 = al4;
            let bl5 = al5;
            let bl6 = al6;
            let bl7 = al7;
            // add
            h = ah7;
            l = al7;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma1
            h = ((ah4 >>> 14) | (al4 << (32 - 14))) ^ ((ah4 >>> 18) |
                (al4 << (32 - 18))) ^ ((al4 >>> (41 - 32)) | (ah4 << (32 - (41 - 32))));
            l = ((al4 >>> 14) | (ah4 << (32 - 14))) ^ ((al4 >>> 18) |
                (ah4 << (32 - 18))) ^ ((ah4 >>> (41 - 32)) | (al4 << (32 - (41 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Ch
            h = (ah4 & ah5) ^ (~ah4 & ah6);
            l = (al4 & al5) ^ (~al4 & al6);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // K
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // w
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 0xffff | d << 16;
            tl = a & 0xffff | b << 16;
            // add
            h = th;
            l = tl;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            // Sigma0
            h = ((ah0 >>> 28) | (al0 << (32 - 28))) ^ ((al0 >>> (34 - 32)) |
                (ah0 << (32 - (34 - 32)))) ^ ((al0 >>> (39 - 32)) | (ah0 << (32 - (39 - 32))));
            l = ((al0 >>> 28) | (ah0 << (32 - 28))) ^ ((ah0 >>> (34 - 32)) |
                (al0 << (32 - (34 - 32)))) ^ ((ah0 >>> (39 - 32)) | (al0 << (32 - (39 - 32))));
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            // Maj
            h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
            l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = (c & 0xffff) | (d << 16);
            bl7 = (a & 0xffff) | (b << 16);
            // add
            h = bh3;
            l = bl3;
            a = l & 0xffff;
            b = l >>> 16;
            c = h & 0xffff;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 0xffff;
            b += l >>> 16;
            c += h & 0xffff;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = (c & 0xffff) | (d << 16);
            bl3 = (a & 0xffff) | (b << 16);
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
                for (let j = 0; j < 16; j++) {
                    // add
                    h = wh[j];
                    l = wl[j];
                    a = l & 0xffff;
                    b = l >>> 16;
                    c = h & 0xffff;
                    d = h >>> 16;
                    h = wh[(j + 9) % 16];
                    l = wl[(j + 9) % 16];
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma0
                    th = wh[(j + 1) % 16];
                    tl = wl[(j + 1) % 16];
                    h = ((th >>> 1) | (tl << (32 - 1))) ^ ((th >>> 8) |
                        (tl << (32 - 8))) ^ (th >>> 7);
                    l = ((tl >>> 1) | (th << (32 - 1))) ^ ((tl >>> 8) |
                        (th << (32 - 8))) ^ ((tl >>> 7) | (th << (32 - 7)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    // sigma1
                    th = wh[(j + 14) % 16];
                    tl = wl[(j + 14) % 16];
                    h = ((th >>> 19) | (tl << (32 - 19))) ^ ((tl >>> (61 - 32)) |
                        (th << (32 - (61 - 32)))) ^ (th >>> 6);
                    l = ((tl >>> 19) | (th << (32 - 19))) ^ ((th >>> (61 - 32)) |
                        (tl << (32 - (61 - 32)))) ^ ((tl >>> 6) | (th << (32 - 6)));
                    a += l & 0xffff;
                    b += l >>> 16;
                    c += h & 0xffff;
                    d += h >>> 16;
                    b += a >>> 16;
                    c += b >>> 16;
                    d += c >>> 16;
                    wh[j] = (c & 0xffff) | (d << 16);
                    wl[j] = (a & 0xffff) | (b << 16);
                }
            }
        }
        // add
        h = ah0;
        l = al0;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[0];
        l = hl[0];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[0] = ah0 = (c & 0xffff) | (d << 16);
        hl[0] = al0 = (a & 0xffff) | (b << 16);
        h = ah1;
        l = al1;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[1];
        l = hl[1];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[1] = ah1 = (c & 0xffff) | (d << 16);
        hl[1] = al1 = (a & 0xffff) | (b << 16);
        h = ah2;
        l = al2;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[2];
        l = hl[2];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[2] = ah2 = (c & 0xffff) | (d << 16);
        hl[2] = al2 = (a & 0xffff) | (b << 16);
        h = ah3;
        l = al3;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[3];
        l = hl[3];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[3] = ah3 = (c & 0xffff) | (d << 16);
        hl[3] = al3 = (a & 0xffff) | (b << 16);
        h = ah4;
        l = al4;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[4];
        l = hl[4];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[4] = ah4 = (c & 0xffff) | (d << 16);
        hl[4] = al4 = (a & 0xffff) | (b << 16);
        h = ah5;
        l = al5;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[5];
        l = hl[5];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[5] = ah5 = (c & 0xffff) | (d << 16);
        hl[5] = al5 = (a & 0xffff) | (b << 16);
        h = ah6;
        l = al6;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[6];
        l = hl[6];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[6] = ah6 = (c & 0xffff) | (d << 16);
        hl[6] = al6 = (a & 0xffff) | (b << 16);
        h = ah7;
        l = al7;
        a = l & 0xffff;
        b = l >>> 16;
        c = h & 0xffff;
        d = h >>> 16;
        h = hh[7];
        l = hl[7];
        a += l & 0xffff;
        b += l >>> 16;
        c += h & 0xffff;
        d += h >>> 16;
        b += a >>> 16;
        c += b >>> 16;
        d += c >>> 16;
        hh[7] = ah7 = (c & 0xffff) | (d << 16);
        hl[7] = al7 = (a & 0xffff) | (b << 16);
        pos += 128;
        len -= 128;
    }
    return pos;
}

var browser$d = {};

var inherits_browser = {exports: {}};

var hasRequiredInherits_browser;

function requireInherits_browser () {
	if (hasRequiredInherits_browser) return inherits_browser.exports;
	hasRequiredInherits_browser = 1;
	if (typeof Object.create === 'function') {
	  // implementation from standard node.js 'util' module
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      ctor.prototype = Object.create(superCtor.prototype, {
	        constructor: {
	          value: ctor,
	          enumerable: false,
	          writable: true,
	          configurable: true
	        }
	      });
	    }
	  };
	} else {
	  // old school shim for old browsers
	  inherits_browser.exports = function inherits(ctor, superCtor) {
	    if (superCtor) {
	      ctor.super_ = superCtor;
	      var TempCtor = function () {};
	      TempCtor.prototype = superCtor.prototype;
	      ctor.prototype = new TempCtor();
	      ctor.prototype.constructor = ctor;
	    }
	  };
	}
	return inherits_browser.exports;
}

function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var browser$c = { exports: {} };
var process = browser$c.exports = {};
var cachedSetTimeout;
var cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    if (typeof setTimeout === "function") {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    if (typeof clearTimeout === "function") {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
process.nextTick = function(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
};
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = true;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(name) {
  return [];
};
process.binding = function(name) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(dir) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);

var readable = {exports: {}};

var isarray$1;
var hasRequiredIsarray$1;

function requireIsarray$1 () {
	if (hasRequiredIsarray$1) return isarray$1;
	hasRequiredIsarray$1 = 1;
	isarray$1 = Array.isArray || function (arr) {
	  return Object.prototype.toString.call(arr) == '[object Array]';
	};
	return isarray$1;
}

var dist = {};

var hasRequiredDist;

function requireDist () {
	if (hasRequiredDist) return dist;
	hasRequiredDist = 1;
	(function (exports) {

		Object.defineProperties(exports, { __esModule: { value: true }, [Symbol.toStringTag]: { value: 'Module' } });

		var buffer = {};

		var base64Js = {};

		base64Js.byteLength = byteLength;
		base64Js.toByteArray = toByteArray;
		base64Js.fromByteArray = fromByteArray;

		var lookup = [];
		var revLookup = [];
		var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;

		var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
		for (var i = 0, len = code.length; i < len; ++i) {
		  lookup[i] = code[i];
		  revLookup[code.charCodeAt(i)] = i;
		}

		// Support decoding URL-safe base64 strings, as Node.js does.
		// See: https://en.wikipedia.org/wiki/Base64#URL_applications
		revLookup['-'.charCodeAt(0)] = 62;
		revLookup['_'.charCodeAt(0)] = 63;

		function getLens (b64) {
		  var len = b64.length;

		  if (len % 4 > 0) {
		    throw new Error('Invalid string. Length must be a multiple of 4')
		  }

		  // Trim off extra bytes after placeholder bytes are found
		  // See: https://github.com/beatgammit/base64-js/issues/42
		  var validLen = b64.indexOf('=');
		  if (validLen === -1) validLen = len;

		  var placeHoldersLen = validLen === len
		    ? 0
		    : 4 - (validLen % 4);

		  return [validLen, placeHoldersLen]
		}

		// base64 is 4/3 + up to two characters of the original data
		function byteLength (b64) {
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];
		  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
		}

		function _byteLength (b64, validLen, placeHoldersLen) {
		  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
		}

		function toByteArray (b64) {
		  var tmp;
		  var lens = getLens(b64);
		  var validLen = lens[0];
		  var placeHoldersLen = lens[1];

		  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));

		  var curByte = 0;

		  // if there are placeholders, only get up to the last complete 4 chars
		  var len = placeHoldersLen > 0
		    ? validLen - 4
		    : validLen;

		  var i;
		  for (i = 0; i < len; i += 4) {
		    tmp =
		      (revLookup[b64.charCodeAt(i)] << 18) |
		      (revLookup[b64.charCodeAt(i + 1)] << 12) |
		      (revLookup[b64.charCodeAt(i + 2)] << 6) |
		      revLookup[b64.charCodeAt(i + 3)];
		    arr[curByte++] = (tmp >> 16) & 0xFF;
		    arr[curByte++] = (tmp >> 8) & 0xFF;
		    arr[curByte++] = tmp & 0xFF;
		  }

		  if (placeHoldersLen === 2) {
		    tmp =
		      (revLookup[b64.charCodeAt(i)] << 2) |
		      (revLookup[b64.charCodeAt(i + 1)] >> 4);
		    arr[curByte++] = tmp & 0xFF;
		  }

		  if (placeHoldersLen === 1) {
		    tmp =
		      (revLookup[b64.charCodeAt(i)] << 10) |
		      (revLookup[b64.charCodeAt(i + 1)] << 4) |
		      (revLookup[b64.charCodeAt(i + 2)] >> 2);
		    arr[curByte++] = (tmp >> 8) & 0xFF;
		    arr[curByte++] = tmp & 0xFF;
		  }

		  return arr
		}

		function tripletToBase64 (num) {
		  return lookup[num >> 18 & 0x3F] +
		    lookup[num >> 12 & 0x3F] +
		    lookup[num >> 6 & 0x3F] +
		    lookup[num & 0x3F]
		}

		function encodeChunk (uint8, start, end) {
		  var tmp;
		  var output = [];
		  for (var i = start; i < end; i += 3) {
		    tmp =
		      ((uint8[i] << 16) & 0xFF0000) +
		      ((uint8[i + 1] << 8) & 0xFF00) +
		      (uint8[i + 2] & 0xFF);
		    output.push(tripletToBase64(tmp));
		  }
		  return output.join('')
		}

		function fromByteArray (uint8) {
		  var tmp;
		  var len = uint8.length;
		  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
		  var parts = [];
		  var maxChunkLength = 16383; // must be multiple of 3

		  // go through the array every three bytes, we'll deal with trailing stuff later
		  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
		    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)));
		  }

		  // pad the end with zeros, but make sure to not forget the extra bytes
		  if (extraBytes === 1) {
		    tmp = uint8[len - 1];
		    parts.push(
		      lookup[tmp >> 2] +
		      lookup[(tmp << 4) & 0x3F] +
		      '=='
		    );
		  } else if (extraBytes === 2) {
		    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
		    parts.push(
		      lookup[tmp >> 10] +
		      lookup[(tmp >> 4) & 0x3F] +
		      lookup[(tmp << 2) & 0x3F] +
		      '='
		    );
		  }

		  return parts.join('')
		}

		var ieee754 = {};

		/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */

		ieee754.read = function (buffer, offset, isLE, mLen, nBytes) {
		  var e, m;
		  var eLen = (nBytes * 8) - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var nBits = -7;
		  var i = isLE ? (nBytes - 1) : 0;
		  var d = isLE ? -1 : 1;
		  var s = buffer[offset + i];

		  i += d;

		  e = s & ((1 << (-nBits)) - 1);
		  s >>= (-nBits);
		  nBits += eLen;
		  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

		  m = e & ((1 << (-nBits)) - 1);
		  e >>= (-nBits);
		  nBits += mLen;
		  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

		  if (e === 0) {
		    e = 1 - eBias;
		  } else if (e === eMax) {
		    return m ? NaN : ((s ? -1 : 1) * Infinity)
		  } else {
		    m = m + Math.pow(2, mLen);
		    e = e - eBias;
		  }
		  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
		};

		ieee754.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		  var e, m, c;
		  var eLen = (nBytes * 8) - mLen - 1;
		  var eMax = (1 << eLen) - 1;
		  var eBias = eMax >> 1;
		  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0);
		  var i = isLE ? 0 : (nBytes - 1);
		  var d = isLE ? 1 : -1;
		  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

		  value = Math.abs(value);

		  if (isNaN(value) || value === Infinity) {
		    m = isNaN(value) ? 1 : 0;
		    e = eMax;
		  } else {
		    e = Math.floor(Math.log(value) / Math.LN2);
		    if (value * (c = Math.pow(2, -e)) < 1) {
		      e--;
		      c *= 2;
		    }
		    if (e + eBias >= 1) {
		      value += rt / c;
		    } else {
		      value += rt * Math.pow(2, 1 - eBias);
		    }
		    if (value * c >= 2) {
		      e++;
		      c /= 2;
		    }

		    if (e + eBias >= eMax) {
		      m = 0;
		      e = eMax;
		    } else if (e + eBias >= 1) {
		      m = ((value * c) - 1) * Math.pow(2, mLen);
		      e = e + eBias;
		    } else {
		      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
		      e = 0;
		    }
		  }

		  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

		  e = (e << mLen) | m;
		  eLen += mLen;
		  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

		  buffer[offset + i - d] |= s * 128;
		};

		/*!
		 * The buffer module from node.js, for the browser.
		 *
		 * @author   Feross Aboukhadijeh <https://feross.org>
		 * @license  MIT
		 */

		(function (exports) {

			const base64 = base64Js;
			const ieee754$1 = ieee754;
			const customInspectSymbol =
			  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation
			    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
			    : null;

			exports.Buffer = Buffer;
			exports.SlowBuffer = SlowBuffer;
			exports.INSPECT_MAX_BYTES = 50;

			const K_MAX_LENGTH = 0x7fffffff;
			exports.kMaxLength = K_MAX_LENGTH;
			const { Uint8Array: GlobalUint8Array, ArrayBuffer: GlobalArrayBuffer, SharedArrayBuffer: GlobalSharedArrayBuffer } = globalThis;

			/**
			 * If `Buffer.TYPED_ARRAY_SUPPORT`:
			 *   === true    Use Uint8Array implementation (fastest)
			 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
			 *               implementation (most compatible, even IE6)
			 *
			 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
			 * Opera 11.6+, iOS 4.2+.
			 *
			 * We report that the browser does not support typed arrays if the are not subclassable
			 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
			 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
			 * for __proto__ and has a buggy typed array implementation.
			 */
			Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

			if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
			    typeof console.error === 'function') {
			  console.error(
			    'This browser lacks typed array (Uint8Array) support which is required by ' +
			    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
			  );
			}

			function typedArraySupport () {
			  // Can typed array instances can be augmented?
			  try {
			    const arr = new GlobalUint8Array(1);
			    const proto = { foo: function () { return 42 } };
			    Object.setPrototypeOf(proto, GlobalUint8Array.prototype);
			    Object.setPrototypeOf(arr, proto);
			    return arr.foo() === 42
			  } catch (e) {
			    return false
			  }
			}

			Object.defineProperty(Buffer.prototype, 'parent', {
			  enumerable: true,
			  get: function () {
			    if (!Buffer.isBuffer(this)) return undefined
			    return this.buffer
			  }
			});

			Object.defineProperty(Buffer.prototype, 'offset', {
			  enumerable: true,
			  get: function () {
			    if (!Buffer.isBuffer(this)) return undefined
			    return this.byteOffset
			  }
			});

			function createBuffer (length) {
			  if (length > K_MAX_LENGTH) {
			    throw new RangeError('The value "' + length + '" is invalid for option "size"')
			  }
			  // Return an augmented `Uint8Array` instance
			  const buf = new GlobalUint8Array(length);
			  Object.setPrototypeOf(buf, Buffer.prototype);
			  return buf
			}

			/**
			 * The Buffer constructor returns instances of `Uint8Array` that have their
			 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
			 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
			 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
			 * returns a single octet.
			 *
			 * The `Uint8Array` prototype remains unmodified.
			 */

			function Buffer (arg, encodingOrOffset, length) {
			  // Common case.
			  if (typeof arg === 'number') {
			    if (typeof encodingOrOffset === 'string') {
			      throw new TypeError(
			        'The "string" argument must be of type string. Received type number'
			      )
			    }
			    return allocUnsafe(arg)
			  }
			  return from(arg, encodingOrOffset, length)
			}

			Buffer.poolSize = 8192; // not used by this implementation

			function from (value, encodingOrOffset, length) {
			  if (typeof value === 'string') {
			    return fromString(value, encodingOrOffset)
			  }

			  if (GlobalArrayBuffer.isView(value)) {
			    return fromArrayView(value)
			  }

			  if (value == null) {
			    throw new TypeError(
			      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
			      'or Array-like Object. Received type ' + (typeof value)
			    )
			  }

			  if (isInstance(value, GlobalArrayBuffer) ||
			      (value && isInstance(value.buffer, GlobalArrayBuffer))) {
			    return fromArrayBuffer(value, encodingOrOffset, length)
			  }

			  if (typeof GlobalSharedArrayBuffer !== 'undefined' &&
			      (isInstance(value, GlobalSharedArrayBuffer) ||
			      (value && isInstance(value.buffer, GlobalSharedArrayBuffer)))) {
			    return fromArrayBuffer(value, encodingOrOffset, length)
			  }

			  if (typeof value === 'number') {
			    throw new TypeError(
			      'The "value" argument must not be of type number. Received type number'
			    )
			  }

			  const valueOf = value.valueOf && value.valueOf();
			  if (valueOf != null && valueOf !== value) {
			    return Buffer.from(valueOf, encodingOrOffset, length)
			  }

			  const b = fromObject(value);
			  if (b) return b

			  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
			      typeof value[Symbol.toPrimitive] === 'function') {
			    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)
			  }

			  throw new TypeError(
			    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
			    'or Array-like Object. Received type ' + (typeof value)
			  )
			}

			/**
			 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
			 * if value is a number.
			 * Buffer.from(str[, encoding])
			 * Buffer.from(array)
			 * Buffer.from(buffer)
			 * Buffer.from(arrayBuffer[, byteOffset[, length]])
			 **/
			Buffer.from = function (value, encodingOrOffset, length) {
			  return from(value, encodingOrOffset, length)
			};

			// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
			// https://github.com/feross/buffer/pull/148
			Object.setPrototypeOf(Buffer.prototype, GlobalUint8Array.prototype);
			Object.setPrototypeOf(Buffer, GlobalUint8Array);

			function assertSize (size) {
			  if (typeof size !== 'number') {
			    throw new TypeError('"size" argument must be of type number')
			  } else if (size < 0) {
			    throw new RangeError('The value "' + size + '" is invalid for option "size"')
			  }
			}

			function alloc (size, fill, encoding) {
			  assertSize(size);
			  if (size <= 0) {
			    return createBuffer(size)
			  }
			  if (fill !== undefined) {
			    // Only pay attention to encoding if it's a string. This
			    // prevents accidentally sending in a number that would
			    // be interpreted as a start offset.
			    return typeof encoding === 'string'
			      ? createBuffer(size).fill(fill, encoding)
			      : createBuffer(size).fill(fill)
			  }
			  return createBuffer(size)
			}

			/**
			 * Creates a new filled Buffer instance.
			 * alloc(size[, fill[, encoding]])
			 **/
			Buffer.alloc = function (size, fill, encoding) {
			  return alloc(size, fill, encoding)
			};

			function allocUnsafe (size) {
			  assertSize(size);
			  return createBuffer(size < 0 ? 0 : checked(size) | 0)
			}

			/**
			 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
			 * */
			Buffer.allocUnsafe = function (size) {
			  return allocUnsafe(size)
			};
			/**
			 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
			 */
			Buffer.allocUnsafeSlow = function (size) {
			  return allocUnsafe(size)
			};

			function fromString (string, encoding) {
			  if (typeof encoding !== 'string' || encoding === '') {
			    encoding = 'utf8';
			  }

			  if (!Buffer.isEncoding(encoding)) {
			    throw new TypeError('Unknown encoding: ' + encoding)
			  }

			  const length = byteLength(string, encoding) | 0;
			  let buf = createBuffer(length);

			  const actual = buf.write(string, encoding);

			  if (actual !== length) {
			    // Writing a hex string, for example, that contains invalid characters will
			    // cause everything after the first invalid character to be ignored. (e.g.
			    // 'abxxcd' will be treated as 'ab')
			    buf = buf.slice(0, actual);
			  }

			  return buf
			}

			function fromArrayLike (array) {
			  const length = array.length < 0 ? 0 : checked(array.length) | 0;
			  const buf = createBuffer(length);
			  for (let i = 0; i < length; i += 1) {
			    buf[i] = array[i] & 255;
			  }
			  return buf
			}

			function fromArrayView (arrayView) {
			  if (isInstance(arrayView, GlobalUint8Array)) {
			    const copy = new GlobalUint8Array(arrayView);
			    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)
			  }
			  return fromArrayLike(arrayView)
			}

			function fromArrayBuffer (array, byteOffset, length) {
			  if (byteOffset < 0 || array.byteLength < byteOffset) {
			    throw new RangeError('"offset" is outside of buffer bounds')
			  }

			  if (array.byteLength < byteOffset + (length || 0)) {
			    throw new RangeError('"length" is outside of buffer bounds')
			  }

			  let buf;
			  if (byteOffset === undefined && length === undefined) {
			    buf = new GlobalUint8Array(array);
			  } else if (length === undefined) {
			    buf = new GlobalUint8Array(array, byteOffset);
			  } else {
			    buf = new GlobalUint8Array(array, byteOffset, length);
			  }

			  // Return an augmented `Uint8Array` instance
			  Object.setPrototypeOf(buf, Buffer.prototype);

			  return buf
			}

			function fromObject (obj) {
			  if (Buffer.isBuffer(obj)) {
			    const len = checked(obj.length) | 0;
			    const buf = createBuffer(len);

			    if (buf.length === 0) {
			      return buf
			    }

			    obj.copy(buf, 0, 0, len);
			    return buf
			  }

			  if (obj.length !== undefined) {
			    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
			      return createBuffer(0)
			    }
			    return fromArrayLike(obj)
			  }

			  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
			    return fromArrayLike(obj.data)
			  }
			}

			function checked (length) {
			  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
			  // length is NaN (which is otherwise coerced to zero.)
			  if (length >= K_MAX_LENGTH) {
			    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
			                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
			  }
			  return length | 0
			}

			function SlowBuffer (length) {
			  if (+length != length) { // eslint-disable-line eqeqeq
			    length = 0;
			  }
			  return Buffer.alloc(+length)
			}

			Buffer.isBuffer = function isBuffer (b) {
			  return b != null && b._isBuffer === true &&
			    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
			};

			Buffer.compare = function compare (a, b) {
			  if (isInstance(a, GlobalUint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
			  if (isInstance(b, GlobalUint8Array)) b = Buffer.from(b, b.offset, b.byteLength);
			  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
			    throw new TypeError(
			      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
			    )
			  }

			  if (a === b) return 0

			  let x = a.length;
			  let y = b.length;

			  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
			    if (a[i] !== b[i]) {
			      x = a[i];
			      y = b[i];
			      break
			    }
			  }

			  if (x < y) return -1
			  if (y < x) return 1
			  return 0
			};

			Buffer.isEncoding = function isEncoding (encoding) {
			  switch (String(encoding).toLowerCase()) {
			    case 'hex':
			    case 'utf8':
			    case 'utf-8':
			    case 'ascii':
			    case 'latin1':
			    case 'binary':
			    case 'base64':
			    case 'ucs2':
			    case 'ucs-2':
			    case 'utf16le':
			    case 'utf-16le':
			      return true
			    default:
			      return false
			  }
			};

			Buffer.concat = function concat (list, length) {
			  if (!Array.isArray(list)) {
			    throw new TypeError('"list" argument must be an Array of Buffers')
			  }

			  if (list.length === 0) {
			    return Buffer.alloc(0)
			  }

			  let i;
			  if (length === undefined) {
			    length = 0;
			    for (i = 0; i < list.length; ++i) {
			      length += list[i].length;
			    }
			  }

			  const buffer = Buffer.allocUnsafe(length);
			  let pos = 0;
			  for (i = 0; i < list.length; ++i) {
			    let buf = list[i];
			    if (isInstance(buf, GlobalUint8Array)) {
			      if (pos + buf.length > buffer.length) {
			        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
			        buf.copy(buffer, pos);
			      } else {
			        GlobalUint8Array.prototype.set.call(
			          buffer,
			          buf,
			          pos
			        );
			      }
			    } else if (!Buffer.isBuffer(buf)) {
			      throw new TypeError('"list" argument must be an Array of Buffers')
			    } else {
			      buf.copy(buffer, pos);
			    }
			    pos += buf.length;
			  }
			  return buffer
			};

			function byteLength (string, encoding) {
			  if (Buffer.isBuffer(string)) {
			    return string.length
			  }
			  if (GlobalArrayBuffer.isView(string) || isInstance(string, GlobalArrayBuffer)) {
			    return string.byteLength
			  }
			  if (typeof string !== 'string') {
			    throw new TypeError(
			      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
			      'Received type ' + typeof string
			    )
			  }

			  const len = string.length;
			  const mustMatch = (arguments.length > 2 && arguments[2] === true);
			  if (!mustMatch && len === 0) return 0

			  // Use a for loop to avoid recursion
			  let loweredCase = false;
			  for (;;) {
			    switch (encoding) {
			      case 'ascii':
			      case 'latin1':
			      case 'binary':
			        return len
			      case 'utf8':
			      case 'utf-8':
			        return utf8ToBytes(string).length
			      case 'ucs2':
			      case 'ucs-2':
			      case 'utf16le':
			      case 'utf-16le':
			        return len * 2
			      case 'hex':
			        return len >>> 1
			      case 'base64':
			        return base64ToBytes(string).length
			      default:
			        if (loweredCase) {
			          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
			        }
			        encoding = ('' + encoding).toLowerCase();
			        loweredCase = true;
			    }
			  }
			}
			Buffer.byteLength = byteLength;

			function slowToString (encoding, start, end) {
			  let loweredCase = false;

			  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
			  // property of a typed array.

			  // This behaves neither like String nor Uint8Array in that we set start/end
			  // to their upper/lower bounds if the value passed is out of range.
			  // undefined is handled specially as per ECMA-262 6th Edition,
			  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
			  if (start === undefined || start < 0) {
			    start = 0;
			  }
			  // Return early if start > this.length. Done here to prevent potential uint32
			  // coercion fail below.
			  if (start > this.length) {
			    return ''
			  }

			  if (end === undefined || end > this.length) {
			    end = this.length;
			  }

			  if (end <= 0) {
			    return ''
			  }

			  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.
			  end >>>= 0;
			  start >>>= 0;

			  if (end <= start) {
			    return ''
			  }

			  if (!encoding) encoding = 'utf8';

			  while (true) {
			    switch (encoding) {
			      case 'hex':
			        return hexSlice(this, start, end)

			      case 'utf8':
			      case 'utf-8':
			        return utf8Slice(this, start, end)

			      case 'ascii':
			        return asciiSlice(this, start, end)

			      case 'latin1':
			      case 'binary':
			        return latin1Slice(this, start, end)

			      case 'base64':
			        return base64Slice(this, start, end)

			      case 'ucs2':
			      case 'ucs-2':
			      case 'utf16le':
			      case 'utf-16le':
			        return utf16leSlice(this, start, end)

			      default:
			        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
			        encoding = (encoding + '').toLowerCase();
			        loweredCase = true;
			    }
			  }
			}

			// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
			// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
			// reliably in a browserify context because there could be multiple different
			// copies of the 'buffer' package in use. This method works even for Buffer
			// instances that were created from another copy of the `buffer` package.
			// See: https://github.com/feross/buffer/issues/154
			Buffer.prototype._isBuffer = true;

			function swap (b, n, m) {
			  const i = b[n];
			  b[n] = b[m];
			  b[m] = i;
			}

			Buffer.prototype.swap16 = function swap16 () {
			  const len = this.length;
			  if (len % 2 !== 0) {
			    throw new RangeError('Buffer size must be a multiple of 16-bits')
			  }
			  for (let i = 0; i < len; i += 2) {
			    swap(this, i, i + 1);
			  }
			  return this
			};

			Buffer.prototype.swap32 = function swap32 () {
			  const len = this.length;
			  if (len % 4 !== 0) {
			    throw new RangeError('Buffer size must be a multiple of 32-bits')
			  }
			  for (let i = 0; i < len; i += 4) {
			    swap(this, i, i + 3);
			    swap(this, i + 1, i + 2);
			  }
			  return this
			};

			Buffer.prototype.swap64 = function swap64 () {
			  const len = this.length;
			  if (len % 8 !== 0) {
			    throw new RangeError('Buffer size must be a multiple of 64-bits')
			  }
			  for (let i = 0; i < len; i += 8) {
			    swap(this, i, i + 7);
			    swap(this, i + 1, i + 6);
			    swap(this, i + 2, i + 5);
			    swap(this, i + 3, i + 4);
			  }
			  return this
			};

			Buffer.prototype.toString = function toString () {
			  const length = this.length;
			  if (length === 0) return ''
			  if (arguments.length === 0) return utf8Slice(this, 0, length)
			  return slowToString.apply(this, arguments)
			};

			Buffer.prototype.toLocaleString = Buffer.prototype.toString;

			Buffer.prototype.equals = function equals (b) {
			  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
			  if (this === b) return true
			  return Buffer.compare(this, b) === 0
			};

			Buffer.prototype.inspect = function inspect () {
			  let str = '';
			  const max = exports.INSPECT_MAX_BYTES;
			  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
			  if (this.length > max) str += ' ... ';
			  return '<Buffer ' + str + '>'
			};
			if (customInspectSymbol) {
			  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
			}

			Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
			  if (isInstance(target, GlobalUint8Array)) {
			    target = Buffer.from(target, target.offset, target.byteLength);
			  }
			  if (!Buffer.isBuffer(target)) {
			    throw new TypeError(
			      'The "target" argument must be one of type Buffer or Uint8Array. ' +
			      'Received type ' + (typeof target)
			    )
			  }

			  if (start === undefined) {
			    start = 0;
			  }
			  if (end === undefined) {
			    end = target ? target.length : 0;
			  }
			  if (thisStart === undefined) {
			    thisStart = 0;
			  }
			  if (thisEnd === undefined) {
			    thisEnd = this.length;
			  }

			  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
			    throw new RangeError('out of range index')
			  }

			  if (thisStart >= thisEnd && start >= end) {
			    return 0
			  }
			  if (thisStart >= thisEnd) {
			    return -1
			  }
			  if (start >= end) {
			    return 1
			  }

			  start >>>= 0;
			  end >>>= 0;
			  thisStart >>>= 0;
			  thisEnd >>>= 0;

			  if (this === target) return 0

			  let x = thisEnd - thisStart;
			  let y = end - start;
			  const len = Math.min(x, y);

			  const thisCopy = this.slice(thisStart, thisEnd);
			  const targetCopy = target.slice(start, end);

			  for (let i = 0; i < len; ++i) {
			    if (thisCopy[i] !== targetCopy[i]) {
			      x = thisCopy[i];
			      y = targetCopy[i];
			      break
			    }
			  }

			  if (x < y) return -1
			  if (y < x) return 1
			  return 0
			};

			// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
			// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
			//
			// Arguments:
			// - buffer - a Buffer to search
			// - val - a string, Buffer, or number
			// - byteOffset - an index into `buffer`; will be clamped to an int32
			// - encoding - an optional encoding, relevant is val is a string
			// - dir - true for indexOf, false for lastIndexOf
			function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
			  // Empty buffer means no match
			  if (buffer.length === 0) return -1

			  // Normalize byteOffset
			  if (typeof byteOffset === 'string') {
			    encoding = byteOffset;
			    byteOffset = 0;
			  } else if (byteOffset > 0x7fffffff) {
			    byteOffset = 0x7fffffff;
			  } else if (byteOffset < -2147483648) {
			    byteOffset = -2147483648;
			  }
			  byteOffset = +byteOffset; // Coerce to Number.
			  if (numberIsNaN(byteOffset)) {
			    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
			    byteOffset = dir ? 0 : (buffer.length - 1);
			  }

			  // Normalize byteOffset: negative offsets start from the end of the buffer
			  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
			  if (byteOffset >= buffer.length) {
			    if (dir) return -1
			    else byteOffset = buffer.length - 1;
			  } else if (byteOffset < 0) {
			    if (dir) byteOffset = 0;
			    else return -1
			  }

			  // Normalize val
			  if (typeof val === 'string') {
			    val = Buffer.from(val, encoding);
			  }

			  // Finally, search either indexOf (if dir is true) or lastIndexOf
			  if (Buffer.isBuffer(val)) {
			    // Special case: looking for empty string/buffer always fails
			    if (val.length === 0) {
			      return -1
			    }
			    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
			  } else if (typeof val === 'number') {
			    val = val & 0xFF; // Search for a byte value [0-255]
			    if (typeof GlobalUint8Array.prototype.indexOf === 'function') {
			      if (dir) {
			        return GlobalUint8Array.prototype.indexOf.call(buffer, val, byteOffset)
			      } else {
			        return GlobalUint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
			      }
			    }
			    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
			  }

			  throw new TypeError('val must be string, number or Buffer')
			}

			function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
			  let indexSize = 1;
			  let arrLength = arr.length;
			  let valLength = val.length;

			  if (encoding !== undefined) {
			    encoding = String(encoding).toLowerCase();
			    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
			        encoding === 'utf16le' || encoding === 'utf-16le') {
			      if (arr.length < 2 || val.length < 2) {
			        return -1
			      }
			      indexSize = 2;
			      arrLength /= 2;
			      valLength /= 2;
			      byteOffset /= 2;
			    }
			  }

			  function read (buf, i) {
			    if (indexSize === 1) {
			      return buf[i]
			    } else {
			      return buf.readUInt16BE(i * indexSize)
			    }
			  }

			  let i;
			  if (dir) {
			    let foundIndex = -1;
			    for (i = byteOffset; i < arrLength; i++) {
			      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
			        if (foundIndex === -1) foundIndex = i;
			        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
			      } else {
			        if (foundIndex !== -1) i -= i - foundIndex;
			        foundIndex = -1;
			      }
			    }
			  } else {
			    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
			    for (i = byteOffset; i >= 0; i--) {
			      let found = true;
			      for (let j = 0; j < valLength; j++) {
			        if (read(arr, i + j) !== read(val, j)) {
			          found = false;
			          break
			        }
			      }
			      if (found) return i
			    }
			  }

			  return -1
			}

			Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
			  return this.indexOf(val, byteOffset, encoding) !== -1
			};

			Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
			  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
			};

			Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
			  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
			};

			function hexWrite (buf, string, offset, length) {
			  offset = Number(offset) || 0;
			  const remaining = buf.length - offset;
			  if (!length) {
			    length = remaining;
			  } else {
			    length = Number(length);
			    if (length > remaining) {
			      length = remaining;
			    }
			  }

			  const strLen = string.length;

			  if (length > strLen / 2) {
			    length = strLen / 2;
			  }
			  let i;
			  for (i = 0; i < length; ++i) {
			    const parsed = parseInt(string.substr(i * 2, 2), 16);
			    if (numberIsNaN(parsed)) return i
			    buf[offset + i] = parsed;
			  }
			  return i
			}

			function utf8Write (buf, string, offset, length) {
			  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
			}

			function asciiWrite (buf, string, offset, length) {
			  return blitBuffer(asciiToBytes(string), buf, offset, length)
			}

			function base64Write (buf, string, offset, length) {
			  return blitBuffer(base64ToBytes(string), buf, offset, length)
			}

			function ucs2Write (buf, string, offset, length) {
			  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
			}

			Buffer.prototype.write = function write (string, offset, length, encoding) {
			  // Buffer#write(string)
			  if (offset === undefined) {
			    encoding = 'utf8';
			    length = this.length;
			    offset = 0;
			  // Buffer#write(string, encoding)
			  } else if (length === undefined && typeof offset === 'string') {
			    encoding = offset;
			    length = this.length;
			    offset = 0;
			  // Buffer#write(string, offset[, length][, encoding])
			  } else if (isFinite(offset)) {
			    offset = offset >>> 0;
			    if (isFinite(length)) {
			      length = length >>> 0;
			      if (encoding === undefined) encoding = 'utf8';
			    } else {
			      encoding = length;
			      length = undefined;
			    }
			  } else {
			    throw new Error(
			      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
			    )
			  }

			  const remaining = this.length - offset;
			  if (length === undefined || length > remaining) length = remaining;

			  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
			    throw new RangeError('Attempt to write outside buffer bounds')
			  }

			  if (!encoding) encoding = 'utf8';

			  let loweredCase = false;
			  for (;;) {
			    switch (encoding) {
			      case 'hex':
			        return hexWrite(this, string, offset, length)

			      case 'utf8':
			      case 'utf-8':
			        return utf8Write(this, string, offset, length)

			      case 'ascii':
			      case 'latin1':
			      case 'binary':
			        return asciiWrite(this, string, offset, length)

			      case 'base64':
			        // Warning: maxLength not taken into account in base64Write
			        return base64Write(this, string, offset, length)

			      case 'ucs2':
			      case 'ucs-2':
			      case 'utf16le':
			      case 'utf-16le':
			        return ucs2Write(this, string, offset, length)

			      default:
			        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
			        encoding = ('' + encoding).toLowerCase();
			        loweredCase = true;
			    }
			  }
			};

			Buffer.prototype.toJSON = function toJSON () {
			  return {
			    type: 'Buffer',
			    data: Array.prototype.slice.call(this._arr || this, 0)
			  }
			};

			function base64Slice (buf, start, end) {
			  if (start === 0 && end === buf.length) {
			    return base64.fromByteArray(buf)
			  } else {
			    return base64.fromByteArray(buf.slice(start, end))
			  }
			}

			function utf8Slice (buf, start, end) {
			  end = Math.min(buf.length, end);
			  const res = [];

			  let i = start;
			  while (i < end) {
			    const firstByte = buf[i];
			    let codePoint = null;
			    let bytesPerSequence = (firstByte > 0xEF)
			      ? 4
			      : (firstByte > 0xDF)
			          ? 3
			          : (firstByte > 0xBF)
			              ? 2
			              : 1;

			    if (i + bytesPerSequence <= end) {
			      let secondByte, thirdByte, fourthByte, tempCodePoint;

			      switch (bytesPerSequence) {
			        case 1:
			          if (firstByte < 0x80) {
			            codePoint = firstByte;
			          }
			          break
			        case 2:
			          secondByte = buf[i + 1];
			          if ((secondByte & 0xC0) === 0x80) {
			            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F);
			            if (tempCodePoint > 0x7F) {
			              codePoint = tempCodePoint;
			            }
			          }
			          break
			        case 3:
			          secondByte = buf[i + 1];
			          thirdByte = buf[i + 2];
			          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
			            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F);
			            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
			              codePoint = tempCodePoint;
			            }
			          }
			          break
			        case 4:
			          secondByte = buf[i + 1];
			          thirdByte = buf[i + 2];
			          fourthByte = buf[i + 3];
			          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
			            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F);
			            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
			              codePoint = tempCodePoint;
			            }
			          }
			      }
			    }

			    if (codePoint === null) {
			      // we did not generate a valid codePoint so insert a
			      // replacement char (U+FFFD) and advance only 1 byte
			      codePoint = 0xFFFD;
			      bytesPerSequence = 1;
			    } else if (codePoint > 0xFFFF) {
			      // encode to utf16 (surrogate pair dance)
			      codePoint -= 0x10000;
			      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
			      codePoint = 0xDC00 | codePoint & 0x3FF;
			    }

			    res.push(codePoint);
			    i += bytesPerSequence;
			  }

			  return decodeCodePointsArray(res)
			}

			// Based on http://stackoverflow.com/a/22747272/680742, the browser with
			// the lowest limit is Chrome, with 0x10000 args.
			// We go 1 magnitude less, for safety
			const MAX_ARGUMENTS_LENGTH = 0x1000;

			function decodeCodePointsArray (codePoints) {
			  const len = codePoints.length;
			  if (len <= MAX_ARGUMENTS_LENGTH) {
			    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
			  }

			  // Decode in chunks to avoid "call stack size exceeded".
			  let res = '';
			  let i = 0;
			  while (i < len) {
			    res += String.fromCharCode.apply(
			      String,
			      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
			    );
			  }
			  return res
			}

			function asciiSlice (buf, start, end) {
			  let ret = '';
			  end = Math.min(buf.length, end);

			  for (let i = start; i < end; ++i) {
			    ret += String.fromCharCode(buf[i] & 0x7F);
			  }
			  return ret
			}

			function latin1Slice (buf, start, end) {
			  let ret = '';
			  end = Math.min(buf.length, end);

			  for (let i = start; i < end; ++i) {
			    ret += String.fromCharCode(buf[i]);
			  }
			  return ret
			}

			function hexSlice (buf, start, end) {
			  const len = buf.length;

			  if (!start || start < 0) start = 0;
			  if (!end || end < 0 || end > len) end = len;

			  let out = '';
			  for (let i = start; i < end; ++i) {
			    out += hexSliceLookupTable[buf[i]];
			  }
			  return out
			}

			function utf16leSlice (buf, start, end) {
			  const bytes = buf.slice(start, end);
			  let res = '';
			  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)
			  for (let i = 0; i < bytes.length - 1; i += 2) {
			    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256));
			  }
			  return res
			}

			Buffer.prototype.slice = function slice (start, end) {
			  const len = this.length;
			  start = ~~start;
			  end = end === undefined ? len : ~~end;

			  if (start < 0) {
			    start += len;
			    if (start < 0) start = 0;
			  } else if (start > len) {
			    start = len;
			  }

			  if (end < 0) {
			    end += len;
			    if (end < 0) end = 0;
			  } else if (end > len) {
			    end = len;
			  }

			  if (end < start) end = start;

			  const newBuf = this.subarray(start, end);
			  // Return an augmented `Uint8Array` instance
			  Object.setPrototypeOf(newBuf, Buffer.prototype);

			  return newBuf
			};

			/*
			 * Need to make sure that buffer isn't trying to write out of bounds.
			 */
			function checkOffset (offset, ext, length) {
			  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
			  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
			}

			Buffer.prototype.readUintLE =
			Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) checkOffset(offset, byteLength, this.length);

			  let val = this[offset];
			  let mul = 1;
			  let i = 0;
			  while (++i < byteLength && (mul *= 0x100)) {
			    val += this[offset + i] * mul;
			  }

			  return val
			};

			Buffer.prototype.readUintBE =
			Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) {
			    checkOffset(offset, byteLength, this.length);
			  }

			  let val = this[offset + --byteLength];
			  let mul = 1;
			  while (byteLength > 0 && (mul *= 0x100)) {
			    val += this[offset + --byteLength] * mul;
			  }

			  return val
			};

			Buffer.prototype.readUint8 =
			Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 1, this.length);
			  return this[offset]
			};

			Buffer.prototype.readUint16LE =
			Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  return this[offset] | (this[offset + 1] << 8)
			};

			Buffer.prototype.readUint16BE =
			Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  return (this[offset] << 8) | this[offset + 1]
			};

			Buffer.prototype.readUint32LE =
			Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);

			  return ((this[offset]) |
			      (this[offset + 1] << 8) |
			      (this[offset + 2] << 16)) +
			      (this[offset + 3] * 0x1000000)
			};

			Buffer.prototype.readUint32BE =
			Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);

			  return (this[offset] * 0x1000000) +
			    ((this[offset + 1] << 16) |
			    (this[offset + 2] << 8) |
			    this[offset + 3])
			};

			Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }

			  const lo = first +
			    this[++offset] * 2 ** 8 +
			    this[++offset] * 2 ** 16 +
			    this[++offset] * 2 ** 24;

			  const hi = this[++offset] +
			    this[++offset] * 2 ** 8 +
			    this[++offset] * 2 ** 16 +
			    last * 2 ** 24;

			  return BigInt(lo) + (BigInt(hi) << BigInt(32))
			});

			Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }

			  const hi = first * 2 ** 24 +
			    this[++offset] * 2 ** 16 +
			    this[++offset] * 2 ** 8 +
			    this[++offset];

			  const lo = this[++offset] * 2 ** 24 +
			    this[++offset] * 2 ** 16 +
			    this[++offset] * 2 ** 8 +
			    last;

			  return (BigInt(hi) << BigInt(32)) + BigInt(lo)
			});

			Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) checkOffset(offset, byteLength, this.length);

			  let val = this[offset];
			  let mul = 1;
			  let i = 0;
			  while (++i < byteLength && (mul *= 0x100)) {
			    val += this[offset + i] * mul;
			  }
			  mul *= 0x80;

			  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

			  return val
			};

			Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) checkOffset(offset, byteLength, this.length);

			  let i = byteLength;
			  let mul = 1;
			  let val = this[offset + --i];
			  while (i > 0 && (mul *= 0x100)) {
			    val += this[offset + --i] * mul;
			  }
			  mul *= 0x80;

			  if (val >= mul) val -= Math.pow(2, 8 * byteLength);

			  return val
			};

			Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 1, this.length);
			  if (!(this[offset] & 0x80)) return (this[offset])
			  return ((0xff - this[offset] + 1) * -1)
			};

			Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  const val = this[offset] | (this[offset + 1] << 8);
			  return (val & 0x8000) ? val | 0xFFFF0000 : val
			};

			Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 2, this.length);
			  const val = this[offset + 1] | (this[offset] << 8);
			  return (val & 0x8000) ? val | 0xFFFF0000 : val
			};

			Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);

			  return (this[offset]) |
			    (this[offset + 1] << 8) |
			    (this[offset + 2] << 16) |
			    (this[offset + 3] << 24)
			};

			Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);

			  return (this[offset] << 24) |
			    (this[offset + 1] << 16) |
			    (this[offset + 2] << 8) |
			    (this[offset + 3])
			};

			Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }

			  const val = this[offset + 4] +
			    this[offset + 5] * 2 ** 8 +
			    this[offset + 6] * 2 ** 16 +
			    (last << 24); // Overflow

			  return (BigInt(val) << BigInt(32)) +
			    BigInt(first +
			    this[++offset] * 2 ** 8 +
			    this[++offset] * 2 ** 16 +
			    this[++offset] * 2 ** 24)
			});

			Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {
			  offset = offset >>> 0;
			  validateNumber(offset, 'offset');
			  const first = this[offset];
			  const last = this[offset + 7];
			  if (first === undefined || last === undefined) {
			    boundsError(offset, this.length - 8);
			  }

			  const val = (first << 24) + // Overflow
			    this[++offset] * 2 ** 16 +
			    this[++offset] * 2 ** 8 +
			    this[++offset];

			  return (BigInt(val) << BigInt(32)) +
			    BigInt(this[++offset] * 2 ** 24 +
			    this[++offset] * 2 ** 16 +
			    this[++offset] * 2 ** 8 +
			    last)
			});

			Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return ieee754$1.read(this, offset, true, 23, 4)
			};

			Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 4, this.length);
			  return ieee754$1.read(this, offset, false, 23, 4)
			};

			Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 8, this.length);
			  return ieee754$1.read(this, offset, true, 52, 8)
			};

			Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
			  offset = offset >>> 0;
			  if (!noAssert) checkOffset(offset, 8, this.length);
			  return ieee754$1.read(this, offset, false, 52, 8)
			};

			function checkInt (buf, value, offset, ext, max, min) {
			  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
			  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
			  if (offset + ext > buf.length) throw new RangeError('Index out of range')
			}

			Buffer.prototype.writeUintLE =
			Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) {
			    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
			    checkInt(this, value, offset, byteLength, maxBytes, 0);
			  }

			  let mul = 1;
			  let i = 0;
			  this[offset] = value & 0xFF;
			  while (++i < byteLength && (mul *= 0x100)) {
			    this[offset + i] = (value / mul) & 0xFF;
			  }

			  return offset + byteLength
			};

			Buffer.prototype.writeUintBE =
			Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  byteLength = byteLength >>> 0;
			  if (!noAssert) {
			    const maxBytes = Math.pow(2, 8 * byteLength) - 1;
			    checkInt(this, value, offset, byteLength, maxBytes, 0);
			  }

			  let i = byteLength - 1;
			  let mul = 1;
			  this[offset + i] = value & 0xFF;
			  while (--i >= 0 && (mul *= 0x100)) {
			    this[offset + i] = (value / mul) & 0xFF;
			  }

			  return offset + byteLength
			};

			Buffer.prototype.writeUint8 =
			Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
			  this[offset] = (value & 0xff);
			  return offset + 1
			};

			Buffer.prototype.writeUint16LE =
			Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
			  this[offset] = (value & 0xff);
			  this[offset + 1] = (value >>> 8);
			  return offset + 2
			};

			Buffer.prototype.writeUint16BE =
			Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
			  this[offset] = (value >>> 8);
			  this[offset + 1] = (value & 0xff);
			  return offset + 2
			};

			Buffer.prototype.writeUint32LE =
			Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
			  this[offset + 3] = (value >>> 24);
			  this[offset + 2] = (value >>> 16);
			  this[offset + 1] = (value >>> 8);
			  this[offset] = (value & 0xff);
			  return offset + 4
			};

			Buffer.prototype.writeUint32BE =
			Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
			  this[offset] = (value >>> 24);
			  this[offset + 1] = (value >>> 16);
			  this[offset + 2] = (value >>> 8);
			  this[offset + 3] = (value & 0xff);
			  return offset + 4
			};

			function wrtBigUInt64LE (buf, value, offset, min, max) {
			  checkIntBI(value, min, max, buf, offset, 7);

			  let lo = Number(value & BigInt(0xffffffff));
			  buf[offset++] = lo;
			  lo = lo >> 8;
			  buf[offset++] = lo;
			  lo = lo >> 8;
			  buf[offset++] = lo;
			  lo = lo >> 8;
			  buf[offset++] = lo;
			  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
			  buf[offset++] = hi;
			  hi = hi >> 8;
			  buf[offset++] = hi;
			  hi = hi >> 8;
			  buf[offset++] = hi;
			  hi = hi >> 8;
			  buf[offset++] = hi;
			  return offset
			}

			function wrtBigUInt64BE (buf, value, offset, min, max) {
			  checkIntBI(value, min, max, buf, offset, 7);

			  let lo = Number(value & BigInt(0xffffffff));
			  buf[offset + 7] = lo;
			  lo = lo >> 8;
			  buf[offset + 6] = lo;
			  lo = lo >> 8;
			  buf[offset + 5] = lo;
			  lo = lo >> 8;
			  buf[offset + 4] = lo;
			  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
			  buf[offset + 3] = hi;
			  hi = hi >> 8;
			  buf[offset + 2] = hi;
			  hi = hi >> 8;
			  buf[offset + 1] = hi;
			  hi = hi >> 8;
			  buf[offset] = hi;
			  return offset + 8
			}

			Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {
			  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
			});

			Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {
			  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))
			});

			Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    const limit = Math.pow(2, (8 * byteLength) - 1);

			    checkInt(this, value, offset, byteLength, limit - 1, -limit);
			  }

			  let i = 0;
			  let mul = 1;
			  let sub = 0;
			  this[offset] = value & 0xFF;
			  while (++i < byteLength && (mul *= 0x100)) {
			    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
			      sub = 1;
			    }
			    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
			  }

			  return offset + byteLength
			};

			Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    const limit = Math.pow(2, (8 * byteLength) - 1);

			    checkInt(this, value, offset, byteLength, limit - 1, -limit);
			  }

			  let i = byteLength - 1;
			  let mul = 1;
			  let sub = 0;
			  this[offset + i] = value & 0xFF;
			  while (--i >= 0 && (mul *= 0x100)) {
			    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
			      sub = 1;
			    }
			    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF;
			  }

			  return offset + byteLength
			};

			Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -128);
			  if (value < 0) value = 0xff + value + 1;
			  this[offset] = (value & 0xff);
			  return offset + 1
			};

			Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
			  this[offset] = (value & 0xff);
			  this[offset + 1] = (value >>> 8);
			  return offset + 2
			};

			Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -32768);
			  this[offset] = (value >>> 8);
			  this[offset + 1] = (value & 0xff);
			  return offset + 2
			};

			Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
			  this[offset] = (value & 0xff);
			  this[offset + 1] = (value >>> 8);
			  this[offset + 2] = (value >>> 16);
			  this[offset + 3] = (value >>> 24);
			  return offset + 4
			};

			Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -2147483648);
			  if (value < 0) value = 0xffffffff + value + 1;
			  this[offset] = (value >>> 24);
			  this[offset + 1] = (value >>> 16);
			  this[offset + 2] = (value >>> 8);
			  this[offset + 3] = (value & 0xff);
			  return offset + 4
			};

			Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {
			  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
			});

			Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {
			  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))
			});

			function checkIEEE754 (buf, value, offset, ext, max, min) {
			  if (offset + ext > buf.length) throw new RangeError('Index out of range')
			  if (offset < 0) throw new RangeError('Index out of range')
			}

			function writeFloat (buf, value, offset, littleEndian, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    checkIEEE754(buf, value, offset, 4);
			  }
			  ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
			  return offset + 4
			}

			Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
			  return writeFloat(this, value, offset, true, noAssert)
			};

			Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
			  return writeFloat(this, value, offset, false, noAssert)
			};

			function writeDouble (buf, value, offset, littleEndian, noAssert) {
			  value = +value;
			  offset = offset >>> 0;
			  if (!noAssert) {
			    checkIEEE754(buf, value, offset, 8);
			  }
			  ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
			  return offset + 8
			}

			Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
			  return writeDouble(this, value, offset, true, noAssert)
			};

			Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
			  return writeDouble(this, value, offset, false, noAssert)
			};

			// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
			Buffer.prototype.copy = function copy (target, targetStart, start, end) {
			  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
			  if (!start) start = 0;
			  if (!end && end !== 0) end = this.length;
			  if (targetStart >= target.length) targetStart = target.length;
			  if (!targetStart) targetStart = 0;
			  if (end > 0 && end < start) end = start;

			  // Copy 0 bytes; we're done
			  if (end === start) return 0
			  if (target.length === 0 || this.length === 0) return 0

			  // Fatal error conditions
			  if (targetStart < 0) {
			    throw new RangeError('targetStart out of bounds')
			  }
			  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
			  if (end < 0) throw new RangeError('sourceEnd out of bounds')

			  // Are we oob?
			  if (end > this.length) end = this.length;
			  if (target.length - targetStart < end - start) {
			    end = target.length - targetStart + start;
			  }

			  const len = end - start;

			  if (this === target && typeof GlobalUint8Array.prototype.copyWithin === 'function') {
			    // Use built-in when available, missing from IE11
			    this.copyWithin(targetStart, start, end);
			  } else {
			    GlobalUint8Array.prototype.set.call(
			      target,
			      this.subarray(start, end),
			      targetStart
			    );
			  }

			  return len
			};

			// Usage:
			//    buffer.fill(number[, offset[, end]])
			//    buffer.fill(buffer[, offset[, end]])
			//    buffer.fill(string[, offset[, end]][, encoding])
			Buffer.prototype.fill = function fill (val, start, end, encoding) {
			  // Handle string cases:
			  if (typeof val === 'string') {
			    if (typeof start === 'string') {
			      encoding = start;
			      start = 0;
			      end = this.length;
			    } else if (typeof end === 'string') {
			      encoding = end;
			      end = this.length;
			    }
			    if (encoding !== undefined && typeof encoding !== 'string') {
			      throw new TypeError('encoding must be a string')
			    }
			    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
			      throw new TypeError('Unknown encoding: ' + encoding)
			    }
			    if (val.length === 1) {
			      const code = val.charCodeAt(0);
			      if ((encoding === 'utf8' && code < 128) ||
			          encoding === 'latin1') {
			        // Fast path: If `val` fits into a single byte, use that numeric value.
			        val = code;
			      }
			    }
			  } else if (typeof val === 'number') {
			    val = val & 255;
			  } else if (typeof val === 'boolean') {
			    val = Number(val);
			  }

			  // Invalid ranges are not set to a default, so can range check early.
			  if (start < 0 || this.length < start || this.length < end) {
			    throw new RangeError('Out of range index')
			  }

			  if (end <= start) {
			    return this
			  }

			  start = start >>> 0;
			  end = end === undefined ? this.length : end >>> 0;

			  if (!val) val = 0;

			  let i;
			  if (typeof val === 'number') {
			    for (i = start; i < end; ++i) {
			      this[i] = val;
			    }
			  } else {
			    const bytes = Buffer.isBuffer(val)
			      ? val
			      : Buffer.from(val, encoding);
			    const len = bytes.length;
			    if (len === 0) {
			      throw new TypeError('The value "' + val +
			        '" is invalid for argument "value"')
			    }
			    for (i = 0; i < end - start; ++i) {
			      this[i + start] = bytes[i % len];
			    }
			  }

			  return this
			};

			// CUSTOM ERRORS
			// =============

			// Simplified versions from Node, changed for Buffer-only usage
			const errors = {};
			function E (sym, getMessage, Base) {
			  errors[sym] = class NodeError extends Base {
			    constructor () {
			      super();

			      Object.defineProperty(this, 'message', {
			        value: getMessage.apply(this, arguments),
			        writable: true,
			        configurable: true
			      });

			      // Add the error code to the name to include it in the stack trace.
			      this.name = `${this.name} [${sym}]`;
			      // Access the stack to generate the error message including the error code
			      // from the name.
			      this.stack; // eslint-disable-line no-unused-expressions
			      // Reset the name to the actual name.
			      delete this.name;
			    }

			    get code () {
			      return sym
			    }

			    set code (value) {
			      Object.defineProperty(this, 'code', {
			        configurable: true,
			        enumerable: true,
			        value,
			        writable: true
			      });
			    }

			    toString () {
			      return `${this.name} [${sym}]: ${this.message}`
			    }
			  };
			}

			E('ERR_BUFFER_OUT_OF_BOUNDS',
			  function (name) {
			    if (name) {
			      return `${name} is outside of buffer bounds`
			    }

			    return 'Attempt to access memory outside buffer bounds'
			  }, RangeError);
			E('ERR_INVALID_ARG_TYPE',
			  function (name, actual) {
			    return `The "${name}" argument must be of type number. Received type ${typeof actual}`
			  }, TypeError);
			E('ERR_OUT_OF_RANGE',
			  function (str, range, input) {
			    let msg = `The value of "${str}" is out of range.`;
			    let received = input;
			    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
			      received = addNumericalSeparator(String(input));
			    } else if (typeof input === 'bigint') {
			      received = String(input);
			      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
			        received = addNumericalSeparator(received);
			      }
			      received += 'n';
			    }
			    msg += ` It must be ${range}. Received ${received}`;
			    return msg
			  }, RangeError);

			function addNumericalSeparator (val) {
			  let res = '';
			  let i = val.length;
			  const start = val[0] === '-' ? 1 : 0;
			  for (; i >= start + 4; i -= 3) {
			    res = `_${val.slice(i - 3, i)}${res}`;
			  }
			  return `${val.slice(0, i)}${res}`
			}

			// CHECK FUNCTIONS
			// ===============

			function checkBounds (buf, offset, byteLength) {
			  validateNumber(offset, 'offset');
			  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
			    boundsError(offset, buf.length - (byteLength + 1));
			  }
			}

			function checkIntBI (value, min, max, buf, offset, byteLength) {
			  if (value > max || value < min) {
			    const n = typeof min === 'bigint' ? 'n' : '';
			    let range;
			    {
			      if (min === 0 || min === BigInt(0)) {
			        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`;
			      } else {
			        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +
			                `${(byteLength + 1) * 8 - 1}${n}`;
			      }
			    }
			    throw new errors.ERR_OUT_OF_RANGE('value', range, value)
			  }
			  checkBounds(buf, offset, byteLength);
			}

			function validateNumber (value, name) {
			  if (typeof value !== 'number') {
			    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)
			  }
			}

			function boundsError (value, length, type) {
			  if (Math.floor(value) !== value) {
			    validateNumber(value, type);
			    throw new errors.ERR_OUT_OF_RANGE('offset', 'an integer', value)
			  }

			  if (length < 0) {
			    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()
			  }

			  throw new errors.ERR_OUT_OF_RANGE('offset',
			                                    `>= ${0} and <= ${length}`,
			                                    value)
			}

			// HELPER FUNCTIONS
			// ================

			const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

			function base64clean (str) {
			  // Node takes equal signs as end of the Base64 encoding
			  str = str.split('=')[0];
			  // Node strips out invalid characters like \n and \t from the string, base64-js does not
			  str = str.trim().replace(INVALID_BASE64_RE, '');
			  // Node converts strings with length < 2 to ''
			  if (str.length < 2) return ''
			  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
			  while (str.length % 4 !== 0) {
			    str = str + '=';
			  }
			  return str
			}

			function utf8ToBytes (string, units) {
			  units = units || Infinity;
			  let codePoint;
			  const length = string.length;
			  let leadSurrogate = null;
			  const bytes = [];

			  for (let i = 0; i < length; ++i) {
			    codePoint = string.charCodeAt(i);

			    // is surrogate component
			    if (codePoint > 0xD7FF && codePoint < 0xE000) {
			      // last char was a lead
			      if (!leadSurrogate) {
			        // no lead yet
			        if (codePoint > 0xDBFF) {
			          // unexpected trail
			          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			          continue
			        } else if (i + 1 === length) {
			          // unpaired lead
			          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			          continue
			        }

			        // valid lead
			        leadSurrogate = codePoint;

			        continue
			      }

			      // 2 leads in a row
			      if (codePoint < 0xDC00) {
			        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			        leadSurrogate = codePoint;
			        continue
			      }

			      // valid surrogate pair
			      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
			    } else if (leadSurrogate) {
			      // valid bmp char, but last char was a lead
			      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
			    }

			    leadSurrogate = null;

			    // encode utf8
			    if (codePoint < 0x80) {
			      if ((units -= 1) < 0) break
			      bytes.push(codePoint);
			    } else if (codePoint < 0x800) {
			      if ((units -= 2) < 0) break
			      bytes.push(
			        codePoint >> 0x6 | 0xC0,
			        codePoint & 0x3F | 0x80
			      );
			    } else if (codePoint < 0x10000) {
			      if ((units -= 3) < 0) break
			      bytes.push(
			        codePoint >> 0xC | 0xE0,
			        codePoint >> 0x6 & 0x3F | 0x80,
			        codePoint & 0x3F | 0x80
			      );
			    } else if (codePoint < 0x110000) {
			      if ((units -= 4) < 0) break
			      bytes.push(
			        codePoint >> 0x12 | 0xF0,
			        codePoint >> 0xC & 0x3F | 0x80,
			        codePoint >> 0x6 & 0x3F | 0x80,
			        codePoint & 0x3F | 0x80
			      );
			    } else {
			      throw new Error('Invalid code point')
			    }
			  }

			  return bytes
			}

			function asciiToBytes (str) {
			  const byteArray = [];
			  for (let i = 0; i < str.length; ++i) {
			    // Node's code seems to be doing this and not & 0x7F..
			    byteArray.push(str.charCodeAt(i) & 0xFF);
			  }
			  return byteArray
			}

			function utf16leToBytes (str, units) {
			  let c, hi, lo;
			  const byteArray = [];
			  for (let i = 0; i < str.length; ++i) {
			    if ((units -= 2) < 0) break

			    c = str.charCodeAt(i);
			    hi = c >> 8;
			    lo = c % 256;
			    byteArray.push(lo);
			    byteArray.push(hi);
			  }

			  return byteArray
			}

			function base64ToBytes (str) {
			  return base64.toByteArray(base64clean(str))
			}

			function blitBuffer (src, dst, offset, length) {
			  let i;
			  for (i = 0; i < length; ++i) {
			    if ((i + offset >= dst.length) || (i >= src.length)) break
			    dst[i + offset] = src[i];
			  }
			  return i
			}

			// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
			// the `instanceof` check but they should be treated as of that type.
			// See: https://github.com/feross/buffer/issues/166
			function isInstance (obj, type) {
			  return obj instanceof type ||
			    (obj != null && obj.constructor != null && obj.constructor.name != null &&
			      obj.constructor.name === type.name)
			}
			function numberIsNaN (obj) {
			  // For IE11 support
			  return obj !== obj // eslint-disable-line no-self-compare
			}

			// Create lookup table for `toString('hex')`
			// See: https://github.com/feross/buffer/issues/219
			const hexSliceLookupTable = (function () {
			  const alphabet = '0123456789abcdef';
			  const table = new Array(256);
			  for (let i = 0; i < 16; ++i) {
			    const i16 = i * 16;
			    for (let j = 0; j < 16; ++j) {
			      table[i16 + j] = alphabet[i] + alphabet[j];
			    }
			  }
			  return table
			})();

			// Return not function with Error if BigInt not supported
			function defineBigIntMethod (fn) {
			  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn
			}

			function BufferBigIntNotDefined () {
			  throw new Error('BigInt not supported')
			} 
		} (buffer));

		const Buffer = buffer.Buffer;

		exports.Blob = buffer.Blob;
		exports.BlobOptions = buffer.BlobOptions;
		exports.Buffer = buffer.Buffer;
		exports.File = buffer.File;
		exports.FileOptions = buffer.FileOptions;
		exports.INSPECT_MAX_BYTES = buffer.INSPECT_MAX_BYTES;
		exports.SlowBuffer = buffer.SlowBuffer;
		exports.TranscodeEncoding = buffer.TranscodeEncoding;
		exports.atob = buffer.atob;
		exports.btoa = buffer.btoa;
		exports.constants = buffer.constants;
		exports.default = Buffer;
		exports.isAscii = buffer.isAscii;
		exports.isUtf8 = buffer.isUtf8;
		exports.kMaxLength = buffer.kMaxLength;
		exports.kStringMaxLength = buffer.kStringMaxLength;
		exports.resolveObjectURL = buffer.resolveObjectURL;
		exports.transcode = buffer.transcode;
		
	} (dist));
	return dist;
}

var events = {exports: {}};

var hasRequiredEvents;

function requireEvents () {
	if (hasRequiredEvents) return events.exports;
	hasRequiredEvents = 1;

	var R = typeof Reflect === 'object' ? Reflect : null;
	var ReflectApply = R && typeof R.apply === 'function'
	  ? R.apply
	  : function ReflectApply(target, receiver, args) {
	    return Function.prototype.apply.call(target, receiver, args);
	  };

	var ReflectOwnKeys;
	if (R && typeof R.ownKeys === 'function') {
	  ReflectOwnKeys = R.ownKeys;
	} else if (Object.getOwnPropertySymbols) {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target)
	      .concat(Object.getOwnPropertySymbols(target));
	  };
	} else {
	  ReflectOwnKeys = function ReflectOwnKeys(target) {
	    return Object.getOwnPropertyNames(target);
	  };
	}

	function ProcessEmitWarning(warning) {
	  if (console && console.warn) console.warn(warning);
	}

	var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
	  return value !== value;
	};

	function EventEmitter() {
	  EventEmitter.init.call(this);
	}
	events.exports = EventEmitter;
	events.exports.once = once;

	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;

	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = undefined;

	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners = 10;

	function checkListener(listener) {
	  if (typeof listener !== 'function') {
	    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
	  }
	}

	Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
	  enumerable: true,
	  get: function() {
	    return defaultMaxListeners;
	  },
	  set: function(arg) {
	    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
	      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
	    }
	    defaultMaxListeners = arg;
	  }
	});

	EventEmitter.init = function() {

	  if (this._events === undefined ||
	      this._events === Object.getPrototypeOf(this)._events) {
	    this._events = Object.create(null);
	    this._eventsCount = 0;
	  }

	  this._maxListeners = this._maxListeners || undefined;
	};

	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
	  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
	    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
	  }
	  this._maxListeners = n;
	  return this;
	};

	function _getMaxListeners(that) {
	  if (that._maxListeners === undefined)
	    return EventEmitter.defaultMaxListeners;
	  return that._maxListeners;
	}

	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
	  return _getMaxListeners(this);
	};

	EventEmitter.prototype.emit = function emit(type) {
	  var args = [];
	  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
	  var doError = (type === 'error');

	  var events = this._events;
	  if (events !== undefined)
	    doError = (doError && events.error === undefined);
	  else if (!doError)
	    return false;

	  // If there is no 'error' event listener then throw.
	  if (doError) {
	    var er;
	    if (args.length > 0)
	      er = args[0];
	    if (er instanceof Error) {
	      // Note: The comments on the `throw` lines are intentional, they show
	      // up in Node's output if this results in an unhandled exception.
	      throw er; // Unhandled 'error' event
	    }
	    // At least give some kind of context to the user
	    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
	    err.context = er;
	    throw err; // Unhandled 'error' event
	  }

	  var handler = events[type];

	  if (handler === undefined)
	    return false;

	  if (typeof handler === 'function') {
	    ReflectApply(handler, this, args);
	  } else {
	    var len = handler.length;
	    var listeners = arrayClone(handler, len);
	    for (var i = 0; i < len; ++i)
	      ReflectApply(listeners[i], this, args);
	  }

	  return true;
	};

	function _addListener(target, type, listener, prepend) {
	  var m;
	  var events;
	  var existing;

	  checkListener(listener);

	  events = target._events;
	  if (events === undefined) {
	    events = target._events = Object.create(null);
	    target._eventsCount = 0;
	  } else {
	    // To avoid recursion in the case that type === "newListener"! Before
	    // adding it to the listeners, first emit "newListener".
	    if (events.newListener !== undefined) {
	      target.emit('newListener', type,
	                  listener.listener ? listener.listener : listener);

	      // Re-assign `events` because a newListener handler could have caused the
	      // this._events to be assigned to a new object
	      events = target._events;
	    }
	    existing = events[type];
	  }

	  if (existing === undefined) {
	    // Optimize the case of one listener. Don't need the extra array object.
	    existing = events[type] = listener;
	    ++target._eventsCount;
	  } else {
	    if (typeof existing === 'function') {
	      // Adding the second element, need to change to array.
	      existing = events[type] =
	        prepend ? [listener, existing] : [existing, listener];
	      // If we've already got an array, just append.
	    } else if (prepend) {
	      existing.unshift(listener);
	    } else {
	      existing.push(listener);
	    }

	    // Check for listener leak
	    m = _getMaxListeners(target);
	    if (m > 0 && existing.length > m && !existing.warned) {
	      existing.warned = true;
	      // No error code for this since it is a Warning
	      // eslint-disable-next-line no-restricted-syntax
	      var w = new Error('Possible EventEmitter memory leak detected. ' +
	                          existing.length + ' ' + String(type) + ' listeners ' +
	                          'added. Use emitter.setMaxListeners() to ' +
	                          'increase limit');
	      w.name = 'MaxListenersExceededWarning';
	      w.emitter = target;
	      w.type = type;
	      w.count = existing.length;
	      ProcessEmitWarning(w);
	    }
	  }

	  return target;
	}

	EventEmitter.prototype.addListener = function addListener(type, listener) {
	  return _addListener(this, type, listener, false);
	};

	EventEmitter.prototype.on = EventEmitter.prototype.addListener;

	EventEmitter.prototype.prependListener =
	    function prependListener(type, listener) {
	      return _addListener(this, type, listener, true);
	    };

	function onceWrapper() {
	  if (!this.fired) {
	    this.target.removeListener(this.type, this.wrapFn);
	    this.fired = true;
	    if (arguments.length === 0)
	      return this.listener.call(this.target);
	    return this.listener.apply(this.target, arguments);
	  }
	}

	function _onceWrap(target, type, listener) {
	  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
	  var wrapped = onceWrapper.bind(state);
	  wrapped.listener = listener;
	  state.wrapFn = wrapped;
	  return wrapped;
	}

	EventEmitter.prototype.once = function once(type, listener) {
	  checkListener(listener);
	  this.on(type, _onceWrap(this, type, listener));
	  return this;
	};

	EventEmitter.prototype.prependOnceListener =
	    function prependOnceListener(type, listener) {
	      checkListener(listener);
	      this.prependListener(type, _onceWrap(this, type, listener));
	      return this;
	    };

	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter.prototype.removeListener =
	    function removeListener(type, listener) {
	      var list, events, position, i, originalListener;

	      checkListener(listener);

	      events = this._events;
	      if (events === undefined)
	        return this;

	      list = events[type];
	      if (list === undefined)
	        return this;

	      if (list === listener || list.listener === listener) {
	        if (--this._eventsCount === 0)
	          this._events = Object.create(null);
	        else {
	          delete events[type];
	          if (events.removeListener)
	            this.emit('removeListener', type, list.listener || listener);
	        }
	      } else if (typeof list !== 'function') {
	        position = -1;

	        for (i = list.length - 1; i >= 0; i--) {
	          if (list[i] === listener || list[i].listener === listener) {
	            originalListener = list[i].listener;
	            position = i;
	            break;
	          }
	        }

	        if (position < 0)
	          return this;

	        if (position === 0)
	          list.shift();
	        else {
	          spliceOne(list, position);
	        }

	        if (list.length === 1)
	          events[type] = list[0];

	        if (events.removeListener !== undefined)
	          this.emit('removeListener', type, originalListener || listener);
	      }

	      return this;
	    };

	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

	EventEmitter.prototype.removeAllListeners =
	    function removeAllListeners(type) {
	      var listeners, events, i;

	      events = this._events;
	      if (events === undefined)
	        return this;

	      // not listening for removeListener, no need to emit
	      if (events.removeListener === undefined) {
	        if (arguments.length === 0) {
	          this._events = Object.create(null);
	          this._eventsCount = 0;
	        } else if (events[type] !== undefined) {
	          if (--this._eventsCount === 0)
	            this._events = Object.create(null);
	          else
	            delete events[type];
	        }
	        return this;
	      }

	      // emit removeListener for all listeners on all events
	      if (arguments.length === 0) {
	        var keys = Object.keys(events);
	        var key;
	        for (i = 0; i < keys.length; ++i) {
	          key = keys[i];
	          if (key === 'removeListener') continue;
	          this.removeAllListeners(key);
	        }
	        this.removeAllListeners('removeListener');
	        this._events = Object.create(null);
	        this._eventsCount = 0;
	        return this;
	      }

	      listeners = events[type];

	      if (typeof listeners === 'function') {
	        this.removeListener(type, listeners);
	      } else if (listeners !== undefined) {
	        // LIFO order
	        for (i = listeners.length - 1; i >= 0; i--) {
	          this.removeListener(type, listeners[i]);
	        }
	      }

	      return this;
	    };

	function _listeners(target, type, unwrap) {
	  var events = target._events;

	  if (events === undefined)
	    return [];

	  var evlistener = events[type];
	  if (evlistener === undefined)
	    return [];

	  if (typeof evlistener === 'function')
	    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

	  return unwrap ?
	    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}

	EventEmitter.prototype.listeners = function listeners(type) {
	  return _listeners(this, type, true);
	};

	EventEmitter.prototype.rawListeners = function rawListeners(type) {
	  return _listeners(this, type, false);
	};

	EventEmitter.listenerCount = function(emitter, type) {
	  if (typeof emitter.listenerCount === 'function') {
	    return emitter.listenerCount(type);
	  } else {
	    return listenerCount.call(emitter, type);
	  }
	};

	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
	  var events = this._events;

	  if (events !== undefined) {
	    var evlistener = events[type];

	    if (typeof evlistener === 'function') {
	      return 1;
	    } else if (evlistener !== undefined) {
	      return evlistener.length;
	    }
	  }

	  return 0;
	}

	EventEmitter.prototype.eventNames = function eventNames() {
	  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};

	function arrayClone(arr, n) {
	  var copy = new Array(n);
	  for (var i = 0; i < n; ++i)
	    copy[i] = arr[i];
	  return copy;
	}

	function spliceOne(list, index) {
	  for (; index + 1 < list.length; index++)
	    list[index] = list[index + 1];
	  list.pop();
	}

	function unwrapListeners(arr) {
	  var ret = new Array(arr.length);
	  for (var i = 0; i < ret.length; ++i) {
	    ret[i] = arr[i].listener || arr[i];
	  }
	  return ret;
	}

	function once(emitter, name) {
	  return new Promise(function (resolve, reject) {
	    function errorListener(err) {
	      emitter.removeListener(name, resolver);
	      reject(err);
	    }

	    function resolver() {
	      if (typeof emitter.removeListener === 'function') {
	        emitter.removeListener('error', errorListener);
	      }
	      resolve([].slice.call(arguments));
	    }
	    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
	    if (name !== 'error') {
	      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
	    }
	  });
	}

	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
	  if (typeof emitter.on === 'function') {
	    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
	  }
	}

	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
	  if (typeof emitter.on === 'function') {
	    if (flags.once) {
	      emitter.once(name, listener);
	    } else {
	      emitter.on(name, listener);
	    }
	  } else if (typeof emitter.addEventListener === 'function') {
	    // EventTarget does not have `error` event semantics like Node
	    // EventEmitters, we do not listen for `error` events here.
	    emitter.addEventListener(name, function wrapListener(arg) {
	      // IE does not have builtin `{ once: true }` support so we
	      // have to do it manually.
	      if (flags.once) {
	        emitter.removeEventListener(name, wrapListener);
	      }
	      listener(arg);
	    });
	  } else {
	    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
	  }
	}
	return events.exports;
}

var streamBrowser$1;
var hasRequiredStreamBrowser$1;

function requireStreamBrowser$1 () {
	if (hasRequiredStreamBrowser$1) return streamBrowser$1;
	hasRequiredStreamBrowser$1 = 1;
	streamBrowser$1 = requireEvents().EventEmitter;
	return streamBrowser$1;
}

var util$2 = {};

var types = {};

var shams$1;
var hasRequiredShams$1;

function requireShams$1 () {
	if (hasRequiredShams$1) return shams$1;
	hasRequiredShams$1 = 1;

	/* eslint complexity: [2, 18], max-statements: [2, 33] */
	shams$1 = function hasSymbols() {
		if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
		if (typeof Symbol.iterator === 'symbol') { return true; }

		var obj = {};
		var sym = Symbol('test');
		var symObj = Object(sym);
		if (typeof sym === 'string') { return false; }

		if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
		if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

		// temp disabled per https://github.com/ljharb/object.assign/issues/17
		// if (sym instanceof Symbol) { return false; }
		// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
		// if (!(symObj instanceof Symbol)) { return false; }

		// if (typeof Symbol.prototype.toString !== 'function') { return false; }
		// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

		var symVal = 42;
		obj[sym] = symVal;
		for (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
		if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

		if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

		var syms = Object.getOwnPropertySymbols(obj);
		if (syms.length !== 1 || syms[0] !== sym) { return false; }

		if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

		if (typeof Object.getOwnPropertyDescriptor === 'function') {
			var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
			if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
		}

		return true;
	};
	return shams$1;
}

var shams;
var hasRequiredShams;

function requireShams () {
	if (hasRequiredShams) return shams;
	hasRequiredShams = 1;

	var hasSymbols = requireShams$1();

	/** @type {import('.')} */
	shams = function hasToStringTagShams() {
		return hasSymbols() && !!Symbol.toStringTag;
	};
	return shams;
}

var esErrors;
var hasRequiredEsErrors;

function requireEsErrors () {
	if (hasRequiredEsErrors) return esErrors;
	hasRequiredEsErrors = 1;

	/** @type {import('.')} */
	esErrors = Error;
	return esErrors;
}

var _eval;
var hasRequired_eval;

function require_eval () {
	if (hasRequired_eval) return _eval;
	hasRequired_eval = 1;

	/** @type {import('./eval')} */
	_eval = EvalError;
	return _eval;
}

var range;
var hasRequiredRange;

function requireRange () {
	if (hasRequiredRange) return range;
	hasRequiredRange = 1;

	/** @type {import('./range')} */
	range = RangeError;
	return range;
}

var ref;
var hasRequiredRef;

function requireRef () {
	if (hasRequiredRef) return ref;
	hasRequiredRef = 1;

	/** @type {import('./ref')} */
	ref = ReferenceError;
	return ref;
}

var syntax;
var hasRequiredSyntax;

function requireSyntax () {
	if (hasRequiredSyntax) return syntax;
	hasRequiredSyntax = 1;

	/** @type {import('./syntax')} */
	syntax = SyntaxError;
	return syntax;
}

var type;
var hasRequiredType;

function requireType () {
	if (hasRequiredType) return type;
	hasRequiredType = 1;

	/** @type {import('./type')} */
	type = TypeError;
	return type;
}

var uri;
var hasRequiredUri;

function requireUri () {
	if (hasRequiredUri) return uri;
	hasRequiredUri = 1;

	/** @type {import('./uri')} */
	uri = URIError;
	return uri;
}

var hasSymbols;
var hasRequiredHasSymbols;

function requireHasSymbols () {
	if (hasRequiredHasSymbols) return hasSymbols;
	hasRequiredHasSymbols = 1;

	var origSymbol = typeof Symbol !== 'undefined' && Symbol;
	var hasSymbolSham = requireShams$1();

	hasSymbols = function hasNativeSymbols() {
		if (typeof origSymbol !== 'function') { return false; }
		if (typeof Symbol !== 'function') { return false; }
		if (typeof origSymbol('foo') !== 'symbol') { return false; }
		if (typeof Symbol('bar') !== 'symbol') { return false; }

		return hasSymbolSham();
	};
	return hasSymbols;
}

var hasProto;
var hasRequiredHasProto;

function requireHasProto () {
	if (hasRequiredHasProto) return hasProto;
	hasRequiredHasProto = 1;

	var test = {
		__proto__: null,
		foo: {}
	};

	var $Object = Object;

	/** @type {import('.')} */
	hasProto = function hasProto() {
		// @ts-expect-error: TS errors on an inherited property for some reason
		return { __proto__: test }.foo === test.foo
			&& !(test instanceof $Object);
	};
	return hasProto;
}

var implementation;
var hasRequiredImplementation;

function requireImplementation () {
	if (hasRequiredImplementation) return implementation;
	hasRequiredImplementation = 1;

	/* eslint no-invalid-this: 1 */

	var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
	var toStr = Object.prototype.toString;
	var max = Math.max;
	var funcType = '[object Function]';

	var concatty = function concatty(a, b) {
	    var arr = [];

	    for (var i = 0; i < a.length; i += 1) {
	        arr[i] = a[i];
	    }
	    for (var j = 0; j < b.length; j += 1) {
	        arr[j + a.length] = b[j];
	    }

	    return arr;
	};

	var slicy = function slicy(arrLike, offset) {
	    var arr = [];
	    for (var i = offset, j = 0; i < arrLike.length; i += 1, j += 1) {
	        arr[j] = arrLike[i];
	    }
	    return arr;
	};

	var joiny = function (arr, joiner) {
	    var str = '';
	    for (var i = 0; i < arr.length; i += 1) {
	        str += arr[i];
	        if (i + 1 < arr.length) {
	            str += joiner;
	        }
	    }
	    return str;
	};

	implementation = function bind(that) {
	    var target = this;
	    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
	        throw new TypeError(ERROR_MESSAGE + target);
	    }
	    var args = slicy(arguments, 1);

	    var bound;
	    var binder = function () {
	        if (this instanceof bound) {
	            var result = target.apply(
	                this,
	                concatty(args, arguments)
	            );
	            if (Object(result) === result) {
	                return result;
	            }
	            return this;
	        }
	        return target.apply(
	            that,
	            concatty(args, arguments)
	        );

	    };

	    var boundLength = max(0, target.length - args.length);
	    var boundArgs = [];
	    for (var i = 0; i < boundLength; i++) {
	        boundArgs[i] = '$' + i;
	    }

	    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

	    if (target.prototype) {
	        var Empty = function Empty() {};
	        Empty.prototype = target.prototype;
	        bound.prototype = new Empty();
	        Empty.prototype = null;
	    }

	    return bound;
	};
	return implementation;
}

var functionBind;
var hasRequiredFunctionBind;

function requireFunctionBind () {
	if (hasRequiredFunctionBind) return functionBind;
	hasRequiredFunctionBind = 1;

	var implementation = requireImplementation();

	functionBind = Function.prototype.bind || implementation;
	return functionBind;
}

var hasown;
var hasRequiredHasown;

function requireHasown () {
	if (hasRequiredHasown) return hasown;
	hasRequiredHasown = 1;

	var call = Function.prototype.call;
	var $hasOwn = Object.prototype.hasOwnProperty;
	var bind = requireFunctionBind();

	/** @type {import('.')} */
	hasown = bind.call(call, $hasOwn);
	return hasown;
}

var getIntrinsic;
var hasRequiredGetIntrinsic;

function requireGetIntrinsic () {
	if (hasRequiredGetIntrinsic) return getIntrinsic;
	hasRequiredGetIntrinsic = 1;

	var undefined$1;

	var $Error = /*@__PURE__*/ requireEsErrors();
	var $EvalError = /*@__PURE__*/ require_eval();
	var $RangeError = /*@__PURE__*/ requireRange();
	var $ReferenceError = /*@__PURE__*/ requireRef();
	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();
	var $URIError = /*@__PURE__*/ requireUri();

	var $Function = Function;

	// eslint-disable-next-line consistent-return
	var getEvalledConstructor = function (expressionSyntax) {
		try {
			return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
		} catch (e) {}
	};

	var $gOPD = Object.getOwnPropertyDescriptor;
	if ($gOPD) {
		try {
			$gOPD({}, '');
		} catch (e) {
			$gOPD = null; // this is IE 8, which has a broken gOPD
		}
	}

	var throwTypeError = function () {
		throw new $TypeError();
	};
	var ThrowTypeError = $gOPD
		? (function () {
			try {
				// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
				arguments.callee; // IE 8 does not throw here
				return throwTypeError;
			} catch (calleeThrows) {
				try {
					// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
					return $gOPD(arguments, 'callee').get;
				} catch (gOPDthrows) {
					return throwTypeError;
				}
			}
		}())
		: throwTypeError;

	var hasSymbols = requireHasSymbols()();
	var hasProto = /*@__PURE__*/ requireHasProto()();

	var getProto = Object.getPrototypeOf || (
		hasProto
			? function (x) { return x.__proto__; } // eslint-disable-line no-proto
			: null
	);

	var needsEval = {};

	var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined$1 : getProto(Uint8Array);

	var INTRINSICS = {
		__proto__: null,
		'%AggregateError%': typeof AggregateError === 'undefined' ? undefined$1 : AggregateError,
		'%Array%': Array,
		'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined$1 : ArrayBuffer,
		'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
		'%AsyncFromSyncIteratorPrototype%': undefined$1,
		'%AsyncFunction%': needsEval,
		'%AsyncGenerator%': needsEval,
		'%AsyncGeneratorFunction%': needsEval,
		'%AsyncIteratorPrototype%': needsEval,
		'%Atomics%': typeof Atomics === 'undefined' ? undefined$1 : Atomics,
		'%BigInt%': typeof BigInt === 'undefined' ? undefined$1 : BigInt,
		'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined$1 : BigInt64Array,
		'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined$1 : BigUint64Array,
		'%Boolean%': Boolean,
		'%DataView%': typeof DataView === 'undefined' ? undefined$1 : DataView,
		'%Date%': Date,
		'%decodeURI%': decodeURI,
		'%decodeURIComponent%': decodeURIComponent,
		'%encodeURI%': encodeURI,
		'%encodeURIComponent%': encodeURIComponent,
		'%Error%': $Error,
		'%eval%': eval, // eslint-disable-line no-eval
		'%EvalError%': $EvalError,
		'%Float32Array%': typeof Float32Array === 'undefined' ? undefined$1 : Float32Array,
		'%Float64Array%': typeof Float64Array === 'undefined' ? undefined$1 : Float64Array,
		'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined$1 : FinalizationRegistry,
		'%Function%': $Function,
		'%GeneratorFunction%': needsEval,
		'%Int8Array%': typeof Int8Array === 'undefined' ? undefined$1 : Int8Array,
		'%Int16Array%': typeof Int16Array === 'undefined' ? undefined$1 : Int16Array,
		'%Int32Array%': typeof Int32Array === 'undefined' ? undefined$1 : Int32Array,
		'%isFinite%': isFinite,
		'%isNaN%': isNaN,
		'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
		'%JSON%': typeof JSON === 'object' ? JSON : undefined$1,
		'%Map%': typeof Map === 'undefined' ? undefined$1 : Map,
		'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Map()[Symbol.iterator]()),
		'%Math%': Math,
		'%Number%': Number,
		'%Object%': Object,
		'%parseFloat%': parseFloat,
		'%parseInt%': parseInt,
		'%Promise%': typeof Promise === 'undefined' ? undefined$1 : Promise,
		'%Proxy%': typeof Proxy === 'undefined' ? undefined$1 : Proxy,
		'%RangeError%': $RangeError,
		'%ReferenceError%': $ReferenceError,
		'%Reflect%': typeof Reflect === 'undefined' ? undefined$1 : Reflect,
		'%RegExp%': RegExp,
		'%Set%': typeof Set === 'undefined' ? undefined$1 : Set,
		'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined$1 : getProto(new Set()[Symbol.iterator]()),
		'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined$1 : SharedArrayBuffer,
		'%String%': String,
		'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined$1,
		'%Symbol%': hasSymbols ? Symbol : undefined$1,
		'%SyntaxError%': $SyntaxError,
		'%ThrowTypeError%': ThrowTypeError,
		'%TypedArray%': TypedArray,
		'%TypeError%': $TypeError,
		'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined$1 : Uint8Array,
		'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined$1 : Uint8ClampedArray,
		'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined$1 : Uint16Array,
		'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined$1 : Uint32Array,
		'%URIError%': $URIError,
		'%WeakMap%': typeof WeakMap === 'undefined' ? undefined$1 : WeakMap,
		'%WeakRef%': typeof WeakRef === 'undefined' ? undefined$1 : WeakRef,
		'%WeakSet%': typeof WeakSet === 'undefined' ? undefined$1 : WeakSet
	};

	if (getProto) {
		try {
			null.error; // eslint-disable-line no-unused-expressions
		} catch (e) {
			// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
			var errorProto = getProto(getProto(e));
			INTRINSICS['%Error.prototype%'] = errorProto;
		}
	}

	var doEval = function doEval(name) {
		var value;
		if (name === '%AsyncFunction%') {
			value = getEvalledConstructor('async function () {}');
		} else if (name === '%GeneratorFunction%') {
			value = getEvalledConstructor('function* () {}');
		} else if (name === '%AsyncGeneratorFunction%') {
			value = getEvalledConstructor('async function* () {}');
		} else if (name === '%AsyncGenerator%') {
			var fn = doEval('%AsyncGeneratorFunction%');
			if (fn) {
				value = fn.prototype;
			}
		} else if (name === '%AsyncIteratorPrototype%') {
			var gen = doEval('%AsyncGenerator%');
			if (gen && getProto) {
				value = getProto(gen.prototype);
			}
		}

		INTRINSICS[name] = value;

		return value;
	};

	var LEGACY_ALIASES = {
		__proto__: null,
		'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
		'%ArrayPrototype%': ['Array', 'prototype'],
		'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
		'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
		'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
		'%ArrayProto_values%': ['Array', 'prototype', 'values'],
		'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
		'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
		'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
		'%BooleanPrototype%': ['Boolean', 'prototype'],
		'%DataViewPrototype%': ['DataView', 'prototype'],
		'%DatePrototype%': ['Date', 'prototype'],
		'%ErrorPrototype%': ['Error', 'prototype'],
		'%EvalErrorPrototype%': ['EvalError', 'prototype'],
		'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
		'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
		'%FunctionPrototype%': ['Function', 'prototype'],
		'%Generator%': ['GeneratorFunction', 'prototype'],
		'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
		'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
		'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
		'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
		'%JSONParse%': ['JSON', 'parse'],
		'%JSONStringify%': ['JSON', 'stringify'],
		'%MapPrototype%': ['Map', 'prototype'],
		'%NumberPrototype%': ['Number', 'prototype'],
		'%ObjectPrototype%': ['Object', 'prototype'],
		'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
		'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
		'%PromisePrototype%': ['Promise', 'prototype'],
		'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
		'%Promise_all%': ['Promise', 'all'],
		'%Promise_reject%': ['Promise', 'reject'],
		'%Promise_resolve%': ['Promise', 'resolve'],
		'%RangeErrorPrototype%': ['RangeError', 'prototype'],
		'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
		'%RegExpPrototype%': ['RegExp', 'prototype'],
		'%SetPrototype%': ['Set', 'prototype'],
		'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
		'%StringPrototype%': ['String', 'prototype'],
		'%SymbolPrototype%': ['Symbol', 'prototype'],
		'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
		'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
		'%TypeErrorPrototype%': ['TypeError', 'prototype'],
		'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
		'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
		'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
		'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
		'%URIErrorPrototype%': ['URIError', 'prototype'],
		'%WeakMapPrototype%': ['WeakMap', 'prototype'],
		'%WeakSetPrototype%': ['WeakSet', 'prototype']
	};

	var bind = requireFunctionBind();
	var hasOwn = /*@__PURE__*/ requireHasown();
	var $concat = bind.call(Function.call, Array.prototype.concat);
	var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
	var $replace = bind.call(Function.call, String.prototype.replace);
	var $strSlice = bind.call(Function.call, String.prototype.slice);
	var $exec = bind.call(Function.call, RegExp.prototype.exec);

	/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
	var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
	var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
	var stringToPath = function stringToPath(string) {
		var first = $strSlice(string, 0, 1);
		var last = $strSlice(string, -1);
		if (first === '%' && last !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
		} else if (last === '%' && first !== '%') {
			throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
		}
		var result = [];
		$replace(string, rePropName, function (match, number, quote, subString) {
			result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
		});
		return result;
	};
	/* end adaptation */

	var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
		var intrinsicName = name;
		var alias;
		if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
			alias = LEGACY_ALIASES[intrinsicName];
			intrinsicName = '%' + alias[0] + '%';
		}

		if (hasOwn(INTRINSICS, intrinsicName)) {
			var value = INTRINSICS[intrinsicName];
			if (value === needsEval) {
				value = doEval(intrinsicName);
			}
			if (typeof value === 'undefined' && !allowMissing) {
				throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
			}

			return {
				alias: alias,
				name: intrinsicName,
				value: value
			};
		}

		throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
	};

	getIntrinsic = function GetIntrinsic(name, allowMissing) {
		if (typeof name !== 'string' || name.length === 0) {
			throw new $TypeError('intrinsic name must be a non-empty string');
		}
		if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
			throw new $TypeError('"allowMissing" argument must be a boolean');
		}

		if ($exec(/^%?[^%]*%?$/, name) === null) {
			throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
		}
		var parts = stringToPath(name);
		var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

		var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
		var intrinsicRealName = intrinsic.name;
		var value = intrinsic.value;
		var skipFurtherCaching = false;

		var alias = intrinsic.alias;
		if (alias) {
			intrinsicBaseName = alias[0];
			$spliceApply(parts, $concat([0, 1], alias));
		}

		for (var i = 1, isOwn = true; i < parts.length; i += 1) {
			var part = parts[i];
			var first = $strSlice(part, 0, 1);
			var last = $strSlice(part, -1);
			if (
				(
					(first === '"' || first === "'" || first === '`')
					|| (last === '"' || last === "'" || last === '`')
				)
				&& first !== last
			) {
				throw new $SyntaxError('property names with quotes must have matching quotes');
			}
			if (part === 'constructor' || !isOwn) {
				skipFurtherCaching = true;
			}

			intrinsicBaseName += '.' + part;
			intrinsicRealName = '%' + intrinsicBaseName + '%';

			if (hasOwn(INTRINSICS, intrinsicRealName)) {
				value = INTRINSICS[intrinsicRealName];
			} else if (value != null) {
				if (!(part in value)) {
					if (!allowMissing) {
						throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
					}
					return void 0;
				}
				if ($gOPD && (i + 1) >= parts.length) {
					var desc = $gOPD(value, part);
					isOwn = !!desc;

					// By convention, when a data property is converted to an accessor
					// property to emulate a data property that does not suffer from
					// the override mistake, that accessor's getter is marked with
					// an `originalValue` property. Here, when we detect this, we
					// uphold the illusion by pretending to see that original data
					// property, i.e., returning the value rather than the getter
					// itself.
					if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
						value = desc.get;
					} else {
						value = value[part];
					}
				} else {
					isOwn = hasOwn(value, part);
					value = value[part];
				}

				if (isOwn && !skipFurtherCaching) {
					INTRINSICS[intrinsicRealName] = value;
				}
			}
		}
		return value;
	};
	return getIntrinsic;
}

var callBind = {exports: {}};

var esDefineProperty;
var hasRequiredEsDefineProperty;

function requireEsDefineProperty () {
	if (hasRequiredEsDefineProperty) return esDefineProperty;
	hasRequiredEsDefineProperty = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	/** @type {import('.')} */
	var $defineProperty = GetIntrinsic('%Object.defineProperty%', true) || false;
	if ($defineProperty) {
		try {
			$defineProperty({}, 'a', { value: 1 });
		} catch (e) {
			// IE 8 has a broken defineProperty
			$defineProperty = false;
		}
	}

	esDefineProperty = $defineProperty;
	return esDefineProperty;
}

var gopd;
var hasRequiredGopd;

function requireGopd () {
	if (hasRequiredGopd) return gopd;
	hasRequiredGopd = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);

	if ($gOPD) {
		try {
			$gOPD([], 'length');
		} catch (e) {
			// IE 8 has a broken gOPD
			$gOPD = null;
		}
	}

	gopd = $gOPD;
	return gopd;
}

var defineDataProperty;
var hasRequiredDefineDataProperty;

function requireDefineDataProperty () {
	if (hasRequiredDefineDataProperty) return defineDataProperty;
	hasRequiredDefineDataProperty = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var $SyntaxError = /*@__PURE__*/ requireSyntax();
	var $TypeError = /*@__PURE__*/ requireType();

	var gopd = /*@__PURE__*/ requireGopd();

	/** @type {import('.')} */
	defineDataProperty = function defineDataProperty(
		obj,
		property,
		value
	) {
		if (!obj || (typeof obj !== 'object' && typeof obj !== 'function')) {
			throw new $TypeError('`obj` must be an object or a function`');
		}
		if (typeof property !== 'string' && typeof property !== 'symbol') {
			throw new $TypeError('`property` must be a string or a symbol`');
		}
		if (arguments.length > 3 && typeof arguments[3] !== 'boolean' && arguments[3] !== null) {
			throw new $TypeError('`nonEnumerable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 4 && typeof arguments[4] !== 'boolean' && arguments[4] !== null) {
			throw new $TypeError('`nonWritable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 5 && typeof arguments[5] !== 'boolean' && arguments[5] !== null) {
			throw new $TypeError('`nonConfigurable`, if provided, must be a boolean or null');
		}
		if (arguments.length > 6 && typeof arguments[6] !== 'boolean') {
			throw new $TypeError('`loose`, if provided, must be a boolean');
		}

		var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
		var nonWritable = arguments.length > 4 ? arguments[4] : null;
		var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
		var loose = arguments.length > 6 ? arguments[6] : false;

		/* @type {false | TypedPropertyDescriptor<unknown>} */
		var desc = !!gopd && gopd(obj, property);

		if ($defineProperty) {
			$defineProperty(obj, property, {
				configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
				enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
				value: value,
				writable: nonWritable === null && desc ? desc.writable : !nonWritable
			});
		} else if (loose || (!nonEnumerable && !nonWritable && !nonConfigurable)) {
			// must fall back to [[Set]], and was not explicitly asked to make non-enumerable, non-writable, or non-configurable
			obj[property] = value; // eslint-disable-line no-param-reassign
		} else {
			throw new $SyntaxError('This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.');
		}
	};
	return defineDataProperty;
}

var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;

function requireHasPropertyDescriptors () {
	if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
	hasRequiredHasPropertyDescriptors = 1;

	var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();

	var hasPropertyDescriptors = function hasPropertyDescriptors() {
		return !!$defineProperty;
	};

	hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
		// node v0.6 has a bug where array lengths can be Set but not Defined
		if (!$defineProperty) {
			return null;
		}
		try {
			return $defineProperty([], 'length', { value: 1 }).length !== 1;
		} catch (e) {
			// In Firefox 4-22, defining length on an array throws an exception.
			return true;
		}
	};

	hasPropertyDescriptors_1 = hasPropertyDescriptors;
	return hasPropertyDescriptors_1;
}

var setFunctionLength;
var hasRequiredSetFunctionLength;

function requireSetFunctionLength () {
	if (hasRequiredSetFunctionLength) return setFunctionLength;
	hasRequiredSetFunctionLength = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
	var define = /*@__PURE__*/ requireDefineDataProperty();
	var hasDescriptors = /*@__PURE__*/ requireHasPropertyDescriptors()();
	var gOPD = /*@__PURE__*/ requireGopd();

	var $TypeError = /*@__PURE__*/ requireType();
	var $floor = GetIntrinsic('%Math.floor%');

	/** @type {import('.')} */
	setFunctionLength = function setFunctionLength(fn, length) {
		if (typeof fn !== 'function') {
			throw new $TypeError('`fn` is not a function');
		}
		if (typeof length !== 'number' || length < 0 || length > 0xFFFFFFFF || $floor(length) !== length) {
			throw new $TypeError('`length` must be a positive 32-bit integer');
		}

		var loose = arguments.length > 2 && !!arguments[2];

		var functionLengthIsConfigurable = true;
		var functionLengthIsWritable = true;
		if ('length' in fn && gOPD) {
			var desc = gOPD(fn, 'length');
			if (desc && !desc.configurable) {
				functionLengthIsConfigurable = false;
			}
			if (desc && !desc.writable) {
				functionLengthIsWritable = false;
			}
		}

		if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
			if (hasDescriptors) {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length, true, true);
			} else {
				define(/** @type {Parameters<define>[0]} */ (fn), 'length', length);
			}
		}
		return fn;
	};
	return setFunctionLength;
}

var hasRequiredCallBind;

function requireCallBind () {
	if (hasRequiredCallBind) return callBind.exports;
	hasRequiredCallBind = 1;
	(function (module) {

		var bind = requireFunctionBind();
		var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();
		var setFunctionLength = /*@__PURE__*/ requireSetFunctionLength();

		var $TypeError = /*@__PURE__*/ requireType();
		var $apply = GetIntrinsic('%Function.prototype.apply%');
		var $call = GetIntrinsic('%Function.prototype.call%');
		var $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);

		var $defineProperty = /*@__PURE__*/ requireEsDefineProperty();
		var $max = GetIntrinsic('%Math.max%');

		module.exports = function callBind(originalFunction) {
			if (typeof originalFunction !== 'function') {
				throw new $TypeError('a function is required');
			}
			var func = $reflectApply(bind, $call, arguments);
			return setFunctionLength(
				func,
				1 + $max(0, originalFunction.length - (arguments.length - 1)),
				true
			);
		};

		var applyBind = function applyBind() {
			return $reflectApply(bind, $apply, arguments);
		};

		if ($defineProperty) {
			$defineProperty(module.exports, 'apply', { value: applyBind });
		} else {
			module.exports.apply = applyBind;
		} 
	} (callBind));
	return callBind.exports;
}

var callBound;
var hasRequiredCallBound;

function requireCallBound () {
	if (hasRequiredCallBound) return callBound;
	hasRequiredCallBound = 1;

	var GetIntrinsic = /*@__PURE__*/ requireGetIntrinsic();

	var callBind = requireCallBind();

	var $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));

	callBound = function callBoundIntrinsic(name, allowMissing) {
		var intrinsic = GetIntrinsic(name, !!allowMissing);
		if (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {
			return callBind(intrinsic);
		}
		return intrinsic;
	};
	return callBound;
}

var isArguments;
var hasRequiredIsArguments;

function requireIsArguments () {
	if (hasRequiredIsArguments) return isArguments;
	hasRequiredIsArguments = 1;

	var hasToStringTag = requireShams()();
	var callBound = requireCallBound();

	var $toString = callBound('Object.prototype.toString');

	var isStandardArguments = function isArguments(value) {
		if (hasToStringTag && value && typeof value === 'object' && Symbol.toStringTag in value) {
			return false;
		}
		return $toString(value) === '[object Arguments]';
	};

	var isLegacyArguments = function isArguments(value) {
		if (isStandardArguments(value)) {
			return true;
		}
		return value !== null &&
			typeof value === 'object' &&
			typeof value.length === 'number' &&
			value.length >= 0 &&
			$toString(value) !== '[object Array]' &&
			$toString(value.callee) === '[object Function]';
	};

	var supportsStandardArguments = (function () {
		return isStandardArguments(arguments);
	}());

	isStandardArguments.isLegacyArguments = isLegacyArguments; // for tests

	isArguments = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
	return isArguments;
}

var isGeneratorFunction;
var hasRequiredIsGeneratorFunction;

function requireIsGeneratorFunction () {
	if (hasRequiredIsGeneratorFunction) return isGeneratorFunction;
	hasRequiredIsGeneratorFunction = 1;

	var toStr = Object.prototype.toString;
	var fnToStr = Function.prototype.toString;
	var isFnRegex = /^\s*(?:function)?\*/;
	var hasToStringTag = requireShams()();
	var getProto = Object.getPrototypeOf;
	var getGeneratorFunc = function () { // eslint-disable-line consistent-return
		if (!hasToStringTag) {
			return false;
		}
		try {
			return Function('return function*() {}')();
		} catch (e) {
		}
	};
	var GeneratorFunction;

	isGeneratorFunction = function isGeneratorFunction(fn) {
		if (typeof fn !== 'function') {
			return false;
		}
		if (isFnRegex.test(fnToStr.call(fn))) {
			return true;
		}
		if (!hasToStringTag) {
			var str = toStr.call(fn);
			return str === '[object GeneratorFunction]';
		}
		if (!getProto) {
			return false;
		}
		if (typeof GeneratorFunction === 'undefined') {
			var generatorFunc = getGeneratorFunc();
			GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
		}
		return getProto(fn) === GeneratorFunction;
	};
	return isGeneratorFunction;
}

var isCallable;
var hasRequiredIsCallable;

function requireIsCallable () {
	if (hasRequiredIsCallable) return isCallable;
	hasRequiredIsCallable = 1;

	var fnToStr = Function.prototype.toString;
	var reflectApply = typeof Reflect === 'object' && Reflect !== null && Reflect.apply;
	var badArrayLike;
	var isCallableMarker;
	if (typeof reflectApply === 'function' && typeof Object.defineProperty === 'function') {
		try {
			badArrayLike = Object.defineProperty({}, 'length', {
				get: function () {
					throw isCallableMarker;
				}
			});
			isCallableMarker = {};
			// eslint-disable-next-line no-throw-literal
			reflectApply(function () { throw 42; }, null, badArrayLike);
		} catch (_) {
			if (_ !== isCallableMarker) {
				reflectApply = null;
			}
		}
	} else {
		reflectApply = null;
	}

	var constructorRegex = /^\s*class\b/;
	var isES6ClassFn = function isES6ClassFunction(value) {
		try {
			var fnStr = fnToStr.call(value);
			return constructorRegex.test(fnStr);
		} catch (e) {
			return false; // not a function
		}
	};

	var tryFunctionObject = function tryFunctionToStr(value) {
		try {
			if (isES6ClassFn(value)) { return false; }
			fnToStr.call(value);
			return true;
		} catch (e) {
			return false;
		}
	};
	var toStr = Object.prototype.toString;
	var objectClass = '[object Object]';
	var fnClass = '[object Function]';
	var genClass = '[object GeneratorFunction]';
	var ddaClass = '[object HTMLAllCollection]'; // IE 11
	var ddaClass2 = '[object HTML document.all class]';
	var ddaClass3 = '[object HTMLCollection]'; // IE 9-10
	var hasToStringTag = typeof Symbol === 'function' && !!Symbol.toStringTag; // better: use `has-tostringtag`

	var isIE68 = !(0 in [,]); // eslint-disable-line no-sparse-arrays, comma-spacing

	var isDDA = function isDocumentDotAll() { return false; };
	if (typeof document === 'object') {
		// Firefox 3 canonicalizes DDA to undefined when it's not accessed directly
		var all = document.all;
		if (toStr.call(all) === toStr.call(document.all)) {
			isDDA = function isDocumentDotAll(value) {
				/* globals document: false */
				// in IE 6-8, typeof document.all is "object" and it's truthy
				if ((isIE68 || !value) && (typeof value === 'undefined' || typeof value === 'object')) {
					try {
						var str = toStr.call(value);
						return (
							str === ddaClass
							|| str === ddaClass2
							|| str === ddaClass3 // opera 12.16
							|| str === objectClass // IE 6-8
						) && value('') == null; // eslint-disable-line eqeqeq
					} catch (e) { /**/ }
				}
				return false;
			};
		}
	}

	isCallable = reflectApply
		? function isCallable(value) {
			if (isDDA(value)) { return true; }
			if (!value) { return false; }
			if (typeof value !== 'function' && typeof value !== 'object') { return false; }
			try {
				reflectApply(value, null, badArrayLike);
			} catch (e) {
				if (e !== isCallableMarker) { return false; }
			}
			return !isES6ClassFn(value) && tryFunctionObject(value);
		}
		: function isCallable(value) {
			if (isDDA(value)) { return true; }
			if (!value) { return false; }
			if (typeof value !== 'function' && typeof value !== 'object') { return false; }
			if (hasToStringTag) { return tryFunctionObject(value); }
			if (isES6ClassFn(value)) { return false; }
			var strClass = toStr.call(value);
			if (strClass !== fnClass && strClass !== genClass && !(/^\[object HTML/).test(strClass)) { return false; }
			return tryFunctionObject(value);
		};
	return isCallable;
}

var forEach_1;
var hasRequiredForEach;

function requireForEach () {
	if (hasRequiredForEach) return forEach_1;
	hasRequiredForEach = 1;

	var isCallable = requireIsCallable();

	var toStr = Object.prototype.toString;
	var hasOwnProperty = Object.prototype.hasOwnProperty;

	var forEachArray = function forEachArray(array, iterator, receiver) {
	    for (var i = 0, len = array.length; i < len; i++) {
	        if (hasOwnProperty.call(array, i)) {
	            if (receiver == null) {
	                iterator(array[i], i, array);
	            } else {
	                iterator.call(receiver, array[i], i, array);
	            }
	        }
	    }
	};

	var forEachString = function forEachString(string, iterator, receiver) {
	    for (var i = 0, len = string.length; i < len; i++) {
	        // no such thing as a sparse string.
	        if (receiver == null) {
	            iterator(string.charAt(i), i, string);
	        } else {
	            iterator.call(receiver, string.charAt(i), i, string);
	        }
	    }
	};

	var forEachObject = function forEachObject(object, iterator, receiver) {
	    for (var k in object) {
	        if (hasOwnProperty.call(object, k)) {
	            if (receiver == null) {
	                iterator(object[k], k, object);
	            } else {
	                iterator.call(receiver, object[k], k, object);
	            }
	        }
	    }
	};

	var forEach = function forEach(list, iterator, thisArg) {
	    if (!isCallable(iterator)) {
	        throw new TypeError('iterator must be a function');
	    }

	    var receiver;
	    if (arguments.length >= 3) {
	        receiver = thisArg;
	    }

	    if (toStr.call(list) === '[object Array]') {
	        forEachArray(list, iterator, receiver);
	    } else if (typeof list === 'string') {
	        forEachString(list, iterator, receiver);
	    } else {
	        forEachObject(list, iterator, receiver);
	    }
	};

	forEach_1 = forEach;
	return forEach_1;
}

var possibleTypedArrayNames;
var hasRequiredPossibleTypedArrayNames;

function requirePossibleTypedArrayNames () {
	if (hasRequiredPossibleTypedArrayNames) return possibleTypedArrayNames;
	hasRequiredPossibleTypedArrayNames = 1;

	/** @type {import('.')} */
	possibleTypedArrayNames = [
		'Float32Array',
		'Float64Array',
		'Int8Array',
		'Int16Array',
		'Int32Array',
		'Uint8Array',
		'Uint8ClampedArray',
		'Uint16Array',
		'Uint32Array',
		'BigInt64Array',
		'BigUint64Array'
	];
	return possibleTypedArrayNames;
}

var availableTypedArrays;
var hasRequiredAvailableTypedArrays;

function requireAvailableTypedArrays () {
	if (hasRequiredAvailableTypedArrays) return availableTypedArrays;
	hasRequiredAvailableTypedArrays = 1;

	var possibleNames = /*@__PURE__*/ requirePossibleTypedArrayNames();

	var g = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;

	/** @type {import('.')} */
	availableTypedArrays = function availableTypedArrays() {
		var /** @type {ReturnType<typeof availableTypedArrays>} */ out = [];
		for (var i = 0; i < possibleNames.length; i++) {
			if (typeof g[possibleNames[i]] === 'function') {
				// @ts-expect-error
				out[out.length] = possibleNames[i];
			}
		}
		return out;
	};
	return availableTypedArrays;
}

var whichTypedArray;
var hasRequiredWhichTypedArray;

function requireWhichTypedArray () {
	if (hasRequiredWhichTypedArray) return whichTypedArray;
	hasRequiredWhichTypedArray = 1;

	var forEach = requireForEach();
	var availableTypedArrays = /*@__PURE__*/ requireAvailableTypedArrays();
	var callBind = requireCallBind();
	var callBound = requireCallBound();
	var gOPD = /*@__PURE__*/ requireGopd();

	/** @type {(O: object) => string} */
	var $toString = callBound('Object.prototype.toString');
	var hasToStringTag = requireShams()();

	var g = typeof globalThis === 'undefined' ? commonjsGlobal : globalThis;
	var typedArrays = availableTypedArrays();

	var $slice = callBound('String.prototype.slice');
	var getPrototypeOf = Object.getPrototypeOf; // require('getprototypeof');

	/** @type {<T = unknown>(array: readonly T[], value: unknown) => number} */
	var $indexOf = callBound('Array.prototype.indexOf', true) || function indexOf(array, value) {
		for (var i = 0; i < array.length; i += 1) {
			if (array[i] === value) {
				return i;
			}
		}
		return -1;
	};

	/** @typedef {(receiver: import('.').TypedArray) => string | typeof Uint8Array.prototype.slice.call | typeof Uint8Array.prototype.set.call} Getter */
	/** @type {{ [k in `\$${import('.').TypedArrayName}`]?: Getter } & { __proto__: null }} */
	var cache = { __proto__: null };
	if (hasToStringTag && gOPD && getPrototypeOf) {
		forEach(typedArrays, function (typedArray) {
			var arr = new g[typedArray]();
			if (Symbol.toStringTag in arr) {
				var proto = getPrototypeOf(arr);
				// @ts-expect-error TS won't narrow inside a closure
				var descriptor = gOPD(proto, Symbol.toStringTag);
				if (!descriptor) {
					var superProto = getPrototypeOf(proto);
					// @ts-expect-error TS won't narrow inside a closure
					descriptor = gOPD(superProto, Symbol.toStringTag);
				}
				// @ts-expect-error TODO: fix
				cache['$' + typedArray] = callBind(descriptor.get);
			}
		});
	} else {
		forEach(typedArrays, function (typedArray) {
			var arr = new g[typedArray]();
			var fn = arr.slice || arr.set;
			if (fn) {
				// @ts-expect-error TODO: fix
				cache['$' + typedArray] = callBind(fn);
			}
		});
	}

	/** @type {(value: object) => false | import('.').TypedArrayName} */
	var tryTypedArrays = function tryAllTypedArrays(value) {
		/** @type {ReturnType<typeof tryAllTypedArrays>} */ var found = false;
		forEach(
			// eslint-disable-next-line no-extra-parens
			/** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),
			/** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
			function (getter, typedArray) {
				if (!found) {
					try {
					// @ts-expect-error TODO: fix
						if ('$' + getter(value) === typedArray) {
							found = $slice(typedArray, 1);
						}
					} catch (e) { /**/ }
				}
			}
		);
		return found;
	};

	/** @type {(value: object) => false | import('.').TypedArrayName} */
	var trySlices = function tryAllSlices(value) {
		/** @type {ReturnType<typeof tryAllSlices>} */ var found = false;
		forEach(
			// eslint-disable-next-line no-extra-parens
			/** @type {Record<`\$${TypedArrayName}`, Getter>} */ /** @type {any} */ (cache),
			/** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */ function (getter, name) {
				if (!found) {
					try {
						// @ts-expect-error TODO: fix
						getter(value);
						found = $slice(name, 1);
					} catch (e) { /**/ }
				}
			}
		);
		return found;
	};

	/** @type {import('.')} */
	whichTypedArray = function whichTypedArray(value) {
		if (!value || typeof value !== 'object') { return false; }
		if (!hasToStringTag) {
			/** @type {string} */
			var tag = $slice($toString(value), 8, -1);
			if ($indexOf(typedArrays, tag) > -1) {
				return tag;
			}
			if (tag !== 'Object') {
				return false;
			}
			// node < 0.6 hits here on real Typed Arrays
			return trySlices(value);
		}
		if (!gOPD) { return null; } // unknown engine
		return tryTypedArrays(value);
	};
	return whichTypedArray;
}

var isTypedArray;
var hasRequiredIsTypedArray;

function requireIsTypedArray () {
	if (hasRequiredIsTypedArray) return isTypedArray;
	hasRequiredIsTypedArray = 1;

	var whichTypedArray = /*@__PURE__*/ requireWhichTypedArray();

	/** @type {import('.')} */
	isTypedArray = function isTypedArray(value) {
		return !!whichTypedArray(value);
	};
	return isTypedArray;
}

var hasRequiredTypes;

function requireTypes () {
	if (hasRequiredTypes) return types;
	hasRequiredTypes = 1;
	(function (exports) {

		var isArgumentsObject = requireIsArguments();
		var isGeneratorFunction = requireIsGeneratorFunction();
		var whichTypedArray = /*@__PURE__*/ requireWhichTypedArray();
		var isTypedArray = /*@__PURE__*/ requireIsTypedArray();

		function uncurryThis(f) {
		  return f.call.bind(f);
		}

		var BigIntSupported = typeof BigInt !== 'undefined';
		var SymbolSupported = typeof Symbol !== 'undefined';

		var ObjectToString = uncurryThis(Object.prototype.toString);

		var numberValue = uncurryThis(Number.prototype.valueOf);
		var stringValue = uncurryThis(String.prototype.valueOf);
		var booleanValue = uncurryThis(Boolean.prototype.valueOf);

		if (BigIntSupported) {
		  var bigIntValue = uncurryThis(BigInt.prototype.valueOf);
		}

		if (SymbolSupported) {
		  var symbolValue = uncurryThis(Symbol.prototype.valueOf);
		}

		function checkBoxedPrimitive(value, prototypeValueOf) {
		  if (typeof value !== 'object') {
		    return false;
		  }
		  try {
		    prototypeValueOf(value);
		    return true;
		  } catch(e) {
		    return false;
		  }
		}

		exports.isArgumentsObject = isArgumentsObject;
		exports.isGeneratorFunction = isGeneratorFunction;
		exports.isTypedArray = isTypedArray;

		// Taken from here and modified for better browser support
		// https://github.com/sindresorhus/p-is-promise/blob/cda35a513bda03f977ad5cde3a079d237e82d7ef/index.js
		function isPromise(input) {
			return (
				(
					typeof Promise !== 'undefined' &&
					input instanceof Promise
				) ||
				(
					input !== null &&
					typeof input === 'object' &&
					typeof input.then === 'function' &&
					typeof input.catch === 'function'
				)
			);
		}
		exports.isPromise = isPromise;

		function isArrayBufferView(value) {
		  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
		    return ArrayBuffer.isView(value);
		  }

		  return (
		    isTypedArray(value) ||
		    isDataView(value)
		  );
		}
		exports.isArrayBufferView = isArrayBufferView;


		function isUint8Array(value) {
		  return whichTypedArray(value) === 'Uint8Array';
		}
		exports.isUint8Array = isUint8Array;

		function isUint8ClampedArray(value) {
		  return whichTypedArray(value) === 'Uint8ClampedArray';
		}
		exports.isUint8ClampedArray = isUint8ClampedArray;

		function isUint16Array(value) {
		  return whichTypedArray(value) === 'Uint16Array';
		}
		exports.isUint16Array = isUint16Array;

		function isUint32Array(value) {
		  return whichTypedArray(value) === 'Uint32Array';
		}
		exports.isUint32Array = isUint32Array;

		function isInt8Array(value) {
		  return whichTypedArray(value) === 'Int8Array';
		}
		exports.isInt8Array = isInt8Array;

		function isInt16Array(value) {
		  return whichTypedArray(value) === 'Int16Array';
		}
		exports.isInt16Array = isInt16Array;

		function isInt32Array(value) {
		  return whichTypedArray(value) === 'Int32Array';
		}
		exports.isInt32Array = isInt32Array;

		function isFloat32Array(value) {
		  return whichTypedArray(value) === 'Float32Array';
		}
		exports.isFloat32Array = isFloat32Array;

		function isFloat64Array(value) {
		  return whichTypedArray(value) === 'Float64Array';
		}
		exports.isFloat64Array = isFloat64Array;

		function isBigInt64Array(value) {
		  return whichTypedArray(value) === 'BigInt64Array';
		}
		exports.isBigInt64Array = isBigInt64Array;

		function isBigUint64Array(value) {
		  return whichTypedArray(value) === 'BigUint64Array';
		}
		exports.isBigUint64Array = isBigUint64Array;

		function isMapToString(value) {
		  return ObjectToString(value) === '[object Map]';
		}
		isMapToString.working = (
		  typeof Map !== 'undefined' &&
		  isMapToString(new Map())
		);

		function isMap(value) {
		  if (typeof Map === 'undefined') {
		    return false;
		  }

		  return isMapToString.working
		    ? isMapToString(value)
		    : value instanceof Map;
		}
		exports.isMap = isMap;

		function isSetToString(value) {
		  return ObjectToString(value) === '[object Set]';
		}
		isSetToString.working = (
		  typeof Set !== 'undefined' &&
		  isSetToString(new Set())
		);
		function isSet(value) {
		  if (typeof Set === 'undefined') {
		    return false;
		  }

		  return isSetToString.working
		    ? isSetToString(value)
		    : value instanceof Set;
		}
		exports.isSet = isSet;

		function isWeakMapToString(value) {
		  return ObjectToString(value) === '[object WeakMap]';
		}
		isWeakMapToString.working = (
		  typeof WeakMap !== 'undefined' &&
		  isWeakMapToString(new WeakMap())
		);
		function isWeakMap(value) {
		  if (typeof WeakMap === 'undefined') {
		    return false;
		  }

		  return isWeakMapToString.working
		    ? isWeakMapToString(value)
		    : value instanceof WeakMap;
		}
		exports.isWeakMap = isWeakMap;

		function isWeakSetToString(value) {
		  return ObjectToString(value) === '[object WeakSet]';
		}
		isWeakSetToString.working = (
		  typeof WeakSet !== 'undefined' &&
		  isWeakSetToString(new WeakSet())
		);
		function isWeakSet(value) {
		  return isWeakSetToString(value);
		}
		exports.isWeakSet = isWeakSet;

		function isArrayBufferToString(value) {
		  return ObjectToString(value) === '[object ArrayBuffer]';
		}
		isArrayBufferToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  isArrayBufferToString(new ArrayBuffer())
		);
		function isArrayBuffer(value) {
		  if (typeof ArrayBuffer === 'undefined') {
		    return false;
		  }

		  return isArrayBufferToString.working
		    ? isArrayBufferToString(value)
		    : value instanceof ArrayBuffer;
		}
		exports.isArrayBuffer = isArrayBuffer;

		function isDataViewToString(value) {
		  return ObjectToString(value) === '[object DataView]';
		}
		isDataViewToString.working = (
		  typeof ArrayBuffer !== 'undefined' &&
		  typeof DataView !== 'undefined' &&
		  isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1))
		);
		function isDataView(value) {
		  if (typeof DataView === 'undefined') {
		    return false;
		  }

		  return isDataViewToString.working
		    ? isDataViewToString(value)
		    : value instanceof DataView;
		}
		exports.isDataView = isDataView;

		// Store a copy of SharedArrayBuffer in case it's deleted elsewhere
		var SharedArrayBufferCopy = typeof SharedArrayBuffer !== 'undefined' ? SharedArrayBuffer : undefined;
		function isSharedArrayBufferToString(value) {
		  return ObjectToString(value) === '[object SharedArrayBuffer]';
		}
		function isSharedArrayBuffer(value) {
		  if (typeof SharedArrayBufferCopy === 'undefined') {
		    return false;
		  }

		  if (typeof isSharedArrayBufferToString.working === 'undefined') {
		    isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
		  }

		  return isSharedArrayBufferToString.working
		    ? isSharedArrayBufferToString(value)
		    : value instanceof SharedArrayBufferCopy;
		}
		exports.isSharedArrayBuffer = isSharedArrayBuffer;

		function isAsyncFunction(value) {
		  return ObjectToString(value) === '[object AsyncFunction]';
		}
		exports.isAsyncFunction = isAsyncFunction;

		function isMapIterator(value) {
		  return ObjectToString(value) === '[object Map Iterator]';
		}
		exports.isMapIterator = isMapIterator;

		function isSetIterator(value) {
		  return ObjectToString(value) === '[object Set Iterator]';
		}
		exports.isSetIterator = isSetIterator;

		function isGeneratorObject(value) {
		  return ObjectToString(value) === '[object Generator]';
		}
		exports.isGeneratorObject = isGeneratorObject;

		function isWebAssemblyCompiledModule(value) {
		  return ObjectToString(value) === '[object WebAssembly.Module]';
		}
		exports.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;

		function isNumberObject(value) {
		  return checkBoxedPrimitive(value, numberValue);
		}
		exports.isNumberObject = isNumberObject;

		function isStringObject(value) {
		  return checkBoxedPrimitive(value, stringValue);
		}
		exports.isStringObject = isStringObject;

		function isBooleanObject(value) {
		  return checkBoxedPrimitive(value, booleanValue);
		}
		exports.isBooleanObject = isBooleanObject;

		function isBigIntObject(value) {
		  return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
		}
		exports.isBigIntObject = isBigIntObject;

		function isSymbolObject(value) {
		  return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
		}
		exports.isSymbolObject = isSymbolObject;

		function isBoxedPrimitive(value) {
		  return (
		    isNumberObject(value) ||
		    isStringObject(value) ||
		    isBooleanObject(value) ||
		    isBigIntObject(value) ||
		    isSymbolObject(value)
		  );
		}
		exports.isBoxedPrimitive = isBoxedPrimitive;

		function isAnyArrayBuffer(value) {
		  return typeof Uint8Array !== 'undefined' && (
		    isArrayBuffer(value) ||
		    isSharedArrayBuffer(value)
		  );
		}
		exports.isAnyArrayBuffer = isAnyArrayBuffer;

		['isProxy', 'isExternal', 'isModuleNamespaceObject'].forEach(function(method) {
		  Object.defineProperty(exports, method, {
		    enumerable: false,
		    value: function() {
		      throw new Error(method + ' is not supported in userland');
		    }
		  });
		}); 
	} (types));
	return types;
}

var isBufferBrowser;
var hasRequiredIsBufferBrowser;

function requireIsBufferBrowser () {
	if (hasRequiredIsBufferBrowser) return isBufferBrowser;
	hasRequiredIsBufferBrowser = 1;
	isBufferBrowser = function isBuffer(arg) {
	  return arg && typeof arg === 'object'
	    && typeof arg.copy === 'function'
	    && typeof arg.fill === 'function'
	    && typeof arg.readUInt8 === 'function';
	};
	return isBufferBrowser;
}

var hasRequiredUtil$2;

function requireUtil$2 () {
	if (hasRequiredUtil$2) return util$2;
	hasRequiredUtil$2 = 1;
	(function (exports) {
		var define_process_env_default = {};
		var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
		  var keys = Object.keys(obj);
		  var descriptors = {};
		  for (var i = 0; i < keys.length; i++) {
		    descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
		  }
		  return descriptors;
		};
		var formatRegExp = /%[sdj%]/g;
		exports.format = function(f) {
		  if (!isString(f)) {
		    var objects = [];
		    for (var i = 0; i < arguments.length; i++) {
		      objects.push(inspect(arguments[i]));
		    }
		    return objects.join(" ");
		  }
		  var i = 1;
		  var args = arguments;
		  var len = args.length;
		  var str = String(f).replace(formatRegExp, function(x2) {
		    if (x2 === "%%") return "%";
		    if (i >= len) return x2;
		    switch (x2) {
		      case "%s":
		        return String(args[i++]);
		      case "%d":
		        return Number(args[i++]);
		      case "%j":
		        try {
		          return JSON.stringify(args[i++]);
		        } catch (_) {
		          return "[Circular]";
		        }
		      default:
		        return x2;
		    }
		  });
		  for (var x = args[i]; i < len; x = args[++i]) {
		    if (isNull(x) || !isObject(x)) {
		      str += " " + x;
		    } else {
		      str += " " + inspect(x);
		    }
		  }
		  return str;
		};
		exports.deprecate = function(fn, msg) {
		  if (typeof process$1 !== "undefined" && process$1.noDeprecation === true) {
		    return fn;
		  }
		  if (typeof process$1 === "undefined") {
		    return function() {
		      return exports.deprecate(fn, msg).apply(this, arguments);
		    };
		  }
		  var warned = false;
		  function deprecated() {
		    if (!warned) {
		      if (process$1.throwDeprecation) {
		        throw new Error(msg);
		      } else if (process$1.traceDeprecation) {
		        console.trace(msg);
		      } else {
		        console.error(msg);
		      }
		      warned = true;
		    }
		    return fn.apply(this, arguments);
		  }
		  return deprecated;
		};
		var debugs = {};
		var debugEnvRegex = /^$/;
		if (define_process_env_default.NODE_DEBUG) {
		  var debugEnv = define_process_env_default.NODE_DEBUG;
		  debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
		  debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
		}
		exports.debuglog = function(set) {
		  set = set.toUpperCase();
		  if (!debugs[set]) {
		    if (debugEnvRegex.test(set)) {
		      var pid = process$1.pid;
		      debugs[set] = function() {
		        var msg = exports.format.apply(exports, arguments);
		        console.error("%s %d: %s", set, pid, msg);
		      };
		    } else {
		      debugs[set] = function() {
		      };
		    }
		  }
		  return debugs[set];
		};
		function inspect(obj, opts) {
		  var ctx = {
		    seen: [],
		    stylize: stylizeNoColor
		  };
		  if (arguments.length >= 3) ctx.depth = arguments[2];
		  if (arguments.length >= 4) ctx.colors = arguments[3];
		  if (isBoolean(opts)) {
		    ctx.showHidden = opts;
		  } else if (opts) {
		    exports._extend(ctx, opts);
		  }
		  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
		  if (isUndefined(ctx.depth)) ctx.depth = 2;
		  if (isUndefined(ctx.colors)) ctx.colors = false;
		  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
		  if (ctx.colors) ctx.stylize = stylizeWithColor;
		  return formatValue(ctx, obj, ctx.depth);
		}
		exports.inspect = inspect;
		inspect.colors = {
		  "bold": [1, 22],
		  "italic": [3, 23],
		  "underline": [4, 24],
		  "inverse": [7, 27],
		  "white": [37, 39],
		  "grey": [90, 39],
		  "black": [30, 39],
		  "blue": [34, 39],
		  "cyan": [36, 39],
		  "green": [32, 39],
		  "magenta": [35, 39],
		  "red": [31, 39],
		  "yellow": [33, 39]
		};
		inspect.styles = {
		  "special": "cyan",
		  "number": "yellow",
		  "boolean": "yellow",
		  "undefined": "grey",
		  "null": "bold",
		  "string": "green",
		  "date": "magenta",
		  // "name": intentionally not styling
		  "regexp": "red"
		};
		function stylizeWithColor(str, styleType) {
		  var style = inspect.styles[styleType];
		  if (style) {
		    return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
		  } else {
		    return str;
		  }
		}
		function stylizeNoColor(str, styleType) {
		  return str;
		}
		function arrayToHash(array) {
		  var hash = {};
		  array.forEach(function(val, idx) {
		    hash[val] = true;
		  });
		  return hash;
		}
		function formatValue(ctx, value, recurseTimes) {
		  if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
		  value.inspect !== exports.inspect && // Also filter out any prototype objects using the circular check.
		  !(value.constructor && value.constructor.prototype === value)) {
		    var ret = value.inspect(recurseTimes, ctx);
		    if (!isString(ret)) {
		      ret = formatValue(ctx, ret, recurseTimes);
		    }
		    return ret;
		  }
		  var primitive = formatPrimitive(ctx, value);
		  if (primitive) {
		    return primitive;
		  }
		  var keys = Object.keys(value);
		  var visibleKeys = arrayToHash(keys);
		  if (ctx.showHidden) {
		    keys = Object.getOwnPropertyNames(value);
		  }
		  if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
		    return formatError(value);
		  }
		  if (keys.length === 0) {
		    if (isFunction(value)) {
		      var name = value.name ? ": " + value.name : "";
		      return ctx.stylize("[Function" + name + "]", "special");
		    }
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
		    }
		    if (isDate(value)) {
		      return ctx.stylize(Date.prototype.toString.call(value), "date");
		    }
		    if (isError(value)) {
		      return formatError(value);
		    }
		  }
		  var base = "", array = false, braces = ["{", "}"];
		  if (isArray(value)) {
		    array = true;
		    braces = ["[", "]"];
		  }
		  if (isFunction(value)) {
		    var n = value.name ? ": " + value.name : "";
		    base = " [Function" + n + "]";
		  }
		  if (isRegExp(value)) {
		    base = " " + RegExp.prototype.toString.call(value);
		  }
		  if (isDate(value)) {
		    base = " " + Date.prototype.toUTCString.call(value);
		  }
		  if (isError(value)) {
		    base = " " + formatError(value);
		  }
		  if (keys.length === 0 && (!array || value.length == 0)) {
		    return braces[0] + base + braces[1];
		  }
		  if (recurseTimes < 0) {
		    if (isRegExp(value)) {
		      return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
		    } else {
		      return ctx.stylize("[Object]", "special");
		    }
		  }
		  ctx.seen.push(value);
		  var output;
		  if (array) {
		    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
		  } else {
		    output = keys.map(function(key) {
		      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
		    });
		  }
		  ctx.seen.pop();
		  return reduceToSingleString(output, base, braces);
		}
		function formatPrimitive(ctx, value) {
		  if (isUndefined(value))
		    return ctx.stylize("undefined", "undefined");
		  if (isString(value)) {
		    var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
		    return ctx.stylize(simple, "string");
		  }
		  if (isNumber(value))
		    return ctx.stylize("" + value, "number");
		  if (isBoolean(value))
		    return ctx.stylize("" + value, "boolean");
		  if (isNull(value))
		    return ctx.stylize("null", "null");
		}
		function formatError(value) {
		  return "[" + Error.prototype.toString.call(value) + "]";
		}
		function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
		  var output = [];
		  for (var i = 0, l = value.length; i < l; ++i) {
		    if (hasOwnProperty(value, String(i))) {
		      output.push(formatProperty(
		        ctx,
		        value,
		        recurseTimes,
		        visibleKeys,
		        String(i),
		        true
		      ));
		    } else {
		      output.push("");
		    }
		  }
		  keys.forEach(function(key) {
		    if (!key.match(/^\d+$/)) {
		      output.push(formatProperty(
		        ctx,
		        value,
		        recurseTimes,
		        visibleKeys,
		        key,
		        true
		      ));
		    }
		  });
		  return output;
		}
		function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
		  var name, str, desc;
		  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
		  if (desc.get) {
		    if (desc.set) {
		      str = ctx.stylize("[Getter/Setter]", "special");
		    } else {
		      str = ctx.stylize("[Getter]", "special");
		    }
		  } else {
		    if (desc.set) {
		      str = ctx.stylize("[Setter]", "special");
		    }
		  }
		  if (!hasOwnProperty(visibleKeys, key)) {
		    name = "[" + key + "]";
		  }
		  if (!str) {
		    if (ctx.seen.indexOf(desc.value) < 0) {
		      if (isNull(recurseTimes)) {
		        str = formatValue(ctx, desc.value, null);
		      } else {
		        str = formatValue(ctx, desc.value, recurseTimes - 1);
		      }
		      if (str.indexOf("\n") > -1) {
		        if (array) {
		          str = str.split("\n").map(function(line) {
		            return "  " + line;
		          }).join("\n").slice(2);
		        } else {
		          str = "\n" + str.split("\n").map(function(line) {
		            return "   " + line;
		          }).join("\n");
		        }
		      }
		    } else {
		      str = ctx.stylize("[Circular]", "special");
		    }
		  }
		  if (isUndefined(name)) {
		    if (array && key.match(/^\d+$/)) {
		      return str;
		    }
		    name = JSON.stringify("" + key);
		    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
		      name = name.slice(1, -1);
		      name = ctx.stylize(name, "name");
		    } else {
		      name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
		      name = ctx.stylize(name, "string");
		    }
		  }
		  return name + ": " + str;
		}
		function reduceToSingleString(output, base, braces) {
		  var length = output.reduce(function(prev, cur) {
		    if (cur.indexOf("\n") >= 0) ;
		    return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
		  }, 0);
		  if (length > 60) {
		    return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
		  }
		  return braces[0] + base + " " + output.join(", ") + " " + braces[1];
		}
		exports.types = requireTypes();
		function isArray(ar) {
		  return Array.isArray(ar);
		}
		exports.isArray = isArray;
		function isBoolean(arg) {
		  return typeof arg === "boolean";
		}
		exports.isBoolean = isBoolean;
		function isNull(arg) {
		  return arg === null;
		}
		exports.isNull = isNull;
		function isNullOrUndefined(arg) {
		  return arg == null;
		}
		exports.isNullOrUndefined = isNullOrUndefined;
		function isNumber(arg) {
		  return typeof arg === "number";
		}
		exports.isNumber = isNumber;
		function isString(arg) {
		  return typeof arg === "string";
		}
		exports.isString = isString;
		function isSymbol(arg) {
		  return typeof arg === "symbol";
		}
		exports.isSymbol = isSymbol;
		function isUndefined(arg) {
		  return arg === void 0;
		}
		exports.isUndefined = isUndefined;
		function isRegExp(re) {
		  return isObject(re) && objectToString(re) === "[object RegExp]";
		}
		exports.isRegExp = isRegExp;
		exports.types.isRegExp = isRegExp;
		function isObject(arg) {
		  return typeof arg === "object" && arg !== null;
		}
		exports.isObject = isObject;
		function isDate(d) {
		  return isObject(d) && objectToString(d) === "[object Date]";
		}
		exports.isDate = isDate;
		exports.types.isDate = isDate;
		function isError(e) {
		  return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
		}
		exports.isError = isError;
		exports.types.isNativeError = isError;
		function isFunction(arg) {
		  return typeof arg === "function";
		}
		exports.isFunction = isFunction;
		function isPrimitive(arg) {
		  return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
		  typeof arg === "undefined";
		}
		exports.isPrimitive = isPrimitive;
		exports.isBuffer = requireIsBufferBrowser();
		function objectToString(o) {
		  return Object.prototype.toString.call(o);
		}
		function pad(n) {
		  return n < 10 ? "0" + n.toString(10) : n.toString(10);
		}
		var months = [
		  "Jan",
		  "Feb",
		  "Mar",
		  "Apr",
		  "May",
		  "Jun",
		  "Jul",
		  "Aug",
		  "Sep",
		  "Oct",
		  "Nov",
		  "Dec"
		];
		function timestamp() {
		  var d = /* @__PURE__ */ new Date();
		  var time = [
		    pad(d.getHours()),
		    pad(d.getMinutes()),
		    pad(d.getSeconds())
		  ].join(":");
		  return [d.getDate(), months[d.getMonth()], time].join(" ");
		}
		exports.log = function() {
		  console.log("%s - %s", timestamp(), exports.format.apply(exports, arguments));
		};
		exports.inherits = requireInherits_browser();
		exports._extend = function(origin, add) {
		  if (!add || !isObject(add)) return origin;
		  var keys = Object.keys(add);
		  var i = keys.length;
		  while (i--) {
		    origin[keys[i]] = add[keys[i]];
		  }
		  return origin;
		};
		function hasOwnProperty(obj, prop) {
		  return Object.prototype.hasOwnProperty.call(obj, prop);
		}
		var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
		exports.promisify = function promisify(original) {
		  if (typeof original !== "function")
		    throw new TypeError('The "original" argument must be of type Function');
		  if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
		    var fn = original[kCustomPromisifiedSymbol];
		    if (typeof fn !== "function") {
		      throw new TypeError('The "util.promisify.custom" argument must be of type Function');
		    }
		    Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		      value: fn,
		      enumerable: false,
		      writable: false,
		      configurable: true
		    });
		    return fn;
		  }
		  function fn() {
		    var promiseResolve, promiseReject;
		    var promise = new Promise(function(resolve, reject) {
		      promiseResolve = resolve;
		      promiseReject = reject;
		    });
		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }
		    args.push(function(err, value) {
		      if (err) {
		        promiseReject(err);
		      } else {
		        promiseResolve(value);
		      }
		    });
		    try {
		      original.apply(this, args);
		    } catch (err) {
		      promiseReject(err);
		    }
		    return promise;
		  }
		  Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
		  if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
		    value: fn,
		    enumerable: false,
		    writable: false,
		    configurable: true
		  });
		  return Object.defineProperties(
		    fn,
		    getOwnPropertyDescriptors(original)
		  );
		};
		exports.promisify.custom = kCustomPromisifiedSymbol;
		function callbackifyOnRejected(reason, cb) {
		  if (!reason) {
		    var newReason = new Error("Promise was rejected with a falsy value");
		    newReason.reason = reason;
		    reason = newReason;
		  }
		  return cb(reason);
		}
		function callbackify(original) {
		  if (typeof original !== "function") {
		    throw new TypeError('The "original" argument must be of type Function');
		  }
		  function callbackified() {
		    var args = [];
		    for (var i = 0; i < arguments.length; i++) {
		      args.push(arguments[i]);
		    }
		    var maybeCb = args.pop();
		    if (typeof maybeCb !== "function") {
		      throw new TypeError("The last argument must be of type Function");
		    }
		    var self = this;
		    var cb = function() {
		      return maybeCb.apply(self, arguments);
		    };
		    original.apply(this, args).then(
		      function(ret) {
		        process$1.nextTick(cb.bind(null, null, ret));
		      },
		      function(rej) {
		        process$1.nextTick(callbackifyOnRejected.bind(null, rej, cb));
		      }
		    );
		  }
		  Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
		  Object.defineProperties(
		    callbackified,
		    getOwnPropertyDescriptors(original)
		  );
		  return callbackified;
		}
		exports.callbackify = callbackify; 
	} (util$2));
	return util$2;
}

var buffer_list;
var hasRequiredBuffer_list;

function requireBuffer_list () {
	if (hasRequiredBuffer_list) return buffer_list;
	hasRequiredBuffer_list = 1;

	function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
	function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
	function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (String )(input); }
	var _require = requireDist(),
	  Buffer = _require.Buffer;
	var _require2 = requireUtil$2(),
	  inspect = _require2.inspect;
	var custom = inspect && inspect.custom || 'inspect';
	function copyBuffer(src, target, offset) {
	  Buffer.prototype.copy.call(src, target, offset);
	}
	buffer_list = /*#__PURE__*/function () {
	  function BufferList() {
	    _classCallCheck(this, BufferList);
	    this.head = null;
	    this.tail = null;
	    this.length = 0;
	  }
	  _createClass(BufferList, [{
	    key: "push",
	    value: function push(v) {
	      var entry = {
	        data: v,
	        next: null
	      };
	      if (this.length > 0) this.tail.next = entry;else this.head = entry;
	      this.tail = entry;
	      ++this.length;
	    }
	  }, {
	    key: "unshift",
	    value: function unshift(v) {
	      var entry = {
	        data: v,
	        next: this.head
	      };
	      if (this.length === 0) this.tail = entry;
	      this.head = entry;
	      ++this.length;
	    }
	  }, {
	    key: "shift",
	    value: function shift() {
	      if (this.length === 0) return;
	      var ret = this.head.data;
	      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
	      --this.length;
	      return ret;
	    }
	  }, {
	    key: "clear",
	    value: function clear() {
	      this.head = this.tail = null;
	      this.length = 0;
	    }
	  }, {
	    key: "join",
	    value: function join(s) {
	      if (this.length === 0) return '';
	      var p = this.head;
	      var ret = '' + p.data;
	      while (p = p.next) ret += s + p.data;
	      return ret;
	    }
	  }, {
	    key: "concat",
	    value: function concat(n) {
	      if (this.length === 0) return Buffer.alloc(0);
	      var ret = Buffer.allocUnsafe(n >>> 0);
	      var p = this.head;
	      var i = 0;
	      while (p) {
	        copyBuffer(p.data, ret, i);
	        i += p.data.length;
	        p = p.next;
	      }
	      return ret;
	    }

	    // Consumes a specified amount of bytes or characters from the buffered data.
	  }, {
	    key: "consume",
	    value: function consume(n, hasStrings) {
	      var ret;
	      if (n < this.head.data.length) {
	        // `slice` is the same for buffers and strings.
	        ret = this.head.data.slice(0, n);
	        this.head.data = this.head.data.slice(n);
	      } else if (n === this.head.data.length) {
	        // First chunk is a perfect match.
	        ret = this.shift();
	      } else {
	        // Result spans more than one buffer.
	        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
	      }
	      return ret;
	    }
	  }, {
	    key: "first",
	    value: function first() {
	      return this.head.data;
	    }

	    // Consumes a specified amount of characters from the buffered data.
	  }, {
	    key: "_getString",
	    value: function _getString(n) {
	      var p = this.head;
	      var c = 1;
	      var ret = p.data;
	      n -= ret.length;
	      while (p = p.next) {
	        var str = p.data;
	        var nb = n > str.length ? str.length : n;
	        if (nb === str.length) ret += str;else ret += str.slice(0, n);
	        n -= nb;
	        if (n === 0) {
	          if (nb === str.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = str.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Consumes a specified amount of bytes from the buffered data.
	  }, {
	    key: "_getBuffer",
	    value: function _getBuffer(n) {
	      var ret = Buffer.allocUnsafe(n);
	      var p = this.head;
	      var c = 1;
	      p.data.copy(ret);
	      n -= p.data.length;
	      while (p = p.next) {
	        var buf = p.data;
	        var nb = n > buf.length ? buf.length : n;
	        buf.copy(ret, ret.length - n, 0, nb);
	        n -= nb;
	        if (n === 0) {
	          if (nb === buf.length) {
	            ++c;
	            if (p.next) this.head = p.next;else this.head = this.tail = null;
	          } else {
	            this.head = p;
	            p.data = buf.slice(nb);
	          }
	          break;
	        }
	        ++c;
	      }
	      this.length -= c;
	      return ret;
	    }

	    // Make sure the linked list only shows the minimal necessary information.
	  }, {
	    key: custom,
	    value: function value(_, options) {
	      return inspect(this, _objectSpread(_objectSpread({}, options), {}, {
	        // Only inspect one level.
	        depth: 0,
	        // It should not recurse.
	        customInspect: false
	      }));
	    }
	  }]);
	  return BufferList;
	}();
	return buffer_list;
}

var destroy_1$1;
var hasRequiredDestroy$1;

function requireDestroy$1 () {
	if (hasRequiredDestroy$1) return destroy_1$1;
	hasRequiredDestroy$1 = 1;

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;
	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;
	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        process$1.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        process$1.nextTick(emitErrorNT, this, err);
	      }
	    }
	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }
	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        process$1.nextTick(emitErrorAndCloseNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        process$1.nextTick(emitErrorAndCloseNT, _this, err);
	      } else {
	        process$1.nextTick(emitCloseNT, _this);
	      }
	    } else if (cb) {
	      process$1.nextTick(emitCloseNT, _this);
	      cb(err);
	    } else {
	      process$1.nextTick(emitCloseNT, _this);
	    }
	  });
	  return this;
	}
	function emitErrorAndCloseNT(self, err) {
	  emitErrorNT(self, err);
	  emitCloseNT(self);
	}
	function emitCloseNT(self) {
	  if (self._writableState && !self._writableState.emitClose) return;
	  if (self._readableState && !self._readableState.emitClose) return;
	  self.emit('close');
	}
	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }
	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}
	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}
	function errorOrDestroy(stream, err) {
	  // We have tests that rely on errors being emitted
	  // in the same tick, so changing this is semver major.
	  // For now when you opt-in to autoDestroy we allow
	  // the error to be emitted nextTick. In a future
	  // semver major update we should change the default to this.

	  var rState = stream._readableState;
	  var wState = stream._writableState;
	  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
	}
	destroy_1$1 = {
	  destroy: destroy,
	  undestroy: undestroy,
	  errorOrDestroy: errorOrDestroy
	};
	return destroy_1$1;
}

var errorsBrowser = {};

var hasRequiredErrorsBrowser;

function requireErrorsBrowser () {
	if (hasRequiredErrorsBrowser) return errorsBrowser;
	hasRequiredErrorsBrowser = 1;

	function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

	var codes = {};

	function createErrorType(code, message, Base) {
	  if (!Base) {
	    Base = Error;
	  }

	  function getMessage(arg1, arg2, arg3) {
	    if (typeof message === 'string') {
	      return message;
	    } else {
	      return message(arg1, arg2, arg3);
	    }
	  }

	  var NodeError =
	  /*#__PURE__*/
	  function (_Base) {
	    _inheritsLoose(NodeError, _Base);

	    function NodeError(arg1, arg2, arg3) {
	      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
	    }

	    return NodeError;
	  }(Base);

	  NodeError.prototype.name = Base.name;
	  NodeError.prototype.code = code;
	  codes[code] = NodeError;
	} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


	function oneOf(expected, thing) {
	  if (Array.isArray(expected)) {
	    var len = expected.length;
	    expected = expected.map(function (i) {
	      return String(i);
	    });

	    if (len > 2) {
	      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
	    } else if (len === 2) {
	      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
	    } else {
	      return "of ".concat(thing, " ").concat(expected[0]);
	    }
	  } else {
	    return "of ".concat(thing, " ").concat(String(expected));
	  }
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


	function startsWith(str, search, pos) {
	  return str.substr(0 , search.length) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


	function endsWith(str, search, this_len) {
	  if (this_len === undefined || this_len > str.length) {
	    this_len = str.length;
	  }

	  return str.substring(this_len - search.length, this_len) === search;
	} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


	function includes(str, search, start) {
	  if (typeof start !== 'number') {
	    start = 0;
	  }

	  if (start + search.length > str.length) {
	    return false;
	  } else {
	    return str.indexOf(search, start) !== -1;
	  }
	}

	createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
	  return 'The value "' + value + '" is invalid for option "' + name + '"';
	}, TypeError);
	createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
	  // determiner: 'must be' or 'must not be'
	  var determiner;

	  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
	    determiner = 'must not be';
	    expected = expected.replace(/^not /, '');
	  } else {
	    determiner = 'must be';
	  }

	  var msg;

	  if (endsWith(name, ' argument')) {
	    // For cases like 'first argument'
	    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  } else {
	    var type = includes(name, '.') ? 'property' : 'argument';
	    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
	  }

	  msg += ". Received type ".concat(typeof actual);
	  return msg;
	}, TypeError);
	createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
	createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
	  return 'The ' + name + ' method is not implemented';
	});
	createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
	createErrorType('ERR_STREAM_DESTROYED', function (name) {
	  return 'Cannot call ' + name + ' after a stream was destroyed';
	});
	createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
	createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
	createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
	createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
	createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
	  return 'Unknown encoding: ' + arg;
	}, TypeError);
	createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
	errorsBrowser.codes = codes;
	return errorsBrowser;
}

var state;
var hasRequiredState;

function requireState () {
	if (hasRequiredState) return state;
	hasRequiredState = 1;

	var ERR_INVALID_OPT_VALUE = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
	function highWaterMarkFrom(options, isDuplex, duplexKey) {
	  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
	}
	function getHighWaterMark(state, options, duplexKey, isDuplex) {
	  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
	  if (hwm != null) {
	    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
	      var name = isDuplex ? duplexKey : 'highWaterMark';
	      throw new ERR_INVALID_OPT_VALUE(name, hwm);
	    }
	    return Math.floor(hwm);
	  }

	  // Default value
	  return state.objectMode ? 16 : 16 * 1024;
	}
	state = {
	  getHighWaterMark: getHighWaterMark
	};
	return state;
}

var browser$b;
var hasRequiredBrowser$c;

function requireBrowser$c () {
	if (hasRequiredBrowser$c) return browser$b;
	hasRequiredBrowser$c = 1;
	/**
	 * Module exports.
	 */

	browser$b = deprecate;

	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */

	function deprecate (fn, msg) {
	  if (config('noDeprecation')) {
	    return fn;
	  }

	  var warned = false;
	  function deprecated() {
	    if (!warned) {
	      if (config('throwDeprecation')) {
	        throw new Error(msg);
	      } else if (config('traceDeprecation')) {
	        console.trace(msg);
	      } else {
	        console.warn(msg);
	      }
	      warned = true;
	    }
	    return fn.apply(this, arguments);
	  }

	  return deprecated;
	}

	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */

	function config (name) {
	  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
	  try {
	    if (!commonjsGlobal.localStorage) return false;
	  } catch (_) {
	    return false;
	  }
	  var val = commonjsGlobal.localStorage[name];
	  if (null == val) return false;
	  return String(val).toLowerCase() === 'true';
	}
	return browser$b;
}

var _stream_writable$2;
var hasRequired_stream_writable$2;

function require_stream_writable$2 () {
	if (hasRequired_stream_writable$2) return _stream_writable$2;
	hasRequired_stream_writable$2 = 1;

	_stream_writable$2 = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;
	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireBrowser$c()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStreamBrowser$1();
	/*</replacement>*/

	var Buffer = requireDist().Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	var destroyImpl = requireDestroy$1();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
	  ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
	  ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
	  ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	requireInherits_browser()(Writable, Stream);
	function nop() {}
	function WritableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex$2();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream,
	  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;
	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'finish' (and potentially 'end')
	  this.autoDestroy = !!options.autoDestroy;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}
	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};
	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function writableStateBufferGetter() {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function value(object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;
	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function realHasInstance(object) {
	    return object instanceof this;
	  };
	}
	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex$2();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the WritableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
	  this._writableState = new WritableState(options, this, isDuplex);

	  // legacy.
	  this.writable = true;
	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;
	    if (typeof options.writev === 'function') this._writev = options.writev;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	    if (typeof options.final === 'function') this._final = options.final;
	  }
	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
	};
	function writeAfterEnd(stream, cb) {
	  var er = new ERR_STREAM_WRITE_AFTER_END();
	  // TODO: defer error events consistently everywhere, not just the cb
	  errorOrDestroy(stream, er);
	  process$1.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var er;
	  if (chunk === null) {
	    er = new ERR_STREAM_NULL_VALUES();
	  } else if (typeof chunk !== 'string' && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
	  }
	  if (er) {
	    errorOrDestroy(stream, er);
	    process$1.nextTick(cb, er);
	    return false;
	  }
	  return true;
	}
	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);
	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }
	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	  if (typeof cb !== 'function') cb = nop;
	  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }
	  return ret;
	};
	Writable.prototype.cork = function () {
	  this._writableState.corked++;
	};
	Writable.prototype.uncork = function () {
	  var state = this._writableState;
	  if (state.corked) {
	    state.corked--;
	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;
	  state.length += len;
	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;
	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }
	  return ret;
	}
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}
	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;
	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    process$1.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    process$1.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    errorOrDestroy(stream, er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}
	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}
	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;
	  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
	  onwriteStateUpdate(state);
	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state) || stream.destroyed;
	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }
	    if (sync) {
	      process$1.nextTick(afterWrite, stream, state, finished, cb);
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}
	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;
	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;
	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;
	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;
	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }
	    if (entry === null) state.lastBufferedRequest = null;
	  }
	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}
	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
	};
	Writable.prototype._writev = null;
	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }
	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	  return this;
	};
	Object.defineProperty(Writable.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});
	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      errorOrDestroy(stream, err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function' && !state.destroyed) {
	      state.pendingcb++;
	      state.finalCalled = true;
	      process$1.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}
	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	      if (state.autoDestroy) {
	        // In case of duplex streams we need a way to detect
	        // if the readable side is ready for autoDestroy as well
	        var rState = stream._readableState;
	        if (!rState || rState.autoDestroy && rState.endEmitted) {
	          stream.destroy();
	        }
	      }
	    }
	  }
	  return need;
	}
	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) process$1.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}
	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}
	Object.defineProperty(Writable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  cb(err);
	};
	return _stream_writable$2;
}

var _stream_duplex$2;
var hasRequired_stream_duplex$2;

function require_stream_duplex$2 () {
	if (hasRequired_stream_duplex$2) return _stream_duplex$2;
	hasRequired_stream_duplex$2 = 1;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/

	_stream_duplex$2 = Duplex;
	var Readable = require_stream_readable$2();
	var Writable = require_stream_writable$2();
	requireInherits_browser()(Duplex, Readable);
	{
	  // Allow the keys array to be GC'ed.
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}
	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);
	  Readable.call(this, options);
	  Writable.call(this, options);
	  this.allowHalfOpen = true;
	  if (options) {
	    if (options.readable === false) this.readable = false;
	    if (options.writable === false) this.writable = false;
	    if (options.allowHalfOpen === false) {
	      this.allowHalfOpen = false;
	      this.once('end', onend);
	    }
	  }
	}
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.highWaterMark;
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState && this._writableState.getBuffer();
	  }
	});
	Object.defineProperty(Duplex.prototype, 'writableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._writableState.length;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // If the writable side ended, then we're ok.
	  if (this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process$1.nextTick(onEndNT, this);
	}
	function onEndNT(self) {
	  self.end();
	}
	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});
	return _stream_duplex$2;
}

var string_decoder$2 = {};

var safeBuffer$2 = {exports: {}};

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var hasRequiredSafeBuffer$2;

function requireSafeBuffer$2 () {
	if (hasRequiredSafeBuffer$2) return safeBuffer$2.exports;
	hasRequiredSafeBuffer$2 = 1;
	(function (module, exports) {
		/* eslint-disable node/no-deprecated-api */
		var buffer = requireDist();
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		SafeBuffer.prototype = Object.create(Buffer.prototype);

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer$2, safeBuffer$2.exports));
	return safeBuffer$2.exports;
}

var hasRequiredString_decoder$2;

function requireString_decoder$2 () {
	if (hasRequiredString_decoder$2) return string_decoder$2;
	hasRequiredString_decoder$2 = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer$2().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder$2.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder$2;
}

var endOfStream;
var hasRequiredEndOfStream;

function requireEndOfStream () {
	if (hasRequiredEndOfStream) return endOfStream;
	hasRequiredEndOfStream = 1;

	var ERR_STREAM_PREMATURE_CLOSE = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	    callback.apply(this, args);
	  };
	}
	function noop() {}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function eos(stream, opts, callback) {
	  if (typeof opts === 'function') return eos(stream, null, opts);
	  if (!opts) opts = {};
	  callback = once(callback || noop);
	  var readable = opts.readable || opts.readable !== false && stream.readable;
	  var writable = opts.writable || opts.writable !== false && stream.writable;
	  var onlegacyfinish = function onlegacyfinish() {
	    if (!stream.writable) onfinish();
	  };
	  var writableEnded = stream._writableState && stream._writableState.finished;
	  var onfinish = function onfinish() {
	    writable = false;
	    writableEnded = true;
	    if (!readable) callback.call(stream);
	  };
	  var readableEnded = stream._readableState && stream._readableState.endEmitted;
	  var onend = function onend() {
	    readable = false;
	    readableEnded = true;
	    if (!writable) callback.call(stream);
	  };
	  var onerror = function onerror(err) {
	    callback.call(stream, err);
	  };
	  var onclose = function onclose() {
	    var err;
	    if (readable && !readableEnded) {
	      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	    if (writable && !writableEnded) {
	      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
	      return callback.call(stream, err);
	    }
	  };
	  var onrequest = function onrequest() {
	    stream.req.on('finish', onfinish);
	  };
	  if (isRequest(stream)) {
	    stream.on('complete', onfinish);
	    stream.on('abort', onclose);
	    if (stream.req) onrequest();else stream.on('request', onrequest);
	  } else if (writable && !stream._writableState) {
	    // legacy streams
	    stream.on('end', onlegacyfinish);
	    stream.on('close', onlegacyfinish);
	  }
	  stream.on('end', onend);
	  stream.on('finish', onfinish);
	  if (opts.error !== false) stream.on('error', onerror);
	  stream.on('close', onclose);
	  return function () {
	    stream.removeListener('complete', onfinish);
	    stream.removeListener('abort', onclose);
	    stream.removeListener('request', onrequest);
	    if (stream.req) stream.req.removeListener('finish', onfinish);
	    stream.removeListener('end', onlegacyfinish);
	    stream.removeListener('close', onlegacyfinish);
	    stream.removeListener('finish', onfinish);
	    stream.removeListener('end', onend);
	    stream.removeListener('error', onerror);
	    stream.removeListener('close', onclose);
	  };
	}
	endOfStream = eos;
	return endOfStream;
}

var async_iterator;
var hasRequiredAsync_iterator;

function requireAsync_iterator () {
	if (hasRequiredAsync_iterator) return async_iterator;
	hasRequiredAsync_iterator = 1;

	var _Object$setPrototypeO;
	function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
	function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
	function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
	var finished = requireEndOfStream();
	var kLastResolve = Symbol('lastResolve');
	var kLastReject = Symbol('lastReject');
	var kError = Symbol('error');
	var kEnded = Symbol('ended');
	var kLastPromise = Symbol('lastPromise');
	var kHandlePromise = Symbol('handlePromise');
	var kStream = Symbol('stream');
	function createIterResult(value, done) {
	  return {
	    value: value,
	    done: done
	  };
	}
	function readAndResolve(iter) {
	  var resolve = iter[kLastResolve];
	  if (resolve !== null) {
	    var data = iter[kStream].read();
	    // we defer if data is null
	    // we can be expecting either 'end' or
	    // 'error'
	    if (data !== null) {
	      iter[kLastPromise] = null;
	      iter[kLastResolve] = null;
	      iter[kLastReject] = null;
	      resolve(createIterResult(data, false));
	    }
	  }
	}
	function onReadable(iter) {
	  // we wait for the next tick, because it might
	  // emit an error with process.nextTick
	  process$1.nextTick(readAndResolve, iter);
	}
	function wrapForNext(lastPromise, iter) {
	  return function (resolve, reject) {
	    lastPromise.then(function () {
	      if (iter[kEnded]) {
	        resolve(createIterResult(undefined, true));
	        return;
	      }
	      iter[kHandlePromise](resolve, reject);
	    }, reject);
	  };
	}
	var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
	var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
	  get stream() {
	    return this[kStream];
	  },
	  next: function next() {
	    var _this = this;
	    // if we have detected an error in the meanwhile
	    // reject straight away
	    var error = this[kError];
	    if (error !== null) {
	      return Promise.reject(error);
	    }
	    if (this[kEnded]) {
	      return Promise.resolve(createIterResult(undefined, true));
	    }
	    if (this[kStream].destroyed) {
	      // We need to defer via nextTick because if .destroy(err) is
	      // called, the error will be emitted via nextTick, and
	      // we cannot guarantee that there is no error lingering around
	      // waiting to be emitted.
	      return new Promise(function (resolve, reject) {
	        process$1.nextTick(function () {
	          if (_this[kError]) {
	            reject(_this[kError]);
	          } else {
	            resolve(createIterResult(undefined, true));
	          }
	        });
	      });
	    }

	    // if we have multiple next() calls
	    // we will wait for the previous Promise to finish
	    // this logic is optimized to support for await loops,
	    // where next() is only called once at a time
	    var lastPromise = this[kLastPromise];
	    var promise;
	    if (lastPromise) {
	      promise = new Promise(wrapForNext(lastPromise, this));
	    } else {
	      // fast path needed to support multiple this.push()
	      // without triggering the next() queue
	      var data = this[kStream].read();
	      if (data !== null) {
	        return Promise.resolve(createIterResult(data, false));
	      }
	      promise = new Promise(this[kHandlePromise]);
	    }
	    this[kLastPromise] = promise;
	    return promise;
	  }
	}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
	  return this;
	}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
	  var _this2 = this;
	  // destroy(err, cb) is a private API
	  // we can guarantee we have that here, because we control the
	  // Readable class this is attached to
	  return new Promise(function (resolve, reject) {
	    _this2[kStream].destroy(null, function (err) {
	      if (err) {
	        reject(err);
	        return;
	      }
	      resolve(createIterResult(undefined, true));
	    });
	  });
	}), _Object$setPrototypeO), AsyncIteratorPrototype);
	var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
	  var _Object$create;
	  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
	    value: stream,
	    writable: true
	  }), _defineProperty(_Object$create, kLastResolve, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kLastReject, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kError, {
	    value: null,
	    writable: true
	  }), _defineProperty(_Object$create, kEnded, {
	    value: stream._readableState.endEmitted,
	    writable: true
	  }), _defineProperty(_Object$create, kHandlePromise, {
	    value: function value(resolve, reject) {
	      var data = iterator[kStream].read();
	      if (data) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        resolve(createIterResult(data, false));
	      } else {
	        iterator[kLastResolve] = resolve;
	        iterator[kLastReject] = reject;
	      }
	    },
	    writable: true
	  }), _Object$create));
	  iterator[kLastPromise] = null;
	  finished(stream, function (err) {
	    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
	      var reject = iterator[kLastReject];
	      // reject if we are waiting for data in the Promise
	      // returned by next() and store the error
	      if (reject !== null) {
	        iterator[kLastPromise] = null;
	        iterator[kLastResolve] = null;
	        iterator[kLastReject] = null;
	        reject(err);
	      }
	      iterator[kError] = err;
	      return;
	    }
	    var resolve = iterator[kLastResolve];
	    if (resolve !== null) {
	      iterator[kLastPromise] = null;
	      iterator[kLastResolve] = null;
	      iterator[kLastReject] = null;
	      resolve(createIterResult(undefined, true));
	    }
	    iterator[kEnded] = true;
	  });
	  stream.on('readable', onReadable.bind(null, iterator));
	  return iterator;
	};
	async_iterator = createReadableStreamAsyncIterator;
	return async_iterator;
}

var fromBrowser;
var hasRequiredFromBrowser;

function requireFromBrowser () {
	if (hasRequiredFromBrowser) return fromBrowser;
	hasRequiredFromBrowser = 1;
	fromBrowser = function () {
	  throw new Error('Readable.from is not available in the browser')
	};
	return fromBrowser;
}

var _stream_readable$2;
var hasRequired_stream_readable$2;

function require_stream_readable$2 () {
	if (hasRequired_stream_readable$2) return _stream_readable$2;
	hasRequired_stream_readable$2 = 1;

	_stream_readable$2 = Readable;

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	requireEvents().EventEmitter;
	var EElistenerCount = function EElistenerCount(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStreamBrowser$1();
	/*</replacement>*/

	var Buffer = requireDist().Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*<replacement>*/
	var debugUtil = requireUtil$2();
	var debug;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function debug() {};
	}
	/*</replacement>*/

	var BufferList = requireBuffer_list();
	var destroyImpl = requireDestroy$1();
	var _require = requireState(),
	  getHighWaterMark = _require.getHighWaterMark;
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
	  ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;

	// Lazy loaded to improve the startup performance.
	var StringDecoder;
	var createReadableStreamAsyncIterator;
	var from;
	requireInherits_browser()(Readable, Stream);
	var errorOrDestroy = destroyImpl.errorOrDestroy;
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	function ReadableState(options, stream, isDuplex) {
	  Duplex = Duplex || require_stream_duplex$2();
	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;
	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;
	  this.paused = true;

	  // Should close be emitted on destroy. Defaults to true.
	  this.emitClose = options.emitClose !== false;

	  // Should .destroy() be called after 'end' (and potentially 'finish')
	  this.autoDestroy = !!options.autoDestroy;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;
	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder$2().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}
	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex$2();
	  if (!(this instanceof Readable)) return new Readable(options);

	  // Checking for a Stream.Duplex instance is faster here instead of inside
	  // the ReadableState constructor, at least with V8 6.5
	  var isDuplex = this instanceof Duplex;
	  this._readableState = new ReadableState(options, this, isDuplex);

	  // legacy
	  this.readable = true;
	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;
	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }
	  Stream.call(this);
	}
	Object.defineProperty(Readable.prototype, 'destroyed', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function set(value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;
	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }
	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  debug('readableAddChunk', chunk);
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      errorOrDestroy(stream, er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }
	      if (addToFront) {
	        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
	      } else if (state.destroyed) {
	        return false;
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	      maybeReadMore(stream, state);
	    }
	  }

	  // We can push more data if we are below the highWaterMark.
	  // Also, if we have no data yet, we can stand some more bytes.
	  // This is to work around cases where hwm=0, such as the repl.
	  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
	}
	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    state.awaitDrain = 0;
	    stream.emit('data', chunk);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}
	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
	  }
	  return er;
	}
	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder$2().StringDecoder;
	  var decoder = new StringDecoder(enc);
	  this._readableState.decoder = decoder;
	  // If setEncoding(null), decoder.encoding equals utf8
	  this._readableState.encoding = this._readableState.decoder.encoding;

	  // Iterate over current buffer to convert already stored Buffers:
	  var p = this._readableState.buffer.head;
	  var content = '';
	  while (p !== null) {
	    content += decoder.write(p.data);
	    p = p.next;
	  }
	  this._readableState.buffer.clear();
	  if (content !== '') this._readableState.buffer.push(content);
	  this._readableState.length = content.length;
	  return this;
	};

	// Don't raise the hwm > 1GB
	var MAX_HWM = 0x40000000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;
	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }
	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }
	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;
	  if (ret === null) {
	    state.needReadable = state.length <= state.highWaterMark;
	    n = 0;
	  } else {
	    state.length -= n;
	    state.awaitDrain = 0;
	  }
	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }
	  if (ret !== null) this.emit('data', ret);
	  return ret;
	};
	function onEofChunk(stream, state) {
	  debug('onEofChunk');
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;
	  if (state.sync) {
	    // if we are sync, wait until next tick to emit the data.
	    // Otherwise we risk emitting data in the flow()
	    // the readable code triggers during a read() call
	    emitReadable(stream);
	  } else {
	    // emit 'readable' now to make sure it gets picked up.
	    state.needReadable = false;
	    if (!state.emittedReadable) {
	      state.emittedReadable = true;
	      emitReadable_(stream);
	    }
	  }
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  debug('emitReadable', state.needReadable, state.emittedReadable);
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    process$1.nextTick(emitReadable_, stream);
	  }
	}
	function emitReadable_(stream) {
	  var state = stream._readableState;
	  debug('emitReadable_', state.destroyed, state.length, state.ended);
	  if (!state.destroyed && (state.length || state.ended)) {
	    stream.emit('readable');
	    state.emittedReadable = false;
	  }

	  // The stream needs another readable event if
	  // 1. It is not flowing, as the flow mechanism will take
	  //    care of it.
	  // 2. It is not ended.
	  // 3. It is below the highWaterMark, so we can schedule
	  //    another readable later.
	  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process$1.nextTick(maybeReadMore_, stream, state);
	  }
	}
	function maybeReadMore_(stream, state) {
	  // Attempt to read more data if we should.
	  //
	  // The conditions for reading more data are (one of):
	  // - Not enough data buffered (state.length < state.highWaterMark). The loop
	  //   is responsible for filling the buffer with enough data if such data
	  //   is available. If highWaterMark is 0 and we are not in the flowing mode
	  //   we should _not_ attempt to buffer any extra data. We'll get more data
	  //   when the stream consumer calls read() instead.
	  // - No data in the buffer, and the stream is in flowing mode. In this mode
	  //   the loop below is responsible for ensuring read() is called. Failing to
	  //   call read here would abort the flow and there's no other mechanism for
	  //   continuing the flow if the stream consumer has just subscribed to the
	  //   'data' event.
	  //
	  // In addition to the above conditions to keep reading data, the following
	  // conditions prevent the data from being read:
	  // - The stream has ended (state.ended).
	  // - There is already a pending 'read' operation (state.reading). This is a
	  //   case where the the stream has called the implementation defined _read()
	  //   method, but they are processing the call asynchronously and have _not_
	  //   called push() with new data. In this case we skip performing more
	  //   read()s. The execution ends in this method again after the _read() ends
	  //   up calling push() with more data.
	  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
	    var len = state.length;
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
	};
	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;
	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;
	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) process$1.nextTick(endFn);else src.once('end', endFn);
	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }
	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);
	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);
	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    debug('dest.write', ret);
	    if (ret === false) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);
	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }
	  return dest;
	};
	function pipeOnDrain(src) {
	  return function pipeOnDrainFunctionResult() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}
	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = {
	    hasUnpiped: false
	  };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;
	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    for (var i = 0; i < len; i++) dests[i].emit('unpipe', this, {
	      hasUnpiped: false
	    });
	    return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;
	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];
	  dest.emit('unpipe', this, unpipeInfo);
	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);
	  var state = this._readableState;
	  if (ev === 'data') {
	    // update readableListening so that resume() may be a no-op
	    // a few lines down. This is needed to support once('readable').
	    state.readableListening = this.listenerCount('readable') > 0;

	    // Try start flowing on next tick if stream isn't explicitly paused
	    if (state.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.flowing = false;
	      state.emittedReadable = false;
	      debug('on readable', state.length, state.reading);
	      if (state.length) {
	        emitReadable(this);
	      } else if (!state.reading) {
	        process$1.nextTick(nReadingNextTick, this);
	      }
	    }
	  }
	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	Readable.prototype.removeListener = function (ev, fn) {
	  var res = Stream.prototype.removeListener.call(this, ev, fn);
	  if (ev === 'readable') {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process$1.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	Readable.prototype.removeAllListeners = function (ev) {
	  var res = Stream.prototype.removeAllListeners.apply(this, arguments);
	  if (ev === 'readable' || ev === undefined) {
	    // We need to check if there is someone still listening to
	    // readable and reset the state. However this needs to happen
	    // after readable has been emitted but before I/O (nextTick) to
	    // support once('readable', fn) cycles. This means that calling
	    // resume within the same tick will have no
	    // effect.
	    process$1.nextTick(updateReadableListening, this);
	  }
	  return res;
	};
	function updateReadableListening(self) {
	  var state = self._readableState;
	  state.readableListening = self.listenerCount('readable') > 0;
	  if (state.resumeScheduled && !state.paused) {
	    // flowing needs to be set to true now, otherwise
	    // the upcoming resume will not flow.
	    state.flowing = true;

	    // crude way to check if we should resume
	  } else if (self.listenerCount('data') > 0) {
	    self.resume();
	  }
	}
	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    // we flow only if there is no one listening
	    // for readable, but we still have to call
	    // resume()
	    state.flowing = !state.readableListening;
	    resume(this, state);
	  }
	  state.paused = false;
	  return this;
	};
	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process$1.nextTick(resume_, stream, state);
	  }
	}
	function resume_(stream, state) {
	  debug('resume', state.reading);
	  if (!state.reading) {
	    stream.read(0);
	  }
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}
	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (this._readableState.flowing !== false) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  this._readableState.paused = true;
	  return this;
	};
	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null);
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;
	  var state = this._readableState;
	  var paused = false;
	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }
	    _this.push(null);
	  });
	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function methodWrap(method) {
	        return function methodWrapReturnFunction() {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };
	  return this;
	};
	if (typeof Symbol === 'function') {
	  Readable.prototype[Symbol.asyncIterator] = function () {
	    if (createReadableStreamAsyncIterator === undefined) {
	      createReadableStreamAsyncIterator = requireAsync_iterator();
	    }
	    return createReadableStreamAsyncIterator(this);
	  };
	}
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.highWaterMark;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableBuffer', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState && this._readableState.buffer;
	  }
	});
	Object.defineProperty(Readable.prototype, 'readableFlowing', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.flowing;
	  },
	  set: function set(state) {
	    if (this._readableState) {
	      this._readableState.flowing = state;
	    }
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;
	Object.defineProperty(Readable.prototype, 'readableLength', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function get() {
	    return this._readableState.length;
	  }
	});

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;
	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = state.buffer.consume(n, state.decoder);
	  }
	  return ret;
	}
	function endReadable(stream) {
	  var state = stream._readableState;
	  debug('endReadable', state.endEmitted);
	  if (!state.endEmitted) {
	    state.ended = true;
	    process$1.nextTick(endReadableNT, state, stream);
	  }
	}
	function endReadableNT(state, stream) {
	  debug('endReadableNT', state.endEmitted, state.length);

	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	    if (state.autoDestroy) {
	      // In case of duplex streams we need a way to detect
	      // if the writable side is ready for autoDestroy as well
	      var wState = stream._writableState;
	      if (!wState || wState.autoDestroy && wState.finished) {
	        stream.destroy();
	      }
	    }
	  }
	}
	if (typeof Symbol === 'function') {
	  Readable.from = function (iterable, opts) {
	    if (from === undefined) {
	      from = requireFromBrowser();
	    }
	    return from(Readable, iterable, opts);
	  };
	}
	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable$2;
}

var _stream_transform$2;
var hasRequired_stream_transform$2;

function require_stream_transform$2 () {
	if (hasRequired_stream_transform$2) return _stream_transform$2;
	hasRequired_stream_transform$2 = 1;

	_stream_transform$2 = Transform;
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
	  ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
	  ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
	  ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
	var Duplex = require_stream_duplex$2();
	requireInherits_browser()(Transform, Duplex);
	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;
	  var cb = ts.writecb;
	  if (cb === null) {
	    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
	  }
	  ts.writechunk = null;
	  ts.writecb = null;
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    this.push(data);
	  cb(er);
	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}
	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);
	  Duplex.call(this, options);
	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;
	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;
	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}
	function prefinish() {
	  var _this = this;
	  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}
	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
	};
	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;
	  if (ts.writechunk !== null && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};
	Transform.prototype._destroy = function (err, cb) {
	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	  });
	};
	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);
	  if (data != null)
	    // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // TODO(BridgeAR): Write a test for these two error cases
	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
	  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
	  return stream.push(null);
	}
	return _stream_transform$2;
}

var _stream_passthrough$2;
var hasRequired_stream_passthrough$2;

function require_stream_passthrough$2 () {
	if (hasRequired_stream_passthrough$2) return _stream_passthrough$2;
	hasRequired_stream_passthrough$2 = 1;

	_stream_passthrough$2 = PassThrough;
	var Transform = require_stream_transform$2();
	requireInherits_browser()(PassThrough, Transform);
	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);
	  Transform.call(this, options);
	}
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough$2;
}

var pipeline_1;
var hasRequiredPipeline;

function requirePipeline () {
	if (hasRequiredPipeline) return pipeline_1;
	hasRequiredPipeline = 1;

	var eos;
	function once(callback) {
	  var called = false;
	  return function () {
	    if (called) return;
	    called = true;
	    callback.apply(void 0, arguments);
	  };
	}
	var _require$codes = requireErrorsBrowser().codes,
	  ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
	  ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
	function noop(err) {
	  // Rethrow the error if it exists to avoid swallowing it
	  if (err) throw err;
	}
	function isRequest(stream) {
	  return stream.setHeader && typeof stream.abort === 'function';
	}
	function destroyer(stream, reading, writing, callback) {
	  callback = once(callback);
	  var closed = false;
	  stream.on('close', function () {
	    closed = true;
	  });
	  if (eos === undefined) eos = requireEndOfStream();
	  eos(stream, {
	    readable: reading,
	    writable: writing
	  }, function (err) {
	    if (err) return callback(err);
	    closed = true;
	    callback();
	  });
	  var destroyed = false;
	  return function (err) {
	    if (closed) return;
	    if (destroyed) return;
	    destroyed = true;

	    // request.destroy just do .end - .abort is what we want
	    if (isRequest(stream)) return stream.abort();
	    if (typeof stream.destroy === 'function') return stream.destroy();
	    callback(err || new ERR_STREAM_DESTROYED('pipe'));
	  };
	}
	function call(fn) {
	  fn();
	}
	function pipe(from, to) {
	  return from.pipe(to);
	}
	function popCallback(streams) {
	  if (!streams.length) return noop;
	  if (typeof streams[streams.length - 1] !== 'function') return noop;
	  return streams.pop();
	}
	function pipeline() {
	  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
	    streams[_key] = arguments[_key];
	  }
	  var callback = popCallback(streams);
	  if (Array.isArray(streams[0])) streams = streams[0];
	  if (streams.length < 2) {
	    throw new ERR_MISSING_ARGS('streams');
	  }
	  var error;
	  var destroys = streams.map(function (stream, i) {
	    var reading = i < streams.length - 1;
	    var writing = i > 0;
	    return destroyer(stream, reading, writing, function (err) {
	      if (!error) error = err;
	      if (err) destroys.forEach(call);
	      if (reading) return;
	      destroys.forEach(call);
	      callback(error);
	    });
	  });
	  return streams.reduce(pipe);
	}
	pipeline_1 = pipeline;
	return pipeline_1;
}

var streamBrowserify;
var hasRequiredStreamBrowserify;

function requireStreamBrowserify () {
	if (hasRequiredStreamBrowserify) return streamBrowserify;
	hasRequiredStreamBrowserify = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	streamBrowserify = Stream;

	var EE = requireEvents().EventEmitter;
	var inherits = requireInherits_browser();

	inherits(Stream, EE);
	Stream.Readable = require_stream_readable$2();
	Stream.Writable = require_stream_writable$2();
	Stream.Duplex = require_stream_duplex$2();
	Stream.Transform = require_stream_transform$2();
	Stream.PassThrough = require_stream_passthrough$2();
	Stream.finished = requireEndOfStream();
	Stream.pipeline = requirePipeline();

	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;



	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.

	function Stream() {
	  EE.call(this);
	}

	Stream.prototype.pipe = function(dest, options) {
	  var source = this;

	  function ondata(chunk) {
	    if (dest.writable) {
	      if (false === dest.write(chunk) && source.pause) {
	        source.pause();
	      }
	    }
	  }

	  source.on('data', ondata);

	  function ondrain() {
	    if (source.readable && source.resume) {
	      source.resume();
	    }
	  }

	  dest.on('drain', ondrain);

	  // If the 'end' option is not supplied, dest.end() will be called when
	  // source gets the 'end' or 'close' events.  Only dest.end() once.
	  if (!dest._isStdio && (!options || options.end !== false)) {
	    source.on('end', onend);
	    source.on('close', onclose);
	  }

	  var didOnEnd = false;
	  function onend() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    dest.end();
	  }


	  function onclose() {
	    if (didOnEnd) return;
	    didOnEnd = true;

	    if (typeof dest.destroy === 'function') dest.destroy();
	  }

	  // don't leave dangling pipes when there are errors.
	  function onerror(er) {
	    cleanup();
	    if (EE.listenerCount(this, 'error') === 0) {
	      throw er; // Unhandled stream error in pipe.
	    }
	  }

	  source.on('error', onerror);
	  dest.on('error', onerror);

	  // remove all the event listeners that were added.
	  function cleanup() {
	    source.removeListener('data', ondata);
	    dest.removeListener('drain', ondrain);

	    source.removeListener('end', onend);
	    source.removeListener('close', onclose);

	    source.removeListener('error', onerror);
	    dest.removeListener('error', onerror);

	    source.removeListener('end', cleanup);
	    source.removeListener('close', cleanup);

	    dest.removeListener('close', cleanup);
	  }

	  source.on('end', cleanup);
	  source.on('close', cleanup);

	  dest.on('close', cleanup);

	  dest.emit('pipe', source);

	  // Allow for unix-like usage: A.pipe(B).pipe(C)
	  return dest;
	};
	return streamBrowserify;
}

var util$1 = {};

var hasRequiredUtil$1;

function requireUtil$1 () {
	if (hasRequiredUtil$1) return util$1;
	hasRequiredUtil$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.

	function isArray(arg) {
	  if (Array.isArray) {
	    return Array.isArray(arg);
	  }
	  return objectToString(arg) === '[object Array]';
	}
	util$1.isArray = isArray;

	function isBoolean(arg) {
	  return typeof arg === 'boolean';
	}
	util$1.isBoolean = isBoolean;

	function isNull(arg) {
	  return arg === null;
	}
	util$1.isNull = isNull;

	function isNullOrUndefined(arg) {
	  return arg == null;
	}
	util$1.isNullOrUndefined = isNullOrUndefined;

	function isNumber(arg) {
	  return typeof arg === 'number';
	}
	util$1.isNumber = isNumber;

	function isString(arg) {
	  return typeof arg === 'string';
	}
	util$1.isString = isString;

	function isSymbol(arg) {
	  return typeof arg === 'symbol';
	}
	util$1.isSymbol = isSymbol;

	function isUndefined(arg) {
	  return arg === void 0;
	}
	util$1.isUndefined = isUndefined;

	function isRegExp(re) {
	  return objectToString(re) === '[object RegExp]';
	}
	util$1.isRegExp = isRegExp;

	function isObject(arg) {
	  return typeof arg === 'object' && arg !== null;
	}
	util$1.isObject = isObject;

	function isDate(d) {
	  return objectToString(d) === '[object Date]';
	}
	util$1.isDate = isDate;

	function isError(e) {
	  return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	util$1.isError = isError;

	function isFunction(arg) {
	  return typeof arg === 'function';
	}
	util$1.isFunction = isFunction;

	function isPrimitive(arg) {
	  return arg === null ||
	         typeof arg === 'boolean' ||
	         typeof arg === 'number' ||
	         typeof arg === 'string' ||
	         typeof arg === 'symbol' ||  // ES6 symbol
	         typeof arg === 'undefined';
	}
	util$1.isPrimitive = isPrimitive;

	util$1.isBuffer = requireDist().Buffer.isBuffer;

	function objectToString(o) {
	  return Object.prototype.toString.call(o);
	}
	return util$1;
}

var _stream_writable$1;
var hasRequired_stream_writable$1;

function require_stream_writable$1 () {
	if (hasRequired_stream_writable$1) return _stream_writable$1;
	hasRequired_stream_writable$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, cb), and it'll handle all
	// the drain event emission and buffering.

	_stream_writable$1 = Writable;

	/*<replacement>*/
	var Buffer = requireDist().Buffer;
	/*</replacement>*/

	Writable.WritableState = WritableState;


	/*<replacement>*/
	var util = requireUtil$1();
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	var Stream = requireStreamBrowserify();

	util.inherits(Writable, Stream);

	function WriteReq(chunk, encoding, cb) {
	  this.chunk = chunk;
	  this.encoding = encoding;
	  this.callback = cb;
	}

	function WritableState(options, stream) {
	  var Duplex = require_stream_duplex$1();

	  options = options || {};

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function(er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.buffer = [];

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;
	}

	function Writable(options) {
	  var Duplex = require_stream_duplex$1();

	  // Writable ctor is applied to Duplexes, though they're not
	  // instanceof Writable, they're instanceof Readable.
	  if (!(this instanceof Writable) && !(this instanceof Duplex))
	    return new Writable(options);

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function() {
	  this.emit('error', new Error('Cannot pipe. Not readable.'));
	};


	function writeAfterEnd(stream, state, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  process$1.nextTick(function() {
	    cb(er);
	  });
	}

	// If we get something that is not a buffer, string, null, or undefined,
	// and we're not in objectMode, then that's an error.
	// Otherwise stream chunks are all considered to be of length=1, and the
	// watermarks determine how many objects to keep in the buffer, rather than
	// how many bytes or characters.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    var er = new TypeError('Invalid non-string/buffer chunk');
	    stream.emit('error', er);
	    process$1.nextTick(function() {
	      cb(er);
	    });
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function(chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;

	  if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  else if (!encoding)
	    encoding = state.defaultEncoding;

	  if (!util.isFunction(cb))
	    cb = function() {};

	  if (state.ended)
	    writeAfterEnd(this, state, cb);
	  else if (validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function() {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function() {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing &&
	        !state.corked &&
	        !state.finished &&
	        !state.bufferProcessing &&
	        state.buffer.length)
	      clearBuffer(this, state);
	  }
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode &&
	      state.decodeStrings !== false &&
	      util.isString(chunk)) {
	    chunk = new Buffer(chunk, encoding);
	  }
	  return chunk;
	}

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, chunk, encoding, cb) {
	  chunk = decodeChunk(state, chunk, encoding);
	  if (util.isBuffer(chunk))
	    encoding = 'buffer';
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret)
	    state.needDrain = true;

	  if (state.writing || state.corked)
	    state.buffer.push(new WriteReq(chunk, encoding, cb));
	  else
	    doWrite(stream, state, false, len, chunk, encoding, cb);

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev)
	    stream._writev(chunk, state.onwrite);
	  else
	    stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  if (sync)
	    process$1.nextTick(function() {
	      state.pendingcb--;
	      cb(er);
	    });
	  else {
	    state.pendingcb--;
	    cb(er);
	  }

	  stream._writableState.errorEmitted = true;
	  stream.emit('error', er);
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er)
	    onwriteError(stream, state, sync, er, cb);
	  else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(stream, state);

	    if (!finished &&
	        !state.corked &&
	        !state.bufferProcessing &&
	        state.buffer.length) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      process$1.nextTick(function() {
	        afterWrite(stream, state, finished, cb);
	      });
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished)
	    onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}


	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;

	  if (stream._writev && state.buffer.length > 1) {
	    // Fast case, write everything using _writev()
	    var cbs = [];
	    for (var c = 0; c < state.buffer.length; c++)
	      cbs.push(state.buffer[c].callback);

	    // count the one we are adding, as well.
	    // TODO(isaacs) clean this up
	    state.pendingcb++;
	    doWrite(stream, state, true, state.length, state.buffer, '', function(err) {
	      for (var i = 0; i < cbs.length; i++) {
	        state.pendingcb--;
	        cbs[i](err);
	      }
	    });

	    // Clear buffer
	    state.buffer = [];
	  } else {
	    // Slow case, write chunks one-by-one
	    for (var c = 0; c < state.buffer.length; c++) {
	      var entry = state.buffer[c];
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);

	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        c++;
	        break;
	      }
	    }

	    if (c < state.buffer.length)
	      state.buffer = state.buffer.slice(c);
	    else
	      state.buffer.length = 0;
	  }

	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function(chunk, encoding, cb) {
	  cb(new Error('not implemented'));

	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function(chunk, encoding, cb) {
	  var state = this._writableState;

	  if (util.isFunction(chunk)) {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (util.isFunction(encoding)) {
	    cb = encoding;
	    encoding = null;
	  }

	  if (!util.isNullOrUndefined(chunk))
	    this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending && !state.finished)
	    endWritable(this, state, cb);
	};


	function needFinish(stream, state) {
	  return (state.ending &&
	          state.length === 0 &&
	          !state.finished &&
	          !state.writing);
	}

	function prefinish(stream, state) {
	  if (!state.prefinished) {
	    state.prefinished = true;
	    stream.emit('prefinish');
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(stream, state);
	  if (need) {
	    if (state.pendingcb === 0) {
	      prefinish(stream, state);
	      state.finished = true;
	      stream.emit('finish');
	    } else
	      prefinish(stream, state);
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished)
	      process$1.nextTick(cb);
	    else
	      stream.once('finish', cb);
	  }
	  state.ended = true;
	}
	return _stream_writable$1;
}

var _stream_duplex$1;
var hasRequired_stream_duplex$1;

function require_stream_duplex$1 () {
	if (hasRequired_stream_duplex$1) return _stream_duplex$1;
	hasRequired_stream_duplex$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.

	_stream_duplex$1 = Duplex;

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) keys.push(key);
	  return keys;
	};
	/*</replacement>*/


	/*<replacement>*/
	var util = requireUtil$1();
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	var Readable = require_stream_readable$1();
	var Writable = require_stream_writable$1();

	util.inherits(Duplex, Readable);

	forEach(objectKeys(Writable.prototype), function(method) {
	  if (!Duplex.prototype[method])
	    Duplex.prototype[method] = Writable.prototype[method];
	});

	function Duplex(options) {
	  if (!(this instanceof Duplex))
	    return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false)
	    this.readable = false;

	  if (options && options.writable === false)
	    this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false)
	    this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended)
	    return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  process$1.nextTick(this.end.bind(this));
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}
	return _stream_duplex$1;
}

var string_decoder$1 = {};

var hasRequiredString_decoder$1;

function requireString_decoder$1 () {
	if (hasRequiredString_decoder$1) return string_decoder$1;
	hasRequiredString_decoder$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	var Buffer = requireDist().Buffer;

	var isBufferEncoding = Buffer.isEncoding
	  || function(encoding) {
	       switch (encoding && encoding.toLowerCase()) {
	         case 'hex': case 'utf8': case 'utf-8': case 'ascii': case 'binary': case 'base64': case 'ucs2': case 'ucs-2': case 'utf16le': case 'utf-16le': case 'raw': return true;
	         default: return false;
	       }
	     };


	function assertEncoding(encoding) {
	  if (encoding && !isBufferEncoding(encoding)) {
	    throw new Error('Unknown encoding: ' + encoding);
	  }
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters. CESU-8 is handled as part of the UTF-8 encoding.
	//
	// @TODO Handling all encodings inside a single object makes it very difficult
	// to reason about this code, so it should be split up in the future.
	// @TODO There should be a utf8-strict encoding that rejects invalid UTF-8 code
	// points as used by CESU-8.
	var StringDecoder = string_decoder$1.StringDecoder = function(encoding) {
	  this.encoding = (encoding || 'utf8').toLowerCase().replace(/[-_]/, '');
	  assertEncoding(encoding);
	  switch (this.encoding) {
	    case 'utf8':
	      // CESU-8 represents each of Surrogate Pair by 3-bytes
	      this.surrogateSize = 3;
	      break;
	    case 'ucs2':
	    case 'utf16le':
	      // UTF-16 represents each of Surrogate Pair by 2-bytes
	      this.surrogateSize = 2;
	      this.detectIncompleteChar = utf16DetectIncompleteChar;
	      break;
	    case 'base64':
	      // Base-64 stores 3 bytes in 4 chars, and pads the remainder.
	      this.surrogateSize = 3;
	      this.detectIncompleteChar = base64DetectIncompleteChar;
	      break;
	    default:
	      this.write = passThroughWrite;
	      return;
	  }

	  // Enough space to store all bytes of a single character. UTF-8 needs 4
	  // bytes, but CESU-8 may require up to 6 (3 bytes per surrogate).
	  this.charBuffer = new Buffer(6);
	  // Number of bytes received for the current incomplete multi-byte character.
	  this.charReceived = 0;
	  // Number of bytes expected for the current incomplete multi-byte character.
	  this.charLength = 0;
	};


	// write decodes the given buffer and returns it as JS string that is
	// guaranteed to not contain any partial multi-byte characters. Any partial
	// character found at the end of the buffer is buffered up, and will be
	// returned when calling write again with the remaining bytes.
	//
	// Note: Converting a Buffer containing an orphan surrogate to a String
	// currently works, but converting a String to a Buffer (via `new Buffer`, or
	// Buffer#write) will replace incomplete surrogates with the unicode
	// replacement character. See https://codereview.chromium.org/121173009/ .
	StringDecoder.prototype.write = function(buffer) {
	  var charStr = '';
	  // if our last write ended with an incomplete multibyte character
	  while (this.charLength) {
	    // determine how many remaining bytes this buffer has to offer for this char
	    var available = (buffer.length >= this.charLength - this.charReceived) ?
	        this.charLength - this.charReceived :
	        buffer.length;

	    // add the new bytes to the char buffer
	    buffer.copy(this.charBuffer, this.charReceived, 0, available);
	    this.charReceived += available;

	    if (this.charReceived < this.charLength) {
	      // still not enough chars in this buffer? wait for more ...
	      return '';
	    }

	    // remove bytes belonging to the current character from the buffer
	    buffer = buffer.slice(available, buffer.length);

	    // get the character that was split
	    charStr = this.charBuffer.slice(0, this.charLength).toString(this.encoding);

	    // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	    var charCode = charStr.charCodeAt(charStr.length - 1);
	    if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	      this.charLength += this.surrogateSize;
	      charStr = '';
	      continue;
	    }
	    this.charReceived = this.charLength = 0;

	    // if there are no more bytes in this buffer, just emit our char
	    if (buffer.length === 0) {
	      return charStr;
	    }
	    break;
	  }

	  // determine and set charLength / charReceived
	  this.detectIncompleteChar(buffer);

	  var end = buffer.length;
	  if (this.charLength) {
	    // buffer the incomplete character bytes we got
	    buffer.copy(this.charBuffer, 0, buffer.length - this.charReceived, end);
	    end -= this.charReceived;
	  }

	  charStr += buffer.toString(this.encoding, 0, end);

	  var end = charStr.length - 1;
	  var charCode = charStr.charCodeAt(end);
	  // CESU-8: lead surrogate (D800-DBFF) is also the incomplete character
	  if (charCode >= 0xD800 && charCode <= 0xDBFF) {
	    var size = this.surrogateSize;
	    this.charLength += size;
	    this.charReceived += size;
	    this.charBuffer.copy(this.charBuffer, size, 0, size);
	    buffer.copy(this.charBuffer, 0, 0, size);
	    return charStr.substring(0, end);
	  }

	  // or just emit the charStr
	  return charStr;
	};

	// detectIncompleteChar determines if there is an incomplete UTF-8 character at
	// the end of the given buffer. If so, it sets this.charLength to the byte
	// length that character, and sets this.charReceived to the number of bytes
	// that are available for this character.
	StringDecoder.prototype.detectIncompleteChar = function(buffer) {
	  // determine how many bytes we have to check at the end of this buffer
	  var i = (buffer.length >= 3) ? 3 : buffer.length;

	  // Figure out if one of the last i bytes of our buffer announces an
	  // incomplete char.
	  for (; i > 0; i--) {
	    var c = buffer[buffer.length - i];

	    // See http://en.wikipedia.org/wiki/UTF-8#Description

	    // 110XXXXX
	    if (i == 1 && c >> 5 == 0x06) {
	      this.charLength = 2;
	      break;
	    }

	    // 1110XXXX
	    if (i <= 2 && c >> 4 == 0x0E) {
	      this.charLength = 3;
	      break;
	    }

	    // 11110XXX
	    if (i <= 3 && c >> 3 == 0x1E) {
	      this.charLength = 4;
	      break;
	    }
	  }
	  this.charReceived = i;
	};

	StringDecoder.prototype.end = function(buffer) {
	  var res = '';
	  if (buffer && buffer.length)
	    res = this.write(buffer);

	  if (this.charReceived) {
	    var cr = this.charReceived;
	    var buf = this.charBuffer;
	    var enc = this.encoding;
	    res += buf.slice(0, cr).toString(enc);
	  }

	  return res;
	};

	function passThroughWrite(buffer) {
	  return buffer.toString(this.encoding);
	}

	function utf16DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 2;
	  this.charLength = this.charReceived ? 2 : 0;
	}

	function base64DetectIncompleteChar(buffer) {
	  this.charReceived = buffer.length % 3;
	  this.charLength = this.charReceived ? 3 : 0;
	}
	return string_decoder$1;
}

var _stream_readable$1;
var hasRequired_stream_readable$1;

function require_stream_readable$1 () {
	if (hasRequired_stream_readable$1) return _stream_readable$1;
	hasRequired_stream_readable$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	_stream_readable$1 = Readable;

	/*<replacement>*/
	var isArray = requireIsarray$1();
	/*</replacement>*/


	/*<replacement>*/
	var Buffer = requireDist().Buffer;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	var EE = requireEvents().EventEmitter;

	/*<replacement>*/
	if (!EE.listenerCount) EE.listenerCount = function(emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	var Stream = requireStreamBrowserify();

	/*<replacement>*/
	var util = requireUtil$1();
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	var StringDecoder;


	/*<replacement>*/
	var debug = requireUtil$2();
	if (debug && debug.debuglog) {
	  debug = debug.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/


	util.inherits(Readable, Stream);

	function ReadableState(options, stream) {
	  var Duplex = require_stream_duplex$1();

	  options = options || {};

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var defaultHwm = options.objectMode ? 16 : 16 * 1024;
	  this.highWaterMark = (hwm || hwm === 0) ? hwm : defaultHwm;

	  // cast to ints.
	  this.highWaterMark = ~~this.highWaterMark;

	  this.buffer = [];
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;


	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (stream instanceof Duplex)
	    this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // when piping, we only care about 'readable' events that happen
	  // after read()ing all the bytes and not getting any pushback.
	  this.ranOut = false;

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder)
	      StringDecoder = requireString_decoder$1().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  require_stream_duplex$1();

	  if (!(this instanceof Readable))
	    return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  Stream.call(this);
	}

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function(chunk, encoding) {
	  var state = this._readableState;

	  if (util.isString(chunk) && !state.objectMode) {
	    encoding = encoding || state.defaultEncoding;
	    if (encoding !== state.encoding) {
	      chunk = new Buffer(chunk, encoding);
	      encoding = '';
	    }
	  }

	  return readableAddChunk(this, state, chunk, encoding, false);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function(chunk) {
	  var state = this._readableState;
	  return readableAddChunk(this, state, chunk, '', true);
	};

	function readableAddChunk(stream, state, chunk, encoding, addToFront) {
	  var er = chunkInvalid(state, chunk);
	  if (er) {
	    stream.emit('error', er);
	  } else if (util.isNullOrUndefined(chunk)) {
	    state.reading = false;
	    if (!state.ended)
	      onEofChunk(stream, state);
	  } else if (state.objectMode || chunk && chunk.length > 0) {
	    if (state.ended && !addToFront) {
	      var e = new Error('stream.push() after EOF');
	      stream.emit('error', e);
	    } else if (state.endEmitted && addToFront) {
	      var e = new Error('stream.unshift() after end event');
	      stream.emit('error', e);
	    } else {
	      if (state.decoder && !addToFront && !encoding)
	        chunk = state.decoder.write(chunk);

	      if (!addToFront)
	        state.reading = false;

	      // if we want the data now, just emit it.
	      if (state.flowing && state.length === 0 && !state.sync) {
	        stream.emit('data', chunk);
	        stream.read(0);
	      } else {
	        // update the buffer info.
	        state.length += state.objectMode ? 1 : chunk.length;
	        if (addToFront)
	          state.buffer.unshift(chunk);
	        else
	          state.buffer.push(chunk);

	        if (state.needReadable)
	          emitReadable(stream);
	      }

	      maybeReadMore(stream, state);
	    }
	  } else if (!addToFront) {
	    state.reading = false;
	  }

	  return needMoreData(state);
	}



	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended &&
	         (state.needReadable ||
	          state.length < state.highWaterMark ||
	          state.length === 0);
	}

	// backwards compatibility.
	Readable.prototype.setEncoding = function(enc) {
	  if (!StringDecoder)
	    StringDecoder = requireString_decoder$1().StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 128MB
	var MAX_HWM = 0x800000;
	function roundUpToNextPowerOf2(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2
	    n--;
	    for (var p = 1; p < 32; p <<= 1) n |= n >> p;
	    n++;
	  }
	  return n;
	}

	function howMuchToRead(n, state) {
	  if (state.length === 0 && state.ended)
	    return 0;

	  if (state.objectMode)
	    return n === 0 ? 0 : 1;

	  if (isNaN(n) || util.isNull(n)) {
	    // only flow one buffer at a time
	    if (state.flowing && state.buffer.length)
	      return state.buffer[0].length;
	    else
	      return state.length;
	  }

	  if (n <= 0)
	    return 0;

	  // If we're asking for more than the target buffer level,
	  // then raise the water mark.  Bump up to the next highest
	  // power of 2, to prevent increasing it excessively in tiny
	  // amounts.
	  if (n > state.highWaterMark)
	    state.highWaterMark = roundUpToNextPowerOf2(n);

	  // don't have that much.  return null, unless we've ended.
	  if (n > state.length) {
	    if (!state.ended) {
	      state.needReadable = true;
	      return 0;
	    } else
	      return state.length;
	  }

	  return n;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function(n) {
	  debug('read', n);
	  var state = this._readableState;
	  var nOrig = n;

	  if (!util.isNumber(n) || n > 0)
	    state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 &&
	      state.needReadable &&
	      (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended)
	      endReadable(this);
	    else
	      emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0)
	      endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  }

	  if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0)
	      state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	  }

	  // If _read pushed data synchronously, then `reading` will be false,
	  // and we need to re-evaluate how much data we can return to the user.
	  if (doRead && !state.reading)
	    n = howMuchToRead(nOrig, state);

	  var ret;
	  if (n > 0)
	    ret = fromList(n, state);
	  else
	    ret = null;

	  if (util.isNull(ret)) {
	    state.needReadable = true;
	    n = 0;
	  }

	  state.length -= n;

	  // If we have nothing in the buffer, then we want to know
	  // as soon as we *do* get something into the buffer.
	  if (state.length === 0 && !state.ended)
	    state.needReadable = true;

	  // If we tried to read() past the EOF, then emit end on the next tick.
	  if (nOrig !== n && state.ended && state.length === 0)
	    endReadable(this);

	  if (!util.isNull(ret))
	    this.emit('data', ret);

	  return ret;
	};

	function chunkInvalid(state, chunk) {
	  var er = null;
	  if (!util.isBuffer(chunk) &&
	      !util.isString(chunk) &&
	      !util.isNullOrUndefined(chunk) &&
	      !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}


	function onEofChunk(stream, state) {
	  if (state.decoder && !state.ended) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync)
	      process$1.nextTick(function() {
	        emitReadable_(stream);
	      });
	    else
	      emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}


	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    process$1.nextTick(function() {
	      maybeReadMore_(stream, state);
	    });
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended &&
	         state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;
	    else
	      len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function(n) {
	  this.emit('error', new Error('not implemented'));
	};

	Readable.prototype.pipe = function(dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) &&
	              dest !== process$1.stdout &&
	              dest !== process$1.stderr;

	  var endFn = doEnd ? onend : cleanup;
	  if (state.endEmitted)
	    process$1.nextTick(endFn);
	  else
	    src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable) {
	    debug('onunpipe');
	    if (readable === src) {
	      cleanup();
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', cleanup);
	    src.removeListener('data', ondata);

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain &&
	        (!dest._writableState || dest._writableState.needDrain))
	      ondrain();
	  }

	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    var ret = dest.write(chunk);
	    if (false === ret) {
	      debug('false write response, pause',
	            src._readableState.awaitDrain);
	      src._readableState.awaitDrain++;
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EE.listenerCount(dest, 'error') === 0)
	      dest.emit('error', er);
	  }
	  // This is a brutally ugly hack to make sure that our error handler
	  // is attached before any userland ones.  NEVER DO THIS.
	  if (!dest._events || !dest._events.error)
	    dest.on('error', onerror);
	  else if (isArray(dest._events.error))
	    dest._events.error.unshift(onerror);
	  else
	    dest._events.error = [onerror, dest._events.error];



	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function() {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain)
	      state.awaitDrain--;
	    if (state.awaitDrain === 0 && EE.listenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}


	Readable.prototype.unpipe = function(dest) {
	  var state = this._readableState;

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0)
	    return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes)
	      return this;

	    if (!dest)
	      dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest)
	      dest.emit('unpipe', this);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++)
	      dests[i].emit('unpipe', this);
	    return this;
	  }

	  // try to find the right one.
	  var i = indexOf(state.pipes, dest);
	  if (i === -1)
	    return this;

	  state.pipes.splice(i, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1)
	    state.pipes = state.pipes[0];

	  dest.emit('unpipe', this);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function(ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  // If listening to data, and it has not explicitly been paused,
	  // then call resume to start the flow of data on the next tick.
	  if (ev === 'data' && false !== this._readableState.flowing) {
	    this.resume();
	  }

	  if (ev === 'readable' && this.readable) {
	    var state = this._readableState;
	    if (!state.readableListening) {
	      state.readableListening = true;
	      state.emittedReadable = false;
	      state.needReadable = true;
	      if (!state.reading) {
	        var self = this;
	        process$1.nextTick(function() {
	          debug('readable nexttick read 0');
	          self.read(0);
	        });
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function() {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    if (!state.reading) {
	      debug('resume read 0');
	      this.read(0);
	    }
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    process$1.nextTick(function() {
	      resume_(stream, state);
	    });
	  }
	}

	function resume_(stream, state) {
	  state.resumeScheduled = false;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading)
	    stream.read(0);
	}

	Readable.prototype.pause = function() {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  if (state.flowing) {
	    do {
	      var chunk = stream.read();
	    } while (null !== chunk && state.flowing);
	  }
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function(stream) {
	  var state = this._readableState;
	  var paused = false;

	  var self = this;
	  stream.on('end', function() {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length)
	        self.push(chunk);
	    }

	    self.push(null);
	  });

	  stream.on('data', function(chunk) {
	    debug('wrapped data');
	    if (state.decoder)
	      chunk = state.decoder.write(chunk);
	    if (!chunk || !state.objectMode && !chunk.length)
	      return;

	    var ret = self.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (util.isFunction(stream[i]) && util.isUndefined(this[i])) {
	      this[i] = function(method) { return function() {
	        return stream[method].apply(stream, arguments);
	      }}(i);
	    }
	  }

	  // proxy certain important events.
	  var events = ['error', 'close', 'destroy', 'pause', 'resume'];
	  forEach(events, function(ev) {
	    stream.on(ev, self.emit.bind(self, ev));
	  });

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  self._read = function(n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return self;
	};



	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	function fromList(n, state) {
	  var list = state.buffer;
	  var length = state.length;
	  var stringMode = !!state.decoder;
	  var objectMode = !!state.objectMode;
	  var ret;

	  // nothing in the list, definitely empty.
	  if (list.length === 0)
	    return null;

	  if (length === 0)
	    ret = null;
	  else if (objectMode)
	    ret = list.shift();
	  else if (!n || n >= length) {
	    // read it all, truncate the array.
	    if (stringMode)
	      ret = list.join('');
	    else
	      ret = Buffer.concat(list, length);
	    list.length = 0;
	  } else {
	    // read just some of it.
	    if (n < list[0].length) {
	      // just take a part of the first list item.
	      // slice is the same for buffers and strings.
	      var buf = list[0];
	      ret = buf.slice(0, n);
	      list[0] = buf.slice(n);
	    } else if (n === list[0].length) {
	      // first list is a perfect match
	      ret = list.shift();
	    } else {
	      // complex case.
	      // we have enough to cover it, but it spans past the first buffer.
	      if (stringMode)
	        ret = '';
	      else
	        ret = new Buffer(n);

	      var c = 0;
	      for (var i = 0, l = list.length; i < l && c < n; i++) {
	        var buf = list[0];
	        var cpy = Math.min(n - c, buf.length);

	        if (stringMode)
	          ret += buf.slice(0, cpy);
	        else
	          buf.copy(ret, c, 0, cpy);

	        if (cpy < buf.length)
	          list[0] = buf.slice(cpy);
	        else
	          list.shift();

	        c += cpy;
	      }
	    }
	  }

	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0)
	    throw new Error('endReadable called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    process$1.nextTick(function() {
	      // Check that we didn't get one last unshift.
	      if (!state.endEmitted && state.length === 0) {
	        state.endEmitted = true;
	        stream.readable = false;
	        stream.emit('end');
	      }
	    });
	  }
	}

	function forEach (xs, f) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    f(xs[i], i);
	  }
	}

	function indexOf (xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable$1;
}

var _stream_transform$1;
var hasRequired_stream_transform$1;

function require_stream_transform$1 () {
	if (hasRequired_stream_transform$1) return _stream_transform$1;
	hasRequired_stream_transform$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.


	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.

	_stream_transform$1 = Transform;

	var Duplex = require_stream_duplex$1();

	/*<replacement>*/
	var util = requireUtil$1();
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	util.inherits(Transform, Duplex);


	function TransformState(options, stream) {
	  this.afterTransform = function(er, data) {
	    return afterTransform(stream, er, data);
	  };

	  this.needTransform = false;
	  this.transforming = false;
	  this.writecb = null;
	  this.writechunk = null;
	}

	function afterTransform(stream, er, data) {
	  var ts = stream._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb)
	    return stream.emit('error', new Error('no writecb in Transform class'));

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (!util.isNullOrUndefined(data))
	    stream.push(data);

	  if (cb)
	    cb(er);

	  var rs = stream._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    stream._read(rs.highWaterMark);
	  }
	}


	function Transform(options) {
	  if (!(this instanceof Transform))
	    return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = new TransformState(options, this);

	  // when the writable side finishes, then flush out anything remaining.
	  var stream = this;

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  this.once('prefinish', function() {
	    if (util.isFunction(this._flush))
	      this._flush(function(er) {
	        done(stream, er);
	      });
	    else
	      done(stream);
	  });
	}

	Transform.prototype.push = function(chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function(chunk, encoding, cb) {
	  throw new Error('not implemented');
	};

	Transform.prototype._write = function(chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform ||
	        rs.needReadable ||
	        rs.length < rs.highWaterMark)
	      this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function(n) {
	  var ts = this._transformState;

	  if (!util.isNull(ts.writechunk) && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};


	function done(stream, er) {
	  if (er)
	    return stream.emit('error', er);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  var ws = stream._writableState;
	  var ts = stream._transformState;

	  if (ws.length)
	    throw new Error('calling transform done when ws.length != 0');

	  if (ts.transforming)
	    throw new Error('calling transform done when still transforming');

	  return stream.push(null);
	}
	return _stream_transform$1;
}

var _stream_passthrough$1;
var hasRequired_stream_passthrough$1;

function require_stream_passthrough$1 () {
	if (hasRequired_stream_passthrough$1) return _stream_passthrough$1;
	hasRequired_stream_passthrough$1 = 1;
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.

	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.

	_stream_passthrough$1 = PassThrough;

	var Transform = require_stream_transform$1();

	/*<replacement>*/
	var util = requireUtil$1();
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough))
	    return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function(chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough$1;
}

var hasRequiredReadable;

function requireReadable () {
	if (hasRequiredReadable) return readable.exports;
	hasRequiredReadable = 1;
	(function (module, exports) {
		var define_process_env_default = {};
		exports = module.exports = require_stream_readable$1();
		exports.Stream = requireStreamBrowserify();
		exports.Readable = exports;
		exports.Writable = require_stream_writable$1();
		exports.Duplex = require_stream_duplex$1();
		exports.Transform = require_stream_transform$1();
		exports.PassThrough = require_stream_passthrough$1();
		if (!process$1.browser && define_process_env_default.READABLE_STREAM === "disable") {
		  module.exports = requireStreamBrowserify();
		} 
	} (readable, readable.exports));
	return readable.exports;
}

var cipherbase;
var hasRequiredCipherbase;

function requireCipherbase () {
	if (hasRequiredCipherbase) return cipherbase;
	hasRequiredCipherbase = 1;
	var Transform = requireReadable().Transform;
	var inherits = requireInherits_browser();

	cipherbase = CipherBase;
	inherits(CipherBase, Transform);
	function CipherBase(digest) {
	  if (digest) {
	    this.digest = finalFunc;
	  } else {
	    this.final = finalFunc;
	  }

	}
	[
	  '_readableState',
	  '_writableState',
	  '_transformState'
	].forEach(function(prop) {
	  Object.defineProperty(CipherBase.prototype, prop, {
	    get: function() {
	      Transform.call(this);
	      return this[prop];
	    },
	    set: function(val) {
	      Object.defineProperty(this, prop, {
	        value: val,
	        enumerable: true,
	        configurable: true,
	        writable: true
	      });
	    },
	    configurable: true,
	    enumerable: true
	  });
	});
	CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	  if (typeof data === 'string') {
	    data = new Buffer$1(data, inputEnc);
	  }
	  var outData = this._update(data) || new Buffer$1('');
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  if (this.digest) {
	    return this;
	  }
	  return outData;
	};
	CipherBase.prototype._transform = function (data, _, next) {
	  this.push(this._update(data));
	  next();
	};
	CipherBase.prototype._flush = function (next) {
	  try {
	    this.push(this._final());
	  } catch(e) {
	    return next(e);
	  }
	  next();
	};
	function finalFunc (outputEnc) {
	  var outData = this._final() || new Buffer$1('');
	  if (outputEnc) {
	    outData = outData.toString(outputEnc);
	  }
	  return outData;
	}	CipherBase.prototype._final = function () {};
	return cipherbase;
}

var chacha20;
var hasRequiredChacha20;

function requireChacha20 () {
	if (hasRequiredChacha20) return chacha20;
	hasRequiredChacha20 = 1;
	function ROTATE(v, c) {
	  return (v << c) | (v >>> (32 - c));
	}
	var constants = new Buffer$1('expand 32-byte k');
	chacha20 = Chacha20;
	function Chacha20(key, nonce) {
	  this.input = new Uint32Array(16);

	  // https://tools.ietf.org/html/draft-irtf-cfrg-chacha20-poly1305-01#section-2.3
	  this.input[0] = constants.readUInt32LE(0);
	  this.input[1] =  constants.readUInt32LE(4);
	  this.input[2] = constants.readUInt32LE(8);
	  this.input[3] = constants.readUInt32LE(12);
	  this.input[4] = key.readUInt32LE(0);
	  this.input[5] = key.readUInt32LE(4);
	  this.input[6] = key.readUInt32LE(8);
	  this.input[7] = key.readUInt32LE(12);
	  this.input[8] = key.readUInt32LE(16);
	  this.input[9] = key.readUInt32LE(20);
	  this.input[10] = key.readUInt32LE(24);
	  this.input[11] = key.readUInt32LE(28);

	  this.input[12] = 0;

	  this.input[13] = nonce.readUInt32LE(0);
	  this.input[14] = nonce.readUInt32LE(4);
	  this.input[15] = nonce.readUInt32LE(8);
	  
	  this.cachePos = 64;
	  this.buffer = new Uint32Array(16);
	  this.output = new Buffer$1(64);
	}

	Chacha20.prototype.quarterRound = function(a, b, c, d) {
	  var x = this.buffer;
	  x[a] += x[b]; x[d] = ROTATE(x[d] ^ x[a], 16);
	  x[c] += x[d]; x[b] = ROTATE(x[b] ^ x[c], 12);
	  x[a] += x[b]; x[d] = ROTATE(x[d] ^ x[a],  8);
	  x[c] += x[d]; x[b] = ROTATE(x[b] ^ x[c],  7);
	};
	Chacha20.prototype.makeBlock = function (output, start) {
	  var i = -1;
	  // copy input into working buffer
	  while (++i < 16) {
	    this.buffer[i] = this.input[i];
	  }
	  i = -1;
	  while (++i < 10) {
	    // straight round
	    this.quarterRound(0, 4, 8,12);
	    this.quarterRound(1, 5, 9,13);
	    this.quarterRound(2, 6,10,14);
	    this.quarterRound(3, 7,11,15);


	    //diaganle round
	    this.quarterRound(0, 5,10,15);
	    this.quarterRound(1, 6,11,12);
	    this.quarterRound(2, 7, 8,13);
	    this.quarterRound(3, 4, 9,14);
	  }
	  i = -1;
	  // copy working buffer into output
	  while (++i < 16) {
	    this.buffer[i] += this.input[i];
	    output.writeUInt32LE(this.buffer[i], start);
	    start += 4;
	  }

	  this.input[12]++;
	  if (!this.input[12]) {
	    throw new Error('counter is exausted');
	  }
	};
	Chacha20.prototype.getBytes = function(len) {
	  var dpos = 0;
	  var dst = new Buffer$1(len);
	  var cacheLen = 64 - this.cachePos;
	  if (cacheLen) {
	    if (cacheLen >= len) {
	      this.output.copy(dst, 0, this.cachePos, 64);
	      this.cachePos += len;
	      return dst;
	    } else {
	      this.output.copy(dst, 0, this.cachePos, 64);
	      len -= cacheLen;
	      dpos += cacheLen;
	      this.cachePos = 64;
	    }
	  }
	  while (len > 0 ) {
	    if (len <= 64) {
	      this.makeBlock(this.output, 0);
	      this.output.copy(dst, dpos, 0, len);
	      if (len < 64) {
	        this.cachePos = len;
	      }
	      return dst;
	    } else {
	      this.makeBlock(dst, dpos);
	    }
	    len -= 64;
	    dpos += 64;
	  }
	  throw new Error('something bad happended');
	};
	return chacha20;
}

var poly1305;
var hasRequiredPoly1305;

function requirePoly1305 () {
	if (hasRequiredPoly1305) return poly1305;
	hasRequiredPoly1305 = 1;
	poly1305 = Poly1305;
	function Poly1305(key) {
	  if (!(this instanceof Poly1305)) {
	    return new Poly1305(key);
	  }
	  this.buffer = new Buffer$1(16);
	  this.leftover = 0;
	  this.r = new Uint16Array(10);
	  this.h = new Uint16Array(10);
	  this.pad = new Uint16Array(8);
	  this.finished = 0;

	  var t = new Uint16Array(8), i;
	 
	  for (i = 8; i--;) t[i] = key.readUInt16LE(i*2);
	 
	  this.r[0] =   t[0]                         & 0x1fff;
	  this.r[1] = ((t[0] >>> 13) | (t[1] <<  3)) & 0x1fff;
	  this.r[2] = ((t[1] >>> 10) | (t[2] <<  6)) & 0x1f03;
	  this.r[3] = ((t[2] >>>  7) | (t[3] <<  9)) & 0x1fff;
	  this.r[4] = ((t[3] >>>  4) | (t[4] << 12)) & 0x00ff;
	  this.r[5] =  (t[4] >>>  1)                 & 0x1ffe;
	  this.r[6] = ((t[4] >>> 14) | (t[5] <<  2)) & 0x1fff;
	  this.r[7] = ((t[5] >>> 11) | (t[6] <<  5)) & 0x1f81;
	  this.r[8] = ((t[6] >>>  8) | (t[7] <<  8)) & 0x1fff;
	  this.r[9] =  (t[7] >>>  5)                 & 0x007f;
	 
	  for (i = 8; i--;) {
	    this.h[i]   = 0;
	    this.pad[i] = key.readUInt16LE( 16+(2*i));
	  }
	  this.h[8] = 0;
	  this.h[9] = 0;
	  this.leftover = 0;
	  this.finished = 0;  
	}

	Poly1305.prototype.blocks = function(m, mpos, bytes) {
	  var hibit = this.finished ? 0 : (1 << 11);
	  var t = new Uint16Array(8),
	      d = new Uint32Array(10),
	      c = 0, i = 0, j = 0;
	 
	  while (bytes >= 16) {
	    for (i = 8; i--;) t[i] = m.readUInt16LE(i*2+mpos);
	 
	    this.h[0] +=   t[0]                         & 0x1fff;
	    this.h[1] += ((t[0] >>> 13) | (t[1] <<  3)) & 0x1fff;
	    this.h[2] += ((t[1] >>> 10) | (t[2] <<  6)) & 0x1fff;
	    this.h[3] += ((t[2] >>>  7) | (t[3] <<  9)) & 0x1fff;
	    this.h[4] += ((t[3] >>>  4) | (t[4] << 12)) & 0x1fff;
	    this.h[5] +=  (t[4] >>>  1)                 & 0x1fff;
	    this.h[6] += ((t[4] >>> 14) | (t[5] <<  2)) & 0x1fff;
	    this.h[7] += ((t[5] >>> 11) | (t[6] <<  5)) & 0x1fff;
	    this.h[8] += ((t[6] >>>  8) | (t[7] <<  8)) & 0x1fff;
	    this.h[9] +=  (t[7] >>>  5)                 | hibit;
	 
	    for (i = 0, c = 0; i < 10; i++) {
	      d[i] = c;
	      for (j = 0; j < 10; j++) {
	        d[i] += (this.h[j] & 0xffffffff) * ((j <= i) ? this.r[i-j] : (5 * this.r[i+10-j]));
	        if (j === 4) {
	          c = (d[i] >>> 13);
	          d[i] &= 0x1fff;
	        }
	      }
	      c += (d[i] >>> 13);
	      d[i] &= 0x1fff;
	    }
	    c = ((c << 2) + c);
	    c += d[0];
	    d[0] = ((c & 0xffff) & 0x1fff);
	    c = (c >>> 13);
	    d[1] += c;
	 
	    for (i = 10; i--;) this.h[i] = d[i];
	 
	    mpos += 16;
	    bytes -= 16;
	  }
	};

	Poly1305.prototype.update = function(m) {
	  var bytes = m.length;
	  var want = 0, i = 0, mpos = 0;
	  // var chunk;
	  // this.buffer = Buffer.concat([this.buffer, m]);
	  // while (this.buffer.length >= 16) {
	  //   chunk = this.buffer.slice(0, 16);
	  //   this.buffer = this.buffer.slice(16)
	  //   this.blocks(chunk, 0, 16);
	  // }
	  if (this.leftover) {
	    want = 16 - this.leftover;
	    if (want > bytes)
	      want = bytes;
	    for (i = want; i--;) {
	      this.buffer[this.leftover+i] = m[i+mpos];
	    }
	    bytes -= want;
	    mpos += want;
	    this.leftover += want;
	    if (this.leftover < 16)
	      return this;
	    this.blocks(this.buffer, 0, 16);
	    this.leftover = 0;    
	  }
	 
	  if (bytes >= 16) {
	    want = (bytes & -16);
	    this.blocks(m, mpos, want);
	    mpos += want;
	    bytes -= want;
	  }
	 
	  if (bytes) {
	    for (i = bytes; i--;) {
	      this.buffer[this.leftover+i] = m[i+mpos];
	    }
	    this.leftover += bytes;
	  }
	  return this;
	};
	 
	Poly1305.prototype.finish = function() {
	  var mac = new Buffer$1(16),
	      g = new Uint16Array(10),
	      c = 0, mask = 0, f = 0, i = 0;
	  if (this.leftover) {
	    i = this.leftover;
	    this.buffer[i++] = 1;
	    for (; i < 16; i++) {
	      this.buffer[i] = 0;
	    }
	    this.finished = 1;
	    this.blocks(this.buffer, 0, 16);
	  }
	 
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  for (i = 2; i < 10; i++) {
	    this.h[i] += c;
	    c = this.h[i] >>> 13;
	    this.h[i] &= 0x1fff;
	  }
	  this.h[0] += (c * 5);
	  c = this.h[0] >>> 13;
	  this.h[0] &= 0x1fff;
	  this.h[1] += c;
	  c = this.h[1] >>> 13;
	  this.h[1] &= 0x1fff;
	  this.h[2] += c;
	 
	  g[0] = this.h[0] + 5;
	  c = g[0] >>> 13;
	  g[0] &= 0x1fff;
	  for (i = 1; i < 10; i++) {
	    g[i] = this.h[i] + c;
	    c = g[i] >>> 13;
	    g[i] &= 0x1fff;
	  }
	  g[9] -= (1 << 13);
	 
	  mask = (g[9] >>> 15) - 1;
	  for (i = 10; i--;) g[i] &= mask;
	  mask = ~mask;
	  for (i = 10; i--;) {
	    this.h[i] = (this.h[i] & mask) | g[i];
	  }
	 
	  this.h[0] = (this.h[0]      ) | (this.h[1] << 13);
	  this.h[1] = (this.h[1] >>  3) | (this.h[2] << 10);
	  this.h[2] = (this.h[2] >>  6) | (this.h[3] <<  7);
	  this.h[3] = (this.h[3] >>  9) | (this.h[4] <<  4);
	  this.h[4] = (this.h[4] >> 12) | (this.h[5] <<  1) | (this.h[6] << 14);
	  this.h[5] = (this.h[6] >>  2) | (this.h[7] << 11);
	  this.h[6] = (this.h[7] >>  5) | (this.h[8] <<  8);
	  this.h[7] = (this.h[8] >>  8) | (this.h[9] <<  5);
	 
	  f = (this.h[0] & 0xffffffff) + this.pad[0];
	  this.h[0] = f;
	  for (i = 1; i < 8; i++) {
	    f = (this.h[i] & 0xffffffff) + this.pad[i] + (f >>> 16);
	    this.h[i] = f;
	  }
	 
	  for (i = 8; i--;) {
	    mac.writeUInt16LE(this.h[i], i*2);
	    this.pad[i] = 0;
	  }
	  for (i = 10; i--;) {
	    this.h[i] = 0;
	    this.r[i] = 0;
	  }

	  return mac;
	};
	return poly1305;
}

var aead;
var hasRequiredAead;

function requireAead () {
	if (hasRequiredAead) return aead;
	hasRequiredAead = 1;
	var inherits = requireInherits_browser();
	var CipherBase = requireCipherbase();
	var Chacha20 = requireChacha20();
	var CipherBase = requireCipherbase();
	var Poly1305 = requirePoly1305();
	inherits(Cipher, CipherBase);
	aead = Cipher;
	function Cipher(key, iv, decrypt){
	  if (!(this instanceof Cipher)) {
	    return new Cipher(key, iv, decrypt);
	  }
	  CipherBase.call(this);
	  this.alen = 0;
	  this.clen = 0;
	  this.chacha = new Chacha20(key, iv);
	  this.poly = new Poly1305(this.chacha.getBytes(64));
	  this.tag = null;
	  this._decrypt = decrypt;
	  this._hasData = false;
	}
	Cipher.prototype.setAAD = function (aad) {
	  if (this._hasData) {
	    throw new Error('Attempting to set AAD in unsupported state');
	  }
	  this.alen = aad.length;
	  this.poly.update(aad);
	  var padding = new Buffer$1(padAmount(this.alen));
	  if (padding.length) {
	    padding.fill(0);
	    this.poly.update(padding);
	  }
	};
	Cipher.prototype._update = function (chunk) {
	  if (!this._hasData) {
	    this._hasData = true;
	  }
	  var len = chunk.length;
	  if (!len) {
	    return next();
	  }
	  this.clen += len;
	  var pad = this.chacha.getBytes(len);
	  var i = -1;
	  while (++i < len) {
	    pad[i] ^= chunk[i];
	  }
	  if (this._decrypt) {
	    this.poly.update(chunk);
	  } else {
	    this.poly.update(pad);
	  }
	  return pad;
	};
	Cipher.prototype._final = function () {
	  if (this._decrypt && !this.tag) {
	    throw new Error('Unsupported state or unable to authenticate data');
	  }
	  var padding = new Buffer$1(padAmount(this.clen));
	  if (padding.length) {
	    padding.fill(0);
	    this.poly.update(padding);
	  }
	  var lens = new Buffer$1(16);
	  lens.fill(0);
	  lens.writeUInt32LE(this.alen, 0);
	  lens.writeUInt32LE(this.clen, 8);
	  var tag = this.poly.update(lens).finish();
	  if (this._decrypt) {
	    if (xorTest(tag, this.tag)) {
	      throw new Error('Unsupported state or unable to authenticate data');
	    }
	  } else {
	    this.tag = tag;
	  }
	};
	Cipher.prototype.getAuthTag = function () {
	  if(this._decrypt || this.tag === null) {
	    throw new Error('Attempting to get auth tag in unsupported state');
	  }
	  return this.tag;
	};
	Cipher.prototype.setAuthTag = function setAuthTag (tag) {
	  if (this._decrypt) {
	    this.tag = tag;
	  } else {
	    throw new Error('Attempting to set auth tag in unsupported state');
	  }
	};
	function padAmount(len) {
	  var rem = len % 16;
	  if (!rem) {
	    return 0;
	  }
	  return 16 - rem;
	}
	function xorTest(a, b) {
	  var out = 0;
	  if (a.length !== b.length) {
	    out++;
	  }
	  var len = Math.min(a.length, b.length);
	  var i = -1;
	  while (++i < len) {
	    out += (a[i] ^ b[i]);
	  }
	  return out;
	}
	return aead;
}

var polystream;
var hasRequiredPolystream;

function requirePolystream () {
	if (hasRequiredPolystream) return polystream;
	hasRequiredPolystream = 1;
	var inherits = requireInherits_browser();

	var CipherBase = requireCipherbase();
	var Poly1305 = requirePoly1305();
	polystream = PolyStream;
	inherits(PolyStream, CipherBase);
	function PolyStream (key) {
	  if (!(this instanceof PolyStream)) {
	    return new PolyStream(key);
	  }
	  CipherBase.call(this, true);
	  this.poly = new Poly1305(key);
	}
	PolyStream.prototype._update = function (data) {
	  this.poly.update(data);
	};

	PolyStream.prototype._final = function () {
	  return this.poly.finish();
	};
	return polystream;
}

var chachastream;
var hasRequiredChachastream;

function requireChachastream () {
	if (hasRequiredChachastream) return chachastream;
	hasRequiredChachastream = 1;
	var Chacha20 = requireChacha20();
	var inherits = requireInherits_browser();
	var CipherBase = requireCipherbase();
	inherits(ChaChaStream, CipherBase);
	chachastream = ChaChaStream;
	function ChaChaStream (key, iv) {
	  if (!(this instanceof ChaChaStream)) {
	    return new ChaChaStream(key, iv);
	  }
	  CipherBase.call(this);
	  this.chacha = new Chacha20(key, iv);
	}
	ChaChaStream.prototype._update = function (chunk) {
	  var len = chunk.length;
	  if (!len) {
	    return;
	  }
	  var pad = this.chacha.getBytes(len);
	  var i = -1;
	  while (++i < len) {
	    pad[i] ^= chunk[i];
	  }
	  return pad;
	  };
	return chachastream;
}

var legacyAead;
var hasRequiredLegacyAead;

function requireLegacyAead () {
	if (hasRequiredLegacyAead) return legacyAead;
	hasRequiredLegacyAead = 1;
	var inherits = requireInherits_browser();
	var CipherBase = requireCipherbase();
	var Chacha20 = requireChacha20();
	var Poly1305 = requirePoly1305();
	inherits(Cipher, CipherBase);
	legacyAead = Cipher;
	    var zeros = new Buffer$1 (4);
	    zeros.fill(0);
	function Cipher(key, iv, decrypt){
	  if (!(this instanceof Cipher)) {
	    return new Cipher(key, iv, decrypt);
	  }
	  CipherBase.call(this);
	  this.alen = 0;
	  this.clen = 0;
	  this.chacha = new Chacha20(key, Buffer$1.concat([zeros,iv]));
	  this.poly = new Poly1305(this.chacha.getBytes(64));
	  this.tag = null;
	  this._decrypt = decrypt;
	  this._hasData = false;
	}
	Cipher.prototype.setAAD = function (aad) {
	  if (this._hasData) {
	    throw new Error('Attempting to set AAD in unsupported state');
	  }
	  this.alen += aad.length;
	  this.poly.update(aad);
	  // var padding = new Buffer(padAmount(this.alen));
	  // if (padding.length) {
	  //   padding.fill(0);
	  //   this.poly.update(padding);
	  // }
	  //this.poly.update(len);
	};
	Cipher.prototype._flushlentag = function () {
	  this._hasData = true;
	  var len = new Buffer$1(8);
	  len.fill(0);
	  len.writeUInt32LE(this.alen, 0);
	  this.poly.update(len);
	};
	Cipher.prototype._update = function (chunk) {
	  if (!this._hasData) {
	    this._flushlentag();
	  }
	  var len = chunk.length;
	  if (!len) {
	    return;
	  }
	  this.clen += len;
	  var pad = this.chacha.getBytes(len);
	  var i = -1;
	  while (++i < len) {
	    pad[i] ^= chunk[i];
	  }
	  if (this._decrypt) {
	    this.poly.update(chunk);
	  } else {
	    this.poly.update(pad);
	  }
	  return pad;
	};
	Cipher.prototype._final = function () {
	  if (this._decrypt && !this.tag) {
	    throw new Error('Unsupported state or unable to authenticate data');
	  }
	  if (!this._hasData) {
	    this._flushlentag();
	  }
	  // var padding = new Buffer(padAmount(this.clen));
	  // if (padding.length) {
	  //   padding.fill(0);
	  //   this.poly.update(padding);
	  // }
	  var lens = new Buffer$1(8);
	  lens.fill(0);
	  //lens.writeUInt32LE(this.alen, 0);
	  lens.writeUInt32LE(this.clen, 0);
	  var tag = this.poly.update(lens).finish();
	  if (this._decrypt) {
	    if (xorTest(tag, this.tag)) {
	      throw new Error('Unsupported state or unable to authenticate data');
	    }
	  } else {
	    this.tag = tag;
	  }
	};
	Cipher.prototype.getAuthTag = function () {
	  if(this._decrypt || this.tag === null) {
	    throw new Error('Attempting to get auth tag in unsupported state');
	  }
	  return this.tag;
	};
	Cipher.prototype.setAuthTag = function setAuthTag (tag) {
	  if (this._decrypt) {
	    this.tag = tag;
	  } else {
	    throw new Error('Attempting to set auth tag in unsupported state');
	  }
	};
	function xorTest(a, b) {
	  var out = 0;
	  if (a.length !== b.length) {
	    out++;
	  }
	  var len = Math.min(a.length, b.length);
	  var i = -1;
	  while (++i < len) {
	    out += (a[i] ^ b[i]);
	  }
	  return out;
	}
	return legacyAead;
}

var hasRequiredBrowser$b;

function requireBrowser$b () {
	if (hasRequiredBrowser$b) return browser$d;
	hasRequiredBrowser$b = 1;
	var Cipher = requireAead();
	browser$d.aead = Cipher;
	browser$d.createCipher = createCipher;
	function createCipher(key, iv) {
	  return new Cipher(key, iv);
	}
	browser$d.createDecipher = createDecipher;
	function createDecipher(key, iv) {
	  return new Cipher(key, iv, true);
	}

	browser$d.createHmac = requirePolystream();
	browser$d.chacha20 = browser$d.ChaCha20 = requireChachastream();
	browser$d.aeadLegacy = browser$d.AeadLegacy = requireLegacyAead();
	return browser$d;
}

requireBrowser$b();

var util;
var hasRequiredUtil;

function requireUtil () {
	if (hasRequiredUtil) return util;
	hasRequiredUtil = 1;
	const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array';

	// For convenience, let people hash a string, not just a Uint8Array
	function normalizeInput (input) {
	  let ret;
	  if (input instanceof Uint8Array) {
	    ret = input;
	  } else if (typeof input === 'string') {
	    const encoder = new TextEncoder();
	    ret = encoder.encode(input);
	  } else {
	    throw new Error(ERROR_MSG_INPUT)
	  }
	  return ret
	}

	// Converts a Uint8Array to a hexadecimal string
	// For example, toHex([255, 0, 255]) returns "ff00ff"
	function toHex (bytes) {
	  return Array.prototype.map
	    .call(bytes, function (n) {
	      return (n < 16 ? '0' : '') + n.toString(16)
	    })
	    .join('')
	}

	// Converts any value in [0...2^32-1] to an 8-character hex string
	function uint32ToHex (val) {
	  return (0x100000000 + val).toString(16).substring(1)
	}

	// For debugging: prints out hash state in the same format as the RFC
	// sample computation exactly, so that you can diff
	function debugPrint (label, arr, size) {
	  let msg = '\n' + label + ' = ';
	  for (let i = 0; i < arr.length; i += 2) {
	    if (size === 32) {
	      msg += uint32ToHex(arr[i]).toUpperCase();
	      msg += ' ';
	      msg += uint32ToHex(arr[i + 1]).toUpperCase();
	    } else if (size === 64) {
	      msg += uint32ToHex(arr[i + 1]).toUpperCase();
	      msg += uint32ToHex(arr[i]).toUpperCase();
	    } else throw new Error('Invalid size ' + size)
	    if (i % 6 === 4) {
	      msg += '\n' + new Array(label.length + 4).join(' ');
	    } else if (i < arr.length - 2) {
	      msg += ' ';
	    }
	  }
	  console.log(msg);
	}

	// For performance testing: generates N bytes of input, hashes M times
	// Measures and prints MB/second hash performance each time
	function testSpeed (hashFn, N, M) {
	  let startMs = new Date().getTime();

	  const input = new Uint8Array(N);
	  for (let i = 0; i < N; i++) {
	    input[i] = i % 256;
	  }
	  const genMs = new Date().getTime();
	  console.log('Generated random input in ' + (genMs - startMs) + 'ms');
	  startMs = genMs;

	  for (let i = 0; i < M; i++) {
	    const hashHex = hashFn(input);
	    const hashMs = new Date().getTime();
	    const ms = hashMs - startMs;
	    startMs = hashMs;
	    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...');
	    console.log(
	      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'
	    );
	  }
	}

	util = {
	  normalizeInput: normalizeInput,
	  toHex: toHex,
	  debugPrint: debugPrint,
	  testSpeed: testSpeed
	};
	return util;
}

var blake2b_1;
var hasRequiredBlake2b;

function requireBlake2b () {
	if (hasRequiredBlake2b) return blake2b_1;
	hasRequiredBlake2b = 1;
	// Blake2B in pure Javascript
	// Adapted from the reference implementation in RFC7693
	// Ported to Javascript by DC - https://github.com/dcposch

	const util = requireUtil();

	// 64-bit unsigned addition
	// Sets v[a,a+1] += v[b,b+1]
	// v should be a Uint32Array
	function ADD64AA (v, a, b) {
	  const o0 = v[a] + v[b];
	  let o1 = v[a + 1] + v[b + 1];
	  if (o0 >= 0x100000000) {
	    o1++;
	  }
	  v[a] = o0;
	  v[a + 1] = o1;
	}

	// 64-bit unsigned addition
	// Sets v[a,a+1] += b
	// b0 is the low 32 bits of b, b1 represents the high 32 bits
	function ADD64AC (v, a, b0, b1) {
	  let o0 = v[a] + b0;
	  if (b0 < 0) {
	    o0 += 0x100000000;
	  }
	  let o1 = v[a + 1] + b1;
	  if (o0 >= 0x100000000) {
	    o1++;
	  }
	  v[a] = o0;
	  v[a + 1] = o1;
	}

	// Little-endian byte access
	function B2B_GET32 (arr, i) {
	  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)
	}

	// G Mixing function
	// The ROTRs are inlined for speed
	function B2B_G (a, b, c, d, ix, iy) {
	  const x0 = m[ix];
	  const x1 = m[ix + 1];
	  const y0 = m[iy];
	  const y1 = m[iy + 1];

	  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s
	  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits

	  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits
	  let xor0 = v[d] ^ v[a];
	  let xor1 = v[d + 1] ^ v[a + 1];
	  v[d] = xor1;
	  v[d + 1] = xor0;

	  ADD64AA(v, c, d);

	  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits
	  xor0 = v[b] ^ v[c];
	  xor1 = v[b + 1] ^ v[c + 1];
	  v[b] = (xor0 >>> 24) ^ (xor1 << 8);
	  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8);

	  ADD64AA(v, a, b);
	  ADD64AC(v, a, y0, y1);

	  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits
	  xor0 = v[d] ^ v[a];
	  xor1 = v[d + 1] ^ v[a + 1];
	  v[d] = (xor0 >>> 16) ^ (xor1 << 16);
	  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16);

	  ADD64AA(v, c, d);

	  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits
	  xor0 = v[b] ^ v[c];
	  xor1 = v[b + 1] ^ v[c + 1];
	  v[b] = (xor1 >>> 31) ^ (xor0 << 1);
	  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1);
	}

	// Initialization Vector
	const BLAKE2B_IV32 = new Uint32Array([
	  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,
	  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,
	  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19
	]);

	const SIGMA8 = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,
	  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,
	  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,
	  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,
	  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,
	  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,
	  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,
	  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,
	  1, 12, 0, 2, 11, 7, 5, 3
	];

	// These are offsets into a uint64 buffer.
	// Multiply them all by 2 to make them offsets into a uint32 buffer,
	// because this is Javascript and we don't have uint64s
	const SIGMA82 = new Uint8Array(
	  SIGMA8.map(function (x) {
	    return x * 2
	  })
	);

	// Compression function. 'last' flag indicates last block.
	// Note we're representing 16 uint64s as 32 uint32s
	const v = new Uint32Array(32);
	const m = new Uint32Array(32);
	function blake2bCompress (ctx, last) {
	  let i = 0;

	  // init work variables
	  for (i = 0; i < 16; i++) {
	    v[i] = ctx.h[i];
	    v[i + 16] = BLAKE2B_IV32[i];
	  }

	  // low 64 bits of offset
	  v[24] = v[24] ^ ctx.t;
	  v[25] = v[25] ^ (ctx.t / 0x100000000);
	  // high 64 bits not supported, offset may not be higher than 2**53-1

	  // last block flag set ?
	  if (last) {
	    v[28] = ~v[28];
	    v[29] = ~v[29];
	  }

	  // get little-endian words
	  for (i = 0; i < 32; i++) {
	    m[i] = B2B_GET32(ctx.b, 4 * i);
	  }

	  // twelve rounds of mixing
	  // uncomment the DebugPrint calls to log the computation
	  // and match the RFC sample documentation
	  // util.debugPrint('          m[16]', m, 64)
	  for (i = 0; i < 12; i++) {
	    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)
	    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
	    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
	    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
	    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
	    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
	    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
	    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
	    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
	  }
	  // util.debugPrint('   (i=12) v[16]', v, 64)

	  for (i = 0; i < 16; i++) {
	    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
	  }
	  // util.debugPrint('h[8]', ctx.h, 64)
	}

	// reusable parameterBlock
	const parameterBlock = new Uint8Array([
	  0,
	  0,
	  0,
	  0, //  0: outlen, keylen, fanout, depth
	  0,
	  0,
	  0,
	  0, //  4: leaf length, sequential mode
	  0,
	  0,
	  0,
	  0, //  8: node offset
	  0,
	  0,
	  0,
	  0, // 12: node offset
	  0,
	  0,
	  0,
	  0, // 16: node depth, inner length, rfu
	  0,
	  0,
	  0,
	  0, // 20: rfu
	  0,
	  0,
	  0,
	  0, // 24: rfu
	  0,
	  0,
	  0,
	  0, // 28: rfu
	  0,
	  0,
	  0,
	  0, // 32: salt
	  0,
	  0,
	  0,
	  0, // 36: salt
	  0,
	  0,
	  0,
	  0, // 40: salt
	  0,
	  0,
	  0,
	  0, // 44: salt
	  0,
	  0,
	  0,
	  0, // 48: personal
	  0,
	  0,
	  0,
	  0, // 52: personal
	  0,
	  0,
	  0,
	  0, // 56: personal
	  0,
	  0,
	  0,
	  0 // 60: personal
	]);

	// Creates a BLAKE2b hashing context
	// Requires an output length between 1 and 64 bytes
	// Takes an optional Uint8Array key
	// Takes an optinal Uint8Array salt
	// Takes an optinal Uint8Array personal
	function blake2bInit (outlen, key, salt, personal) {
	  if (outlen === 0 || outlen > 64) {
	    throw new Error('Illegal output length, expected 0 < length <= 64')
	  }
	  if (key && key.length > 64) {
	    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')
	  }
	  if (salt && salt.length !== 16) {
	    throw new Error('Illegal salt, expected Uint8Array with length is 16')
	  }
	  if (personal && personal.length !== 16) {
	    throw new Error('Illegal personal, expected Uint8Array with length is 16')
	  }

	  // state, 'param block'
	  const ctx = {
	    b: new Uint8Array(128),
	    h: new Uint32Array(16),
	    t: 0, // input count
	    c: 0, // pointer within buffer
	    outlen: outlen // output length in bytes
	  };

	  // initialize parameterBlock before usage
	  parameterBlock.fill(0);
	  parameterBlock[0] = outlen;
	  if (key) parameterBlock[1] = key.length;
	  parameterBlock[2] = 1; // fanout
	  parameterBlock[3] = 1; // depth
	  if (salt) parameterBlock.set(salt, 32);
	  if (personal) parameterBlock.set(personal, 48);

	  // initialize hash state
	  for (let i = 0; i < 16; i++) {
	    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4);
	  }

	  // key the hash, if applicable
	  if (key) {
	    blake2bUpdate(ctx, key);
	    // at the end
	    ctx.c = 128;
	  }

	  return ctx
	}

	// Updates a BLAKE2b streaming hash
	// Requires hash context and Uint8Array (byte array)
	function blake2bUpdate (ctx, input) {
	  for (let i = 0; i < input.length; i++) {
	    if (ctx.c === 128) {
	      // buffer full ?
	      ctx.t += ctx.c; // add counters
	      blake2bCompress(ctx, false); // compress (not last)
	      ctx.c = 0; // counter to zero
	    }
	    ctx.b[ctx.c++] = input[i];
	  }
	}

	// Completes a BLAKE2b streaming hash
	// Returns a Uint8Array containing the message digest
	function blake2bFinal (ctx) {
	  ctx.t += ctx.c; // mark last block offset

	  while (ctx.c < 128) {
	    // fill up with zeros
	    ctx.b[ctx.c++] = 0;
	  }
	  blake2bCompress(ctx, true); // final block flag = 1

	  // little endian convert and store
	  const out = new Uint8Array(ctx.outlen);
	  for (let i = 0; i < ctx.outlen; i++) {
	    out[i] = ctx.h[i >> 2] >> (8 * (i & 3));
	  }
	  return out
	}

	// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array
	//
	// Returns a n-byte Uint8Array
	//
	// Parameters:
	// - input - the input bytes, as a string, Buffer or Uint8Array
	// - key - optional key Uint8Array, up to 64 bytes
	// - outlen - optional output length in bytes, default 64
	// - salt - optional salt bytes, string, Buffer or Uint8Array
	// - personal - optional personal bytes, string, Buffer or Uint8Array
	function blake2b (input, key, outlen, salt, personal) {
	  // preprocess inputs
	  outlen = outlen || 64;
	  input = util.normalizeInput(input);
	  if (salt) {
	    salt = util.normalizeInput(salt);
	  }
	  if (personal) {
	    personal = util.normalizeInput(personal);
	  }

	  // do the math
	  const ctx = blake2bInit(outlen, key, salt, personal);
	  blake2bUpdate(ctx, input);
	  return blake2bFinal(ctx)
	}

	// Computes the BLAKE2B hash of a string or byte array
	//
	// Returns an n-byte hash in hex, all lowercase
	//
	// Parameters:
	// - input - the input bytes, as a string, Buffer, or Uint8Array
	// - key - optional key Uint8Array, up to 64 bytes
	// - outlen - optional output length in bytes, default 64
	// - salt - optional salt bytes, string, Buffer or Uint8Array
	// - personal - optional personal bytes, string, Buffer or Uint8Array
	function blake2bHex (input, key, outlen, salt, personal) {
	  const output = blake2b(input, key, outlen, salt, personal);
	  return util.toHex(output)
	}

	blake2b_1 = {
	  blake2b: blake2b,
	  blake2bHex: blake2bHex,
	  blake2bInit: blake2bInit,
	  blake2bUpdate: blake2bUpdate,
	  blake2bFinal: blake2bFinal
	};
	return blake2b_1;
}

var blake2s_1;
var hasRequiredBlake2s;

function requireBlake2s () {
	if (hasRequiredBlake2s) return blake2s_1;
	hasRequiredBlake2s = 1;
	// BLAKE2s hash function in pure Javascript
	// Adapted from the reference implementation in RFC7693
	// Ported to Javascript by DC - https://github.com/dcposch

	const util = requireUtil();

	// Little-endian byte access.
	// Expects a Uint8Array and an index
	// Returns the little-endian uint32 at v[i..i+3]
	function B2S_GET32 (v, i) {
	  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)
	}

	// Mixing function G.
	function B2S_G (a, b, c, d, x, y) {
	  v[a] = v[a] + v[b] + x;
	  v[d] = ROTR32(v[d] ^ v[a], 16);
	  v[c] = v[c] + v[d];
	  v[b] = ROTR32(v[b] ^ v[c], 12);
	  v[a] = v[a] + v[b] + y;
	  v[d] = ROTR32(v[d] ^ v[a], 8);
	  v[c] = v[c] + v[d];
	  v[b] = ROTR32(v[b] ^ v[c], 7);
	}

	// 32-bit right rotation
	// x should be a uint32
	// y must be between 1 and 31, inclusive
	function ROTR32 (x, y) {
	  return (x >>> y) ^ (x << (32 - y))
	}

	// Initialization Vector.
	const BLAKE2S_IV = new Uint32Array([
	  0x6a09e667,
	  0xbb67ae85,
	  0x3c6ef372,
	  0xa54ff53a,
	  0x510e527f,
	  0x9b05688c,
	  0x1f83d9ab,
	  0x5be0cd19
	]);

	const SIGMA = new Uint8Array([
	  0,
	  1,
	  2,
	  3,
	  4,
	  5,
	  6,
	  7,
	  8,
	  9,
	  10,
	  11,
	  12,
	  13,
	  14,
	  15,
	  14,
	  10,
	  4,
	  8,
	  9,
	  15,
	  13,
	  6,
	  1,
	  12,
	  0,
	  2,
	  11,
	  7,
	  5,
	  3,
	  11,
	  8,
	  12,
	  0,
	  5,
	  2,
	  15,
	  13,
	  10,
	  14,
	  3,
	  6,
	  7,
	  1,
	  9,
	  4,
	  7,
	  9,
	  3,
	  1,
	  13,
	  12,
	  11,
	  14,
	  2,
	  6,
	  5,
	  10,
	  4,
	  0,
	  15,
	  8,
	  9,
	  0,
	  5,
	  7,
	  2,
	  4,
	  10,
	  15,
	  14,
	  1,
	  11,
	  12,
	  6,
	  8,
	  3,
	  13,
	  2,
	  12,
	  6,
	  10,
	  0,
	  11,
	  8,
	  3,
	  4,
	  13,
	  7,
	  5,
	  15,
	  14,
	  1,
	  9,
	  12,
	  5,
	  1,
	  15,
	  14,
	  13,
	  4,
	  10,
	  0,
	  7,
	  6,
	  3,
	  9,
	  2,
	  8,
	  11,
	  13,
	  11,
	  7,
	  14,
	  12,
	  1,
	  3,
	  9,
	  5,
	  0,
	  15,
	  4,
	  8,
	  6,
	  2,
	  10,
	  6,
	  15,
	  14,
	  9,
	  11,
	  3,
	  0,
	  8,
	  12,
	  2,
	  13,
	  7,
	  1,
	  4,
	  10,
	  5,
	  10,
	  2,
	  8,
	  4,
	  7,
	  6,
	  1,
	  5,
	  15,
	  11,
	  9,
	  14,
	  3,
	  12,
	  13,
	  0
	]);

	// Compression function. "last" flag indicates last block
	const v = new Uint32Array(16);
	const m = new Uint32Array(16);
	function blake2sCompress (ctx, last) {
	  let i = 0;
	  for (i = 0; i < 8; i++) {
	    // init work variables
	    v[i] = ctx.h[i];
	    v[i + 8] = BLAKE2S_IV[i];
	  }

	  v[12] ^= ctx.t; // low 32 bits of offset
	  v[13] ^= ctx.t / 0x100000000; // high 32 bits
	  if (last) {
	    // last block flag set ?
	    v[14] = ~v[14];
	  }

	  for (i = 0; i < 16; i++) {
	    // get little-endian words
	    m[i] = B2S_GET32(ctx.b, 4 * i);
	  }

	  // ten rounds of mixing
	  // uncomment the DebugPrint calls to log the computation
	  // and match the RFC sample documentation
	  // util.debugPrint('          m[16]', m, 32)
	  for (i = 0; i < 10; i++) {
	    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)
	    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
	    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
	    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
	    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
	    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
	    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
	    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
	    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
	  }
	  // util.debugPrint('   (i=10) v[16]', v, 32)

	  for (i = 0; i < 8; i++) {
	    ctx.h[i] ^= v[i] ^ v[i + 8];
	  }
	  // util.debugPrint('h[8]', ctx.h, 32)
	}

	// Creates a BLAKE2s hashing context
	// Requires an output length between 1 and 32 bytes
	// Takes an optional Uint8Array key
	function blake2sInit (outlen, key) {
	  if (!(outlen > 0 && outlen <= 32)) {
	    throw new Error('Incorrect output length, should be in [1, 32]')
	  }
	  const keylen = key ? key.length : 0;
	  if (key && !(keylen > 0 && keylen <= 32)) {
	    throw new Error('Incorrect key length, should be in [1, 32]')
	  }

	  const ctx = {
	    h: new Uint32Array(BLAKE2S_IV), // hash state
	    b: new Uint8Array(64), // input block
	    c: 0, // pointer within block
	    t: 0, // input count
	    outlen: outlen // output length in bytes
	  };
	  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen;

	  if (keylen > 0) {
	    blake2sUpdate(ctx, key);
	    ctx.c = 64; // at the end
	  }

	  return ctx
	}

	// Updates a BLAKE2s streaming hash
	// Requires hash context and Uint8Array (byte array)
	function blake2sUpdate (ctx, input) {
	  for (let i = 0; i < input.length; i++) {
	    if (ctx.c === 64) {
	      // buffer full ?
	      ctx.t += ctx.c; // add counters
	      blake2sCompress(ctx, false); // compress (not last)
	      ctx.c = 0; // counter to zero
	    }
	    ctx.b[ctx.c++] = input[i];
	  }
	}

	// Completes a BLAKE2s streaming hash
	// Returns a Uint8Array containing the message digest
	function blake2sFinal (ctx) {
	  ctx.t += ctx.c; // mark last block offset
	  while (ctx.c < 64) {
	    // fill up with zeros
	    ctx.b[ctx.c++] = 0;
	  }
	  blake2sCompress(ctx, true); // final block flag = 1

	  // little endian convert and store
	  const out = new Uint8Array(ctx.outlen);
	  for (let i = 0; i < ctx.outlen; i++) {
	    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff;
	  }
	  return out
	}

	// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array
	//
	// Returns a n-byte Uint8Array
	//
	// Parameters:
	// - input - the input bytes, as a string, Buffer, or Uint8Array
	// - key - optional key Uint8Array, up to 32 bytes
	// - outlen - optional output length in bytes, default 64
	function blake2s (input, key, outlen) {
	  // preprocess inputs
	  outlen = outlen || 32;
	  input = util.normalizeInput(input);

	  // do the math
	  const ctx = blake2sInit(outlen, key);
	  blake2sUpdate(ctx, input);
	  return blake2sFinal(ctx)
	}

	// Computes the BLAKE2S hash of a string or byte array
	//
	// Returns an n-byte hash in hex, all lowercase
	//
	// Parameters:
	// - input - the input bytes, as a string, Buffer, or Uint8Array
	// - key - optional key Uint8Array, up to 32 bytes
	// - outlen - optional output length in bytes, default 64
	function blake2sHex (input, key, outlen) {
	  const output = blake2s(input, key, outlen);
	  return util.toHex(output)
	}

	blake2s_1 = {
	  blake2s: blake2s,
	  blake2sHex: blake2sHex,
	  blake2sInit: blake2sInit,
	  blake2sUpdate: blake2sUpdate,
	  blake2sFinal: blake2sFinal
	};
	return blake2s_1;
}

var blakejs;
var hasRequiredBlakejs;

function requireBlakejs () {
	if (hasRequiredBlakejs) return blakejs;
	hasRequiredBlakejs = 1;
	const b2b = requireBlake2b();
	const b2s = requireBlake2s();

	blakejs = {
	  blake2b: b2b.blake2b,
	  blake2bHex: b2b.blake2bHex,
	  blake2bInit: b2b.blake2bInit,
	  blake2bUpdate: b2b.blake2bUpdate,
	  blake2bFinal: b2b.blake2bFinal,
	  blake2s: b2s.blake2s,
	  blake2sHex: b2s.blake2sHex,
	  blake2sInit: b2s.blake2sInit,
	  blake2sUpdate: b2s.blake2sUpdate,
	  blake2sFinal: b2s.blake2sFinal
	};
	return blakejs;
}

var blakejsExports = requireBlakejs();

const blake2b160 = (data) => blakejsExports.blake2b(data, void 0, 20);
const blake2b224Str = (data) => blakejsExports.blake2bHex(data, void 0, 28);
const blake2b256 = (data) => blakejsExports.blake2b(data, void 0, 32);
const blake2b256Str = (data) => blakejsExports.blake2bHex(data, void 0, 32);

const assetIdBech32Map = {};
const decodeBech32 = (data) => Buffer$1.from(distExports.bech32.fromWords(distExports.bech32.decode(data, 128).words)).toString("hex");
const encodeBech32 = (prefix, data) => distExports.bech32.encode(prefix, distExports.bech32.toWords(data));
const getAssetIdBech32 = (policyId, assetName) => {
  if (policyId.length === 0) {
    return "";
  }
  let _bech32 = assetIdBech32Map[policyId + "." + assetName];
  if (!_bech32) {
    _bech32 = distExports.bech32.encode(
      "asset",
      distExports.bech32.toWords(
        blake2b160(
          toHexBuffer(
            byteaToHex(policyId) + byteaToHex(assetName)
          )
        )
      )
    );
    assetIdBech32Map[policyId + "." + assetName] = _bech32;
  }
  return _bech32;
};

const getEnterpriseAddressFromAddress = (cslAddr) => EnterpriseAddress.from_address(cslAddr);
const getRewardAddressFromAddress = (cslAddr) => RewardAddress.from_address(cslAddr);
const getBaseAddressFromAddress = (cslAddr) => BaseAddress.from_address(cslAddr);
const getPointerAddressFromAddress = (cslAddr) => PointerAddress.from_address(cslAddr);
const getByronAddressFromAddress = (cslAddr) => ByronAddress.from_address(cslAddr);
const getEnterpriseAddressFromBech32 = (addrBech32) => getEnterpriseAddressFromAddress(Address.from_bech32(addrBech32));
const getBaseAddressFromBech32 = (addrBech32) => getBaseAddressFromAddress(Address.from_bech32(addrBech32));
const getPointerAddressFromBech32 = (addrBech32) => getPointerAddressFromAddress(Address.from_bech32(addrBech32));
const getRewardAddressFromCred = (stakeCred, networkId, isStakeScript) => {
  const network = getNetworkId(networkId);
  const cslStakeCred = getCSLCredential(stakeCred, isStakeScript);
  const cslRewardAddr = RewardAddress.new(network, cslStakeCred);
  const cslAddr = cslRewardAddr.to_address();
  const addr = cslAddr.to_bech32(void 0);
  safeFreeCSLObject(cslAddr);
  safeFreeCSLObject(cslRewardAddr);
  safeFreeCSLObject(cslStakeCred);
  return addr;
};
const getBaseAddressFromCred = (paymentCred, stakeCred, networkId, isPayScript, isStakeScript) => {
  const network = getNetworkId(networkId);
  const cslPaymentCred = getCSLCredential(paymentCred, isPayScript);
  const cslStakeCred = getCSLCredential(stakeCred, isStakeScript);
  const cslBaseAddr = BaseAddress.new(network, cslPaymentCred, cslStakeCred);
  const cslAddr = cslBaseAddr.to_address();
  const addr = cslAddr.to_bech32(networkAddressPrefix[networkId]);
  safeFreeCSLObject(cslAddr);
  safeFreeCSLObject(cslBaseAddr);
  safeFreeCSLObject(cslStakeCred);
  safeFreeCSLObject(cslPaymentCred);
  return addr;
};
const getEnterpriseAddressFromCred = (paymentCred, networkId, isPayScript) => {
  const network = getNetworkId(networkId);
  const cslPaymentCred = getCSLCredential(paymentCred, isPayScript);
  const cslEnterpriseAddr = EnterpriseAddress.new(network, cslPaymentCred);
  const cslAddr = cslEnterpriseAddr.to_address();
  const addr = cslAddr.to_bech32(networkAddressPrefix[networkId]);
  safeFreeCSLObject(cslAddr);
  safeFreeCSLObject(cslEnterpriseAddr);
  safeFreeCSLObject(cslPaymentCred);
  return addr;
};
const isEnterpriseAddress = (addrBech32, networkId) => {
  try {
    const enterpriseAddr = getEnterpriseAddressFromBech32(addrBech32);
    if (enterpriseAddr) {
      const addr = enterpriseAddr.to_address();
      const result = addr.network_id() === getNetworkId(networkId);
      safeFreeCSLObject(addr);
      safeFreeCSLObject(enterpriseAddr);
      return result;
    }
  } catch (e) {
  }
  return false;
};
const isBaseAddress = (addrBech32, networkId) => {
  try {
    const baseAddr = getBaseAddressFromBech32(addrBech32);
    if (baseAddr) {
      const addr = baseAddr.to_address();
      const result = addr.network_id() === getNetworkId(networkId);
      safeFreeCSLObject(addr);
      safeFreeCSLObject(baseAddr);
      return result;
    }
  } catch (e) {
  }
  return false;
};
const isPointerAddress = (addrBech32, networkId) => {
  try {
    const pointerAddr = getPointerAddressFromBech32(addrBech32);
    if (pointerAddr) {
      const addr = pointerAddr.to_address();
      const result = addr.network_id() === getNetworkId(networkId);
      safeFreeCSLObject(addr);
      safeFreeCSLObject(pointerAddr);
      return result;
    }
  } catch (e) {
  }
  return false;
};
const isByronAddress = (addrBech32, networkId) => {
  try {
    const free = [];
    const addr = getCSLAddressOrNull(addrBech32, free);
    if (!addr) {
      return false;
    }
    const byronAddr = getByronAddressFromAddress(addr);
    if (!byronAddr) {
      freeCSLObjects(free);
      return false;
    }
    free.push(byronAddr);
    const result = addr.network_id() === getNetworkId(networkId);
    freeCSLObjects(free);
    return result;
  } catch (e) {
  }
  return false;
};
const isValidSendAddress = (networkId, addr) => isBaseAddress(addr, networkId) || isEnterpriseAddress(addr, networkId) || isPointerAddress(addr, networkId) || isByronAddress(addr, networkId);
const getCredFromCredentials = (cred) => {
  let stakeCred = toHexString(cred.to_bytes());
  if (stakeCred.length > 56) {
    stakeCred = stakeCred.substr(-56);
  }
  safeFreeCSLObject(cred);
  return stakeCred;
};
const _inMemoryCacheAddressCredentials = /* @__PURE__ */ new Map();
const cacheAddressCredentials = (addrHexOrBech32, addressCredentials) => {
  _inMemoryCacheAddressCredentials.set(addrHexOrBech32, addressCredentials);
  return addressCredentials;
};
const getAddressCredentials = (addrHexOrBech32, cslAddr = null, getBytes = false) => {
  if (addrHexOrBech32) {
    if (_inMemoryCacheAddressCredentials.has(addrHexOrBech32)) {
      const cred = _inMemoryCacheAddressCredentials.get(addrHexOrBech32);
      if (getBytes && !cred.addressBytes) {
        cred.addressBytes = getAddressBytes(addrHexOrBech32);
      }
      return cred;
    }
  }
  if (!addrHexOrBech32 && !cslAddr) {
    return { paymentCred: null, stakeCred: null, stakePointer: null, addressBytes: null, isByron: false };
  }
  if (addrHexOrBech32 && !cslAddr) {
    cslAddr = getCSLAddressOrNull(addrHexOrBech32);
  }
  if (!cslAddr) {
    return { paymentCred: null, stakeCred: null, stakePointer: null, addressBytes: null, isByron: false };
  }
  let paymentCred = null;
  let stakeCred = null;
  let addressBytes = null;
  let stakePointer = null;
  let isByron = false;
  const baseAddr = getBaseAddressFromAddress(cslAddr);
  if (baseAddr) {
    paymentCred = getCredFromCredentials(baseAddr.payment_cred());
    stakeCred = getCredFromCredentials(baseAddr.stake_cred());
    if (getBytes) {
      cslAddr = baseAddr.to_address();
      addressBytes = cslAddr.to_bytes();
    }
    safeFreeCSLObject(baseAddr);
  } else {
    const enterpriseAddr = getEnterpriseAddressFromAddress(cslAddr);
    if (enterpriseAddr) {
      paymentCred = getCredFromCredentials(enterpriseAddr.payment_cred());
      if (getBytes) {
        cslAddr = enterpriseAddr.to_address();
        addressBytes = cslAddr.to_bytes();
      }
      safeFreeCSLObject(enterpriseAddr);
    } else {
      const byronAddr = getByronAddressFromAddress(cslAddr);
      if (byronAddr) {
        isByron = true;
        if (getBytes) {
          cslAddr = byronAddr.to_address();
          addressBytes = cslAddr.to_bytes();
        }
        safeFreeCSLObject(byronAddr);
      } else {
        const pointerAddr = getPointerAddressFromAddress(cslAddr);
        if (pointerAddr) {
          paymentCred = getCredFromCredentials(pointerAddr.payment_cred());
          const pointer = pointerAddr.stake_pointer();
          stakePointer = {
            slot: pointer.slot(),
            txIndex: pointer.tx_index(),
            certIndex: pointer.cert_index()
          };
          if (getBytes) {
            cslAddr = pointerAddr.to_address();
            addressBytes = cslAddr.to_bytes();
          }
          safeFreeCSLObject(pointerAddr);
        } else {
          const stakeAddr = getRewardAddressFromAddress(cslAddr);
          if (stakeAddr) {
            stakeCred = getCredFromCredentials(stakeAddr.payment_cred());
            if (getBytes) {
              cslAddr = stakeAddr.to_address();
              addressBytes = cslAddr.to_bytes();
            }
            safeFreeCSLObject(stakeAddr);
          }
        }
      }
    }
  }
  safeFreeCSLObject(cslAddr);
  const res = { paymentCred, stakeCred, stakePointer, addressBytes, isByron };
  if (addrHexOrBech32) {
    cacheAddressCredentials(addrHexOrBech32, res);
  }
  return res;
};
const getAddressBytes = (addrHexOrBech32) => {
  const free = [];
  const addr = getCSLAddressOrNull(addrHexOrBech32, free);
  if (addr) {
    const bytes = addr.to_bytes();
    freeCSLObjects(free);
    return bytes;
  }
  return null;
};
const getAddressCbor = (addrBech32) => {
  const free = [];
  const addr = getCSLAddressOrNull(addrBech32, free);
  if (addr) {
    const cbor = toHexString(addr.to_bytes());
    freeCSLObjects(free);
    return cbor;
  }
  return null;
};
const getAddressFromKeyHash = (keyHash, type) => {
  const cslKeyHash = Ed25519KeyHash.from_bytes(toHexBuffer(keyHash));
  const bech32 = cslKeyHash.to_bech32(type);
  safeFreeCSLObject(cslKeyHash);
  return bech32;
};
const getPoolAddressFromKeyHash = (keyHash) => getAddressFromKeyHash(keyHash, "pool");
const getDRepAddressFromKeyHashOld = (keyHash, isScript = false) => getAddressFromKeyHash(keyHash, isScript ? "drep_script" : "drep");
const getDRepAddressFromKeyHash = (keyHash, isScript) => encodeBech32("drep", toHexBuffer(isScript ? `23${keyHash}` : `22${keyHash}`));
const getCCColdAddressFromKeyHash = (keyHash, isScript) => encodeBech32("cc_cold", toHexBuffer(`12${keyHash}`));
const getCCHotAddressFromKeyHash = (keyHash, isScript = false) => encodeBech32("cc_hot", toHexBuffer(isScript ? `03${keyHash}` : `02${keyHash}`));
const isScriptDRep = (keyHash) => keyHash.substring(1, 2) === "3";
const getGovProposalId = (txHash, index) => encodeBech32("gov_action", toHexBuffer(txHash + index.toString(16).padStart(2, "0")));
const getDRepCredentialsFromAddress = (drepIdBech32) => {
  try {
    if (!drepIdBech32 || !drepIdBech32.startsWith("drep")) {
      throw "ErrorAddress.invalidDRepId." + drepIdBech32;
    }
    let dRepCred = decodeBech32(drepIdBech32);
    let isScript = false;
    if (dRepCred.length === 56) {
      if (drepIdBech32.length === 63 && drepIdBech32.startsWith("drep_script")) {
        isScript = true;
      }
    } else if (dRepCred.length === 58) {
      isScript = isScriptDRep(dRepCred);
      dRepCred = dRepCred.substring(2);
    }
    return { dRepCred, isScript };
  } catch (err) {
    throw err;
  }
};
const getCalidusAddressFromKeyHash = (keyHash) => encodeBech32("calidus", toHexBuffer(`a1${keyHash}`));

const cslToJson = (data) => data ? JSON.parse(data) : null;
const jsonToCsl = (data) => JSON.stringify(data);
const addValueToValue = (to, from, decrease = false) => {
  if (!to) {
    to = { coin: "0" };
  }
  if (!from) {
    return to;
  }
  if (decrease) {
    to.coin = subtract(to.coin, from.coin);
  } else {
    to.coin = add(to.coin, from.coin);
  }
  const multiAsset = addMultiAssets(to.multiasset ?? {}, from.multiasset ?? {}, decrease);
  if (multiAsset) {
    to.multiasset = multiAsset;
  } else {
    if (typeof to.multiasset !== "undefined") {
      delete to.multiasset;
    }
  }
  return to;
};
const addMultiAssets = (to, from, decrease = false, _abs = false) => {
  const multiAssetList = Object.entries(from);
  for (const multiAsset of multiAssetList) {
    const policyId = multiAsset[0];
    const assetList = Object.entries(multiAsset[1]);
    if (!to[policyId]) {
      to[policyId] = {};
    }
    for (const asset of assetList) {
      const assetName = asset[0];
      const quantityIn = asset[1];
      let quantity = to[policyId][assetName];
      if (!quantity) {
        quantity = "0";
      }
      if (_abs) {
        to[policyId][assetName] = subtract(quantity, abs(quantityIn));
      } else if (decrease) {
        to[policyId][assetName] = subtract(quantity, quantityIn);
      } else {
        to[policyId][assetName] = add(quantity, quantityIn);
      }
    }
  }
  trimMultiAsset(to);
  const numAssets = Object.keys(to);
  return numAssets.length > 0 ? to : void 0;
};
const trimMultiAsset = (to) => {
  const multiAssetList = Object.entries(to);
  for (const multiAsset of multiAssetList) {
    const policyId = multiAsset[0];
    const assetList = Object.entries(multiAsset[1]);
    for (const asset of assetList) {
      const assetName = asset[0];
      const quantity = asset[1];
      if (isZero(quantity)) {
        delete to[policyId][assetName];
      }
    }
    const numAssets = Object.keys(to[policyId]);
    if (numAssets.length === 0) {
      delete to[policyId];
    }
  }
};
const createValueJSON = (ref) => {
  return addValueToValue(void 0, ref);
};
const createTransactionInputJSON = (ref) => {
  return {
    index: ref?.index ?? 0,
    transaction_id: ref?.transaction_id ?? ""
  };
};
const createTransactionOutputJSON = (ref) => {
  const output = {
    address: ref?.address ?? "",
    amount: createValueJSON(ref?.amount)
  };
  if (ref?.script_ref) {
    output.script_ref = ref.script_ref;
  }
  if (ref?.plutus_data) {
    output.plutus_data = ref.plutus_data;
  }
  return output;
};
const createTransactionUnspentOutputJSON = (ref) => {
  return {
    input: createTransactionInputJSON(ref?.input),
    output: createTransactionOutputJSON(ref?.output)
  };
};
const getTransactionJSONFromCSL = (networkId, cslTx, requiredSigners) => {
  const free = [];
  const cslTxBody = cslTx.body();
  const cslAuxData = cslTx.auxiliary_data();
  free.push(cslAuxData);
  const cslFee = cslTxBody.fee();
  free.push(cslFee);
  const cslInputs = cslTxBody.inputs();
  free.push(cslInputs);
  const cslRefInputs = cslTxBody.reference_inputs();
  free.push(cslRefInputs);
  const cslCollateral = cslTxBody.collateral();
  free.push(cslCollateral);
  const cslTotalCol = cslTxBody.total_collateral();
  free.push(cslTotalCol);
  const cslCerts = cslTxBody.certs();
  free.push(cslCerts);
  const cslWithdrawals = cslTxBody.withdrawals();
  free.push(cslWithdrawals);
  const cslReqSigners = cslTxBody.required_signers();
  free.push(cslReqSigners);
  const cslAuxDataHash = cslTxBody.auxiliary_data_hash();
  free.push(cslAuxDataHash);
  const cslScriptDataHash = cslTxBody.script_data_hash();
  free.push(cslScriptDataHash);
  const cslTTL = cslTxBody.ttl_bignum();
  free.push(cslTTL);
  const cslVSI = cslTxBody.validity_start_interval_bignum();
  free.push(cslVSI);
  const cslNetworkId = cslTxBody.network_id();
  free.push(cslNetworkId);
  const cslUpdate = cslTxBody.update();
  free.push(cslUpdate);
  const cslVotingProcedures = cslTxBody.voting_procedures();
  free.push(cslVotingProcedures);
  const cslVotingProposals = cslTxBody.voting_proposals();
  free.push(cslVotingProposals);
  const cslDonation = cslTxBody.donation();
  free.push(cslDonation);
  const tx = {
    body: {
      network_id: cslToJson(cslNetworkId?.to_json()),
      auxiliary_data_hash: cslAuxDataHash ? cslAuxDataHash.to_hex() : null,
      fee: cslFee.to_str(),
      ttl: cslTTL?.to_str() ?? null,
      validity_start_interval: cslVSI?.to_str() ?? null,
      certs: cslToJson(cslCerts?.to_json()),
      withdrawals: cslToJson(cslWithdrawals?.to_json()),
      collateral: cslToJson(cslCollateral?.to_json()),
      total_collateral: cslTotalCol?.to_str(),
      reference_inputs: cslToJson(cslRefInputs?.to_json()),
      required_signers: requiredSigners ?? cslToJson(cslReqSigners?.to_json()),
      script_data_hash: cslScriptDataHash ? toHexString(cslScriptDataHash.to_bytes()) : null,
      voting_procedures: cslToJson(cslVotingProcedures?.to_json()),
      voting_proposals: cslToJson(cslVotingProposals?.to_json()),
      donation: cslDonation?.to_str() ?? null,
      inputs: cslToJson(cslInputs?.to_json()),
      outputs: [],
      mint: null,
      collateral_return: null,
      update: cslToJson(cslUpdate?.to_json())
    },
    witness_set: {},
    auxiliary_data: cslToJson(cslAuxData?.to_json()),
    is_valid: cslTx.is_valid()
  };
  freeCSLObjects(free);
  const cslOutputs = cslTxBody.outputs();
  const numOutputs = cslOutputs.len();
  for (let index = 0; index < numOutputs; index++) {
    const cslOutput = cslOutputs.get(index);
    const output = getTransactionOutputJSONFromCSL(networkId, cslOutput);
    tx.body.outputs.push(output);
    safeFreeCSLObject(cslOutput);
  }
  safeFreeCSLObject(cslOutputs);
  const cslColReturn = cslTxBody.collateral_return();
  if (cslColReturn) {
    tx.body.collateral_return = getTransactionOutputJSONFromCSL(networkId, cslColReturn);
    safeFreeCSLObject(cslColReturn);
  }
  const cslMint = cslTxBody.mint();
  if (cslMint) {
    tx.body.mint = getMintJSONFromCSL(cslMint);
    safeFreeCSLObject(cslMint);
  }
  safeFreeCSLObject(cslTxBody);
  const cslWitnessSet = cslTx.witness_set();
  if (cslWitnessSet) {
    const cslVkeys = cslWitnessSet.vkeys();
    const cslNativeScripts = cslWitnessSet.native_scripts();
    const cslPS = cslWitnessSet.plutus_scripts();
    const cslRedeemers = cslWitnessSet.redeemers();
    const witnessSet = {
      bootstraps: null,
      native_scripts: cslToJson(cslNativeScripts?.to_json()),
      plutus_data: null,
      plutus_scripts: cslToJson(cslPS?.to_json()),
      vkeys: cslToJson(cslVkeys?.to_json())
    };
    if (cslRedeemers) {
      const length = cslRedeemers.len();
      if (length > 0) {
        witnessSet.redeemers = [];
      }
      for (let index = 0; index < length; index++) {
        const cslRedeemer = cslRedeemers.get(index);
        const cslExUnits = cslRedeemer.ex_units();
        const cslPS2 = cslRedeemer.data();
        const cslMem = cslExUnits.mem();
        const cslSteps = cslExUnits.steps();
        const cslIndex = cslRedeemer.index();
        const cslTag = cslRedeemer.tag();
        const redeemer = {
          data: toHexString(cslPS2.to_bytes()),
          ex_units: {
            mem: cslMem.to_str(),
            steps: cslSteps.to_str()
          },
          index: cslIndex.to_str(),
          tag: cslTag.to_js_value()
        };
        witnessSet.redeemers.push(redeemer);
        safeFreeCSLObject(cslPS2);
        safeFreeCSLObject(cslMem);
        safeFreeCSLObject(cslSteps);
        safeFreeCSLObject(cslIndex);
        safeFreeCSLObject(cslTag);
        safeFreeCSLObject(cslExUnits);
        safeFreeCSLObject(cslRedeemer);
      }
    }
    safeFreeCSLObject(cslVkeys);
    safeFreeCSLObject(cslRedeemers);
    safeFreeCSLObject(cslPS);
    const cslBS = cslWitnessSet.bootstraps();
    if (cslBS) {
      const length = cslBS.len();
      if (length > 0) {
        witnessSet.bootstraps = [];
      }
      for (let index = 0; index < length; index++) {
        const cslBS_ = cslBS.get(index);
        witnessSet.bootstraps.push(cslToJson(cslBS_.to_json()));
        safeFreeCSLObject(cslBS_);
      }
      safeFreeCSLObject(cslBS);
    }
    const cslNS = cslWitnessSet.native_scripts();
    if (cslNS) {
      const length = cslNS.len();
      if (length > 0) {
        witnessSet.native_scripts = [];
      }
      for (let index = 0; index < length; index++) {
        const cslNS_ = cslNS.get(index);
        witnessSet.native_scripts.push(cslToJson(cslNS_.to_json()));
        safeFreeCSLObject(cslNS_);
      }
      safeFreeCSLObject(cslNS);
    }
    const cslPD = cslWitnessSet.plutus_data();
    if (cslPD) {
      const length = cslPD.len();
      if (length > 0) {
        witnessSet.plutus_data = getPlutusListJSONFromCSL(cslPD);
      }
      safeFreeCSLObject(cslPD);
    }
    tx.witness_set = witnessSet;
    safeFreeCSLObject(cslWitnessSet);
  }
  freeCSLObjects(free);
  return tx;
};
const getTransactionOutputJSONFromCSL = (networkId, cslOutput) => {
  const cslAddress = cslOutput.address();
  let addrBech32 = cslAddress.to_bech32(networkAddressPrefix[networkId]);
  const byronAddr = getByronAddressFromAddress(cslAddress);
  if (byronAddr) {
    addrBech32 = byronAddr.to_base58();
    safeFreeCSLObject(byronAddr);
  }
  safeFreeCSLObject(cslAddress);
  const cslValue = cslOutput.amount();
  const amount = getValueJSONFromCSL(cslValue);
  safeFreeCSLObject(cslValue);
  const cslScriptRef = cslOutput.script_ref();
  const script_ref = cslToJson(cslScriptRef?.to_json());
  safeFreeCSLObject(cslScriptRef);
  const output = {
    address: addrBech32,
    amount,
    script_ref
  };
  const cslDataHash = cslOutput.data_hash();
  const cslPlutusData = cslOutput.plutus_data();
  if (cslDataHash) {
    output.plutus_data = {
      //@ts-ignore
      DataHash: cslDataHash.to_hex()
    };
    safeFreeCSLObject(cslDataHash);
  } else if (cslPlutusData) {
    output.plutus_data = {
      Data: getPlutusDataJSONFromCSL(cslPlutusData)
    };
  }
  safeFreeCSLObject(cslPlutusData);
  return output;
};
const getSortedMultiAssetFromJSON = (multiasset) => {
  const multiAsset = MultiAsset.new();
  const sortedPolicyList = Object.keys(multiasset).sort((a, b) => a.localeCompare(b, "en-US"));
  const maxValue = BigNum$1.max_value();
  const maxValueStr = maxValue.to_str();
  for (let i = 0; i < sortedPolicyList.length; i++) {
    const policy = ScriptHash.from_bytes(toHexArray(sortedPolicyList[i]));
    const assets = Assets.new();
    const sortedAssetList = Object.entries(multiasset[sortedPolicyList[i]]).sort((a, b) => {
      return a[0].length === b[0].length ? a[0].localeCompare(b[0], "en-US") : a[0].length - b[0].length;
    });
    for (const asset of sortedAssetList) {
      const assetName = AssetName.new(toHexArray(asset[0]));
      let quantity = asset[1];
      if (compare$1(quantity, ">", maxValueStr)) {
        console.warn("quantity", quantity, ">", maxValueStr);
        quantity = maxValueStr;
      }
      const assetAmount = BigNum$1.from_str(quantity);
      assets.insert(assetName, assetAmount);
      safeFreeCSLObject(assetName);
      safeFreeCSLObject(assetAmount);
    }
    multiAsset.insert(policy, assets);
    safeFreeCSLObject(policy);
    safeFreeCSLObject(assets);
  }
  safeFreeCSLObject(maxValue);
  return multiAsset;
};
const getTransactionOutputFromJSON = (output) => {
  try {
    let json = jsonToCsl(output);
    return TransactionOutput.from_json(json);
  } catch (err) {
  }
  const cslAddress = getCSLAddressOrNull(output.address);
  const cslCoin = BigNum$1.from_str(output.amount.coin);
  const cslAmount = Value.new(cslCoin);
  safeFreeCSLObject(cslCoin);
  if (output.amount.multiasset) {
    const multiasset = getSortedMultiAssetFromJSON(output.amount.multiasset);
    cslAmount.set_multiasset(multiasset);
    safeFreeCSLObject(multiasset);
  }
  if (cslAddress) {
    const cslOutput = TransactionOutput.new(cslAddress, cslAmount);
    safeFreeCSLObject(cslAddress);
    safeFreeCSLObject(cslAmount);
    try {
      if (output.script_ref) {
        const nativeScriptRef = output.script_ref["NativeScript"];
        const plutusScriptRef = output.script_ref["PlutusScript"];
        if (nativeScriptRef) {
          try {
            const cslNativeScript = NativeScript.from_bytes(toHexArray(nativeScriptRef));
            const cslScriptRef = ScriptRef.new_native_script(cslNativeScript);
            cslOutput.set_script_ref(cslScriptRef);
            safeFreeCSLObject(cslScriptRef);
            safeFreeCSLObject(cslNativeScript);
          } catch (err) {
            console.warn("scriptRef: ns:", err);
          }
        } else if (plutusScriptRef) {
          try {
            const cslPlutusScript = PlutusScript.from_bytes(toHexArray(plutusScriptRef));
            const cslScriptRef = ScriptRef.new_plutus_script(cslPlutusScript);
            cslOutput.set_script_ref(cslScriptRef);
            safeFreeCSLObject(cslScriptRef);
            safeFreeCSLObject(cslPlutusScript);
          } catch (err) {
            console.warn("scriptRef: ps:", err);
          }
        }
      }
      if (output.plutus_data) {
        try {
          const hvb = getPlutusHVB(output.plutus_data);
          if (hvb.bytes) {
            const cslPlutusData = PlutusData.from_bytes(toHexArray(hvb.bytes));
            cslOutput.set_plutus_data(cslPlutusData);
            safeFreeCSLObject(cslPlutusData);
          } else if (hvb.hash) {
            const cslDataHash = DataHash.from_bytes(toHexArray(hvb.hash));
            cslOutput.set_data_hash(cslDataHash);
            safeFreeCSLObject(cslDataHash);
          }
        } catch (err) {
          console.warn("plutusData:", err);
        }
      }
    } catch (err) {
      console.warn("1", err);
    }
    return cslOutput;
  }
  safeFreeCSLObject(cslAmount);
  throw new Error("Could not parse output: " + JSON.stringify(output, null, 2));
};
const getValueFromJSON = (amount) => {
  try {
    return Value.from_json(jsonToCsl(amount));
  } catch (err) {
    console.warn("1", err, "; using fallback...", amount);
  }
  const cslCoin = BigNum$1.from_str(amount.coin);
  const cslAmount = Value.new(cslCoin);
  safeFreeCSLObject(cslCoin);
  if (amount.multiasset) {
    const multiasset = getSortedMultiAssetFromJSON(amount.multiasset);
    cslAmount.set_multiasset(multiasset);
    safeFreeCSLObject(multiasset);
  }
  return cslAmount;
};
const getValueJSONFromCSL = (cslValue) => {
  const cslCoin = cslValue.coin();
  const amount = {
    coin: cslCoin.to_str()
  };
  safeFreeCSLObject(cslCoin);
  const cslMultiasset = cslValue.multiasset();
  if (cslMultiasset) {
    const multiasset = getMultiAssetJSONFromCSL(cslMultiasset);
    if (multiasset) {
      amount.multiasset = multiasset;
    }
    safeFreeCSLObject(cslMultiasset);
  }
  return amount;
};
const getMultiAssetJSONFromCSL = (cslMultiasset) => {
  const cslPolicyIdList = cslMultiasset?.keys();
  let multiasset = void 0;
  if (cslPolicyIdList) {
    multiasset = {};
    const numPolicyIds = cslPolicyIdList.len();
    for (let iPolicy = 0; iPolicy < numPolicyIds; iPolicy++) {
      const cslPolicy = cslPolicyIdList.get(iPolicy);
      const cslAssetMap = cslMultiasset.get(cslPolicy);
      if (cslAssetMap) {
        const policyId = toHexString(cslPolicy.to_bytes());
        if (!multiasset[policyId]) {
          multiasset[policyId] = {};
        }
        const assetMap = multiasset[policyId];
        const cslAssetNameList = cslAssetMap.keys();
        const numAssetNames = cslAssetNameList.len();
        for (let iAssetName = 0; iAssetName < numAssetNames; iAssetName++) {
          const cslAssetName = cslAssetNameList.get(iAssetName);
          const cslAssetQuantity = cslAssetMap.get(cslAssetName);
          if (cslAssetQuantity) {
            assetMap[toHexString(cslAssetName.name())] = cslAssetQuantity.to_str();
            safeFreeCSLObject(cslAssetQuantity);
          }
          safeFreeCSLObject(cslAssetName);
        }
        safeFreeCSLObject(cslAssetNameList);
        safeFreeCSLObject(cslAssetMap);
      }
      safeFreeCSLObject(cslPolicy);
    }
    safeFreeCSLObject(cslPolicyIdList);
  }
  return multiasset;
};
const getMintJSONFromCSL = (cslMint) => {
  const mints = cslMint?.as_positive_multiasset();
  const burns = cslMint?.as_negative_multiasset();
  let mintsJSON = getMultiAssetJSONFromCSL(mints);
  const burnsJSON = getMultiAssetJSONFromCSL(burns);
  if (burnsJSON) {
    mintsJSON = addMultiAssets(mintsJSON ?? {}, burnsJSON, true);
  }
  let mint = void 0;
  if (mintsJSON) {
    mint = [];
    for (const entry of Object.entries(mintsJSON)) {
      mint.push([entry[0], entry[1]]);
    }
  }
  return mint;
};
const _getPlutusHVB = (data) => {
  let pData = null;
  const free = [];
  if (typeof data === "string") {
    try {
      pData = PlutusData.from_bytes(toHexArray(data));
      free.push(pData);
    } catch (err) {
    }
  }
  try {
    pData = PlutusData.from_json(jsonToCsl(data), PlutusDatumSchema.DetailedSchema);
    free.push(pData);
  } catch (err) {
  }
  if (!pData) {
    try {
      pData = PlutusData.from_json(jsonToCsl(data), PlutusDatumSchema.BasicConversions);
      free.push(pData);
    } catch (err) {
    }
  }
  if (pData) {
    const datum = {
      hash: getCSLPlutusDataHash(pData, free),
      bytes: pData.to_hex(),
      value: getPlutusDataJSONFromCSL(pData)
    };
    freeCSLObjects(free);
    return datum;
  }
  return null;
};
const getPlutusHVB = (data) => {
  if (!data) {
    return {
      hash: "",
      bytes: "",
      value: null
    };
  }
  if (typeof data === "string") {
    const datum = _getPlutusHVB(data);
    if (datum) {
      return datum;
    }
  } else if (typeof data === "object") {
    if (data.hasOwnProperty("DataHash")) {
      return {
        hash: data.DataHash,
        bytes: "",
        value: null
      };
    } else if (data.hasOwnProperty("Data")) {
      const datum = _getPlutusHVB(data.Data);
      if (datum) {
        return datum;
      }
    } else {
      const datum = _getPlutusHVB(data);
      if (datum) {
        return datum;
      }
    }
  }
  return {
    hash: "",
    bytes: "",
    value: null
  };
};
const getPlutusDataJSONFromCSL = (cslPlutusData) => {
  if (!cslPlutusData) {
    return null;
  }
  let _json;
  try {
    _json = cslPlutusData.to_json(PlutusDatumSchema.DetailedSchema);
  } catch (err) {
  }
  if (!_json) {
    try {
      _json = cslPlutusData.to_json(PlutusDatumSchema.BasicConversions);
    } catch (err) {
    }
  }
  if (_json) {
    _json = cslToJson(_json);
  }
  return _json ?? null;
};
const getPlutusListJSONFromCSL = (cslPlutusList) => {
  if (!cslPlutusList) {
    return null;
  }
  const plutusData = [];
  const length = cslPlutusList.len();
  for (let index = 0; index < length; index++) {
    const cslData = cslPlutusList.get(index);
    if (cslData) {
      const data = getPlutusDataJSONFromCSL(cslData);
      plutusData.push(data);
      safeFreeCSLObject(cslData);
    }
  }
  return {
    elems: plutusData,
    definite_encoding: false
  };
};
const getNativeScriptCredFromHex = (script) => {
  const cslNativeScript = NativeScript.from_bytes(toHexArray(script));
  const cslScriptHash = cslNativeScript.hash();
  const cred = toHexString(cslScriptHash.to_bytes());
  safeFreeCSLObject(cslScriptHash);
  safeFreeCSLObject(cslNativeScript);
  return cred;
};

const createIBalance = (ref) => {
  const balance = createValueJSON(ref);
  balance.rewards = "0";
  balance.total = add(balance.coin, balance.rewards);
  return balance;
};

const clearValueJSON = (value) => {
  value.coin = "0";
  if (value.multiasset) {
    delete value.multiasset;
  }
};
const clearBalance = (balance) => {
  clearValueJSON(balance);
  balance.rewards = "0";
  balance.total = "0";
};
const addToBalance = (to, from, addRewards = true, updateTotal = false) => {
  addValueToValue(to, from);
  if (!!from && from.rewards && addRewards) {
    to.rewards = add(to.rewards, from.rewards);
  }
  if (updateTotal) {
    updateBalanceTotal(to);
  }
};
const decreaseBalance = (to, from, addRewards = true, updateTotal = false) => {
  addValueToValue(to, from, true);
  if (!!from && addRewards) {
    to.rewards = subtract(to.rewards, from.rewards);
  }
  if (updateTotal) {
    updateBalanceTotal(to);
  }
};
const updateBalanceTotal = (balance) => {
  balance.total = add(balance.coin, balance.rewards);
};
const addUtxosToBalance = (balance, utxoList, decrease = false) => {
  if (!utxoList) {
    return;
  }
  for (const utxo of utxoList) {
    addValueToValue(balance, utxo.output.amount, decrease);
  }
  updateBalanceTotal(balance);
};
const addOutputToBalance = (balance, output) => {
  addValueToValue(balance, output.amount);
  updateBalanceTotal(balance);
};
const addRewardsToBalance = (balance, rewardInfo, decrease = false) => {
  if (!decrease) {
    balance.rewards = add(balance.rewards, rewardInfo.rewards);
  } else {
    balance.rewards = subtract(balance.rewards, rewardInfo.rewards);
  }
};

const AccountError = {
  wrongCustomAddress: "AccountError.wrongCustomAddress"
};
const DataError = {
  updateIAccountIfNeeded: "DataError.updateIAccountIfNeeded",
  updateIAccountStateIfNeeded: "DataError.updateIAccountStateIfNeeded",
  updateIAccountBalanceIfNeeded: "DataError.updateIAccountBalanceIfNeeded",
  updateIAccountCredsIfNeeded: "DataError.updateIAccountCredsIfNeeded",
  updateIAccountSettingsIfNeeded: "DataError.updateIAccountSettingsIfNeeded",
  updateIAccountSettingsPartial: "DataError.updateIAccountSettingsPartial",
  updateIAccountSettings: "DataError.updateIAccountSettings",
  updateIWalletSettingsIfNeeded: "DataError.updateIWalletSettingsIfNeeded",
  updateIRewardInfoIfNeeded: "DataError.updateIRewardInfoIfNeeded",
  updateIUtxoBalanceIfNeeded: "DataError.updateIUtxoBalanceIfNeeded",
  updateIUtxoBalanceListIfNeeded: "DataError.updateIUtxoBalanceListIfNeeded",
  updateIAccountDBDataIfNeeded: "DataError.updateIAccountDBDataIfNeeded",
  updateIWalletDBDataIfNeeded: "DataError.updateIWalletDBDataIfNeeded",
  missingAccountSettings: "DataError.missingAccountSettings",
  missingAccountData: "DataError.missingAccountData",
  noIAccountBalance: "DataError.noIAccountBalance",
  noIStakeInfo: "DataError.noIStakeInfo"};

var cryptoBrowserify = {};

var browser$a = {exports: {}};

var hasRequiredBrowser$a;

function requireBrowser$a () {
	if (hasRequiredBrowser$a) return browser$a.exports;
	hasRequiredBrowser$a = 1;

	// limit of Crypto.getRandomValues()
	// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
	var MAX_BYTES = 65536;

	// Node supports requesting up to this number of bytes
	// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
	var MAX_UINT32 = 4294967295;

	function oldBrowser () {
	  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
	}

	var Buffer = requireSafeBuffer$2().Buffer;
	var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;

	if (crypto && crypto.getRandomValues) {
	  browser$a.exports = randomBytes;
	} else {
	  browser$a.exports = oldBrowser;
	}

	function randomBytes (size, cb) {
	  // phantomjs needs to throw
	  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

	  var bytes = Buffer.allocUnsafe(size);

	  if (size > 0) {  // getRandomValues fails on IE if size == 0
	    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
	      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
	      for (var generated = 0; generated < size; generated += MAX_BYTES) {
	        // buffer.slice automatically checks if the end is past the end of
	        // the buffer so we don't have to here
	        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
	      }
	    } else {
	      crypto.getRandomValues(bytes);
	    }
	  }

	  if (typeof cb === 'function') {
	    return process$1.nextTick(function () {
	      cb(null, bytes);
	    })
	  }

	  return bytes
	}
	return browser$a.exports;
}

var readableBrowser$1 = {exports: {}};

var hasRequiredReadableBrowser$1;

function requireReadableBrowser$1 () {
	if (hasRequiredReadableBrowser$1) return readableBrowser$1.exports;
	hasRequiredReadableBrowser$1 = 1;
	(function (module, exports) {
		exports = module.exports = require_stream_readable$2();
		exports.Stream = exports;
		exports.Readable = exports;
		exports.Writable = require_stream_writable$2();
		exports.Duplex = require_stream_duplex$2();
		exports.Transform = require_stream_transform$2();
		exports.PassThrough = require_stream_passthrough$2();
		exports.finished = requireEndOfStream();
		exports.pipeline = requirePipeline(); 
	} (readableBrowser$1, readableBrowser$1.exports));
	return readableBrowser$1.exports;
}

var hashBase;
var hasRequiredHashBase;

function requireHashBase () {
	if (hasRequiredHashBase) return hashBase;
	hasRequiredHashBase = 1;
	var Buffer = requireSafeBuffer$2().Buffer;
	var Transform = requireReadableBrowser$1().Transform;
	var inherits = requireInherits_browser();

	function throwIfNotStringOrBuffer (val, prefix) {
	  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
	    throw new TypeError(prefix + ' must be a string or a buffer')
	  }
	}

	function HashBase (blockSize) {
	  Transform.call(this);

	  this._block = Buffer.allocUnsafe(blockSize);
	  this._blockSize = blockSize;
	  this._blockOffset = 0;
	  this._length = [0, 0, 0, 0];

	  this._finalized = false;
	}

	inherits(HashBase, Transform);

	HashBase.prototype._transform = function (chunk, encoding, callback) {
	  var error = null;
	  try {
	    this.update(chunk, encoding);
	  } catch (err) {
	    error = err;
	  }

	  callback(error);
	};

	HashBase.prototype._flush = function (callback) {
	  var error = null;
	  try {
	    this.push(this.digest());
	  } catch (err) {
	    error = err;
	  }

	  callback(error);
	};

	HashBase.prototype.update = function (data, encoding) {
	  throwIfNotStringOrBuffer(data, 'Data');
	  if (this._finalized) throw new Error('Digest already called')
	  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding);

	  // consume data
	  var block = this._block;
	  var offset = 0;
	  while (this._blockOffset + data.length - offset >= this._blockSize) {
	    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++];
	    this._update();
	    this._blockOffset = 0;
	  }
	  while (offset < data.length) block[this._blockOffset++] = data[offset++];

	  // update length
	  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
	    this._length[j] += carry;
	    carry = (this._length[j] / 0x0100000000) | 0;
	    if (carry > 0) this._length[j] -= 0x0100000000 * carry;
	  }

	  return this
	};

	HashBase.prototype._update = function () {
	  throw new Error('_update is not implemented')
	};

	HashBase.prototype.digest = function (encoding) {
	  if (this._finalized) throw new Error('Digest already called')
	  this._finalized = true;

	  var digest = this._digest();
	  if (encoding !== undefined) digest = digest.toString(encoding);

	  // reset state
	  this._block.fill(0);
	  this._blockOffset = 0;
	  for (var i = 0; i < 4; ++i) this._length[i] = 0;

	  return digest
	};

	HashBase.prototype._digest = function () {
	  throw new Error('_digest is not implemented')
	};

	hashBase = HashBase;
	return hashBase;
}

var md5_js;
var hasRequiredMd5_js;

function requireMd5_js () {
	if (hasRequiredMd5_js) return md5_js;
	hasRequiredMd5_js = 1;
	var inherits = requireInherits_browser();
	var HashBase = requireHashBase();
	var Buffer = requireSafeBuffer$2().Buffer;

	var ARRAY16 = new Array(16);

	function MD5 () {
	  HashBase.call(this, 64);

	  // state
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	}

	inherits(MD5, HashBase);

	MD5.prototype._update = function () {
	  var M = ARRAY16;
	  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4);

	  var a = this._a;
	  var b = this._b;
	  var c = this._c;
	  var d = this._d;

	  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7);
	  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12);
	  c = fnF(c, d, a, b, M[2], 0x242070db, 17);
	  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22);
	  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7);
	  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12);
	  c = fnF(c, d, a, b, M[6], 0xa8304613, 17);
	  b = fnF(b, c, d, a, M[7], 0xfd469501, 22);
	  a = fnF(a, b, c, d, M[8], 0x698098d8, 7);
	  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12);
	  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17);
	  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22);
	  a = fnF(a, b, c, d, M[12], 0x6b901122, 7);
	  d = fnF(d, a, b, c, M[13], 0xfd987193, 12);
	  c = fnF(c, d, a, b, M[14], 0xa679438e, 17);
	  b = fnF(b, c, d, a, M[15], 0x49b40821, 22);

	  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5);
	  d = fnG(d, a, b, c, M[6], 0xc040b340, 9);
	  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14);
	  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20);
	  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5);
	  d = fnG(d, a, b, c, M[10], 0x02441453, 9);
	  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14);
	  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20);
	  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5);
	  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9);
	  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14);
	  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20);
	  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5);
	  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9);
	  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14);
	  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20);

	  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4);
	  d = fnH(d, a, b, c, M[8], 0x8771f681, 11);
	  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16);
	  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23);
	  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4);
	  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11);
	  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16);
	  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23);
	  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4);
	  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11);
	  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16);
	  b = fnH(b, c, d, a, M[6], 0x04881d05, 23);
	  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4);
	  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11);
	  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16);
	  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23);

	  a = fnI(a, b, c, d, M[0], 0xf4292244, 6);
	  d = fnI(d, a, b, c, M[7], 0x432aff97, 10);
	  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15);
	  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21);
	  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6);
	  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10);
	  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15);
	  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21);
	  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6);
	  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10);
	  c = fnI(c, d, a, b, M[6], 0xa3014314, 15);
	  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21);
	  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6);
	  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10);
	  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15);
	  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21);

	  this._a = (this._a + a) | 0;
	  this._b = (this._b + b) | 0;
	  this._c = (this._c + c) | 0;
	  this._d = (this._d + d) | 0;
	};

	MD5.prototype._digest = function () {
	  // create padding and handle blocks
	  this._block[this._blockOffset++] = 0x80;
	  if (this._blockOffset > 56) {
	    this._block.fill(0, this._blockOffset, 64);
	    this._update();
	    this._blockOffset = 0;
	  }

	  this._block.fill(0, this._blockOffset, 56);
	  this._block.writeUInt32LE(this._length[0], 56);
	  this._block.writeUInt32LE(this._length[1], 60);
	  this._update();

	  // produce result
	  var buffer = Buffer.allocUnsafe(16);
	  buffer.writeInt32LE(this._a, 0);
	  buffer.writeInt32LE(this._b, 4);
	  buffer.writeInt32LE(this._c, 8);
	  buffer.writeInt32LE(this._d, 12);
	  return buffer
	};

	function rotl (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function fnF (a, b, c, d, m, k, s) {
	  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
	}

	function fnG (a, b, c, d, m, k, s) {
	  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
	}

	function fnH (a, b, c, d, m, k, s) {
	  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
	}

	function fnI (a, b, c, d, m, k, s) {
	  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
	}

	md5_js = MD5;
	return md5_js;
}

var ripemd160;
var hasRequiredRipemd160;

function requireRipemd160 () {
	if (hasRequiredRipemd160) return ripemd160;
	hasRequiredRipemd160 = 1;
	var Buffer = requireDist().Buffer;
	var inherits = requireInherits_browser();
	var HashBase = requireHashBase();

	var ARRAY16 = new Array(16);

	var zl = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var zr = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var sl = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sr = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];

	var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e];
	var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000];

	function RIPEMD160 () {
	  HashBase.call(this, 64);

	  // state
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;
	}

	inherits(RIPEMD160, HashBase);

	RIPEMD160.prototype._update = function () {
	  var words = ARRAY16;
	  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4);

	  var al = this._a | 0;
	  var bl = this._b | 0;
	  var cl = this._c | 0;
	  var dl = this._d | 0;
	  var el = this._e | 0;

	  var ar = this._a | 0;
	  var br = this._b | 0;
	  var cr = this._c | 0;
	  var dr = this._d | 0;
	  var er = this._e | 0;

	  // computation
	  for (var i = 0; i < 80; i += 1) {
	    var tl;
	    var tr;
	    if (i < 16) {
	      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i]);
	      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i]);
	    } else if (i < 32) {
	      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i]);
	      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i]);
	    } else if (i < 48) {
	      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i]);
	      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i]);
	    } else if (i < 64) {
	      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i]);
	      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i]);
	    } else { // if (i<80) {
	      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i]);
	      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i]);
	    }

	    al = el;
	    el = dl;
	    dl = rotl(cl, 10);
	    cl = bl;
	    bl = tl;

	    ar = er;
	    er = dr;
	    dr = rotl(cr, 10);
	    cr = br;
	    br = tr;
	  }

	  // update state
	  var t = (this._b + cl + dr) | 0;
	  this._b = (this._c + dl + er) | 0;
	  this._c = (this._d + el + ar) | 0;
	  this._d = (this._e + al + br) | 0;
	  this._e = (this._a + bl + cr) | 0;
	  this._a = t;
	};

	RIPEMD160.prototype._digest = function () {
	  // create padding and handle blocks
	  this._block[this._blockOffset++] = 0x80;
	  if (this._blockOffset > 56) {
	    this._block.fill(0, this._blockOffset, 64);
	    this._update();
	    this._blockOffset = 0;
	  }

	  this._block.fill(0, this._blockOffset, 56);
	  this._block.writeUInt32LE(this._length[0], 56);
	  this._block.writeUInt32LE(this._length[1], 60);
	  this._update();

	  // produce result
	  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20);
	  buffer.writeInt32LE(this._a, 0);
	  buffer.writeInt32LE(this._b, 4);
	  buffer.writeInt32LE(this._c, 8);
	  buffer.writeInt32LE(this._d, 12);
	  buffer.writeInt32LE(this._e, 16);
	  return buffer
	};

	function rotl (x, n) {
	  return (x << n) | (x >>> (32 - n))
	}

	function fn1 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
	}

	function fn2 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
	}

	function fn3 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
	}

	function fn4 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
	}

	function fn5 (a, b, c, d, e, m, k, s) {
	  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
	}

	ripemd160 = RIPEMD160;
	return ripemd160;
}

var sha_js = {exports: {}};

var hash$1;
var hasRequiredHash$1;

function requireHash$1 () {
	if (hasRequiredHash$1) return hash$1;
	hasRequiredHash$1 = 1;
	var Buffer = requireSafeBuffer$2().Buffer;

	// prototype class for hash functions
	function Hash (blockSize, finalSize) {
	  this._block = Buffer.alloc(blockSize);
	  this._finalSize = finalSize;
	  this._blockSize = blockSize;
	  this._len = 0;
	}

	Hash.prototype.update = function (data, enc) {
	  if (typeof data === 'string') {
	    enc = enc || 'utf8';
	    data = Buffer.from(data, enc);
	  }

	  var block = this._block;
	  var blockSize = this._blockSize;
	  var length = data.length;
	  var accum = this._len;

	  for (var offset = 0; offset < length;) {
	    var assigned = accum % blockSize;
	    var remainder = Math.min(length - offset, blockSize - assigned);

	    for (var i = 0; i < remainder; i++) {
	      block[assigned + i] = data[offset + i];
	    }

	    accum += remainder;
	    offset += remainder;

	    if ((accum % blockSize) === 0) {
	      this._update(block);
	    }
	  }

	  this._len += length;
	  return this
	};

	Hash.prototype.digest = function (enc) {
	  var rem = this._len % this._blockSize;

	  this._block[rem] = 0x80;

	  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
	  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
	  this._block.fill(0, rem + 1);

	  if (rem >= this._finalSize) {
	    this._update(this._block);
	    this._block.fill(0);
	  }

	  var bits = this._len * 8;

	  // uint32
	  if (bits <= 0xffffffff) {
	    this._block.writeUInt32BE(bits, this._blockSize - 4);

	  // uint64
	  } else {
	    var lowBits = (bits & 0xffffffff) >>> 0;
	    var highBits = (bits - lowBits) / 0x100000000;

	    this._block.writeUInt32BE(highBits, this._blockSize - 8);
	    this._block.writeUInt32BE(lowBits, this._blockSize - 4);
	  }

	  this._update(this._block);
	  var hash = this._hash();

	  return enc ? hash.toString(enc) : hash
	};

	Hash.prototype._update = function () {
	  throw new Error('_update must be implemented by subclass')
	};

	hash$1 = Hash;
	return hash$1;
}

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var sha$1;
var hasRequiredSha$1;

function requireSha$1 () {
	if (hasRequiredSha$1) return sha$1;
	hasRequiredSha$1 = 1;
	var inherits = requireInherits_browser();
	var Hash = requireHash$1();
	var Buffer = requireSafeBuffer$2().Buffer;

	var K = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha () {
	  this.init();
	  this._w = W;

	  Hash.call(this, 64, 56);
	}

	inherits(Sha, Hash);

	Sha.prototype.init = function () {
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;

	  return this
	};

	function rotl5 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20);
	    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

	    e = d;
	    d = c;
	    c = rotl30(b);
	    b = a;
	    a = t;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	};

	Sha.prototype._hash = function () {
	  var H = Buffer.allocUnsafe(20);

	  H.writeInt32BE(this._a | 0, 0);
	  H.writeInt32BE(this._b | 0, 4);
	  H.writeInt32BE(this._c | 0, 8);
	  H.writeInt32BE(this._d | 0, 12);
	  H.writeInt32BE(this._e | 0, 16);

	  return H
	};

	sha$1 = Sha;
	return sha$1;
}

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var sha1;
var hasRequiredSha1;

function requireSha1 () {
	if (hasRequiredSha1) return sha1;
	hasRequiredSha1 = 1;
	var inherits = requireInherits_browser();
	var Hash = requireHash$1();
	var Buffer = requireSafeBuffer$2().Buffer;

	var K = [
	  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
	];

	var W = new Array(80);

	function Sha1 () {
	  this.init();
	  this._w = W;

	  Hash.call(this, 64, 56);
	}

	inherits(Sha1, Hash);

	Sha1.prototype.init = function () {
	  this._a = 0x67452301;
	  this._b = 0xefcdab89;
	  this._c = 0x98badcfe;
	  this._d = 0x10325476;
	  this._e = 0xc3d2e1f0;

	  return this
	};

	function rotl1 (num) {
	  return (num << 1) | (num >>> 31)
	}

	function rotl5 (num) {
	  return (num << 5) | (num >>> 27)
	}

	function rotl30 (num) {
	  return (num << 30) | (num >>> 2)
	}

	function ft (s, b, c, d) {
	  if (s === 0) return (b & c) | ((~b) & d)
	  if (s === 2) return (b & c) | (b & d) | (c & d)
	  return b ^ c ^ d
	}

	Sha1.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]);

	  for (var j = 0; j < 80; ++j) {
	    var s = ~~(j / 20);
	    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0;

	    e = d;
	    d = c;
	    c = rotl30(b);
	    b = a;
	    a = t;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	};

	Sha1.prototype._hash = function () {
	  var H = Buffer.allocUnsafe(20);

	  H.writeInt32BE(this._a | 0, 0);
	  H.writeInt32BE(this._b | 0, 4);
	  H.writeInt32BE(this._c | 0, 8);
	  H.writeInt32BE(this._d | 0, 12);
	  H.writeInt32BE(this._e | 0, 16);

	  return H
	};

	sha1 = Sha1;
	return sha1;
}

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var sha256$1;
var hasRequiredSha256;

function requireSha256 () {
	if (hasRequiredSha256) return sha256$1;
	hasRequiredSha256 = 1;
	var inherits = requireInherits_browser();
	var Hash = requireHash$1();
	var Buffer = requireSafeBuffer$2().Buffer;

	var K = [
	  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
	  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
	  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
	  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
	  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
	  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
	  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
	  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
	  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
	  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
	  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
	  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
	  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
	  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
	  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
	  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
	];

	var W = new Array(64);

	function Sha256 () {
	  this.init();

	  this._w = W; // new Array(64)

	  Hash.call(this, 64, 56);
	}

	inherits(Sha256, Hash);

	Sha256.prototype.init = function () {
	  this._a = 0x6a09e667;
	  this._b = 0xbb67ae85;
	  this._c = 0x3c6ef372;
	  this._d = 0xa54ff53a;
	  this._e = 0x510e527f;
	  this._f = 0x9b05688c;
	  this._g = 0x1f83d9ab;
	  this._h = 0x5be0cd19;

	  return this
	};

	function ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0 (x) {
	  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
	}

	function sigma1 (x) {
	  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
	}

	function gamma0 (x) {
	  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
	}

	function gamma1 (x) {
	  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
	}

	Sha256.prototype._update = function (M) {
	  var W = this._w;

	  var a = this._a | 0;
	  var b = this._b | 0;
	  var c = this._c | 0;
	  var d = this._d | 0;
	  var e = this._e | 0;
	  var f = this._f | 0;
	  var g = this._g | 0;
	  var h = this._h | 0;

	  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4);
	  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0;

	  for (var j = 0; j < 64; ++j) {
	    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0;
	    var T2 = (sigma0(a) + maj(a, b, c)) | 0;

	    h = g;
	    g = f;
	    f = e;
	    e = (d + T1) | 0;
	    d = c;
	    c = b;
	    b = a;
	    a = (T1 + T2) | 0;
	  }

	  this._a = (a + this._a) | 0;
	  this._b = (b + this._b) | 0;
	  this._c = (c + this._c) | 0;
	  this._d = (d + this._d) | 0;
	  this._e = (e + this._e) | 0;
	  this._f = (f + this._f) | 0;
	  this._g = (g + this._g) | 0;
	  this._h = (h + this._h) | 0;
	};

	Sha256.prototype._hash = function () {
	  var H = Buffer.allocUnsafe(32);

	  H.writeInt32BE(this._a, 0);
	  H.writeInt32BE(this._b, 4);
	  H.writeInt32BE(this._c, 8);
	  H.writeInt32BE(this._d, 12);
	  H.writeInt32BE(this._e, 16);
	  H.writeInt32BE(this._f, 20);
	  H.writeInt32BE(this._g, 24);
	  H.writeInt32BE(this._h, 28);

	  return H
	};

	sha256$1 = Sha256;
	return sha256$1;
}

/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var sha224$1;
var hasRequiredSha224;

function requireSha224 () {
	if (hasRequiredSha224) return sha224$1;
	hasRequiredSha224 = 1;
	var inherits = requireInherits_browser();
	var Sha256 = requireSha256();
	var Hash = requireHash$1();
	var Buffer = requireSafeBuffer$2().Buffer;

	var W = new Array(64);

	function Sha224 () {
	  this.init();

	  this._w = W; // new Array(64)

	  Hash.call(this, 64, 56);
	}

	inherits(Sha224, Sha256);

	Sha224.prototype.init = function () {
	  this._a = 0xc1059ed8;
	  this._b = 0x367cd507;
	  this._c = 0x3070dd17;
	  this._d = 0xf70e5939;
	  this._e = 0xffc00b31;
	  this._f = 0x68581511;
	  this._g = 0x64f98fa7;
	  this._h = 0xbefa4fa4;

	  return this
	};

	Sha224.prototype._hash = function () {
	  var H = Buffer.allocUnsafe(28);

	  H.writeInt32BE(this._a, 0);
	  H.writeInt32BE(this._b, 4);
	  H.writeInt32BE(this._c, 8);
	  H.writeInt32BE(this._d, 12);
	  H.writeInt32BE(this._e, 16);
	  H.writeInt32BE(this._f, 20);
	  H.writeInt32BE(this._g, 24);

	  return H
	};

	sha224$1 = Sha224;
	return sha224$1;
}

var sha512$1;
var hasRequiredSha512;

function requireSha512 () {
	if (hasRequiredSha512) return sha512$1;
	hasRequiredSha512 = 1;
	var inherits = requireInherits_browser();
	var Hash = requireHash$1();
	var Buffer = requireSafeBuffer$2().Buffer;

	var K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	var W = new Array(160);

	function Sha512 () {
	  this.init();
	  this._w = W;

	  Hash.call(this, 128, 112);
	}

	inherits(Sha512, Hash);

	Sha512.prototype.init = function () {
	  this._ah = 0x6a09e667;
	  this._bh = 0xbb67ae85;
	  this._ch = 0x3c6ef372;
	  this._dh = 0xa54ff53a;
	  this._eh = 0x510e527f;
	  this._fh = 0x9b05688c;
	  this._gh = 0x1f83d9ab;
	  this._hh = 0x5be0cd19;

	  this._al = 0xf3bcc908;
	  this._bl = 0x84caa73b;
	  this._cl = 0xfe94f82b;
	  this._dl = 0x5f1d36f1;
	  this._el = 0xade682d1;
	  this._fl = 0x2b3e6c1f;
	  this._gl = 0xfb41bd6b;
	  this._hl = 0x137e2179;

	  return this
	};

	function Ch (x, y, z) {
	  return z ^ (x & (y ^ z))
	}

	function maj (x, y, z) {
	  return (x & y) | (z & (x | y))
	}

	function sigma0 (x, xl) {
	  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
	}

	function sigma1 (x, xl) {
	  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
	}

	function Gamma0 (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
	}

	function Gamma0l (x, xl) {
	  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
	}

	function Gamma1 (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
	}

	function Gamma1l (x, xl) {
	  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
	}

	function getCarry (a, b) {
	  return (a >>> 0) < (b >>> 0) ? 1 : 0
	}

	Sha512.prototype._update = function (M) {
	  var W = this._w;

	  var ah = this._ah | 0;
	  var bh = this._bh | 0;
	  var ch = this._ch | 0;
	  var dh = this._dh | 0;
	  var eh = this._eh | 0;
	  var fh = this._fh | 0;
	  var gh = this._gh | 0;
	  var hh = this._hh | 0;

	  var al = this._al | 0;
	  var bl = this._bl | 0;
	  var cl = this._cl | 0;
	  var dl = this._dl | 0;
	  var el = this._el | 0;
	  var fl = this._fl | 0;
	  var gl = this._gl | 0;
	  var hl = this._hl | 0;

	  for (var i = 0; i < 32; i += 2) {
	    W[i] = M.readInt32BE(i * 4);
	    W[i + 1] = M.readInt32BE(i * 4 + 4);
	  }
	  for (; i < 160; i += 2) {
	    var xh = W[i - 15 * 2];
	    var xl = W[i - 15 * 2 + 1];
	    var gamma0 = Gamma0(xh, xl);
	    var gamma0l = Gamma0l(xl, xh);

	    xh = W[i - 2 * 2];
	    xl = W[i - 2 * 2 + 1];
	    var gamma1 = Gamma1(xh, xl);
	    var gamma1l = Gamma1l(xl, xh);

	    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
	    var Wi7h = W[i - 7 * 2];
	    var Wi7l = W[i - 7 * 2 + 1];

	    var Wi16h = W[i - 16 * 2];
	    var Wi16l = W[i - 16 * 2 + 1];

	    var Wil = (gamma0l + Wi7l) | 0;
	    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0;
	    Wil = (Wil + gamma1l) | 0;
	    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0;
	    Wil = (Wil + Wi16l) | 0;
	    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0;

	    W[i] = Wih;
	    W[i + 1] = Wil;
	  }

	  for (var j = 0; j < 160; j += 2) {
	    Wih = W[j];
	    Wil = W[j + 1];

	    var majh = maj(ah, bh, ch);
	    var majl = maj(al, bl, cl);

	    var sigma0h = sigma0(ah, al);
	    var sigma0l = sigma0(al, ah);
	    var sigma1h = sigma1(eh, el);
	    var sigma1l = sigma1(el, eh);

	    // t1 = h + sigma1 + ch + K[j] + W[j]
	    var Kih = K[j];
	    var Kil = K[j + 1];

	    var chh = Ch(eh, fh, gh);
	    var chl = Ch(el, fl, gl);

	    var t1l = (hl + sigma1l) | 0;
	    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0;
	    t1l = (t1l + chl) | 0;
	    t1h = (t1h + chh + getCarry(t1l, chl)) | 0;
	    t1l = (t1l + Kil) | 0;
	    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0;
	    t1l = (t1l + Wil) | 0;
	    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0;

	    // t2 = sigma0 + maj
	    var t2l = (sigma0l + majl) | 0;
	    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0;

	    hh = gh;
	    hl = gl;
	    gh = fh;
	    gl = fl;
	    fh = eh;
	    fl = el;
	    el = (dl + t1l) | 0;
	    eh = (dh + t1h + getCarry(el, dl)) | 0;
	    dh = ch;
	    dl = cl;
	    ch = bh;
	    cl = bl;
	    bh = ah;
	    bl = al;
	    al = (t1l + t2l) | 0;
	    ah = (t1h + t2h + getCarry(al, t1l)) | 0;
	  }

	  this._al = (this._al + al) | 0;
	  this._bl = (this._bl + bl) | 0;
	  this._cl = (this._cl + cl) | 0;
	  this._dl = (this._dl + dl) | 0;
	  this._el = (this._el + el) | 0;
	  this._fl = (this._fl + fl) | 0;
	  this._gl = (this._gl + gl) | 0;
	  this._hl = (this._hl + hl) | 0;

	  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0;
	  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0;
	  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0;
	  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0;
	  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0;
	  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0;
	  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0;
	  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0;
	};

	Sha512.prototype._hash = function () {
	  var H = Buffer.allocUnsafe(64);

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset);
	    H.writeInt32BE(l, offset + 4);
	  }

	  writeInt64BE(this._ah, this._al, 0);
	  writeInt64BE(this._bh, this._bl, 8);
	  writeInt64BE(this._ch, this._cl, 16);
	  writeInt64BE(this._dh, this._dl, 24);
	  writeInt64BE(this._eh, this._el, 32);
	  writeInt64BE(this._fh, this._fl, 40);
	  writeInt64BE(this._gh, this._gl, 48);
	  writeInt64BE(this._hh, this._hl, 56);

	  return H
	};

	sha512$1 = Sha512;
	return sha512$1;
}

var sha384$1;
var hasRequiredSha384;

function requireSha384 () {
	if (hasRequiredSha384) return sha384$1;
	hasRequiredSha384 = 1;
	var inherits = requireInherits_browser();
	var SHA512 = requireSha512();
	var Hash = requireHash$1();
	var Buffer = requireSafeBuffer$2().Buffer;

	var W = new Array(160);

	function Sha384 () {
	  this.init();
	  this._w = W;

	  Hash.call(this, 128, 112);
	}

	inherits(Sha384, SHA512);

	Sha384.prototype.init = function () {
	  this._ah = 0xcbbb9d5d;
	  this._bh = 0x629a292a;
	  this._ch = 0x9159015a;
	  this._dh = 0x152fecd8;
	  this._eh = 0x67332667;
	  this._fh = 0x8eb44a87;
	  this._gh = 0xdb0c2e0d;
	  this._hh = 0x47b5481d;

	  this._al = 0xc1059ed8;
	  this._bl = 0x367cd507;
	  this._cl = 0x3070dd17;
	  this._dl = 0xf70e5939;
	  this._el = 0xffc00b31;
	  this._fl = 0x68581511;
	  this._gl = 0x64f98fa7;
	  this._hl = 0xbefa4fa4;

	  return this
	};

	Sha384.prototype._hash = function () {
	  var H = Buffer.allocUnsafe(48);

	  function writeInt64BE (h, l, offset) {
	    H.writeInt32BE(h, offset);
	    H.writeInt32BE(l, offset + 4);
	  }

	  writeInt64BE(this._ah, this._al, 0);
	  writeInt64BE(this._bh, this._bl, 8);
	  writeInt64BE(this._ch, this._cl, 16);
	  writeInt64BE(this._dh, this._dl, 24);
	  writeInt64BE(this._eh, this._el, 32);
	  writeInt64BE(this._fh, this._fl, 40);

	  return H
	};

	sha384$1 = Sha384;
	return sha384$1;
}

var hasRequiredSha_js;

function requireSha_js () {
	if (hasRequiredSha_js) return sha_js.exports;
	hasRequiredSha_js = 1;
	var exports = sha_js.exports = function SHA (algorithm) {
	  algorithm = algorithm.toLowerCase();

	  var Algorithm = exports[algorithm];
	  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

	  return new Algorithm()
	};

	exports.sha = requireSha$1();
	exports.sha1 = requireSha1();
	exports.sha224 = requireSha224();
	exports.sha256 = requireSha256();
	exports.sha384 = requireSha384();
	exports.sha512 = requireSha512();
	return sha_js.exports;
}

var cipherBase;
var hasRequiredCipherBase;

function requireCipherBase () {
	if (hasRequiredCipherBase) return cipherBase;
	hasRequiredCipherBase = 1;
	var Buffer = requireSafeBuffer$2().Buffer;
	var Transform = requireStreamBrowserify().Transform;
	var StringDecoder = requireString_decoder$2().StringDecoder;
	var inherits = requireInherits_browser();

	function CipherBase (hashMode) {
	  Transform.call(this);
	  this.hashMode = typeof hashMode === 'string';
	  if (this.hashMode) {
	    this[hashMode] = this._finalOrDigest;
	  } else {
	    this.final = this._finalOrDigest;
	  }
	  if (this._final) {
	    this.__final = this._final;
	    this._final = null;
	  }
	  this._decoder = null;
	  this._encoding = null;
	}
	inherits(CipherBase, Transform);

	CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
	  if (typeof data === 'string') {
	    data = Buffer.from(data, inputEnc);
	  }

	  var outData = this._update(data);
	  if (this.hashMode) return this

	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc);
	  }

	  return outData
	};

	CipherBase.prototype.setAutoPadding = function () {};
	CipherBase.prototype.getAuthTag = function () {
	  throw new Error('trying to get auth tag in unsupported state')
	};

	CipherBase.prototype.setAuthTag = function () {
	  throw new Error('trying to set auth tag in unsupported state')
	};

	CipherBase.prototype.setAAD = function () {
	  throw new Error('trying to set aad in unsupported state')
	};

	CipherBase.prototype._transform = function (data, _, next) {
	  var err;
	  try {
	    if (this.hashMode) {
	      this._update(data);
	    } else {
	      this.push(this._update(data));
	    }
	  } catch (e) {
	    err = e;
	  } finally {
	    next(err);
	  }
	};
	CipherBase.prototype._flush = function (done) {
	  var err;
	  try {
	    this.push(this.__final());
	  } catch (e) {
	    err = e;
	  }

	  done(err);
	};
	CipherBase.prototype._finalOrDigest = function (outputEnc) {
	  var outData = this.__final() || Buffer.alloc(0);
	  if (outputEnc) {
	    outData = this._toString(outData, outputEnc, true);
	  }
	  return outData
	};

	CipherBase.prototype._toString = function (value, enc, fin) {
	  if (!this._decoder) {
	    this._decoder = new StringDecoder(enc);
	    this._encoding = enc;
	  }

	  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

	  var out = this._decoder.write(value);
	  if (fin) {
	    out += this._decoder.end();
	  }

	  return out
	};

	cipherBase = CipherBase;
	return cipherBase;
}

var browser$9;
var hasRequiredBrowser$9;

function requireBrowser$9 () {
	if (hasRequiredBrowser$9) return browser$9;
	hasRequiredBrowser$9 = 1;
	var inherits = requireInherits_browser();
	var MD5 = requireMd5_js();
	var RIPEMD160 = requireRipemd160();
	var sha = requireSha_js();
	var Base = requireCipherBase();

	function Hash (hash) {
	  Base.call(this, 'digest');

	  this._hash = hash;
	}

	inherits(Hash, Base);

	Hash.prototype._update = function (data) {
	  this._hash.update(data);
	};

	Hash.prototype._final = function () {
	  return this._hash.digest()
	};

	browser$9 = function createHash (alg) {
	  alg = alg.toLowerCase();
	  if (alg === 'md5') return new MD5()
	  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

	  return new Hash(sha(alg))
	};
	return browser$9;
}

var legacy;
var hasRequiredLegacy;

function requireLegacy () {
	if (hasRequiredLegacy) return legacy;
	hasRequiredLegacy = 1;
	var inherits = requireInherits_browser();
	var Buffer = requireSafeBuffer$2().Buffer;

	var Base = requireCipherBase();

	var ZEROS = Buffer.alloc(128);
	var blocksize = 64;

	function Hmac (alg, key) {
	  Base.call(this, 'digest');
	  if (typeof key === 'string') {
	    key = Buffer.from(key);
	  }

	  this._alg = alg;
	  this._key = key;

	  if (key.length > blocksize) {
	    key = alg(key);
	  } else if (key.length < blocksize) {
	    key = Buffer.concat([key, ZEROS], blocksize);
	  }

	  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
	  var opad = this._opad = Buffer.allocUnsafe(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  this._hash = [ipad];
	}

	inherits(Hmac, Base);

	Hmac.prototype._update = function (data) {
	  this._hash.push(data);
	};

	Hmac.prototype._final = function () {
	  var h = this._alg(Buffer.concat(this._hash));
	  return this._alg(Buffer.concat([this._opad, h]))
	};
	legacy = Hmac;
	return legacy;
}

var md5;
var hasRequiredMd5;

function requireMd5 () {
	if (hasRequiredMd5) return md5;
	hasRequiredMd5 = 1;
	var MD5 = requireMd5_js();

	md5 = function (buffer) {
	  return new MD5().update(buffer).digest()
	};
	return md5;
}

var browser$8;
var hasRequiredBrowser$8;

function requireBrowser$8 () {
	if (hasRequiredBrowser$8) return browser$8;
	hasRequiredBrowser$8 = 1;
	var inherits = requireInherits_browser();
	var Legacy = requireLegacy();
	var Base = requireCipherBase();
	var Buffer = requireSafeBuffer$2().Buffer;
	var md5 = requireMd5();
	var RIPEMD160 = requireRipemd160();

	var sha = requireSha_js();

	var ZEROS = Buffer.alloc(128);

	function Hmac (alg, key) {
	  Base.call(this, 'digest');
	  if (typeof key === 'string') {
	    key = Buffer.from(key);
	  }

	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

	  this._alg = alg;
	  this._key = key;
	  if (key.length > blocksize) {
	    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
	    key = hash.update(key).digest();
	  } else if (key.length < blocksize) {
	    key = Buffer.concat([key, ZEROS], blocksize);
	  }

	  var ipad = this._ipad = Buffer.allocUnsafe(blocksize);
	  var opad = this._opad = Buffer.allocUnsafe(blocksize);

	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }
	  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg);
	  this._hash.update(ipad);
	}

	inherits(Hmac, Base);

	Hmac.prototype._update = function (data) {
	  this._hash.update(data);
	};

	Hmac.prototype._final = function () {
	  var h = this._hash.digest();
	  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg);
	  return hash.update(this._opad).update(h).digest()
	};

	browser$8 = function createHmac (alg, key) {
	  alg = alg.toLowerCase();
	  if (alg === 'rmd160' || alg === 'ripemd160') {
	    return new Hmac('rmd160', key)
	  }
	  if (alg === 'md5') {
	    return new Legacy(md5, key)
	  }
	  return new Hmac(alg, key)
	};
	return browser$8;
}

const sha224WithRSAEncryption = {"sign":"rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"};
const sha256WithRSAEncryption = {"sign":"rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"};
const sha384WithRSAEncryption = {"sign":"rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"};
const sha512WithRSAEncryption = {"sign":"rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"};
const sha256 = {"sign":"ecdsa","hash":"sha256","id":""};
const sha224 = {"sign":"ecdsa","hash":"sha224","id":""};
const sha384 = {"sign":"ecdsa","hash":"sha384","id":""};
const sha512 = {"sign":"ecdsa","hash":"sha512","id":""};
const DSA = {"sign":"dsa","hash":"sha1","id":""};
const ripemd160WithRSA = {"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"};
const md5WithRSAEncryption = {"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"};
const require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {"sign":"ecdsa/rsa","hash":"sha224","id":"302d300d06096086480165030402040500041c"},
  sha256WithRSAEncryption,
  "RSA-SHA256": {"sign":"ecdsa/rsa","hash":"sha256","id":"3031300d060960864801650304020105000420"},
  sha384WithRSAEncryption,
  "RSA-SHA384": {"sign":"ecdsa/rsa","hash":"sha384","id":"3041300d060960864801650304020205000430"},
  sha512WithRSAEncryption,
  "RSA-SHA512": {"sign":"ecdsa/rsa","hash":"sha512","id":"3051300d060960864801650304020305000440"},
  "RSA-SHA1": {"sign":"rsa","hash":"sha1","id":"3021300906052b0e03021a05000414"},
  "ecdsa-with-SHA1": {"sign":"ecdsa","hash":"sha1","id":""},
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {"sign":"dsa","hash":"sha1","id":""},
  "DSA-SHA1": {"sign":"dsa","hash":"sha1","id":""},
  DSA,
  "DSA-WITH-SHA224": {"sign":"dsa","hash":"sha224","id":""},
  "DSA-SHA224": {"sign":"dsa","hash":"sha224","id":""},
  "DSA-WITH-SHA256": {"sign":"dsa","hash":"sha256","id":""},
  "DSA-SHA256": {"sign":"dsa","hash":"sha256","id":""},
  "DSA-WITH-SHA384": {"sign":"dsa","hash":"sha384","id":""},
  "DSA-SHA384": {"sign":"dsa","hash":"sha384","id":""},
  "DSA-WITH-SHA512": {"sign":"dsa","hash":"sha512","id":""},
  "DSA-SHA512": {"sign":"dsa","hash":"sha512","id":""},
  "DSA-RIPEMD160": {"sign":"dsa","hash":"rmd160","id":""},
  ripemd160WithRSA,
  "RSA-RIPEMD160": {"sign":"rsa","hash":"rmd160","id":"3021300906052b2403020105000414"},
  md5WithRSAEncryption,
  "RSA-MD5": {"sign":"rsa","hash":"md5","id":"3020300c06082a864886f70d020505000410"},
};

var algos;
var hasRequiredAlgos;

function requireAlgos () {
	if (hasRequiredAlgos) return algos;
	hasRequiredAlgos = 1;

	algos = require$$6;
	return algos;
}

var browser$7 = {};

var precondition;
var hasRequiredPrecondition;

function requirePrecondition () {
	if (hasRequiredPrecondition) return precondition;
	hasRequiredPrecondition = 1;
	var MAX_ALLOC = Math.pow(2, 30) - 1; // default in iojs

	precondition = function (iterations, keylen) {
	  if (typeof iterations !== 'number') {
	    throw new TypeError('Iterations not a number')
	  }

	  if (iterations < 0) {
	    throw new TypeError('Bad iterations')
	  }

	  if (typeof keylen !== 'number') {
	    throw new TypeError('Key length not a number')
	  }

	  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
	    throw new TypeError('Bad key length')
	  }
	};
	return precondition;
}

var defaultEncoding_1;
var hasRequiredDefaultEncoding;

function requireDefaultEncoding () {
	if (hasRequiredDefaultEncoding) return defaultEncoding_1;
	hasRequiredDefaultEncoding = 1;
	var defaultEncoding;
	/* istanbul ignore next */
	if (commonjsGlobal.process && commonjsGlobal.process.browser) {
	  defaultEncoding = 'utf-8';
	} else if (commonjsGlobal.process && commonjsGlobal.process.version) {
	  var pVersionMajor = parseInt(process$1.version.split('.')[0].slice(1), 10);

	  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary';
	} else {
	  defaultEncoding = 'utf-8';
	}
	defaultEncoding_1 = defaultEncoding;
	return defaultEncoding_1;
}

var toBuffer;
var hasRequiredToBuffer;

function requireToBuffer () {
	if (hasRequiredToBuffer) return toBuffer;
	hasRequiredToBuffer = 1;
	var Buffer = requireSafeBuffer$2().Buffer;

	toBuffer = function (thing, encoding, name) {
	  if (Buffer.isBuffer(thing)) {
	    return thing
	  } else if (typeof thing === 'string') {
	    return Buffer.from(thing, encoding)
	  } else if (ArrayBuffer.isView(thing)) {
	    return Buffer.from(thing.buffer)
	  } else {
	    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
	  }
	};
	return toBuffer;
}

var syncBrowser;
var hasRequiredSyncBrowser;

function requireSyncBrowser () {
	if (hasRequiredSyncBrowser) return syncBrowser;
	hasRequiredSyncBrowser = 1;
	var md5 = requireMd5();
	var RIPEMD160 = requireRipemd160();
	var sha = requireSha_js();
	var Buffer = requireSafeBuffer$2().Buffer;

	var checkParameters = requirePrecondition();
	var defaultEncoding = requireDefaultEncoding();
	var toBuffer = requireToBuffer();

	var ZEROS = Buffer.alloc(128);
	var sizes = {
	  md5: 16,
	  sha1: 20,
	  sha224: 28,
	  sha256: 32,
	  sha384: 48,
	  sha512: 64,
	  rmd160: 20,
	  ripemd160: 20
	};

	function Hmac (alg, key, saltLen) {
	  var hash = getDigest(alg);
	  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64;

	  if (key.length > blocksize) {
	    key = hash(key);
	  } else if (key.length < blocksize) {
	    key = Buffer.concat([key, ZEROS], blocksize);
	  }

	  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg]);
	  var opad = Buffer.allocUnsafe(blocksize + sizes[alg]);
	  for (var i = 0; i < blocksize; i++) {
	    ipad[i] = key[i] ^ 0x36;
	    opad[i] = key[i] ^ 0x5C;
	  }

	  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4);
	  ipad.copy(ipad1, 0, 0, blocksize);
	  this.ipad1 = ipad1;
	  this.ipad2 = ipad;
	  this.opad = opad;
	  this.alg = alg;
	  this.blocksize = blocksize;
	  this.hash = hash;
	  this.size = sizes[alg];
	}

	Hmac.prototype.run = function (data, ipad) {
	  data.copy(ipad, this.blocksize);
	  var h = this.hash(ipad);
	  h.copy(this.opad, this.blocksize);
	  return this.hash(this.opad)
	};

	function getDigest (alg) {
	  function shaFunc (data) {
	    return sha(alg).update(data).digest()
	  }
	  function rmd160Func (data) {
	    return new RIPEMD160().update(data).digest()
	  }

	  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
	  if (alg === 'md5') return md5
	  return shaFunc
	}

	function pbkdf2 (password, salt, iterations, keylen, digest) {
	  checkParameters(iterations, keylen);
	  password = toBuffer(password, defaultEncoding, 'Password');
	  salt = toBuffer(salt, defaultEncoding, 'Salt');

	  digest = digest || 'sha1';

	  var hmac = new Hmac(digest, password, salt.length);

	  var DK = Buffer.allocUnsafe(keylen);
	  var block1 = Buffer.allocUnsafe(salt.length + 4);
	  salt.copy(block1, 0, 0, salt.length);

	  var destPos = 0;
	  var hLen = sizes[digest];
	  var l = Math.ceil(keylen / hLen);

	  for (var i = 1; i <= l; i++) {
	    block1.writeUInt32BE(i, salt.length);

	    var T = hmac.run(block1, hmac.ipad1);
	    var U = T;

	    for (var j = 1; j < iterations; j++) {
	      U = hmac.run(U, hmac.ipad2);
	      for (var k = 0; k < hLen; k++) T[k] ^= U[k];
	    }

	    T.copy(DK, destPos);
	    destPos += hLen;
	  }

	  return DK
	}

	syncBrowser = pbkdf2;
	return syncBrowser;
}

var async;
var hasRequiredAsync;

function requireAsync () {
	if (hasRequiredAsync) return async;
	hasRequiredAsync = 1;
	var Buffer = requireSafeBuffer$2().Buffer;

	var checkParameters = requirePrecondition();
	var defaultEncoding = requireDefaultEncoding();
	var sync = requireSyncBrowser();
	var toBuffer = requireToBuffer();

	var ZERO_BUF;
	var subtle = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle;
	var toBrowser = {
	  sha: 'SHA-1',
	  'sha-1': 'SHA-1',
	  sha1: 'SHA-1',
	  sha256: 'SHA-256',
	  'sha-256': 'SHA-256',
	  sha384: 'SHA-384',
	  'sha-384': 'SHA-384',
	  'sha-512': 'SHA-512',
	  sha512: 'SHA-512'
	};
	var checks = [];
	function checkNative (algo) {
	  if (commonjsGlobal.process && !commonjsGlobal.process.browser) {
	    return Promise.resolve(false)
	  }
	  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
	    return Promise.resolve(false)
	  }
	  if (checks[algo] !== undefined) {
	    return checks[algo]
	  }
	  ZERO_BUF = ZERO_BUF || Buffer.alloc(8);
	  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
	    .then(function () {
	      return true
	    }).catch(function () {
	      return false
	    });
	  checks[algo] = prom;
	  return prom
	}
	var nextTick;
	function getNextTick () {
	  if (nextTick) {
	    return nextTick
	  }
	  if (commonjsGlobal.process && commonjsGlobal.process.nextTick) {
	    nextTick = commonjsGlobal.process.nextTick;
	  } else if (commonjsGlobal.queueMicrotask) {
	    nextTick = commonjsGlobal.queueMicrotask;
	  } else if (commonjsGlobal.setImmediate) {
	    nextTick = commonjsGlobal.setImmediate;
	  } else {
	    nextTick = commonjsGlobal.setTimeout;
	  }
	  return nextTick
	}
	function browserPbkdf2 (password, salt, iterations, length, algo) {
	  return subtle.importKey(
	    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
	  ).then(function (key) {
	    return subtle.deriveBits({
	      name: 'PBKDF2',
	      salt: salt,
	      iterations: iterations,
	      hash: {
	        name: algo
	      }
	    }, key, length << 3)
	  }).then(function (res) {
	    return Buffer.from(res)
	  })
	}

	function resolvePromise (promise, callback) {
	  promise.then(function (out) {
	    getNextTick()(function () {
	      callback(null, out);
	    });
	  }, function (e) {
	    getNextTick()(function () {
	      callback(e);
	    });
	  });
	}
	async = function (password, salt, iterations, keylen, digest, callback) {
	  if (typeof digest === 'function') {
	    callback = digest;
	    digest = undefined;
	  }

	  digest = digest || 'sha1';
	  var algo = toBrowser[digest.toLowerCase()];

	  if (!algo || typeof commonjsGlobal.Promise !== 'function') {
	    getNextTick()(function () {
	      var out;
	      try {
	        out = sync(password, salt, iterations, keylen, digest);
	      } catch (e) {
	        return callback(e)
	      }
	      callback(null, out);
	    });
	    return
	  }

	  checkParameters(iterations, keylen);
	  password = toBuffer(password, defaultEncoding, 'Password');
	  salt = toBuffer(salt, defaultEncoding, 'Salt');
	  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

	  resolvePromise(checkNative(algo).then(function (resp) {
	    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

	    return sync(password, salt, iterations, keylen, digest)
	  }), callback);
	};
	return async;
}

var hasRequiredBrowser$7;

function requireBrowser$7 () {
	if (hasRequiredBrowser$7) return browser$7;
	hasRequiredBrowser$7 = 1;
	browser$7.pbkdf2 = requireAsync();
	browser$7.pbkdf2Sync = requireSyncBrowser();
	return browser$7;
}

var browser$6 = {};

var des$1 = {};

var utils$4 = {};

var hasRequiredUtils$4;

function requireUtils$4 () {
	if (hasRequiredUtils$4) return utils$4;
	hasRequiredUtils$4 = 1;

	utils$4.readUInt32BE = function readUInt32BE(bytes, off) {
	  var res =  (bytes[0 + off] << 24) |
	             (bytes[1 + off] << 16) |
	             (bytes[2 + off] << 8) |
	             bytes[3 + off];
	  return res >>> 0;
	};

	utils$4.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
	  bytes[0 + off] = value >>> 24;
	  bytes[1 + off] = (value >>> 16) & 0xff;
	  bytes[2 + off] = (value >>> 8) & 0xff;
	  bytes[3 + off] = value & 0xff;
	};

	utils$4.ip = function ip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }

	  for (var i = 6; i >= 0; i -= 2) {
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	    }
	    for (var j = 1; j <= 25; j += 8) {
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$4.rip = function rip(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  for (var i = 0; i < 4; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outL <<= 1;
	      outL |= (inR >>> (j + i)) & 1;
	      outL <<= 1;
	      outL |= (inL >>> (j + i)) & 1;
	    }
	  }
	  for (var i = 4; i < 8; i++) {
	    for (var j = 24; j >= 0; j -= 8) {
	      outR <<= 1;
	      outR |= (inR >>> (j + i)) & 1;
	      outR <<= 1;
	      outR |= (inL >>> (j + i)) & 1;
	    }
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$4.pc1 = function pc1(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  // 7, 15, 23, 31, 39, 47, 55, 63
	  // 6, 14, 22, 30, 39, 47, 55, 63
	  // 5, 13, 21, 29, 39, 47, 55, 63
	  // 4, 12, 20, 28
	  for (var i = 7; i >= 5; i--) {
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outL <<= 1;
	      outL |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outL <<= 1;
	    outL |= (inR >> (j + i)) & 1;
	  }

	  // 1, 9, 17, 25, 33, 41, 49, 57
	  // 2, 10, 18, 26, 34, 42, 50, 58
	  // 3, 11, 19, 27, 35, 43, 51, 59
	  // 36, 44, 52, 60
	  for (var i = 1; i <= 3; i++) {
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inR >> (j + i)) & 1;
	    }
	    for (var j = 0; j <= 24; j += 8) {
	      outR <<= 1;
	      outR |= (inL >> (j + i)) & 1;
	    }
	  }
	  for (var j = 0; j <= 24; j += 8) {
	    outR <<= 1;
	    outR |= (inL >> (j + i)) & 1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$4.r28shl = function r28shl(num, shift) {
	  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
	};

	var pc2table = [
	  // inL => outL
	  14, 11, 17, 4, 27, 23, 25, 0,
	  13, 22, 7, 18, 5, 9, 16, 24,
	  2, 20, 12, 21, 1, 8, 15, 26,

	  // inR => outR
	  15, 4, 25, 19, 9, 1, 26, 16,
	  5, 11, 23, 8, 12, 7, 17, 0,
	  22, 3, 10, 14, 6, 20, 27, 24
	];

	utils$4.pc2 = function pc2(inL, inR, out, off) {
	  var outL = 0;
	  var outR = 0;

	  var len = pc2table.length >>> 1;
	  for (var i = 0; i < len; i++) {
	    outL <<= 1;
	    outL |= (inL >>> pc2table[i]) & 0x1;
	  }
	  for (var i = len; i < pc2table.length; i++) {
	    outR <<= 1;
	    outR |= (inR >>> pc2table[i]) & 0x1;
	  }

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	utils$4.expand = function expand(r, out, off) {
	  var outL = 0;
	  var outR = 0;

	  outL = ((r & 1) << 5) | (r >>> 27);
	  for (var i = 23; i >= 15; i -= 4) {
	    outL <<= 6;
	    outL |= (r >>> i) & 0x3f;
	  }
	  for (var i = 11; i >= 3; i -= 4) {
	    outR |= (r >>> i) & 0x3f;
	    outR <<= 6;
	  }
	  outR |= ((r & 0x1f) << 1) | (r >>> 31);

	  out[off + 0] = outL >>> 0;
	  out[off + 1] = outR >>> 0;
	};

	var sTable = [
	  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
	  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
	  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
	  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

	  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
	  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
	  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
	  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

	  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
	  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
	  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
	  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

	  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
	  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
	  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
	  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

	  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
	  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
	  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
	  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

	  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
	  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
	  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
	  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

	  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
	  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
	  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
	  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

	  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
	  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
	  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
	  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
	];

	utils$4.substitute = function substitute(inL, inR) {
	  var out = 0;
	  for (var i = 0; i < 4; i++) {
	    var b = (inL >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  for (var i = 0; i < 4; i++) {
	    var b = (inR >>> (18 - i * 6)) & 0x3f;
	    var sb = sTable[4 * 0x40 + i * 0x40 + b];

	    out <<= 4;
	    out |= sb;
	  }
	  return out >>> 0;
	};

	var permuteTable = [
	  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
	  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
	];

	utils$4.permute = function permute(num) {
	  var out = 0;
	  for (var i = 0; i < permuteTable.length; i++) {
	    out <<= 1;
	    out |= (num >>> permuteTable[i]) & 0x1;
	  }
	  return out >>> 0;
	};

	utils$4.padSplit = function padSplit(num, size, group) {
	  var str = num.toString(2);
	  while (str.length < size)
	    str = '0' + str;

	  var out = [];
	  for (var i = 0; i < size; i += group)
	    out.push(str.slice(i, i + group));
	  return out.join(' ');
	};
	return utils$4;
}

var minimalisticAssert;
var hasRequiredMinimalisticAssert;

function requireMinimalisticAssert () {
	if (hasRequiredMinimalisticAssert) return minimalisticAssert;
	hasRequiredMinimalisticAssert = 1;
	minimalisticAssert = assert;

	function assert(val, msg) {
	  if (!val)
	    throw new Error(msg || 'Assertion failed');
	}

	assert.equal = function assertEqual(l, r, msg) {
	  if (l != r)
	    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
	};
	return minimalisticAssert;
}

var cipher;
var hasRequiredCipher;

function requireCipher () {
	if (hasRequiredCipher) return cipher;
	hasRequiredCipher = 1;

	var assert = requireMinimalisticAssert();

	function Cipher(options) {
	  this.options = options;

	  this.type = this.options.type;
	  this.blockSize = 8;
	  this._init();

	  this.buffer = new Array(this.blockSize);
	  this.bufferOff = 0;
	  this.padding = options.padding !== false;
	}
	cipher = Cipher;

	Cipher.prototype._init = function _init() {
	  // Might be overrided
	};

	Cipher.prototype.update = function update(data) {
	  if (data.length === 0)
	    return [];

	  if (this.type === 'decrypt')
	    return this._updateDecrypt(data);
	  else
	    return this._updateEncrypt(data);
	};

	Cipher.prototype._buffer = function _buffer(data, off) {
	  // Append data to buffer
	  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
	  for (var i = 0; i < min; i++)
	    this.buffer[this.bufferOff + i] = data[off + i];
	  this.bufferOff += min;

	  // Shift next
	  return min;
	};

	Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
	  this._update(this.buffer, 0, out, off);
	  this.bufferOff = 0;
	  return this.blockSize;
	};

	Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
	  var out = new Array(count * this.blockSize);

	  if (this.bufferOff !== 0) {
	    inputOff += this._buffer(data, inputOff);

	    if (this.bufferOff === this.buffer.length)
	      outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Write blocks
	  var max = data.length - ((data.length - inputOff) % this.blockSize);
	  for (; inputOff < max; inputOff += this.blockSize) {
	    this._update(data, inputOff, out, outputOff);
	    outputOff += this.blockSize;
	  }

	  // Queue rest
	  for (; inputOff < data.length; inputOff++, this.bufferOff++)
	    this.buffer[this.bufferOff] = data[inputOff];

	  return out;
	};

	Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
	  var inputOff = 0;
	  var outputOff = 0;

	  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
	  var out = new Array(count * this.blockSize);

	  // TODO(indutny): optimize it, this is far from optimal
	  for (; count > 0; count--) {
	    inputOff += this._buffer(data, inputOff);
	    outputOff += this._flushBuffer(out, outputOff);
	  }

	  // Buffer rest of the input
	  inputOff += this._buffer(data, inputOff);

	  return out;
	};

	Cipher.prototype.final = function final(buffer) {
	  var first;
	  if (buffer)
	    first = this.update(buffer);

	  var last;
	  if (this.type === 'encrypt')
	    last = this._finalEncrypt();
	  else
	    last = this._finalDecrypt();

	  if (first)
	    return first.concat(last);
	  else
	    return last;
	};

	Cipher.prototype._pad = function _pad(buffer, off) {
	  if (off === 0)
	    return false;

	  while (off < buffer.length)
	    buffer[off++] = 0;

	  return true;
	};

	Cipher.prototype._finalEncrypt = function _finalEncrypt() {
	  if (!this._pad(this.buffer, this.bufferOff))
	    return [];

	  var out = new Array(this.blockSize);
	  this._update(this.buffer, 0, out, 0);
	  return out;
	};

	Cipher.prototype._unpad = function _unpad(buffer) {
	  return buffer;
	};

	Cipher.prototype._finalDecrypt = function _finalDecrypt() {
	  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
	  var out = new Array(this.blockSize);
	  this._flushBuffer(out, 0);

	  return this._unpad(out);
	};
	return cipher;
}

var des;
var hasRequiredDes$1;

function requireDes$1 () {
	if (hasRequiredDes$1) return des;
	hasRequiredDes$1 = 1;

	var assert = requireMinimalisticAssert();
	var inherits = requireInherits_browser();

	var utils = requireUtils$4();
	var Cipher = requireCipher();

	function DESState() {
	  this.tmp = new Array(2);
	  this.keys = null;
	}

	function DES(options) {
	  Cipher.call(this, options);

	  var state = new DESState();
	  this._desState = state;

	  this.deriveKeys(state, options.key);
	}
	inherits(DES, Cipher);
	des = DES;

	DES.create = function create(options) {
	  return new DES(options);
	};

	var shiftTable = [
	  1, 1, 2, 2, 2, 2, 2, 2,
	  1, 2, 2, 2, 2, 2, 2, 1
	];

	DES.prototype.deriveKeys = function deriveKeys(state, key) {
	  state.keys = new Array(16 * 2);

	  assert.equal(key.length, this.blockSize, 'Invalid key length');

	  var kL = utils.readUInt32BE(key, 0);
	  var kR = utils.readUInt32BE(key, 4);

	  utils.pc1(kL, kR, state.tmp, 0);
	  kL = state.tmp[0];
	  kR = state.tmp[1];
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var shift = shiftTable[i >>> 1];
	    kL = utils.r28shl(kL, shift);
	    kR = utils.r28shl(kR, shift);
	    utils.pc2(kL, kR, state.keys, i);
	  }
	};

	DES.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._desState;

	  var l = utils.readUInt32BE(inp, inOff);
	  var r = utils.readUInt32BE(inp, inOff + 4);

	  // Initial Permutation
	  utils.ip(l, r, state.tmp, 0);
	  l = state.tmp[0];
	  r = state.tmp[1];

	  if (this.type === 'encrypt')
	    this._encrypt(state, l, r, state.tmp, 0);
	  else
	    this._decrypt(state, l, r, state.tmp, 0);

	  l = state.tmp[0];
	  r = state.tmp[1];

	  utils.writeUInt32BE(out, l, outOff);
	  utils.writeUInt32BE(out, r, outOff + 4);
	};

	DES.prototype._pad = function _pad(buffer, off) {
	  if (this.padding === false) {
	    return false;
	  }

	  var value = buffer.length - off;
	  for (var i = off; i < buffer.length; i++)
	    buffer[i] = value;

	  return true;
	};

	DES.prototype._unpad = function _unpad(buffer) {
	  if (this.padding === false) {
	    return buffer;
	  }

	  var pad = buffer[buffer.length - 1];
	  for (var i = buffer.length - pad; i < buffer.length; i++)
	    assert.equal(buffer[i], pad);

	  return buffer.slice(0, buffer.length - pad);
	};

	DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
	  var l = lStart;
	  var r = rStart;

	  // Apply f() x16 times
	  for (var i = 0; i < state.keys.length; i += 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils.expand(r, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils.substitute(keyL, keyR);
	    var f = utils.permute(s);

	    var t = r;
	    r = (l ^ f) >>> 0;
	    l = t;
	  }

	  // Reverse Initial Permutation
	  utils.rip(r, l, out, off);
	};

	DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
	  var l = rStart;
	  var r = lStart;

	  // Apply f() x16 times
	  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
	    var keyL = state.keys[i];
	    var keyR = state.keys[i + 1];

	    // f(r, k)
	    utils.expand(l, state.tmp, 0);

	    keyL ^= state.tmp[0];
	    keyR ^= state.tmp[1];
	    var s = utils.substitute(keyL, keyR);
	    var f = utils.permute(s);

	    var t = l;
	    l = (r ^ f) >>> 0;
	    r = t;
	  }

	  // Reverse Initial Permutation
	  utils.rip(l, r, out, off);
	};
	return des;
}

var cbc$1 = {};

var hasRequiredCbc$1;

function requireCbc$1 () {
	if (hasRequiredCbc$1) return cbc$1;
	hasRequiredCbc$1 = 1;

	var assert = requireMinimalisticAssert();
	var inherits = requireInherits_browser();

	var proto = {};

	function CBCState(iv) {
	  assert.equal(iv.length, 8, 'Invalid IV length');

	  this.iv = new Array(8);
	  for (var i = 0; i < this.iv.length; i++)
	    this.iv[i] = iv[i];
	}

	function instantiate(Base) {
	  function CBC(options) {
	    Base.call(this, options);
	    this._cbcInit();
	  }
	  inherits(CBC, Base);

	  var keys = Object.keys(proto);
	  for (var i = 0; i < keys.length; i++) {
	    var key = keys[i];
	    CBC.prototype[key] = proto[key];
	  }

	  CBC.create = function create(options) {
	    return new CBC(options);
	  };

	  return CBC;
	}

	cbc$1.instantiate = instantiate;

	proto._cbcInit = function _cbcInit() {
	  var state = new CBCState(this.options.iv);
	  this._cbcState = state;
	};

	proto._update = function _update(inp, inOff, out, outOff) {
	  var state = this._cbcState;
	  var superProto = this.constructor.super_.prototype;

	  var iv = state.iv;
	  if (this.type === 'encrypt') {
	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] ^= inp[inOff + i];

	    superProto._update.call(this, iv, 0, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = out[outOff + i];
	  } else {
	    superProto._update.call(this, inp, inOff, out, outOff);

	    for (var i = 0; i < this.blockSize; i++)
	      out[outOff + i] ^= iv[i];

	    for (var i = 0; i < this.blockSize; i++)
	      iv[i] = inp[inOff + i];
	  }
	};
	return cbc$1;
}

var ede;
var hasRequiredEde;

function requireEde () {
	if (hasRequiredEde) return ede;
	hasRequiredEde = 1;

	var assert = requireMinimalisticAssert();
	var inherits = requireInherits_browser();

	var Cipher = requireCipher();
	var DES = requireDes$1();

	function EDEState(type, key) {
	  assert.equal(key.length, 24, 'Invalid key length');

	  var k1 = key.slice(0, 8);
	  var k2 = key.slice(8, 16);
	  var k3 = key.slice(16, 24);

	  if (type === 'encrypt') {
	    this.ciphers = [
	      DES.create({ type: 'encrypt', key: k1 }),
	      DES.create({ type: 'decrypt', key: k2 }),
	      DES.create({ type: 'encrypt', key: k3 })
	    ];
	  } else {
	    this.ciphers = [
	      DES.create({ type: 'decrypt', key: k3 }),
	      DES.create({ type: 'encrypt', key: k2 }),
	      DES.create({ type: 'decrypt', key: k1 })
	    ];
	  }
	}

	function EDE(options) {
	  Cipher.call(this, options);

	  var state = new EDEState(this.type, this.options.key);
	  this._edeState = state;
	}
	inherits(EDE, Cipher);

	ede = EDE;

	EDE.create = function create(options) {
	  return new EDE(options);
	};

	EDE.prototype._update = function _update(inp, inOff, out, outOff) {
	  var state = this._edeState;

	  state.ciphers[0]._update(inp, inOff, out, outOff);
	  state.ciphers[1]._update(out, outOff, out, outOff);
	  state.ciphers[2]._update(out, outOff, out, outOff);
	};

	EDE.prototype._pad = DES.prototype._pad;
	EDE.prototype._unpad = DES.prototype._unpad;
	return ede;
}

var hasRequiredDes;

function requireDes () {
	if (hasRequiredDes) return des$1;
	hasRequiredDes = 1;

	des$1.utils = requireUtils$4();
	des$1.Cipher = requireCipher();
	des$1.DES = requireDes$1();
	des$1.CBC = requireCbc$1();
	des$1.EDE = requireEde();
	return des$1;
}

var browserifyDes;
var hasRequiredBrowserifyDes;

function requireBrowserifyDes () {
	if (hasRequiredBrowserifyDes) return browserifyDes;
	hasRequiredBrowserifyDes = 1;
	var CipherBase = requireCipherBase();
	var des = requireDes();
	var inherits = requireInherits_browser();
	var Buffer = requireSafeBuffer$2().Buffer;

	var modes = {
	  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede3': des.EDE,
	  'des-ede-cbc': des.CBC.instantiate(des.EDE),
	  'des-ede': des.EDE,
	  'des-cbc': des.CBC.instantiate(des.DES),
	  'des-ecb': des.DES
	};
	modes.des = modes['des-cbc'];
	modes.des3 = modes['des-ede3-cbc'];
	browserifyDes = DES;
	inherits(DES, CipherBase);
	function DES (opts) {
	  CipherBase.call(this);
	  var modeName = opts.mode.toLowerCase();
	  var mode = modes[modeName];
	  var type;
	  if (opts.decrypt) {
	    type = 'decrypt';
	  } else {
	    type = 'encrypt';
	  }
	  var key = opts.key;
	  if (!Buffer.isBuffer(key)) {
	    key = Buffer.from(key);
	  }
	  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
	    key = Buffer.concat([key, key.slice(0, 8)]);
	  }
	  var iv = opts.iv;
	  if (!Buffer.isBuffer(iv)) {
	    iv = Buffer.from(iv);
	  }
	  this._des = mode.create({
	    key: key,
	    iv: iv,
	    type: type
	  });
	}
	DES.prototype._update = function (data) {
	  return Buffer.from(this._des.update(data))
	};
	DES.prototype._final = function () {
	  return Buffer.from(this._des.final())
	};
	return browserifyDes;
}

var browser$5 = {};

var encrypter = {};

var ecb = {};

var hasRequiredEcb;

function requireEcb () {
	if (hasRequiredEcb) return ecb;
	hasRequiredEcb = 1;
	ecb.encrypt = function (self, block) {
	  return self._cipher.encryptBlock(block)
	};

	ecb.decrypt = function (self, block) {
	  return self._cipher.decryptBlock(block)
	};
	return ecb;
}

var cbc = {};

var bufferXor;
var hasRequiredBufferXor;

function requireBufferXor () {
	if (hasRequiredBufferXor) return bufferXor;
	hasRequiredBufferXor = 1;
	bufferXor = function xor (a, b) {
	  var length = Math.min(a.length, b.length);
	  var buffer = new Buffer$1(length);

	  for (var i = 0; i < length; ++i) {
	    buffer[i] = a[i] ^ b[i];
	  }

	  return buffer
	};
	return bufferXor;
}

var hasRequiredCbc;

function requireCbc () {
	if (hasRequiredCbc) return cbc;
	hasRequiredCbc = 1;
	var xor = requireBufferXor();

	cbc.encrypt = function (self, block) {
	  var data = xor(block, self._prev);

	  self._prev = self._cipher.encryptBlock(data);
	  return self._prev
	};

	cbc.decrypt = function (self, block) {
	  var pad = self._prev;

	  self._prev = block;
	  var out = self._cipher.decryptBlock(block);

	  return xor(out, pad)
	};
	return cbc;
}

var cfb = {};

var hasRequiredCfb;

function requireCfb () {
	if (hasRequiredCfb) return cfb;
	hasRequiredCfb = 1;
	var Buffer = requireSafeBuffer$2().Buffer;
	var xor = requireBufferXor();

	function encryptStart (self, data, decrypt) {
	  var len = data.length;
	  var out = xor(data, self._cache);
	  self._cache = self._cache.slice(len);
	  self._prev = Buffer.concat([self._prev, decrypt ? data : out]);
	  return out
	}

	cfb.encrypt = function (self, data, decrypt) {
	  var out = Buffer.allocUnsafe(0);
	  var len;

	  while (data.length) {
	    if (self._cache.length === 0) {
	      self._cache = self._cipher.encryptBlock(self._prev);
	      self._prev = Buffer.allocUnsafe(0);
	    }

	    if (self._cache.length <= data.length) {
	      len = self._cache.length;
	      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)]);
	      data = data.slice(len);
	    } else {
	      out = Buffer.concat([out, encryptStart(self, data, decrypt)]);
	      break
	    }
	  }

	  return out
	};
	return cfb;
}

var cfb8 = {};

var hasRequiredCfb8;

function requireCfb8 () {
	if (hasRequiredCfb8) return cfb8;
	hasRequiredCfb8 = 1;
	var Buffer = requireSafeBuffer$2().Buffer;

	function encryptByte (self, byteParam, decrypt) {
	  var pad = self._cipher.encryptBlock(self._prev);
	  var out = pad[0] ^ byteParam;

	  self._prev = Buffer.concat([
	    self._prev.slice(1),
	    Buffer.from([decrypt ? byteParam : out])
	  ]);

	  return out
	}

	cfb8.encrypt = function (self, chunk, decrypt) {
	  var len = chunk.length;
	  var out = Buffer.allocUnsafe(len);
	  var i = -1;

	  while (++i < len) {
	    out[i] = encryptByte(self, chunk[i], decrypt);
	  }

	  return out
	};
	return cfb8;
}

var cfb1 = {};

var hasRequiredCfb1;

function requireCfb1 () {
	if (hasRequiredCfb1) return cfb1;
	hasRequiredCfb1 = 1;
	var Buffer = requireSafeBuffer$2().Buffer;

	function encryptByte (self, byteParam, decrypt) {
	  var pad;
	  var i = -1;
	  var len = 8;
	  var out = 0;
	  var bit, value;
	  while (++i < len) {
	    pad = self._cipher.encryptBlock(self._prev);
	    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0;
	    value = pad[0] ^ bit;
	    out += ((value & 0x80) >> (i % 8));
	    self._prev = shiftIn(self._prev, decrypt ? bit : value);
	  }
	  return out
	}

	function shiftIn (buffer, value) {
	  var len = buffer.length;
	  var i = -1;
	  var out = Buffer.allocUnsafe(buffer.length);
	  buffer = Buffer.concat([buffer, Buffer.from([value])]);

	  while (++i < len) {
	    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7);
	  }

	  return out
	}

	cfb1.encrypt = function (self, chunk, decrypt) {
	  var len = chunk.length;
	  var out = Buffer.allocUnsafe(len);
	  var i = -1;

	  while (++i < len) {
	    out[i] = encryptByte(self, chunk[i], decrypt);
	  }

	  return out
	};
	return cfb1;
}

var ofb = {};

var hasRequiredOfb;

function requireOfb () {
	if (hasRequiredOfb) return ofb;
	hasRequiredOfb = 1;
	var xor = requireBufferXor();

	function getBlock (self) {
	  self._prev = self._cipher.encryptBlock(self._prev);
	  return self._prev
	}

	ofb.encrypt = function (self, chunk) {
	  while (self._cache.length < chunk.length) {
	    self._cache = Buffer$1.concat([self._cache, getBlock(self)]);
	  }

	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad)
	};
	return ofb;
}

var ctr = {};

var incr32_1;
var hasRequiredIncr32;

function requireIncr32 () {
	if (hasRequiredIncr32) return incr32_1;
	hasRequiredIncr32 = 1;
	function incr32 (iv) {
	  var len = iv.length;
	  var item;
	  while (len--) {
	    item = iv.readUInt8(len);
	    if (item === 255) {
	      iv.writeUInt8(0, len);
	    } else {
	      item++;
	      iv.writeUInt8(item, len);
	      break
	    }
	  }
	}
	incr32_1 = incr32;
	return incr32_1;
}

var hasRequiredCtr;

function requireCtr () {
	if (hasRequiredCtr) return ctr;
	hasRequiredCtr = 1;
	var xor = requireBufferXor();
	var Buffer = requireSafeBuffer$2().Buffer;
	var incr32 = requireIncr32();

	function getBlock (self) {
	  var out = self._cipher.encryptBlockRaw(self._prev);
	  incr32(self._prev);
	  return out
	}

	var blockSize = 16;
	ctr.encrypt = function (self, chunk) {
	  var chunkNum = Math.ceil(chunk.length / blockSize);
	  var start = self._cache.length;
	  self._cache = Buffer.concat([
	    self._cache,
	    Buffer.allocUnsafe(chunkNum * blockSize)
	  ]);
	  for (var i = 0; i < chunkNum; i++) {
	    var out = getBlock(self);
	    var offset = start + i * blockSize;
	    self._cache.writeUInt32BE(out[0], offset + 0);
	    self._cache.writeUInt32BE(out[1], offset + 4);
	    self._cache.writeUInt32BE(out[2], offset + 8);
	    self._cache.writeUInt32BE(out[3], offset + 12);
	  }
	  var pad = self._cache.slice(0, chunk.length);
	  self._cache = self._cache.slice(chunk.length);
	  return xor(chunk, pad)
	};
	return ctr;
}

const aes128 = {"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"};
const aes192 = {"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"};
const aes256 = {"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"};
const require$$2 = {
  "aes-128-ecb": {"cipher":"AES","key":128,"iv":0,"mode":"ECB","type":"block"},
  "aes-192-ecb": {"cipher":"AES","key":192,"iv":0,"mode":"ECB","type":"block"},
  "aes-256-ecb": {"cipher":"AES","key":256,"iv":0,"mode":"ECB","type":"block"},
  "aes-128-cbc": {"cipher":"AES","key":128,"iv":16,"mode":"CBC","type":"block"},
  "aes-192-cbc": {"cipher":"AES","key":192,"iv":16,"mode":"CBC","type":"block"},
  "aes-256-cbc": {"cipher":"AES","key":256,"iv":16,"mode":"CBC","type":"block"},
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {"cipher":"AES","key":128,"iv":16,"mode":"CFB","type":"stream"},
  "aes-192-cfb": {"cipher":"AES","key":192,"iv":16,"mode":"CFB","type":"stream"},
  "aes-256-cfb": {"cipher":"AES","key":256,"iv":16,"mode":"CFB","type":"stream"},
  "aes-128-cfb8": {"cipher":"AES","key":128,"iv":16,"mode":"CFB8","type":"stream"},
  "aes-192-cfb8": {"cipher":"AES","key":192,"iv":16,"mode":"CFB8","type":"stream"},
  "aes-256-cfb8": {"cipher":"AES","key":256,"iv":16,"mode":"CFB8","type":"stream"},
  "aes-128-cfb1": {"cipher":"AES","key":128,"iv":16,"mode":"CFB1","type":"stream"},
  "aes-192-cfb1": {"cipher":"AES","key":192,"iv":16,"mode":"CFB1","type":"stream"},
  "aes-256-cfb1": {"cipher":"AES","key":256,"iv":16,"mode":"CFB1","type":"stream"},
  "aes-128-ofb": {"cipher":"AES","key":128,"iv":16,"mode":"OFB","type":"stream"},
  "aes-192-ofb": {"cipher":"AES","key":192,"iv":16,"mode":"OFB","type":"stream"},
  "aes-256-ofb": {"cipher":"AES","key":256,"iv":16,"mode":"OFB","type":"stream"},
  "aes-128-ctr": {"cipher":"AES","key":128,"iv":16,"mode":"CTR","type":"stream"},
  "aes-192-ctr": {"cipher":"AES","key":192,"iv":16,"mode":"CTR","type":"stream"},
  "aes-256-ctr": {"cipher":"AES","key":256,"iv":16,"mode":"CTR","type":"stream"},
  "aes-128-gcm": {"cipher":"AES","key":128,"iv":12,"mode":"GCM","type":"auth"},
  "aes-192-gcm": {"cipher":"AES","key":192,"iv":12,"mode":"GCM","type":"auth"},
  "aes-256-gcm": {"cipher":"AES","key":256,"iv":12,"mode":"GCM","type":"auth"},
};

var modes_1;
var hasRequiredModes$1;

function requireModes$1 () {
	if (hasRequiredModes$1) return modes_1;
	hasRequiredModes$1 = 1;
	var modeModules = {
	  ECB: requireEcb(),
	  CBC: requireCbc(),
	  CFB: requireCfb(),
	  CFB8: requireCfb8(),
	  CFB1: requireCfb1(),
	  OFB: requireOfb(),
	  CTR: requireCtr(),
	  GCM: requireCtr()
	};

	var modes = require$$2;

	for (var key in modes) {
	  modes[key].module = modeModules[modes[key].mode];
	}

	modes_1 = modes;
	return modes_1;
}

var aes = {};

var hasRequiredAes;

function requireAes () {
	if (hasRequiredAes) return aes;
	hasRequiredAes = 1;
	// based on the aes implimentation in triple sec
	// https://github.com/keybase/triplesec
	// which is in turn based on the one from crypto-js
	// https://code.google.com/p/crypto-js/

	var Buffer = requireSafeBuffer$2().Buffer;

	function asUInt32Array (buf) {
	  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);

	  var len = (buf.length / 4) | 0;
	  var out = new Array(len);

	  for (var i = 0; i < len; i++) {
	    out[i] = buf.readUInt32BE(i * 4);
	  }

	  return out
	}

	function scrubVec (v) {
	  for (var i = 0; i < v.length; v++) {
	    v[i] = 0;
	  }
	}

	function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
	  var SUB_MIX0 = SUB_MIX[0];
	  var SUB_MIX1 = SUB_MIX[1];
	  var SUB_MIX2 = SUB_MIX[2];
	  var SUB_MIX3 = SUB_MIX[3];

	  var s0 = M[0] ^ keySchedule[0];
	  var s1 = M[1] ^ keySchedule[1];
	  var s2 = M[2] ^ keySchedule[2];
	  var s3 = M[3] ^ keySchedule[3];
	  var t0, t1, t2, t3;
	  var ksRow = 4;

	  for (var round = 1; round < nRounds; round++) {
	    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++];
	    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++];
	    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++];
	    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++];
	    s0 = t0;
	    s1 = t1;
	    s2 = t2;
	    s3 = t3;
	  }

	  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];
	  t0 = t0 >>> 0;
	  t1 = t1 >>> 0;
	  t2 = t2 >>> 0;
	  t3 = t3 >>> 0;

	  return [t0, t1, t2, t3]
	}

	// AES constants
	var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];
	var G = (function () {
	  // Compute double table
	  var d = new Array(256);
	  for (var j = 0; j < 256; j++) {
	    if (j < 128) {
	      d[j] = j << 1;
	    } else {
	      d[j] = (j << 1) ^ 0x11b;
	    }
	  }

	  var SBOX = [];
	  var INV_SBOX = [];
	  var SUB_MIX = [[], [], [], []];
	  var INV_SUB_MIX = [[], [], [], []];

	  // Walk GF(2^8)
	  var x = 0;
	  var xi = 0;
	  for (var i = 0; i < 256; ++i) {
	    // Compute sbox
	    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	    SBOX[x] = sx;
	    INV_SBOX[sx] = x;

	    // Compute multiplication
	    var x2 = d[x];
	    var x4 = d[x2];
	    var x8 = d[x4];

	    // Compute sub bytes, mix columns tables
	    var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	    SUB_MIX[0][x] = (t << 24) | (t >>> 8);
	    SUB_MIX[1][x] = (t << 16) | (t >>> 16);
	    SUB_MIX[2][x] = (t << 8) | (t >>> 24);
	    SUB_MIX[3][x] = t;

	    // Compute inv sub bytes, inv mix columns tables
	    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8);
	    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16);
	    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24);
	    INV_SUB_MIX[3][sx] = t;

	    if (x === 0) {
	      x = xi = 1;
	    } else {
	      x = x2 ^ d[d[d[x8 ^ x2]]];
	      xi ^= d[d[xi]];
	    }
	  }

	  return {
	    SBOX: SBOX,
	    INV_SBOX: INV_SBOX,
	    SUB_MIX: SUB_MIX,
	    INV_SUB_MIX: INV_SUB_MIX
	  }
	})();

	function AES (key) {
	  this._key = asUInt32Array(key);
	  this._reset();
	}

	AES.blockSize = 4 * 4;
	AES.keySize = 256 / 8;
	AES.prototype.blockSize = AES.blockSize;
	AES.prototype.keySize = AES.keySize;
	AES.prototype._reset = function () {
	  var keyWords = this._key;
	  var keySize = keyWords.length;
	  var nRounds = keySize + 6;
	  var ksRows = (nRounds + 1) * 4;

	  var keySchedule = [];
	  for (var k = 0; k < keySize; k++) {
	    keySchedule[k] = keyWords[k];
	  }

	  for (k = keySize; k < ksRows; k++) {
	    var t = keySchedule[k - 1];

	    if (k % keySize === 0) {
	      t = (t << 8) | (t >>> 24);
	      t =
	        (G.SBOX[t >>> 24] << 24) |
	        (G.SBOX[(t >>> 16) & 0xff] << 16) |
	        (G.SBOX[(t >>> 8) & 0xff] << 8) |
	        (G.SBOX[t & 0xff]);

	      t ^= RCON[(k / keySize) | 0] << 24;
	    } else if (keySize > 6 && k % keySize === 4) {
	      t =
	        (G.SBOX[t >>> 24] << 24) |
	        (G.SBOX[(t >>> 16) & 0xff] << 16) |
	        (G.SBOX[(t >>> 8) & 0xff] << 8) |
	        (G.SBOX[t & 0xff]);
	    }

	    keySchedule[k] = keySchedule[k - keySize] ^ t;
	  }

	  var invKeySchedule = [];
	  for (var ik = 0; ik < ksRows; ik++) {
	    var ksR = ksRows - ik;
	    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)];

	    if (ik < 4 || ksR <= 4) {
	      invKeySchedule[ik] = tt;
	    } else {
	      invKeySchedule[ik] =
	        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
	        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
	        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
	        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]];
	    }
	  }

	  this._nRounds = nRounds;
	  this._keySchedule = keySchedule;
	  this._invKeySchedule = invKeySchedule;
	};

	AES.prototype.encryptBlockRaw = function (M) {
	  M = asUInt32Array(M);
	  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
	};

	AES.prototype.encryptBlock = function (M) {
	  var out = this.encryptBlockRaw(M);
	  var buf = Buffer.allocUnsafe(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[1], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[3], 12);
	  return buf
	};

	AES.prototype.decryptBlock = function (M) {
	  M = asUInt32Array(M);

	  // swap
	  var m1 = M[1];
	  M[1] = M[3];
	  M[3] = m1;

	  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds);
	  var buf = Buffer.allocUnsafe(16);
	  buf.writeUInt32BE(out[0], 0);
	  buf.writeUInt32BE(out[3], 4);
	  buf.writeUInt32BE(out[2], 8);
	  buf.writeUInt32BE(out[1], 12);
	  return buf
	};

	AES.prototype.scrub = function () {
	  scrubVec(this._keySchedule);
	  scrubVec(this._invKeySchedule);
	  scrubVec(this._key);
	};

	aes.AES = AES;
	return aes;
}

var ghash;
var hasRequiredGhash;

function requireGhash () {
	if (hasRequiredGhash) return ghash;
	hasRequiredGhash = 1;
	var Buffer = requireSafeBuffer$2().Buffer;
	var ZEROES = Buffer.alloc(16, 0);

	function toArray (buf) {
	  return [
	    buf.readUInt32BE(0),
	    buf.readUInt32BE(4),
	    buf.readUInt32BE(8),
	    buf.readUInt32BE(12)
	  ]
	}

	function fromArray (out) {
	  var buf = Buffer.allocUnsafe(16);
	  buf.writeUInt32BE(out[0] >>> 0, 0);
	  buf.writeUInt32BE(out[1] >>> 0, 4);
	  buf.writeUInt32BE(out[2] >>> 0, 8);
	  buf.writeUInt32BE(out[3] >>> 0, 12);
	  return buf
	}

	function GHASH (key) {
	  this.h = key;
	  this.state = Buffer.alloc(16, 0);
	  this.cache = Buffer.allocUnsafe(0);
	}

	// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
	// by Juho Vähä-Herttua
	GHASH.prototype.ghash = function (block) {
	  var i = -1;
	  while (++i < block.length) {
	    this.state[i] ^= block[i];
	  }
	  this._multiply();
	};

	GHASH.prototype._multiply = function () {
	  var Vi = toArray(this.h);
	  var Zi = [0, 0, 0, 0];
	  var j, xi, lsbVi;
	  var i = -1;
	  while (++i < 128) {
	    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0;
	    if (xi) {
	      // Z_i+1 = Z_i ^ V_i
	      Zi[0] ^= Vi[0];
	      Zi[1] ^= Vi[1];
	      Zi[2] ^= Vi[2];
	      Zi[3] ^= Vi[3];
	    }

	    // Store the value of LSB(V_i)
	    lsbVi = (Vi[3] & 1) !== 0;

	    // V_i+1 = V_i >> 1
	    for (j = 3; j > 0; j--) {
	      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31);
	    }
	    Vi[0] = Vi[0] >>> 1;

	    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
	    if (lsbVi) {
	      Vi[0] = Vi[0] ^ (0xe1 << 24);
	    }
	  }
	  this.state = fromArray(Zi);
	};

	GHASH.prototype.update = function (buf) {
	  this.cache = Buffer.concat([this.cache, buf]);
	  var chunk;
	  while (this.cache.length >= 16) {
	    chunk = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    this.ghash(chunk);
	  }
	};

	GHASH.prototype.final = function (abl, bl) {
	  if (this.cache.length) {
	    this.ghash(Buffer.concat([this.cache, ZEROES], 16));
	  }

	  this.ghash(fromArray([0, abl, 0, bl]));
	  return this.state
	};

	ghash = GHASH;
	return ghash;
}

var authCipher;
var hasRequiredAuthCipher;

function requireAuthCipher () {
	if (hasRequiredAuthCipher) return authCipher;
	hasRequiredAuthCipher = 1;
	var aes = requireAes();
	var Buffer = requireSafeBuffer$2().Buffer;
	var Transform = requireCipherBase();
	var inherits = requireInherits_browser();
	var GHASH = requireGhash();
	var xor = requireBufferXor();
	var incr32 = requireIncr32();

	function xorTest (a, b) {
	  var out = 0;
	  if (a.length !== b.length) out++;

	  var len = Math.min(a.length, b.length);
	  for (var i = 0; i < len; ++i) {
	    out += (a[i] ^ b[i]);
	  }

	  return out
	}

	function calcIv (self, iv, ck) {
	  if (iv.length === 12) {
	    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])]);
	    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
	  }
	  var ghash = new GHASH(ck);
	  var len = iv.length;
	  var toPad = len % 16;
	  ghash.update(iv);
	  if (toPad) {
	    toPad = 16 - toPad;
	    ghash.update(Buffer.alloc(toPad, 0));
	  }
	  ghash.update(Buffer.alloc(8, 0));
	  var ivBits = len * 8;
	  var tail = Buffer.alloc(8);
	  tail.writeUIntBE(ivBits, 0, 8);
	  ghash.update(tail);
	  self._finID = ghash.state;
	  var out = Buffer.from(self._finID);
	  incr32(out);
	  return out
	}
	function StreamCipher (mode, key, iv, decrypt) {
	  Transform.call(this);

	  var h = Buffer.alloc(4, 0);

	  this._cipher = new aes.AES(key);
	  var ck = this._cipher.encryptBlock(h);
	  this._ghash = new GHASH(ck);
	  iv = calcIv(this, iv, ck);

	  this._prev = Buffer.from(iv);
	  this._cache = Buffer.allocUnsafe(0);
	  this._secCache = Buffer.allocUnsafe(0);
	  this._decrypt = decrypt;
	  this._alen = 0;
	  this._len = 0;
	  this._mode = mode;

	  this._authTag = null;
	  this._called = false;
	}

	inherits(StreamCipher, Transform);

	StreamCipher.prototype._update = function (chunk) {
	  if (!this._called && this._alen) {
	    var rump = 16 - (this._alen % 16);
	    if (rump < 16) {
	      rump = Buffer.alloc(rump, 0);
	      this._ghash.update(rump);
	    }
	  }

	  this._called = true;
	  var out = this._mode.encrypt(this, chunk);
	  if (this._decrypt) {
	    this._ghash.update(chunk);
	  } else {
	    this._ghash.update(out);
	  }
	  this._len += chunk.length;
	  return out
	};

	StreamCipher.prototype._final = function () {
	  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

	  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
	  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

	  this._authTag = tag;
	  this._cipher.scrub();
	};

	StreamCipher.prototype.getAuthTag = function getAuthTag () {
	  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

	  return this._authTag
	};

	StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
	  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

	  this._authTag = tag;
	};

	StreamCipher.prototype.setAAD = function setAAD (buf) {
	  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

	  this._ghash.update(buf);
	  this._alen += buf.length;
	};

	authCipher = StreamCipher;
	return authCipher;
}

var streamCipher;
var hasRequiredStreamCipher;

function requireStreamCipher () {
	if (hasRequiredStreamCipher) return streamCipher;
	hasRequiredStreamCipher = 1;
	var aes = requireAes();
	var Buffer = requireSafeBuffer$2().Buffer;
	var Transform = requireCipherBase();
	var inherits = requireInherits_browser();

	function StreamCipher (mode, key, iv, decrypt) {
	  Transform.call(this);

	  this._cipher = new aes.AES(key);
	  this._prev = Buffer.from(iv);
	  this._cache = Buffer.allocUnsafe(0);
	  this._secCache = Buffer.allocUnsafe(0);
	  this._decrypt = decrypt;
	  this._mode = mode;
	}

	inherits(StreamCipher, Transform);

	StreamCipher.prototype._update = function (chunk) {
	  return this._mode.encrypt(this, chunk, this._decrypt)
	};

	StreamCipher.prototype._final = function () {
	  this._cipher.scrub();
	};

	streamCipher = StreamCipher;
	return streamCipher;
}

var evp_bytestokey;
var hasRequiredEvp_bytestokey;

function requireEvp_bytestokey () {
	if (hasRequiredEvp_bytestokey) return evp_bytestokey;
	hasRequiredEvp_bytestokey = 1;
	var Buffer = requireSafeBuffer$2().Buffer;
	var MD5 = requireMd5_js();

	/* eslint-disable camelcase */
	function EVP_BytesToKey (password, salt, keyBits, ivLen) {
	  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary');
	  if (salt) {
	    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary');
	    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
	  }

	  var keyLen = keyBits / 8;
	  var key = Buffer.alloc(keyLen);
	  var iv = Buffer.alloc(ivLen || 0);
	  var tmp = Buffer.alloc(0);

	  while (keyLen > 0 || ivLen > 0) {
	    var hash = new MD5();
	    hash.update(tmp);
	    hash.update(password);
	    if (salt) hash.update(salt);
	    tmp = hash.digest();

	    var used = 0;

	    if (keyLen > 0) {
	      var keyStart = key.length - keyLen;
	      used = Math.min(keyLen, tmp.length);
	      tmp.copy(key, keyStart, 0, used);
	      keyLen -= used;
	    }

	    if (used < tmp.length && ivLen > 0) {
	      var ivStart = iv.length - ivLen;
	      var length = Math.min(ivLen, tmp.length - used);
	      tmp.copy(iv, ivStart, used, used + length);
	      ivLen -= length;
	    }
	  }

	  tmp.fill(0);
	  return { key: key, iv: iv }
	}

	evp_bytestokey = EVP_BytesToKey;
	return evp_bytestokey;
}

var hasRequiredEncrypter;

function requireEncrypter () {
	if (hasRequiredEncrypter) return encrypter;
	hasRequiredEncrypter = 1;
	var MODES = requireModes$1();
	var AuthCipher = requireAuthCipher();
	var Buffer = requireSafeBuffer$2().Buffer;
	var StreamCipher = requireStreamCipher();
	var Transform = requireCipherBase();
	var aes = requireAes();
	var ebtk = requireEvp_bytestokey();
	var inherits = requireInherits_browser();

	function Cipher (mode, key, iv) {
	  Transform.call(this);

	  this._cache = new Splitter();
	  this._cipher = new aes.AES(key);
	  this._prev = Buffer.from(iv);
	  this._mode = mode;
	  this._autopadding = true;
	}

	inherits(Cipher, Transform);

	Cipher.prototype._update = function (data) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  var out = [];

	  while ((chunk = this._cache.get())) {
	    thing = this._mode.encrypt(this, chunk);
	    out.push(thing);
	  }

	  return Buffer.concat(out)
	};

	var PADDING = Buffer.alloc(16, 0x10);

	Cipher.prototype._final = function () {
	  var chunk = this._cache.flush();
	  if (this._autopadding) {
	    chunk = this._mode.encrypt(this, chunk);
	    this._cipher.scrub();
	    return chunk
	  }

	  if (!chunk.equals(PADDING)) {
	    this._cipher.scrub();
	    throw new Error('data not multiple of block length')
	  }
	};

	Cipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo;
	  return this
	};

	function Splitter () {
	  this.cache = Buffer.allocUnsafe(0);
	}

	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};

	Splitter.prototype.get = function () {
	  if (this.cache.length > 15) {
	    var out = this.cache.slice(0, 16);
	    this.cache = this.cache.slice(16);
	    return out
	  }
	  return null
	};

	Splitter.prototype.flush = function () {
	  var len = 16 - this.cache.length;
	  var padBuff = Buffer.allocUnsafe(len);

	  var i = -1;
	  while (++i < len) {
	    padBuff.writeUInt8(len, i);
	  }

	  return Buffer.concat([this.cache, padBuff])
	};

	function createCipheriv (suite, password, iv) {
	  var config = MODES[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  if (typeof password === 'string') password = Buffer.from(password);
	  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

	  if (typeof iv === 'string') iv = Buffer.from(iv);
	  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

	  if (config.type === 'stream') {
	    return new StreamCipher(config.module, password, iv)
	  } else if (config.type === 'auth') {
	    return new AuthCipher(config.module, password, iv)
	  }

	  return new Cipher(config.module, password, iv)
	}

	function createCipher (suite, password) {
	  var config = MODES[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  var keys = ebtk(password, false, config.key, config.iv);
	  return createCipheriv(suite, keys.key, keys.iv)
	}

	encrypter.createCipheriv = createCipheriv;
	encrypter.createCipher = createCipher;
	return encrypter;
}

var decrypter = {};

var hasRequiredDecrypter;

function requireDecrypter () {
	if (hasRequiredDecrypter) return decrypter;
	hasRequiredDecrypter = 1;
	var AuthCipher = requireAuthCipher();
	var Buffer = requireSafeBuffer$2().Buffer;
	var MODES = requireModes$1();
	var StreamCipher = requireStreamCipher();
	var Transform = requireCipherBase();
	var aes = requireAes();
	var ebtk = requireEvp_bytestokey();
	var inherits = requireInherits_browser();

	function Decipher (mode, key, iv) {
	  Transform.call(this);

	  this._cache = new Splitter();
	  this._last = void 0;
	  this._cipher = new aes.AES(key);
	  this._prev = Buffer.from(iv);
	  this._mode = mode;
	  this._autopadding = true;
	}

	inherits(Decipher, Transform);

	Decipher.prototype._update = function (data) {
	  this._cache.add(data);
	  var chunk;
	  var thing;
	  var out = [];
	  while ((chunk = this._cache.get(this._autopadding))) {
	    thing = this._mode.decrypt(this, chunk);
	    out.push(thing);
	  }
	  return Buffer.concat(out)
	};

	Decipher.prototype._final = function () {
	  var chunk = this._cache.flush();
	  if (this._autopadding) {
	    return unpad(this._mode.decrypt(this, chunk))
	  } else if (chunk) {
	    throw new Error('data not multiple of block length')
	  }
	};

	Decipher.prototype.setAutoPadding = function (setTo) {
	  this._autopadding = !!setTo;
	  return this
	};

	function Splitter () {
	  this.cache = Buffer.allocUnsafe(0);
	}

	Splitter.prototype.add = function (data) {
	  this.cache = Buffer.concat([this.cache, data]);
	};

	Splitter.prototype.get = function (autoPadding) {
	  var out;
	  if (autoPadding) {
	    if (this.cache.length > 16) {
	      out = this.cache.slice(0, 16);
	      this.cache = this.cache.slice(16);
	      return out
	    }
	  } else {
	    if (this.cache.length >= 16) {
	      out = this.cache.slice(0, 16);
	      this.cache = this.cache.slice(16);
	      return out
	    }
	  }

	  return null
	};

	Splitter.prototype.flush = function () {
	  if (this.cache.length) return this.cache
	};

	function unpad (last) {
	  var padded = last[15];
	  if (padded < 1 || padded > 16) {
	    throw new Error('unable to decrypt data')
	  }
	  var i = -1;
	  while (++i < padded) {
	    if (last[(i + (16 - padded))] !== padded) {
	      throw new Error('unable to decrypt data')
	    }
	  }
	  if (padded === 16) return

	  return last.slice(0, 16 - padded)
	}

	function createDecipheriv (suite, password, iv) {
	  var config = MODES[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  if (typeof iv === 'string') iv = Buffer.from(iv);
	  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

	  if (typeof password === 'string') password = Buffer.from(password);
	  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

	  if (config.type === 'stream') {
	    return new StreamCipher(config.module, password, iv, true)
	  } else if (config.type === 'auth') {
	    return new AuthCipher(config.module, password, iv, true)
	  }

	  return new Decipher(config.module, password, iv)
	}

	function createDecipher (suite, password) {
	  var config = MODES[suite.toLowerCase()];
	  if (!config) throw new TypeError('invalid suite type')

	  var keys = ebtk(password, false, config.key, config.iv);
	  return createDecipheriv(suite, keys.key, keys.iv)
	}

	decrypter.createDecipher = createDecipher;
	decrypter.createDecipheriv = createDecipheriv;
	return decrypter;
}

var hasRequiredBrowser$6;

function requireBrowser$6 () {
	if (hasRequiredBrowser$6) return browser$5;
	hasRequiredBrowser$6 = 1;
	var ciphers = requireEncrypter();
	var deciphers = requireDecrypter();
	var modes = require$$2;

	function getCiphers () {
	  return Object.keys(modes)
	}

	browser$5.createCipher = browser$5.Cipher = ciphers.createCipher;
	browser$5.createCipheriv = browser$5.Cipheriv = ciphers.createCipheriv;
	browser$5.createDecipher = browser$5.Decipher = deciphers.createDecipher;
	browser$5.createDecipheriv = browser$5.Decipheriv = deciphers.createDecipheriv;
	browser$5.listCiphers = browser$5.getCiphers = getCiphers;
	return browser$5;
}

var modes = {};

var hasRequiredModes;

function requireModes () {
	if (hasRequiredModes) return modes;
	hasRequiredModes = 1;
	(function (exports) {
		exports['des-ecb'] = {
		  key: 8,
		  iv: 0
		};
		exports['des-cbc'] = exports.des = {
		  key: 8,
		  iv: 8
		};
		exports['des-ede3-cbc'] = exports.des3 = {
		  key: 24,
		  iv: 8
		};
		exports['des-ede3'] = {
		  key: 24,
		  iv: 0
		};
		exports['des-ede-cbc'] = {
		  key: 16,
		  iv: 8
		};
		exports['des-ede'] = {
		  key: 16,
		  iv: 0
		}; 
	} (modes));
	return modes;
}

var hasRequiredBrowser$5;

function requireBrowser$5 () {
	if (hasRequiredBrowser$5) return browser$6;
	hasRequiredBrowser$5 = 1;
	var DES = requireBrowserifyDes();
	var aes = requireBrowser$6();
	var aesModes = requireModes$1();
	var desModes = requireModes();
	var ebtk = requireEvp_bytestokey();

	function createCipher (suite, password) {
	  suite = suite.toLowerCase();

	  var keyLen, ivLen;
	  if (aesModes[suite]) {
	    keyLen = aesModes[suite].key;
	    ivLen = aesModes[suite].iv;
	  } else if (desModes[suite]) {
	    keyLen = desModes[suite].key * 8;
	    ivLen = desModes[suite].iv;
	  } else {
	    throw new TypeError('invalid suite type')
	  }

	  var keys = ebtk(password, false, keyLen, ivLen);
	  return createCipheriv(suite, keys.key, keys.iv)
	}

	function createDecipher (suite, password) {
	  suite = suite.toLowerCase();

	  var keyLen, ivLen;
	  if (aesModes[suite]) {
	    keyLen = aesModes[suite].key;
	    ivLen = aesModes[suite].iv;
	  } else if (desModes[suite]) {
	    keyLen = desModes[suite].key * 8;
	    ivLen = desModes[suite].iv;
	  } else {
	    throw new TypeError('invalid suite type')
	  }

	  var keys = ebtk(password, false, keyLen, ivLen);
	  return createDecipheriv(suite, keys.key, keys.iv)
	}

	function createCipheriv (suite, key, iv) {
	  suite = suite.toLowerCase();
	  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
	  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

	  throw new TypeError('invalid suite type')
	}

	function createDecipheriv (suite, key, iv) {
	  suite = suite.toLowerCase();
	  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
	  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

	  throw new TypeError('invalid suite type')
	}

	function getCiphers () {
	  return Object.keys(desModes).concat(aes.getCiphers())
	}

	browser$6.createCipher = browser$6.Cipher = createCipher;
	browser$6.createCipheriv = browser$6.Cipheriv = createCipheriv;
	browser$6.createDecipher = browser$6.Decipher = createDecipher;
	browser$6.createDecipheriv = browser$6.Decipheriv = createDecipheriv;
	browser$6.listCiphers = browser$6.getCiphers = getCiphers;
	return browser$6;
}

var browser$4 = {};

var bn$f = {exports: {}};

var bn$e = bn$f.exports;

var hasRequiredBn$7;

function requireBn$7 () {
	if (hasRequiredBn$7) return bn$f.exports;
	hasRequiredBn$7 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$e); 
	} (bn$f));
	return bn$f.exports;
}

var bn$d = {exports: {}};

var bn$c = bn$d.exports;

var hasRequiredBn$6;

function requireBn$6 () {
	if (hasRequiredBn$6) return bn$d.exports;
	hasRequiredBn$6 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$c); 
	} (bn$d));
	return bn$d.exports;
}

var brorand = {exports: {}};

var hasRequiredBrorand;

function requireBrorand () {
	if (hasRequiredBrorand) return brorand.exports;
	hasRequiredBrorand = 1;
	var r;

	brorand.exports = function rand(len) {
	  if (!r)
	    r = new Rand(null);

	  return r.generate(len);
	};

	function Rand(rand) {
	  this.rand = rand;
	}
	brorand.exports.Rand = Rand;

	Rand.prototype.generate = function generate(len) {
	  return this._rand(len);
	};

	// Emulate crypto API using randy
	Rand.prototype._rand = function _rand(n) {
	  if (this.rand.getBytes)
	    return this.rand.getBytes(n);

	  var res = new Uint8Array(n);
	  for (var i = 0; i < res.length; i++)
	    res[i] = this.rand.getByte();
	  return res;
	};

	if (typeof self === 'object') {
	  if (self.crypto && self.crypto.getRandomValues) {
	    // Modern browsers
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      self.crypto.getRandomValues(arr);
	      return arr;
	    };
	  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
	    // IE
	    Rand.prototype._rand = function _rand(n) {
	      var arr = new Uint8Array(n);
	      self.msCrypto.getRandomValues(arr);
	      return arr;
	    };

	  // Safari's WebWorkers do not have `crypto`
	  } else if (typeof window === 'object') {
	    // Old junk
	    Rand.prototype._rand = function() {
	      throw new Error('Not implemented yet');
	    };
	  }
	} else {
	  // Node.js or Web worker with no crypto support
	  try {
	    var crypto = requireCryptoBrowserify();
	    if (typeof crypto.randomBytes !== 'function')
	      throw new Error('Not supported');

	    Rand.prototype._rand = function _rand(n) {
	      return crypto.randomBytes(n);
	    };
	  } catch (e) {
	  }
	}
	return brorand.exports;
}

var mr;
var hasRequiredMr;

function requireMr () {
	if (hasRequiredMr) return mr;
	hasRequiredMr = 1;
	var bn = requireBn$6();
	var brorand = requireBrorand();

	function MillerRabin(rand) {
	  this.rand = rand || new brorand.Rand();
	}
	mr = MillerRabin;

	MillerRabin.create = function create(rand) {
	  return new MillerRabin(rand);
	};

	MillerRabin.prototype._randbelow = function _randbelow(n) {
	  var len = n.bitLength();
	  var min_bytes = Math.ceil(len / 8);

	  // Generage random bytes until a number less than n is found.
	  // This ensures that 0..n-1 have an equal probability of being selected.
	  do
	    var a = new bn(this.rand.generate(min_bytes));
	  while (a.cmp(n) >= 0);

	  return a;
	};

	MillerRabin.prototype._randrange = function _randrange(start, stop) {
	  // Generate a random number greater than or equal to start and less than stop.
	  var size = stop.sub(start);
	  return start.add(this._randbelow(size));
	};

	MillerRabin.prototype.test = function test(n, k, cb) {
	  var len = n.bitLength();
	  var red = bn.mont(n);
	  var rone = new bn(1).toRed(red);

	  if (!k)
	    k = Math.max(1, (len / 48) | 0);

	  // Find d and s, (n - 1) = (2 ^ s) * d;
	  var n1 = n.subn(1);
	  for (var s = 0; !n1.testn(s); s++) {}
	  var d = n.shrn(s);

	  var rn1 = n1.toRed(red);

	  var prime = true;
	  for (; k > 0; k--) {
	    var a = this._randrange(new bn(2), n1);
	    if (cb)
	      cb(a);

	    var x = a.toRed(red).redPow(d);
	    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
	      continue;

	    for (var i = 1; i < s; i++) {
	      x = x.redSqr();

	      if (x.cmp(rone) === 0)
	        return false;
	      if (x.cmp(rn1) === 0)
	        break;
	    }

	    if (i === s)
	      return false;
	  }

	  return prime;
	};

	MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
	  var len = n.bitLength();
	  var red = bn.mont(n);
	  var rone = new bn(1).toRed(red);

	  if (!k)
	    k = Math.max(1, (len / 48) | 0);

	  // Find d and s, (n - 1) = (2 ^ s) * d;
	  var n1 = n.subn(1);
	  for (var s = 0; !n1.testn(s); s++) {}
	  var d = n.shrn(s);

	  var rn1 = n1.toRed(red);

	  for (; k > 0; k--) {
	    var a = this._randrange(new bn(2), n1);

	    var g = n.gcd(a);
	    if (g.cmpn(1) !== 0)
	      return g;

	    var x = a.toRed(red).redPow(d);
	    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
	      continue;

	    for (var i = 1; i < s; i++) {
	      x = x.redSqr();

	      if (x.cmp(rone) === 0)
	        return x.fromRed().subn(1).gcd(n);
	      if (x.cmp(rn1) === 0)
	        break;
	    }

	    if (i === s) {
	      x = x.redSqr();
	      return x.fromRed().subn(1).gcd(n);
	    }
	  }

	  return false;
	};
	return mr;
}

var generatePrime;
var hasRequiredGeneratePrime;

function requireGeneratePrime () {
	if (hasRequiredGeneratePrime) return generatePrime;
	hasRequiredGeneratePrime = 1;
	var randomBytes = requireBrowser$a();
	generatePrime = findPrime;
	findPrime.simpleSieve = simpleSieve;
	findPrime.fermatTest = fermatTest;
	var BN = requireBn$7();
	var TWENTYFOUR = new BN(24);
	var MillerRabin = requireMr();
	var millerRabin = new MillerRabin();
	var ONE = new BN(1);
	var TWO = new BN(2);
	var FIVE = new BN(5);
	new BN(16);
	new BN(8);
	var TEN = new BN(10);
	var THREE = new BN(3);
	new BN(7);
	var ELEVEN = new BN(11);
	var FOUR = new BN(4);
	new BN(12);
	var primes = null;

	function _getPrimes() {
	  if (primes !== null)
	    return primes;

	  var limit = 0x100000;
	  var res = [];
	  res[0] = 2;
	  for (var i = 1, k = 3; k < limit; k += 2) {
	    var sqrt = Math.ceil(Math.sqrt(k));
	    for (var j = 0; j < i && res[j] <= sqrt; j++)
	      if (k % res[j] === 0)
	        break;

	    if (i !== j && res[j] <= sqrt)
	      continue;

	    res[i++] = k;
	  }
	  primes = res;
	  return res;
	}

	function simpleSieve(p) {
	  var primes = _getPrimes();

	  for (var i = 0; i < primes.length; i++)
	    if (p.modn(primes[i]) === 0) {
	      if (p.cmpn(primes[i]) === 0) {
	        return true;
	      } else {
	        return false;
	      }
	    }

	  return true;
	}

	function fermatTest(p) {
	  var red = BN.mont(p);
	  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
	}

	function findPrime(bits, gen) {
	  if (bits < 16) {
	    // this is what openssl does
	    if (gen === 2 || gen === 5) {
	      return new BN([0x8c, 0x7b]);
	    } else {
	      return new BN([0x8c, 0x27]);
	    }
	  }
	  gen = new BN(gen);

	  var num, n2;

	  while (true) {
	    num = new BN(randomBytes(Math.ceil(bits / 8)));
	    while (num.bitLength() > bits) {
	      num.ishrn(1);
	    }
	    if (num.isEven()) {
	      num.iadd(ONE);
	    }
	    if (!num.testn(1)) {
	      num.iadd(TWO);
	    }
	    if (!gen.cmp(TWO)) {
	      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
	        num.iadd(FOUR);
	      }
	    } else if (!gen.cmp(FIVE)) {
	      while (num.mod(TEN).cmp(THREE)) {
	        num.iadd(FOUR);
	      }
	    }
	    n2 = num.shrn(1);
	    if (simpleSieve(n2) && simpleSieve(num) &&
	      fermatTest(n2) && fermatTest(num) &&
	      millerRabin.test(n2) && millerRabin.test(num)) {
	      return num;
	    }
	  }

	}
	return generatePrime;
}

const modp1 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"};
const modp2 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"};
const modp5 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"};
const modp14 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"};
const modp15 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"};
const modp16 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"};
const modp17 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"};
const modp18 = {"gen":"02","prime":"ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"};
const require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18,
};

var dh;
var hasRequiredDh;

function requireDh () {
	if (hasRequiredDh) return dh;
	hasRequiredDh = 1;
	var BN = requireBn$7();
	var MillerRabin = requireMr();
	var millerRabin = new MillerRabin();
	var TWENTYFOUR = new BN(24);
	var ELEVEN = new BN(11);
	var TEN = new BN(10);
	var THREE = new BN(3);
	var SEVEN = new BN(7);
	var primes = requireGeneratePrime();
	var randomBytes = requireBrowser$a();
	dh = DH;

	function setPublicKey(pub, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer$1.isBuffer(pub)) {
	    pub = new Buffer$1(pub, enc);
	  }
	  this._pub = new BN(pub);
	  return this;
	}

	function setPrivateKey(priv, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer$1.isBuffer(priv)) {
	    priv = new Buffer$1(priv, enc);
	  }
	  this._priv = new BN(priv);
	  return this;
	}

	var primeCache = {};
	function checkPrime(prime, generator) {
	  var gen = generator.toString('hex');
	  var hex = [gen, prime.toString(16)].join('_');
	  if (hex in primeCache) {
	    return primeCache[hex];
	  }
	  var error = 0;

	  if (prime.isEven() ||
	    !primes.simpleSieve ||
	    !primes.fermatTest(prime) ||
	    !millerRabin.test(prime)) {
	    //not a prime so +1
	    error += 1;

	    if (gen === '02' || gen === '05') {
	      // we'd be able to check the generator
	      // it would fail so +8
	      error += 8;
	    } else {
	      //we wouldn't be able to test the generator
	      // so +4
	      error += 4;
	    }
	    primeCache[hex] = error;
	    return error;
	  }
	  if (!millerRabin.test(prime.shrn(1))) {
	    //not a safe prime
	    error += 2;
	  }
	  var rem;
	  switch (gen) {
	    case '02':
	      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
	        // unsuidable generator
	        error += 8;
	      }
	      break;
	    case '05':
	      rem = prime.mod(TEN);
	      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
	        // prime mod 10 needs to equal 3 or 7
	        error += 8;
	      }
	      break;
	    default:
	      error += 4;
	  }
	  primeCache[hex] = error;
	  return error;
	}

	function DH(prime, generator, malleable) {
	  this.setGenerator(generator);
	  this.__prime = new BN(prime);
	  this._prime = BN.mont(this.__prime);
	  this._primeLen = prime.length;
	  this._pub = undefined;
	  this._priv = undefined;
	  this._primeCode = undefined;
	  if (malleable) {
	    this.setPublicKey = setPublicKey;
	    this.setPrivateKey = setPrivateKey;
	  } else {
	    this._primeCode = 8;
	  }
	}
	Object.defineProperty(DH.prototype, 'verifyError', {
	  enumerable: true,
	  get: function () {
	    if (typeof this._primeCode !== 'number') {
	      this._primeCode = checkPrime(this.__prime, this.__gen);
	    }
	    return this._primeCode;
	  }
	});
	DH.prototype.generateKeys = function () {
	  if (!this._priv) {
	    this._priv = new BN(randomBytes(this._primeLen));
	  }
	  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
	  return this.getPublicKey();
	};

	DH.prototype.computeSecret = function (other) {
	  other = new BN(other);
	  other = other.toRed(this._prime);
	  var secret = other.redPow(this._priv).fromRed();
	  var out = new Buffer$1(secret.toArray());
	  var prime = this.getPrime();
	  if (out.length < prime.length) {
	    var front = new Buffer$1(prime.length - out.length);
	    front.fill(0);
	    out = Buffer$1.concat([front, out]);
	  }
	  return out;
	};

	DH.prototype.getPublicKey = function getPublicKey(enc) {
	  return formatReturnValue(this._pub, enc);
	};

	DH.prototype.getPrivateKey = function getPrivateKey(enc) {
	  return formatReturnValue(this._priv, enc);
	};

	DH.prototype.getPrime = function (enc) {
	  return formatReturnValue(this.__prime, enc);
	};

	DH.prototype.getGenerator = function (enc) {
	  return formatReturnValue(this._gen, enc);
	};

	DH.prototype.setGenerator = function (gen, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer$1.isBuffer(gen)) {
	    gen = new Buffer$1(gen, enc);
	  }
	  this.__gen = gen;
	  this._gen = new BN(gen);
	  return this;
	};

	function formatReturnValue(bn, enc) {
	  var buf = new Buffer$1(bn.toArray());
	  if (!enc) {
	    return buf;
	  } else {
	    return buf.toString(enc);
	  }
	}
	return dh;
}

var hasRequiredBrowser$4;

function requireBrowser$4 () {
	if (hasRequiredBrowser$4) return browser$4;
	hasRequiredBrowser$4 = 1;
	var generatePrime = requireGeneratePrime();
	var primes = require$$1$1;

	var DH = requireDh();

	function getDiffieHellman (mod) {
	  var prime = new Buffer$1(primes[mod].prime, 'hex');
	  var gen = new Buffer$1(primes[mod].gen, 'hex');

	  return new DH(prime, gen)
	}

	var ENCODINGS = {
	  'binary': true, 'hex': true, 'base64': true
	};

	function createDiffieHellman (prime, enc, generator, genc) {
	  if (Buffer$1.isBuffer(enc) || ENCODINGS[enc] === undefined) {
	    return createDiffieHellman(prime, 'binary', enc, generator)
	  }

	  enc = enc || 'binary';
	  genc = genc || 'binary';
	  generator = generator || new Buffer$1([2]);

	  if (!Buffer$1.isBuffer(generator)) {
	    generator = new Buffer$1(generator, genc);
	  }

	  if (typeof prime === 'number') {
	    return new DH(generatePrime(prime, generator), generator, true)
	  }

	  if (!Buffer$1.isBuffer(prime)) {
	    prime = new Buffer$1(prime, enc);
	  }

	  return new DH(prime, generator, true)
	}

	browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = getDiffieHellman;
	browser$4.createDiffieHellman = browser$4.DiffieHellman = createDiffieHellman;
	return browser$4;
}

var readableBrowser = {exports: {}};

var processNextickArgs = {exports: {}};

var hasRequiredProcessNextickArgs;

function requireProcessNextickArgs () {
	if (hasRequiredProcessNextickArgs) return processNextickArgs.exports;
	hasRequiredProcessNextickArgs = 1;

	if (typeof process$1 === 'undefined' ||
	    !process$1.version ||
	    process$1.version.indexOf('v0.') === 0 ||
	    process$1.version.indexOf('v1.') === 0 && process$1.version.indexOf('v1.8.') !== 0) {
	  processNextickArgs.exports = { nextTick: nextTick };
	} else {
	  processNextickArgs.exports = process$1;
	}

	function nextTick(fn, arg1, arg2, arg3) {
	  if (typeof fn !== 'function') {
	    throw new TypeError('"callback" argument must be a function');
	  }
	  var len = arguments.length;
	  var args, i;
	  switch (len) {
	  case 0:
	  case 1:
	    return process$1.nextTick(fn);
	  case 2:
	    return process$1.nextTick(function afterTickOne() {
	      fn.call(null, arg1);
	    });
	  case 3:
	    return process$1.nextTick(function afterTickTwo() {
	      fn.call(null, arg1, arg2);
	    });
	  case 4:
	    return process$1.nextTick(function afterTickThree() {
	      fn.call(null, arg1, arg2, arg3);
	    });
	  default:
	    args = new Array(len - 1);
	    i = 0;
	    while (i < args.length) {
	      args[i++] = arguments[i];
	    }
	    return process$1.nextTick(function afterTick() {
	      fn.apply(null, args);
	    });
	  }
	}
	return processNextickArgs.exports;
}

var isarray;
var hasRequiredIsarray;

function requireIsarray () {
	if (hasRequiredIsarray) return isarray;
	hasRequiredIsarray = 1;
	var toString = {}.toString;

	isarray = Array.isArray || function (arr) {
	  return toString.call(arr) == '[object Array]';
	};
	return isarray;
}

var streamBrowser;
var hasRequiredStreamBrowser;

function requireStreamBrowser () {
	if (hasRequiredStreamBrowser) return streamBrowser;
	hasRequiredStreamBrowser = 1;
	streamBrowser = requireEvents().EventEmitter;
	return streamBrowser;
}

var safeBuffer$1 = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var hasRequiredSafeBuffer$1;

function requireSafeBuffer$1 () {
	if (hasRequiredSafeBuffer$1) return safeBuffer$1.exports;
	hasRequiredSafeBuffer$1 = 1;
	(function (module, exports) {
		var buffer = requireDist();
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer$1, safeBuffer$1.exports));
	return safeBuffer$1.exports;
}

var BufferList = {exports: {}};

var hasRequiredBufferList;

function requireBufferList () {
	if (hasRequiredBufferList) return BufferList.exports;
	hasRequiredBufferList = 1;
	(function (module) {

		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

		var Buffer = requireSafeBuffer$1().Buffer;
		var util = requireUtil$2();

		function copyBuffer(src, target, offset) {
		  src.copy(target, offset);
		}

		module.exports = function () {
		  function BufferList() {
		    _classCallCheck(this, BufferList);

		    this.head = null;
		    this.tail = null;
		    this.length = 0;
		  }

		  BufferList.prototype.push = function push(v) {
		    var entry = { data: v, next: null };
		    if (this.length > 0) this.tail.next = entry;else this.head = entry;
		    this.tail = entry;
		    ++this.length;
		  };

		  BufferList.prototype.unshift = function unshift(v) {
		    var entry = { data: v, next: this.head };
		    if (this.length === 0) this.tail = entry;
		    this.head = entry;
		    ++this.length;
		  };

		  BufferList.prototype.shift = function shift() {
		    if (this.length === 0) return;
		    var ret = this.head.data;
		    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
		    --this.length;
		    return ret;
		  };

		  BufferList.prototype.clear = function clear() {
		    this.head = this.tail = null;
		    this.length = 0;
		  };

		  BufferList.prototype.join = function join(s) {
		    if (this.length === 0) return '';
		    var p = this.head;
		    var ret = '' + p.data;
		    while (p = p.next) {
		      ret += s + p.data;
		    }return ret;
		  };

		  BufferList.prototype.concat = function concat(n) {
		    if (this.length === 0) return Buffer.alloc(0);
		    var ret = Buffer.allocUnsafe(n >>> 0);
		    var p = this.head;
		    var i = 0;
		    while (p) {
		      copyBuffer(p.data, ret, i);
		      i += p.data.length;
		      p = p.next;
		    }
		    return ret;
		  };

		  return BufferList;
		}();

		if (util && util.inspect && util.inspect.custom) {
		  module.exports.prototype[util.inspect.custom] = function () {
		    var obj = util.inspect({ length: this.length });
		    return this.constructor.name + ' ' + obj;
		  };
		} 
	} (BufferList));
	return BufferList.exports;
}

var destroy_1;
var hasRequiredDestroy;

function requireDestroy () {
	if (hasRequiredDestroy) return destroy_1;
	hasRequiredDestroy = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
	  var _this = this;

	  var readableDestroyed = this._readableState && this._readableState.destroyed;
	  var writableDestroyed = this._writableState && this._writableState.destroyed;

	  if (readableDestroyed || writableDestroyed) {
	    if (cb) {
	      cb(err);
	    } else if (err) {
	      if (!this._writableState) {
	        pna.nextTick(emitErrorNT, this, err);
	      } else if (!this._writableState.errorEmitted) {
	        this._writableState.errorEmitted = true;
	        pna.nextTick(emitErrorNT, this, err);
	      }
	    }

	    return this;
	  }

	  // we set destroyed to true before firing error callbacks in order
	  // to make it re-entrance safe in case destroy() is called within callbacks

	  if (this._readableState) {
	    this._readableState.destroyed = true;
	  }

	  // if this is a duplex stream mark the writable part as destroyed as well
	  if (this._writableState) {
	    this._writableState.destroyed = true;
	  }

	  this._destroy(err || null, function (err) {
	    if (!cb && err) {
	      if (!_this._writableState) {
	        pna.nextTick(emitErrorNT, _this, err);
	      } else if (!_this._writableState.errorEmitted) {
	        _this._writableState.errorEmitted = true;
	        pna.nextTick(emitErrorNT, _this, err);
	      }
	    } else if (cb) {
	      cb(err);
	    }
	  });

	  return this;
	}

	function undestroy() {
	  if (this._readableState) {
	    this._readableState.destroyed = false;
	    this._readableState.reading = false;
	    this._readableState.ended = false;
	    this._readableState.endEmitted = false;
	  }

	  if (this._writableState) {
	    this._writableState.destroyed = false;
	    this._writableState.ended = false;
	    this._writableState.ending = false;
	    this._writableState.finalCalled = false;
	    this._writableState.prefinished = false;
	    this._writableState.finished = false;
	    this._writableState.errorEmitted = false;
	  }
	}

	function emitErrorNT(self, err) {
	  self.emit('error', err);
	}

	destroy_1 = {
	  destroy: destroy,
	  undestroy: undestroy
	};
	return destroy_1;
}

var _stream_writable;
var hasRequired_stream_writable;

function require_stream_writable () {
	if (hasRequired_stream_writable) return _stream_writable;
	hasRequired_stream_writable = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	_stream_writable = Writable;

	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
	  var _this = this;

	  this.next = null;
	  this.entry = null;
	  this.finish = function () {
	    onCorkedFinish(_this, state);
	  };
	}
	/* </replacement> */

	/*<replacement>*/
	var asyncWrite = !process$1.browser && ['v0.10', 'v0.9.'].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
	/*</replacement>*/

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Writable.WritableState = WritableState;

	/*<replacement>*/
	var util = Object.create(requireUtil$1());
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	/*<replacement>*/
	var internalUtil = {
	  deprecate: requireBrowser$c()
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStreamBrowser();
	/*</replacement>*/

	/*<replacement>*/

	var Buffer = requireSafeBuffer$1().Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*</replacement>*/

	var destroyImpl = requireDestroy();

	util.inherits(Writable, Stream);

	function nop() {}

	function WritableState(options, stream) {
	  Duplex = Duplex || require_stream_duplex();

	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  var isDuplex = stream instanceof Duplex;

	  // object stream flag to indicate whether or not this stream
	  // contains buffers or objects.
	  this.objectMode = !!options.objectMode;

	  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

	  // the point at which write() starts returning false
	  // Note: 0 is a valid value, means that we always return false if
	  // the entire buffer is not flushed immediately on write()
	  var hwm = options.highWaterMark;
	  var writableHwm = options.writableHighWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

	  // cast to ints.
	  this.highWaterMark = Math.floor(this.highWaterMark);

	  // if _final has been called
	  this.finalCalled = false;

	  // drain event flag.
	  this.needDrain = false;
	  // at the start of calling end()
	  this.ending = false;
	  // when end() has been called, and returned
	  this.ended = false;
	  // when 'finish' is emitted
	  this.finished = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // should we decode strings into buffers before passing to _write?
	  // this is here so that some node-core streams can optimize string
	  // handling at a lower level.
	  var noDecode = options.decodeStrings === false;
	  this.decodeStrings = !noDecode;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // not an actual buffer we keep track of, but a measurement
	  // of how much we're waiting to get pushed to some underlying
	  // socket or file.
	  this.length = 0;

	  // a flag to see when we're in the middle of a write.
	  this.writing = false;

	  // when true all writes will be buffered until .uncork() call
	  this.corked = 0;

	  // a flag to be able to tell if the onwrite cb is called immediately,
	  // or on a later tick.  We set this to true at first, because any
	  // actions that shouldn't happen until "later" should generally also
	  // not happen before the first write call.
	  this.sync = true;

	  // a flag to know if we're processing previously buffered items, which
	  // may call the _write() callback in the same tick, so that we don't
	  // end up in an overlapped onwrite situation.
	  this.bufferProcessing = false;

	  // the callback that's passed to _write(chunk,cb)
	  this.onwrite = function (er) {
	    onwrite(stream, er);
	  };

	  // the callback that the user supplies to write(chunk,encoding,cb)
	  this.writecb = null;

	  // the amount that is being written when _write is called.
	  this.writelen = 0;

	  this.bufferedRequest = null;
	  this.lastBufferedRequest = null;

	  // number of pending user-supplied write callbacks
	  // this must be 0 before 'finish' can be emitted
	  this.pendingcb = 0;

	  // emit prefinish if the only thing we're waiting for is _write cbs
	  // This is relevant for synchronous Transform streams
	  this.prefinished = false;

	  // True if the error was already emitted and should not be thrown again
	  this.errorEmitted = false;

	  // count buffered requests
	  this.bufferedRequestCount = 0;

	  // allocate the first CorkedRequest, there is always
	  // one allocated and free to use, and we maintain at most two
	  this.corkedRequestsFree = new CorkedRequest(this);
	}

	WritableState.prototype.getBuffer = function getBuffer() {
	  var current = this.bufferedRequest;
	  var out = [];
	  while (current) {
	    out.push(current);
	    current = current.next;
	  }
	  return out;
	};

	(function () {
	  try {
	    Object.defineProperty(WritableState.prototype, 'buffer', {
	      get: internalUtil.deprecate(function () {
	        return this.getBuffer();
	      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
	    });
	  } catch (_) {}
	})();

	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
	  realHasInstance = Function.prototype[Symbol.hasInstance];
	  Object.defineProperty(Writable, Symbol.hasInstance, {
	    value: function (object) {
	      if (realHasInstance.call(this, object)) return true;
	      if (this !== Writable) return false;

	      return object && object._writableState instanceof WritableState;
	    }
	  });
	} else {
	  realHasInstance = function (object) {
	    return object instanceof this;
	  };
	}

	function Writable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  // Writable ctor is applied to Duplexes, too.
	  // `realHasInstance` is necessary because using plain `instanceof`
	  // would return false, as no `_writableState` property is attached.

	  // Trying to use the custom `instanceof` for Writable here will also break the
	  // Node.js LazyTransform implementation, which has a non-trivial getter for
	  // `_writableState` that would lead to infinite recursion.
	  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
	    return new Writable(options);
	  }

	  this._writableState = new WritableState(options, this);

	  // legacy.
	  this.writable = true;

	  if (options) {
	    if (typeof options.write === 'function') this._write = options.write;

	    if (typeof options.writev === 'function') this._writev = options.writev;

	    if (typeof options.destroy === 'function') this._destroy = options.destroy;

	    if (typeof options.final === 'function') this._final = options.final;
	  }

	  Stream.call(this);
	}

	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
	  this.emit('error', new Error('Cannot pipe, not readable'));
	};

	function writeAfterEnd(stream, cb) {
	  var er = new Error('write after end');
	  // TODO: defer error events consistently everywhere, not just the cb
	  stream.emit('error', er);
	  pna.nextTick(cb, er);
	}

	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
	  var valid = true;
	  var er = false;

	  if (chunk === null) {
	    er = new TypeError('May not write null values to stream');
	  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  if (er) {
	    stream.emit('error', er);
	    pna.nextTick(cb, er);
	    valid = false;
	  }
	  return valid;
	}

	Writable.prototype.write = function (chunk, encoding, cb) {
	  var state = this._writableState;
	  var ret = false;
	  var isBuf = !state.objectMode && _isUint8Array(chunk);

	  if (isBuf && !Buffer.isBuffer(chunk)) {
	    chunk = _uint8ArrayToBuffer(chunk);
	  }

	  if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

	  if (typeof cb !== 'function') cb = nop;

	  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
	    state.pendingcb++;
	    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
	  }

	  return ret;
	};

	Writable.prototype.cork = function () {
	  var state = this._writableState;

	  state.corked++;
	};

	Writable.prototype.uncork = function () {
	  var state = this._writableState;

	  if (state.corked) {
	    state.corked--;

	    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
	  }
	};

	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
	  // node::ParseEncoding() requires lower case.
	  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
	  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
	  this._writableState.defaultEncoding = encoding;
	  return this;
	};

	function decodeChunk(state, chunk, encoding) {
	  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
	    chunk = Buffer.from(chunk, encoding);
	  }
	  return chunk;
	}

	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._writableState.highWaterMark;
	  }
	});

	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
	  if (!isBuf) {
	    var newChunk = decodeChunk(state, chunk, encoding);
	    if (chunk !== newChunk) {
	      isBuf = true;
	      encoding = 'buffer';
	      chunk = newChunk;
	    }
	  }
	  var len = state.objectMode ? 1 : chunk.length;

	  state.length += len;

	  var ret = state.length < state.highWaterMark;
	  // we must ensure that previous needDrain will not be reset to false.
	  if (!ret) state.needDrain = true;

	  if (state.writing || state.corked) {
	    var last = state.lastBufferedRequest;
	    state.lastBufferedRequest = {
	      chunk: chunk,
	      encoding: encoding,
	      isBuf: isBuf,
	      callback: cb,
	      next: null
	    };
	    if (last) {
	      last.next = state.lastBufferedRequest;
	    } else {
	      state.bufferedRequest = state.lastBufferedRequest;
	    }
	    state.bufferedRequestCount += 1;
	  } else {
	    doWrite(stream, state, false, len, chunk, encoding, cb);
	  }

	  return ret;
	}

	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
	  state.writelen = len;
	  state.writecb = cb;
	  state.writing = true;
	  state.sync = true;
	  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
	  state.sync = false;
	}

	function onwriteError(stream, state, sync, er, cb) {
	  --state.pendingcb;

	  if (sync) {
	    // defer the callback if we are being called synchronously
	    // to avoid piling up things on the stack
	    pna.nextTick(cb, er);
	    // this can emit finish, and it will always happen
	    // after error
	    pna.nextTick(finishMaybe, stream, state);
	    stream._writableState.errorEmitted = true;
	    stream.emit('error', er);
	  } else {
	    // the caller expect this to happen before if
	    // it is async
	    cb(er);
	    stream._writableState.errorEmitted = true;
	    stream.emit('error', er);
	    // this can emit finish, but finish must
	    // always follow error
	    finishMaybe(stream, state);
	  }
	}

	function onwriteStateUpdate(state) {
	  state.writing = false;
	  state.writecb = null;
	  state.length -= state.writelen;
	  state.writelen = 0;
	}

	function onwrite(stream, er) {
	  var state = stream._writableState;
	  var sync = state.sync;
	  var cb = state.writecb;

	  onwriteStateUpdate(state);

	  if (er) onwriteError(stream, state, sync, er, cb);else {
	    // Check if we're actually ready to finish, but don't emit yet
	    var finished = needFinish(state);

	    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
	      clearBuffer(stream, state);
	    }

	    if (sync) {
	      /*<replacement>*/
	      asyncWrite(afterWrite, stream, state, finished, cb);
	      /*</replacement>*/
	    } else {
	      afterWrite(stream, state, finished, cb);
	    }
	  }
	}

	function afterWrite(stream, state, finished, cb) {
	  if (!finished) onwriteDrain(stream, state);
	  state.pendingcb--;
	  cb();
	  finishMaybe(stream, state);
	}

	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
	  if (state.length === 0 && state.needDrain) {
	    state.needDrain = false;
	    stream.emit('drain');
	  }
	}

	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
	  state.bufferProcessing = true;
	  var entry = state.bufferedRequest;

	  if (stream._writev && entry && entry.next) {
	    // Fast case, write everything using _writev()
	    var l = state.bufferedRequestCount;
	    var buffer = new Array(l);
	    var holder = state.corkedRequestsFree;
	    holder.entry = entry;

	    var count = 0;
	    var allBuffers = true;
	    while (entry) {
	      buffer[count] = entry;
	      if (!entry.isBuf) allBuffers = false;
	      entry = entry.next;
	      count += 1;
	    }
	    buffer.allBuffers = allBuffers;

	    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

	    // doWrite is almost always async, defer these to save a bit of time
	    // as the hot path ends with doWrite
	    state.pendingcb++;
	    state.lastBufferedRequest = null;
	    if (holder.next) {
	      state.corkedRequestsFree = holder.next;
	      holder.next = null;
	    } else {
	      state.corkedRequestsFree = new CorkedRequest(state);
	    }
	    state.bufferedRequestCount = 0;
	  } else {
	    // Slow case, write chunks one-by-one
	    while (entry) {
	      var chunk = entry.chunk;
	      var encoding = entry.encoding;
	      var cb = entry.callback;
	      var len = state.objectMode ? 1 : chunk.length;

	      doWrite(stream, state, false, len, chunk, encoding, cb);
	      entry = entry.next;
	      state.bufferedRequestCount--;
	      // if we didn't call the onwrite immediately, then
	      // it means that we need to wait until it does.
	      // also, that means that the chunk and cb are currently
	      // being processed, so move the buffer counter past them.
	      if (state.writing) {
	        break;
	      }
	    }

	    if (entry === null) state.lastBufferedRequest = null;
	  }

	  state.bufferedRequest = entry;
	  state.bufferProcessing = false;
	}

	Writable.prototype._write = function (chunk, encoding, cb) {
	  cb(new Error('_write() is not implemented'));
	};

	Writable.prototype._writev = null;

	Writable.prototype.end = function (chunk, encoding, cb) {
	  var state = this._writableState;

	  if (typeof chunk === 'function') {
	    cb = chunk;
	    chunk = null;
	    encoding = null;
	  } else if (typeof encoding === 'function') {
	    cb = encoding;
	    encoding = null;
	  }

	  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

	  // .end() fully uncorks
	  if (state.corked) {
	    state.corked = 1;
	    this.uncork();
	  }

	  // ignore unnecessary end() calls.
	  if (!state.ending) endWritable(this, state, cb);
	};

	function needFinish(state) {
	  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
	  stream._final(function (err) {
	    state.pendingcb--;
	    if (err) {
	      stream.emit('error', err);
	    }
	    state.prefinished = true;
	    stream.emit('prefinish');
	    finishMaybe(stream, state);
	  });
	}
	function prefinish(stream, state) {
	  if (!state.prefinished && !state.finalCalled) {
	    if (typeof stream._final === 'function') {
	      state.pendingcb++;
	      state.finalCalled = true;
	      pna.nextTick(callFinal, stream, state);
	    } else {
	      state.prefinished = true;
	      stream.emit('prefinish');
	    }
	  }
	}

	function finishMaybe(stream, state) {
	  var need = needFinish(state);
	  if (need) {
	    prefinish(stream, state);
	    if (state.pendingcb === 0) {
	      state.finished = true;
	      stream.emit('finish');
	    }
	  }
	  return need;
	}

	function endWritable(stream, state, cb) {
	  state.ending = true;
	  finishMaybe(stream, state);
	  if (cb) {
	    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
	  }
	  state.ended = true;
	  stream.writable = false;
	}

	function onCorkedFinish(corkReq, state, err) {
	  var entry = corkReq.entry;
	  corkReq.entry = null;
	  while (entry) {
	    var cb = entry.callback;
	    state.pendingcb--;
	    cb(err);
	    entry = entry.next;
	  }

	  // reuse the free corkReq.
	  state.corkedRequestsFree.next = corkReq;
	}

	Object.defineProperty(Writable.prototype, 'destroyed', {
	  get: function () {
	    if (this._writableState === undefined) {
	      return false;
	    }
	    return this._writableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._writableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._writableState.destroyed = value;
	  }
	});

	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
	  this.end();
	  cb(err);
	};
	return _stream_writable;
}

var _stream_duplex;
var hasRequired_stream_duplex;

function require_stream_duplex () {
	if (hasRequired_stream_duplex) return _stream_duplex;
	hasRequired_stream_duplex = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	};
	/*</replacement>*/

	_stream_duplex = Duplex;

	/*<replacement>*/
	var util = Object.create(requireUtil$1());
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	var Readable = require_stream_readable();
	var Writable = require_stream_writable();

	util.inherits(Duplex, Readable);

	{
	  // avoid scope creep, the keys array can then be collected
	  var keys = objectKeys(Writable.prototype);
	  for (var v = 0; v < keys.length; v++) {
	    var method = keys[v];
	    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
	  }
	}

	function Duplex(options) {
	  if (!(this instanceof Duplex)) return new Duplex(options);

	  Readable.call(this, options);
	  Writable.call(this, options);

	  if (options && options.readable === false) this.readable = false;

	  if (options && options.writable === false) this.writable = false;

	  this.allowHalfOpen = true;
	  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

	  this.once('end', onend);
	}

	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._writableState.highWaterMark;
	  }
	});

	// the no-half-open enforcer
	function onend() {
	  // if we allow half-open state, or if the writable side ended,
	  // then we're ok.
	  if (this.allowHalfOpen || this._writableState.ended) return;

	  // no more data can be written.
	  // But allow more writes to happen in this tick.
	  pna.nextTick(onEndNT, this);
	}

	function onEndNT(self) {
	  self.end();
	}

	Object.defineProperty(Duplex.prototype, 'destroyed', {
	  get: function () {
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed && this._writableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (this._readableState === undefined || this._writableState === undefined) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	    this._writableState.destroyed = value;
	  }
	});

	Duplex.prototype._destroy = function (err, cb) {
	  this.push(null);
	  this.end();

	  pna.nextTick(cb, err);
	};
	return _stream_duplex;
}

var string_decoder = {};

var safeBuffer = {exports: {}};

/* eslint-disable node/no-deprecated-api */

var hasRequiredSafeBuffer;

function requireSafeBuffer () {
	if (hasRequiredSafeBuffer) return safeBuffer.exports;
	hasRequiredSafeBuffer = 1;
	(function (module, exports) {
		var buffer = requireDist();
		var Buffer = buffer.Buffer;

		// alternative to using Object.keys for old browsers
		function copyProps (src, dst) {
		  for (var key in src) {
		    dst[key] = src[key];
		  }
		}
		if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		  module.exports = buffer;
		} else {
		  // Copy properties from require('buffer')
		  copyProps(buffer, exports);
		  exports.Buffer = SafeBuffer;
		}

		function SafeBuffer (arg, encodingOrOffset, length) {
		  return Buffer(arg, encodingOrOffset, length)
		}

		// Copy static methods from Buffer
		copyProps(Buffer, SafeBuffer);

		SafeBuffer.from = function (arg, encodingOrOffset, length) {
		  if (typeof arg === 'number') {
		    throw new TypeError('Argument must not be a number')
		  }
		  return Buffer(arg, encodingOrOffset, length)
		};

		SafeBuffer.alloc = function (size, fill, encoding) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  var buf = Buffer(size);
		  if (fill !== undefined) {
		    if (typeof encoding === 'string') {
		      buf.fill(fill, encoding);
		    } else {
		      buf.fill(fill);
		    }
		  } else {
		    buf.fill(0);
		  }
		  return buf
		};

		SafeBuffer.allocUnsafe = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return Buffer(size)
		};

		SafeBuffer.allocUnsafeSlow = function (size) {
		  if (typeof size !== 'number') {
		    throw new TypeError('Argument must be a number')
		  }
		  return buffer.SlowBuffer(size)
		}; 
	} (safeBuffer, safeBuffer.exports));
	return safeBuffer.exports;
}

var hasRequiredString_decoder;

function requireString_decoder () {
	if (hasRequiredString_decoder) return string_decoder;
	hasRequiredString_decoder = 1;

	/*<replacement>*/

	var Buffer = requireSafeBuffer().Buffer;
	/*</replacement>*/

	var isEncoding = Buffer.isEncoding || function (encoding) {
	  encoding = '' + encoding;
	  switch (encoding && encoding.toLowerCase()) {
	    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
	      return true;
	    default:
	      return false;
	  }
	};

	function _normalizeEncoding(enc) {
	  if (!enc) return 'utf8';
	  var retried;
	  while (true) {
	    switch (enc) {
	      case 'utf8':
	      case 'utf-8':
	        return 'utf8';
	      case 'ucs2':
	      case 'ucs-2':
	      case 'utf16le':
	      case 'utf-16le':
	        return 'utf16le';
	      case 'latin1':
	      case 'binary':
	        return 'latin1';
	      case 'base64':
	      case 'ascii':
	      case 'hex':
	        return enc;
	      default:
	        if (retried) return; // undefined
	        enc = ('' + enc).toLowerCase();
	        retried = true;
	    }
	  }
	}
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
	  var nenc = _normalizeEncoding(enc);
	  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
	  return nenc || enc;
	}

	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	string_decoder.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
	  this.encoding = normalizeEncoding(encoding);
	  var nb;
	  switch (this.encoding) {
	    case 'utf16le':
	      this.text = utf16Text;
	      this.end = utf16End;
	      nb = 4;
	      break;
	    case 'utf8':
	      this.fillLast = utf8FillLast;
	      nb = 4;
	      break;
	    case 'base64':
	      this.text = base64Text;
	      this.end = base64End;
	      nb = 3;
	      break;
	    default:
	      this.write = simpleWrite;
	      this.end = simpleEnd;
	      return;
	  }
	  this.lastNeed = 0;
	  this.lastTotal = 0;
	  this.lastChar = Buffer.allocUnsafe(nb);
	}

	StringDecoder.prototype.write = function (buf) {
	  if (buf.length === 0) return '';
	  var r;
	  var i;
	  if (this.lastNeed) {
	    r = this.fillLast(buf);
	    if (r === undefined) return '';
	    i = this.lastNeed;
	    this.lastNeed = 0;
	  } else {
	    i = 0;
	  }
	  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
	  return r || '';
	};

	StringDecoder.prototype.end = utf8End;

	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;

	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
	  this.lastNeed -= buf.length;
	};

	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
	  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
	  return byte >> 6 === 0x02 ? -1 : -2;
	}

	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
	  var j = buf.length - 1;
	  if (j < i) return 0;
	  var nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 1;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) self.lastNeed = nb - 2;
	    return nb;
	  }
	  if (--j < i || nb === -2) return 0;
	  nb = utf8CheckByte(buf[j]);
	  if (nb >= 0) {
	    if (nb > 0) {
	      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
	    }
	    return nb;
	  }
	  return 0;
	}

	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
	  if ((buf[0] & 0xC0) !== 0x80) {
	    self.lastNeed = 0;
	    return '\ufffd';
	  }
	  if (self.lastNeed > 1 && buf.length > 1) {
	    if ((buf[1] & 0xC0) !== 0x80) {
	      self.lastNeed = 1;
	      return '\ufffd';
	    }
	    if (self.lastNeed > 2 && buf.length > 2) {
	      if ((buf[2] & 0xC0) !== 0x80) {
	        self.lastNeed = 2;
	        return '\ufffd';
	      }
	    }
	  }
	}

	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
	  var p = this.lastTotal - this.lastNeed;
	  var r = utf8CheckExtraBytes(this, buf);
	  if (r !== undefined) return r;
	  if (this.lastNeed <= buf.length) {
	    buf.copy(this.lastChar, p, 0, this.lastNeed);
	    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
	  }
	  buf.copy(this.lastChar, p, 0, buf.length);
	  this.lastNeed -= buf.length;
	}

	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
	  var total = utf8CheckIncomplete(this, buf, i);
	  if (!this.lastNeed) return buf.toString('utf8', i);
	  this.lastTotal = total;
	  var end = buf.length - (total - this.lastNeed);
	  buf.copy(this.lastChar, 0, end);
	  return buf.toString('utf8', i, end);
	}

	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + '\ufffd';
	  return r;
	}

	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
	  if ((buf.length - i) % 2 === 0) {
	    var r = buf.toString('utf16le', i);
	    if (r) {
	      var c = r.charCodeAt(r.length - 1);
	      if (c >= 0xD800 && c <= 0xDBFF) {
	        this.lastNeed = 2;
	        this.lastTotal = 4;
	        this.lastChar[0] = buf[buf.length - 2];
	        this.lastChar[1] = buf[buf.length - 1];
	        return r.slice(0, -1);
	      }
	    }
	    return r;
	  }
	  this.lastNeed = 1;
	  this.lastTotal = 2;
	  this.lastChar[0] = buf[buf.length - 1];
	  return buf.toString('utf16le', i, buf.length - 1);
	}

	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) {
	    var end = this.lastTotal - this.lastNeed;
	    return r + this.lastChar.toString('utf16le', 0, end);
	  }
	  return r;
	}

	function base64Text(buf, i) {
	  var n = (buf.length - i) % 3;
	  if (n === 0) return buf.toString('base64', i);
	  this.lastNeed = 3 - n;
	  this.lastTotal = 3;
	  if (n === 1) {
	    this.lastChar[0] = buf[buf.length - 1];
	  } else {
	    this.lastChar[0] = buf[buf.length - 2];
	    this.lastChar[1] = buf[buf.length - 1];
	  }
	  return buf.toString('base64', i, buf.length - n);
	}

	function base64End(buf) {
	  var r = buf && buf.length ? this.write(buf) : '';
	  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
	  return r;
	}

	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
	  return buf.toString(this.encoding);
	}

	function simpleEnd(buf) {
	  return buf && buf.length ? this.write(buf) : '';
	}
	return string_decoder;
}

var _stream_readable;
var hasRequired_stream_readable;

function require_stream_readable () {
	if (hasRequired_stream_readable) return _stream_readable;
	hasRequired_stream_readable = 1;

	/*<replacement>*/

	var pna = requireProcessNextickArgs();
	/*</replacement>*/

	_stream_readable = Readable;

	/*<replacement>*/
	var isArray = requireIsarray();
	/*</replacement>*/

	/*<replacement>*/
	var Duplex;
	/*</replacement>*/

	Readable.ReadableState = ReadableState;

	/*<replacement>*/
	requireEvents().EventEmitter;

	var EElistenerCount = function (emitter, type) {
	  return emitter.listeners(type).length;
	};
	/*</replacement>*/

	/*<replacement>*/
	var Stream = requireStreamBrowser();
	/*</replacement>*/

	/*<replacement>*/

	var Buffer = requireSafeBuffer$1().Buffer;
	var OurUint8Array = (typeof commonjsGlobal !== 'undefined' ? commonjsGlobal : typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : {}).Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
	  return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
	  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}

	/*</replacement>*/

	/*<replacement>*/
	var util = Object.create(requireUtil$1());
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	/*<replacement>*/
	var debugUtil = requireUtil$2();
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
	  debug = debugUtil.debuglog('stream');
	} else {
	  debug = function () {};
	}
	/*</replacement>*/

	var BufferList = requireBufferList();
	var destroyImpl = requireDestroy();
	var StringDecoder;

	util.inherits(Readable, Stream);

	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

	function prependListener(emitter, event, fn) {
	  // Sadly this is not cacheable as some libraries bundle their own
	  // event emitter implementation with them.
	  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

	  // This is a hack to make sure that our error handler is attached before any
	  // userland ones.  NEVER DO THIS. This is here only because this code needs
	  // to continue to work with older versions of Node.js that do not include
	  // the prependListener() method. The goal is to eventually remove this hack.
	  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}

	function ReadableState(options, stream) {
	  Duplex = Duplex || require_stream_duplex();

	  options = options || {};

	  // Duplex streams are both readable and writable, but share
	  // the same options object.
	  // However, some cases require setting options to different
	  // values for the readable and the writable sides of the duplex stream.
	  // These options can be provided separately as readableXXX and writableXXX.
	  var isDuplex = stream instanceof Duplex;

	  // object stream flag. Used to make read(n) ignore n and to
	  // make all the buffer merging and length checks go away
	  this.objectMode = !!options.objectMode;

	  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

	  // the point at which it stops calling _read() to fill the buffer
	  // Note: 0 is a valid value, means "don't call _read preemptively ever"
	  var hwm = options.highWaterMark;
	  var readableHwm = options.readableHighWaterMark;
	  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

	  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

	  // cast to ints.
	  this.highWaterMark = Math.floor(this.highWaterMark);

	  // A linked list is used to store data chunks instead of an array because the
	  // linked list can remove elements from the beginning faster than
	  // array.shift()
	  this.buffer = new BufferList();
	  this.length = 0;
	  this.pipes = null;
	  this.pipesCount = 0;
	  this.flowing = null;
	  this.ended = false;
	  this.endEmitted = false;
	  this.reading = false;

	  // a flag to be able to tell if the event 'readable'/'data' is emitted
	  // immediately, or on a later tick.  We set this to true at first, because
	  // any actions that shouldn't happen until "later" should generally also
	  // not happen before the first read call.
	  this.sync = true;

	  // whenever we return null, then we set a flag to say
	  // that we're awaiting a 'readable' event emission.
	  this.needReadable = false;
	  this.emittedReadable = false;
	  this.readableListening = false;
	  this.resumeScheduled = false;

	  // has it been destroyed
	  this.destroyed = false;

	  // Crypto is kind of old and crusty.  Historically, its default string
	  // encoding is 'binary' so we have to make this configurable.
	  // Everything else in the universe uses 'utf8', though.
	  this.defaultEncoding = options.defaultEncoding || 'utf8';

	  // the number of writers that are awaiting a drain event in .pipe()s
	  this.awaitDrain = 0;

	  // if true, a maybeReadMore has been scheduled
	  this.readingMore = false;

	  this.decoder = null;
	  this.encoding = null;
	  if (options.encoding) {
	    if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	    this.decoder = new StringDecoder(options.encoding);
	    this.encoding = options.encoding;
	  }
	}

	function Readable(options) {
	  Duplex = Duplex || require_stream_duplex();

	  if (!(this instanceof Readable)) return new Readable(options);

	  this._readableState = new ReadableState(options, this);

	  // legacy
	  this.readable = true;

	  if (options) {
	    if (typeof options.read === 'function') this._read = options.read;

	    if (typeof options.destroy === 'function') this._destroy = options.destroy;
	  }

	  Stream.call(this);
	}

	Object.defineProperty(Readable.prototype, 'destroyed', {
	  get: function () {
	    if (this._readableState === undefined) {
	      return false;
	    }
	    return this._readableState.destroyed;
	  },
	  set: function (value) {
	    // we ignore the value if the stream
	    // has not been initialized yet
	    if (!this._readableState) {
	      return;
	    }

	    // backward compatibility, the user is explicitly
	    // managing destroyed
	    this._readableState.destroyed = value;
	  }
	});

	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
	  this.push(null);
	  cb(err);
	};

	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
	  var state = this._readableState;
	  var skipChunkCheck;

	  if (!state.objectMode) {
	    if (typeof chunk === 'string') {
	      encoding = encoding || state.defaultEncoding;
	      if (encoding !== state.encoding) {
	        chunk = Buffer.from(chunk, encoding);
	        encoding = '';
	      }
	      skipChunkCheck = true;
	    }
	  } else {
	    skipChunkCheck = true;
	  }

	  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};

	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
	  return readableAddChunk(this, chunk, null, true, false);
	};

	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
	  var state = stream._readableState;
	  if (chunk === null) {
	    state.reading = false;
	    onEofChunk(stream, state);
	  } else {
	    var er;
	    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
	    if (er) {
	      stream.emit('error', er);
	    } else if (state.objectMode || chunk && chunk.length > 0) {
	      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
	        chunk = _uint8ArrayToBuffer(chunk);
	      }

	      if (addToFront) {
	        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
	      } else if (state.ended) {
	        stream.emit('error', new Error('stream.push() after EOF'));
	      } else {
	        state.reading = false;
	        if (state.decoder && !encoding) {
	          chunk = state.decoder.write(chunk);
	          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
	        } else {
	          addChunk(stream, state, chunk, false);
	        }
	      }
	    } else if (!addToFront) {
	      state.reading = false;
	    }
	  }

	  return needMoreData(state);
	}

	function addChunk(stream, state, chunk, addToFront) {
	  if (state.flowing && state.length === 0 && !state.sync) {
	    stream.emit('data', chunk);
	    stream.read(0);
	  } else {
	    // update the buffer info.
	    state.length += state.objectMode ? 1 : chunk.length;
	    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

	    if (state.needReadable) emitReadable(stream);
	  }
	  maybeReadMore(stream, state);
	}

	function chunkInvalid(state, chunk) {
	  var er;
	  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
	    er = new TypeError('Invalid non-string/buffer chunk');
	  }
	  return er;
	}

	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
	  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}

	Readable.prototype.isPaused = function () {
	  return this._readableState.flowing === false;
	};

	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
	  if (!StringDecoder) StringDecoder = requireString_decoder().StringDecoder;
	  this._readableState.decoder = new StringDecoder(enc);
	  this._readableState.encoding = enc;
	  return this;
	};

	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
	  if (n >= MAX_HWM) {
	    n = MAX_HWM;
	  } else {
	    // Get the next highest power of 2 to prevent increasing hwm excessively in
	    // tiny amounts
	    n--;
	    n |= n >>> 1;
	    n |= n >>> 2;
	    n |= n >>> 4;
	    n |= n >>> 8;
	    n |= n >>> 16;
	    n++;
	  }
	  return n;
	}

	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
	  if (n <= 0 || state.length === 0 && state.ended) return 0;
	  if (state.objectMode) return 1;
	  if (n !== n) {
	    // Only flow one buffer at a time
	    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
	  }
	  // If we're asking for more than the current hwm, then raise the hwm.
	  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
	  if (n <= state.length) return n;
	  // Don't have enough
	  if (!state.ended) {
	    state.needReadable = true;
	    return 0;
	  }
	  return state.length;
	}

	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
	  debug('read', n);
	  n = parseInt(n, 10);
	  var state = this._readableState;
	  var nOrig = n;

	  if (n !== 0) state.emittedReadable = false;

	  // if we're doing read(0) to trigger a readable event, but we
	  // already have a bunch of data in the buffer, then just trigger
	  // the 'readable' event and move on.
	  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
	    debug('read: emitReadable', state.length, state.ended);
	    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
	    return null;
	  }

	  n = howMuchToRead(n, state);

	  // if we've ended, and we're now clear, then finish it up.
	  if (n === 0 && state.ended) {
	    if (state.length === 0) endReadable(this);
	    return null;
	  }

	  // All the actual chunk generation logic needs to be
	  // *below* the call to _read.  The reason is that in certain
	  // synthetic stream cases, such as passthrough streams, _read
	  // may be a completely synchronous operation which may change
	  // the state of the read buffer, providing enough data when
	  // before there was *not* enough.
	  //
	  // So, the steps are:
	  // 1. Figure out what the state of things will be after we do
	  // a read from the buffer.
	  //
	  // 2. If that resulting state will trigger a _read, then call _read.
	  // Note that this may be asynchronous, or synchronous.  Yes, it is
	  // deeply ugly to write APIs this way, but that still doesn't mean
	  // that the Readable class should behave improperly, as streams are
	  // designed to be sync/async agnostic.
	  // Take note if the _read call is sync or async (ie, if the read call
	  // has returned yet), so that we know whether or not it's safe to emit
	  // 'readable' etc.
	  //
	  // 3. Actually pull the requested chunks out of the buffer and return.

	  // if we need a readable event, then we need to do some reading.
	  var doRead = state.needReadable;
	  debug('need readable', doRead);

	  // if we currently have less than the highWaterMark, then also read some
	  if (state.length === 0 || state.length - n < state.highWaterMark) {
	    doRead = true;
	    debug('length less than watermark', doRead);
	  }

	  // however, if we've ended, then there's no point, and if we're already
	  // reading, then it's unnecessary.
	  if (state.ended || state.reading) {
	    doRead = false;
	    debug('reading or ended', doRead);
	  } else if (doRead) {
	    debug('do read');
	    state.reading = true;
	    state.sync = true;
	    // if the length is currently zero, then we *need* a readable event.
	    if (state.length === 0) state.needReadable = true;
	    // call internal read method
	    this._read(state.highWaterMark);
	    state.sync = false;
	    // If _read pushed data synchronously, then `reading` will be false,
	    // and we need to re-evaluate how much data we can return to the user.
	    if (!state.reading) n = howMuchToRead(nOrig, state);
	  }

	  var ret;
	  if (n > 0) ret = fromList(n, state);else ret = null;

	  if (ret === null) {
	    state.needReadable = true;
	    n = 0;
	  } else {
	    state.length -= n;
	  }

	  if (state.length === 0) {
	    // If we have nothing in the buffer, then we want to know
	    // as soon as we *do* get something into the buffer.
	    if (!state.ended) state.needReadable = true;

	    // If we tried to read() past the EOF, then emit end on the next tick.
	    if (nOrig !== n && state.ended) endReadable(this);
	  }

	  if (ret !== null) this.emit('data', ret);

	  return ret;
	};

	function onEofChunk(stream, state) {
	  if (state.ended) return;
	  if (state.decoder) {
	    var chunk = state.decoder.end();
	    if (chunk && chunk.length) {
	      state.buffer.push(chunk);
	      state.length += state.objectMode ? 1 : chunk.length;
	    }
	  }
	  state.ended = true;

	  // emit 'readable' now to make sure it gets picked up.
	  emitReadable(stream);
	}

	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
	  var state = stream._readableState;
	  state.needReadable = false;
	  if (!state.emittedReadable) {
	    debug('emitReadable', state.flowing);
	    state.emittedReadable = true;
	    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
	  }
	}

	function emitReadable_(stream) {
	  debug('emit readable');
	  stream.emit('readable');
	  flow(stream);
	}

	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
	  if (!state.readingMore) {
	    state.readingMore = true;
	    pna.nextTick(maybeReadMore_, stream, state);
	  }
	}

	function maybeReadMore_(stream, state) {
	  var len = state.length;
	  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
	    debug('maybeReadMore read 0');
	    stream.read(0);
	    if (len === state.length)
	      // didn't get any data, stop spinning.
	      break;else len = state.length;
	  }
	  state.readingMore = false;
	}

	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
	  this.emit('error', new Error('_read() is not implemented'));
	};

	Readable.prototype.pipe = function (dest, pipeOpts) {
	  var src = this;
	  var state = this._readableState;

	  switch (state.pipesCount) {
	    case 0:
	      state.pipes = dest;
	      break;
	    case 1:
	      state.pipes = [state.pipes, dest];
	      break;
	    default:
	      state.pipes.push(dest);
	      break;
	  }
	  state.pipesCount += 1;
	  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

	  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process$1.stdout && dest !== process$1.stderr;

	  var endFn = doEnd ? onend : unpipe;
	  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

	  dest.on('unpipe', onunpipe);
	  function onunpipe(readable, unpipeInfo) {
	    debug('onunpipe');
	    if (readable === src) {
	      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
	        unpipeInfo.hasUnpiped = true;
	        cleanup();
	      }
	    }
	  }

	  function onend() {
	    debug('onend');
	    dest.end();
	  }

	  // when the dest drains, it reduces the awaitDrain counter
	  // on the source.  This would be more elegant with a .once()
	  // handler in flow(), but adding and removing repeatedly is
	  // too slow.
	  var ondrain = pipeOnDrain(src);
	  dest.on('drain', ondrain);

	  var cleanedUp = false;
	  function cleanup() {
	    debug('cleanup');
	    // cleanup event handlers once the pipe is broken
	    dest.removeListener('close', onclose);
	    dest.removeListener('finish', onfinish);
	    dest.removeListener('drain', ondrain);
	    dest.removeListener('error', onerror);
	    dest.removeListener('unpipe', onunpipe);
	    src.removeListener('end', onend);
	    src.removeListener('end', unpipe);
	    src.removeListener('data', ondata);

	    cleanedUp = true;

	    // if the reader is waiting for a drain event from this
	    // specific writer, then it would cause it to never start
	    // flowing again.
	    // So, if this is awaiting a drain, then we just call it now.
	    // If we don't know, then assume that we are waiting for one.
	    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
	  }

	  // If the user pushes more data while we're writing to dest then we'll end up
	  // in ondata again. However, we only want to increase awaitDrain once because
	  // dest will only emit one 'drain' event for the multiple writes.
	  // => Introduce a guard on increasing awaitDrain.
	  var increasedAwaitDrain = false;
	  src.on('data', ondata);
	  function ondata(chunk) {
	    debug('ondata');
	    increasedAwaitDrain = false;
	    var ret = dest.write(chunk);
	    if (false === ret && !increasedAwaitDrain) {
	      // If the user unpiped during `dest.write()`, it is possible
	      // to get stuck in a permanently paused state if that write
	      // also returned false.
	      // => Check whether `dest` is still a piping destination.
	      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
	        debug('false write response, pause', state.awaitDrain);
	        state.awaitDrain++;
	        increasedAwaitDrain = true;
	      }
	      src.pause();
	    }
	  }

	  // if the dest has an error, then stop piping into it.
	  // however, don't suppress the throwing behavior for this.
	  function onerror(er) {
	    debug('onerror', er);
	    unpipe();
	    dest.removeListener('error', onerror);
	    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
	  }

	  // Make sure our error handler is attached before userland ones.
	  prependListener(dest, 'error', onerror);

	  // Both close and finish should trigger unpipe, but only once.
	  function onclose() {
	    dest.removeListener('finish', onfinish);
	    unpipe();
	  }
	  dest.once('close', onclose);
	  function onfinish() {
	    debug('onfinish');
	    dest.removeListener('close', onclose);
	    unpipe();
	  }
	  dest.once('finish', onfinish);

	  function unpipe() {
	    debug('unpipe');
	    src.unpipe(dest);
	  }

	  // tell the dest that it's being piped to
	  dest.emit('pipe', src);

	  // start the flow if it hasn't been started already.
	  if (!state.flowing) {
	    debug('pipe resume');
	    src.resume();
	  }

	  return dest;
	};

	function pipeOnDrain(src) {
	  return function () {
	    var state = src._readableState;
	    debug('pipeOnDrain', state.awaitDrain);
	    if (state.awaitDrain) state.awaitDrain--;
	    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
	      state.flowing = true;
	      flow(src);
	    }
	  };
	}

	Readable.prototype.unpipe = function (dest) {
	  var state = this._readableState;
	  var unpipeInfo = { hasUnpiped: false };

	  // if we're not piping anywhere, then do nothing.
	  if (state.pipesCount === 0) return this;

	  // just one destination.  most common case.
	  if (state.pipesCount === 1) {
	    // passed in one, but it's not the right one.
	    if (dest && dest !== state.pipes) return this;

	    if (!dest) dest = state.pipes;

	    // got a match.
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;
	    if (dest) dest.emit('unpipe', this, unpipeInfo);
	    return this;
	  }

	  // slow case. multiple pipe destinations.

	  if (!dest) {
	    // remove all.
	    var dests = state.pipes;
	    var len = state.pipesCount;
	    state.pipes = null;
	    state.pipesCount = 0;
	    state.flowing = false;

	    for (var i = 0; i < len; i++) {
	      dests[i].emit('unpipe', this, { hasUnpiped: false });
	    }return this;
	  }

	  // try to find the right one.
	  var index = indexOf(state.pipes, dest);
	  if (index === -1) return this;

	  state.pipes.splice(index, 1);
	  state.pipesCount -= 1;
	  if (state.pipesCount === 1) state.pipes = state.pipes[0];

	  dest.emit('unpipe', this, unpipeInfo);

	  return this;
	};

	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
	  var res = Stream.prototype.on.call(this, ev, fn);

	  if (ev === 'data') {
	    // Start flowing on next tick if stream isn't explicitly paused
	    if (this._readableState.flowing !== false) this.resume();
	  } else if (ev === 'readable') {
	    var state = this._readableState;
	    if (!state.endEmitted && !state.readableListening) {
	      state.readableListening = state.needReadable = true;
	      state.emittedReadable = false;
	      if (!state.reading) {
	        pna.nextTick(nReadingNextTick, this);
	      } else if (state.length) {
	        emitReadable(this);
	      }
	    }
	  }

	  return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;

	function nReadingNextTick(self) {
	  debug('readable nexttick read 0');
	  self.read(0);
	}

	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
	  var state = this._readableState;
	  if (!state.flowing) {
	    debug('resume');
	    state.flowing = true;
	    resume(this, state);
	  }
	  return this;
	};

	function resume(stream, state) {
	  if (!state.resumeScheduled) {
	    state.resumeScheduled = true;
	    pna.nextTick(resume_, stream, state);
	  }
	}

	function resume_(stream, state) {
	  if (!state.reading) {
	    debug('resume read 0');
	    stream.read(0);
	  }

	  state.resumeScheduled = false;
	  state.awaitDrain = 0;
	  stream.emit('resume');
	  flow(stream);
	  if (state.flowing && !state.reading) stream.read(0);
	}

	Readable.prototype.pause = function () {
	  debug('call pause flowing=%j', this._readableState.flowing);
	  if (false !== this._readableState.flowing) {
	    debug('pause');
	    this._readableState.flowing = false;
	    this.emit('pause');
	  }
	  return this;
	};

	function flow(stream) {
	  var state = stream._readableState;
	  debug('flow', state.flowing);
	  while (state.flowing && stream.read() !== null) {}
	}

	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
	  var _this = this;

	  var state = this._readableState;
	  var paused = false;

	  stream.on('end', function () {
	    debug('wrapped end');
	    if (state.decoder && !state.ended) {
	      var chunk = state.decoder.end();
	      if (chunk && chunk.length) _this.push(chunk);
	    }

	    _this.push(null);
	  });

	  stream.on('data', function (chunk) {
	    debug('wrapped data');
	    if (state.decoder) chunk = state.decoder.write(chunk);

	    // don't skip over falsy values in objectMode
	    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

	    var ret = _this.push(chunk);
	    if (!ret) {
	      paused = true;
	      stream.pause();
	    }
	  });

	  // proxy all the other methods.
	  // important when wrapping filters and duplexes.
	  for (var i in stream) {
	    if (this[i] === undefined && typeof stream[i] === 'function') {
	      this[i] = function (method) {
	        return function () {
	          return stream[method].apply(stream, arguments);
	        };
	      }(i);
	    }
	  }

	  // proxy certain important events.
	  for (var n = 0; n < kProxyEvents.length; n++) {
	    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
	  }

	  // when we try to consume some more bytes, simply unpause the
	  // underlying stream.
	  this._read = function (n) {
	    debug('wrapped _read', n);
	    if (paused) {
	      paused = false;
	      stream.resume();
	    }
	  };

	  return this;
	};

	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
	  // making it explicit this property is not enumerable
	  // because otherwise some prototype manipulation in
	  // userland will fail
	  enumerable: false,
	  get: function () {
	    return this._readableState.highWaterMark;
	  }
	});

	// exposed for testing purposes only.
	Readable._fromList = fromList;

	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
	  // nothing buffered
	  if (state.length === 0) return null;

	  var ret;
	  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
	    // read it all, truncate the list
	    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
	    state.buffer.clear();
	  } else {
	    // read part of list
	    ret = fromListPartial(n, state.buffer, state.decoder);
	  }

	  return ret;
	}

	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
	  var ret;
	  if (n < list.head.data.length) {
	    // slice is the same for buffers and strings
	    ret = list.head.data.slice(0, n);
	    list.head.data = list.head.data.slice(n);
	  } else if (n === list.head.data.length) {
	    // first chunk is a perfect match
	    ret = list.shift();
	  } else {
	    // result spans more than one buffer
	    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
	  }
	  return ret;
	}

	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
	  var p = list.head;
	  var c = 1;
	  var ret = p.data;
	  n -= ret.length;
	  while (p = p.next) {
	    var str = p.data;
	    var nb = n > str.length ? str.length : n;
	    if (nb === str.length) ret += str;else ret += str.slice(0, n);
	    n -= nb;
	    if (n === 0) {
	      if (nb === str.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = str.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
	  var ret = Buffer.allocUnsafe(n);
	  var p = list.head;
	  var c = 1;
	  p.data.copy(ret);
	  n -= p.data.length;
	  while (p = p.next) {
	    var buf = p.data;
	    var nb = n > buf.length ? buf.length : n;
	    buf.copy(ret, ret.length - n, 0, nb);
	    n -= nb;
	    if (n === 0) {
	      if (nb === buf.length) {
	        ++c;
	        if (p.next) list.head = p.next;else list.head = list.tail = null;
	      } else {
	        list.head = p;
	        p.data = buf.slice(nb);
	      }
	      break;
	    }
	    ++c;
	  }
	  list.length -= c;
	  return ret;
	}

	function endReadable(stream) {
	  var state = stream._readableState;

	  // If we get here before consuming all the bytes, then that is a
	  // bug in node.  Should never happen.
	  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

	  if (!state.endEmitted) {
	    state.ended = true;
	    pna.nextTick(endReadableNT, state, stream);
	  }
	}

	function endReadableNT(state, stream) {
	  // Check that we didn't get one last unshift.
	  if (!state.endEmitted && state.length === 0) {
	    state.endEmitted = true;
	    stream.readable = false;
	    stream.emit('end');
	  }
	}

	function indexOf(xs, x) {
	  for (var i = 0, l = xs.length; i < l; i++) {
	    if (xs[i] === x) return i;
	  }
	  return -1;
	}
	return _stream_readable;
}

var _stream_transform;
var hasRequired_stream_transform;

function require_stream_transform () {
	if (hasRequired_stream_transform) return _stream_transform;
	hasRequired_stream_transform = 1;

	_stream_transform = Transform;

	var Duplex = require_stream_duplex();

	/*<replacement>*/
	var util = Object.create(requireUtil$1());
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	util.inherits(Transform, Duplex);

	function afterTransform(er, data) {
	  var ts = this._transformState;
	  ts.transforming = false;

	  var cb = ts.writecb;

	  if (!cb) {
	    return this.emit('error', new Error('write callback called multiple times'));
	  }

	  ts.writechunk = null;
	  ts.writecb = null;

	  if (data != null) // single equals check for both `null` and `undefined`
	    this.push(data);

	  cb(er);

	  var rs = this._readableState;
	  rs.reading = false;
	  if (rs.needReadable || rs.length < rs.highWaterMark) {
	    this._read(rs.highWaterMark);
	  }
	}

	function Transform(options) {
	  if (!(this instanceof Transform)) return new Transform(options);

	  Duplex.call(this, options);

	  this._transformState = {
	    afterTransform: afterTransform.bind(this),
	    needTransform: false,
	    transforming: false,
	    writecb: null,
	    writechunk: null,
	    writeencoding: null
	  };

	  // start out asking for a readable event once data is transformed.
	  this._readableState.needReadable = true;

	  // we have implemented the _read method, and done the other things
	  // that Readable wants before the first _read call, so unset the
	  // sync guard flag.
	  this._readableState.sync = false;

	  if (options) {
	    if (typeof options.transform === 'function') this._transform = options.transform;

	    if (typeof options.flush === 'function') this._flush = options.flush;
	  }

	  // When the writable side finishes, then flush out anything remaining.
	  this.on('prefinish', prefinish);
	}

	function prefinish() {
	  var _this = this;

	  if (typeof this._flush === 'function') {
	    this._flush(function (er, data) {
	      done(_this, er, data);
	    });
	  } else {
	    done(this, null, null);
	  }
	}

	Transform.prototype.push = function (chunk, encoding) {
	  this._transformState.needTransform = false;
	  return Duplex.prototype.push.call(this, chunk, encoding);
	};

	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
	  throw new Error('_transform() is not implemented');
	};

	Transform.prototype._write = function (chunk, encoding, cb) {
	  var ts = this._transformState;
	  ts.writecb = cb;
	  ts.writechunk = chunk;
	  ts.writeencoding = encoding;
	  if (!ts.transforming) {
	    var rs = this._readableState;
	    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
	  }
	};

	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
	  var ts = this._transformState;

	  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
	    ts.transforming = true;
	    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
	  } else {
	    // mark that we need a transform, so that any data that comes in
	    // will get processed, now that we've asked for it.
	    ts.needTransform = true;
	  }
	};

	Transform.prototype._destroy = function (err, cb) {
	  var _this2 = this;

	  Duplex.prototype._destroy.call(this, err, function (err2) {
	    cb(err2);
	    _this2.emit('close');
	  });
	};

	function done(stream, er, data) {
	  if (er) return stream.emit('error', er);

	  if (data != null) // single equals check for both `null` and `undefined`
	    stream.push(data);

	  // if there's nothing in the write buffer, then that means
	  // that nothing more will ever be provided
	  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

	  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

	  return stream.push(null);
	}
	return _stream_transform;
}

var _stream_passthrough;
var hasRequired_stream_passthrough;

function require_stream_passthrough () {
	if (hasRequired_stream_passthrough) return _stream_passthrough;
	hasRequired_stream_passthrough = 1;

	_stream_passthrough = PassThrough;

	var Transform = require_stream_transform();

	/*<replacement>*/
	var util = Object.create(requireUtil$1());
	util.inherits = requireInherits_browser();
	/*</replacement>*/

	util.inherits(PassThrough, Transform);

	function PassThrough(options) {
	  if (!(this instanceof PassThrough)) return new PassThrough(options);

	  Transform.call(this, options);
	}

	PassThrough.prototype._transform = function (chunk, encoding, cb) {
	  cb(null, chunk);
	};
	return _stream_passthrough;
}

var hasRequiredReadableBrowser;

function requireReadableBrowser () {
	if (hasRequiredReadableBrowser) return readableBrowser.exports;
	hasRequiredReadableBrowser = 1;
	(function (module, exports) {
		exports = module.exports = require_stream_readable();
		exports.Stream = exports;
		exports.Readable = exports;
		exports.Writable = require_stream_writable();
		exports.Duplex = require_stream_duplex();
		exports.Transform = require_stream_transform();
		exports.PassThrough = require_stream_passthrough(); 
	} (readableBrowser, readableBrowser.exports));
	return readableBrowser.exports;
}

var sign = {exports: {}};

var bn$b = {exports: {}};

var bn$a = bn$b.exports;

var hasRequiredBn$5;

function requireBn$5 () {
	if (hasRequiredBn$5) return bn$b.exports;
	hasRequiredBn$5 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [number & 0x3ffffff];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [0];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this._strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // '0' - '9'
		    if (c >= 48 && c <= 57) {
		      return c - 48;
		    // 'A' - 'F'
		    } else if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    } else {
		      assert(false, 'Invalid character in ' + string);
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this._strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var b = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        b = c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        b = c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        b = c;
		      }
		      assert(c >= 0 && b < mul, 'Invalid character');
		      r += b;
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [0];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this._strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  function move (dest, src) {
		    dest.words = src.words;
		    dest.length = src.length;
		    dest.negative = src.negative;
		    dest.red = src.red;
		  }

		  BN.prototype._move = function _move (dest) {
		    move(dest, this);
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype._strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  // Check Symbol.for because not everywhere where Symbol defined
		  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
		  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
		    try {
		      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
		    } catch (e) {
		      BN.prototype.inspect = inspect;
		    }
		  } else {
		    BN.prototype.inspect = inspect;
		  }

		  function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  }

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modrn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16, 2);
		  };

		  if (Buffer) {
		    BN.prototype.toBuffer = function toBuffer (endian, length) {
		      return this.toArrayLike(Buffer, endian, length);
		    };
		  }

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  var allocate = function allocate (ArrayType, size) {
		    if (ArrayType.allocUnsafe) {
		      return ArrayType.allocUnsafe(size);
		    }
		    return new ArrayType(size);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    this._strip();

		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    var res = allocate(ArrayType, reqLength);
		    var postfix = endian === 'le' ? 'LE' : 'BE';
		    this['_toArrayLike' + postfix](res, byteLength);
		    return res;
		  };

		  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
		    var position = 0;
		    var carry = 0;

		    for (var i = 0, shift = 0; i < this.length; i++) {
		      var word = (this.words[i] << shift) | carry;

		      res[position++] = word & 0xff;
		      if (position < res.length) {
		        res[position++] = (word >> 8) & 0xff;
		      }
		      if (position < res.length) {
		        res[position++] = (word >> 16) & 0xff;
		      }

		      if (shift === 6) {
		        if (position < res.length) {
		          res[position++] = (word >> 24) & 0xff;
		        }
		        carry = 0;
		        shift = 0;
		      } else {
		        carry = word >>> 24;
		        shift += 2;
		      }
		    }

		    if (position < res.length) {
		      res[position++] = carry;

		      while (position < res.length) {
		        res[position++] = 0;
		      }
		    }
		  };

		  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
		    var position = res.length - 1;
		    var carry = 0;

		    for (var i = 0, shift = 0; i < this.length; i++) {
		      var word = (this.words[i] << shift) | carry;

		      res[position--] = word & 0xff;
		      if (position >= 0) {
		        res[position--] = (word >> 8) & 0xff;
		      }
		      if (position >= 0) {
		        res[position--] = (word >> 16) & 0xff;
		      }

		      if (shift === 6) {
		        if (position >= 0) {
		          res[position--] = (word >> 24) & 0xff;
		        }
		        carry = 0;
		        shift = 0;
		      } else {
		        carry = word >>> 24;
		        shift += 2;
		      }
		    }

		    if (position >= 0) {
		      res[position--] = carry;

		      while (position >= 0) {
		        res[position--] = 0;
		      }
		    }
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] >>> wbit) & 0x01;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this._strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this._strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this._strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this._strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this._strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this._strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out._strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out._strip();
		  }

		  function jumboMulTo (self, num, out) {
		    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
		    // var fftm = new FFTM();
		    // return fftm.mulp(self, num, out);
		    return bigMulTo(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return isNegNum ? this.ineg() : this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this._strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this._strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this._strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) <= num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this._strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this._strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this._strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q._strip();
		    }
		    a._strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modrn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modrn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modrn = function modrn (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return isNegNum ? -acc : acc;
		  };

		  // WARNING: DEPRECATED
		  BN.prototype.modn = function modn (num) {
		    return this.modrn(num);
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    var isNegNum = num < 0;
		    if (isNegNum) num = -num;

		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    this._strip();
		    return isNegNum ? this.ineg() : this;
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this._strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is a BN v4 instance
		        r.strip();
		      } else {
		        // r is a BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

		    move(a, a.umod(this.m)._forceRed(this));
		    return a;
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$a); 
	} (bn$b));
	return bn$b.exports;
}

var browserifyRsa;
var hasRequiredBrowserifyRsa;

function requireBrowserifyRsa () {
	if (hasRequiredBrowserifyRsa) return browserifyRsa;
	hasRequiredBrowserifyRsa = 1;
	var BN = requireBn$5();
	var randomBytes = requireBrowser$a();

	function blind (priv) {
	  var r = getr(priv);
	  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed();
	  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
	}

	function getr (priv) {
	  var len = priv.modulus.byteLength();
	  var r;
	  do {
	    r = new BN(randomBytes(len));
	  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
	  return r
	}

	function crt (msg, priv) {
	  var blinds = blind(priv);
	  var len = priv.modulus.byteLength();
	  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus);
	  var c1 = blinded.toRed(BN.mont(priv.prime1));
	  var c2 = blinded.toRed(BN.mont(priv.prime2));
	  var qinv = priv.coefficient;
	  var p = priv.prime1;
	  var q = priv.prime2;
	  var m1 = c1.redPow(priv.exponent1).fromRed();
	  var m2 = c2.redPow(priv.exponent2).fromRed();
	  var h = m1.isub(m2).imul(qinv).umod(p).imul(q);
	  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer$1, 'be', len)
	}
	crt.getr = getr;

	browserifyRsa = crt;
	return browserifyRsa;
}

var elliptic$1 = {};

const version$1 = "6.5.7";
const require$$0$1 = {
  version: version$1};

var utils$3 = {};

var bn$9 = {exports: {}};

var bn$8 = bn$9.exports;

var hasRequiredBn$4;

function requireBn$4 () {
	if (hasRequiredBn$4) return bn$9.exports;
	hasRequiredBn$4 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$8); 
	} (bn$9));
	return bn$9.exports;
}

var utils$2 = {};

var hasRequiredUtils$3;

function requireUtils$3 () {
	if (hasRequiredUtils$3) return utils$2;
	hasRequiredUtils$3 = 1;
	(function (exports) {

		var utils = exports;

		function toArray(msg, enc) {
		  if (Array.isArray(msg))
		    return msg.slice();
		  if (!msg)
		    return [];
		  var res = [];
		  if (typeof msg !== 'string') {
		    for (var i = 0; i < msg.length; i++)
		      res[i] = msg[i] | 0;
		    return res;
		  }
		  if (enc === 'hex') {
		    msg = msg.replace(/[^a-z0-9]+/ig, '');
		    if (msg.length % 2 !== 0)
		      msg = '0' + msg;
		    for (var i = 0; i < msg.length; i += 2)
		      res.push(parseInt(msg[i] + msg[i + 1], 16));
		  } else {
		    for (var i = 0; i < msg.length; i++) {
		      var c = msg.charCodeAt(i);
		      var hi = c >> 8;
		      var lo = c & 0xff;
		      if (hi)
		        res.push(hi, lo);
		      else
		        res.push(lo);
		    }
		  }
		  return res;
		}
		utils.toArray = toArray;

		function zero2(word) {
		  if (word.length === 1)
		    return '0' + word;
		  else
		    return word;
		}
		utils.zero2 = zero2;

		function toHex(msg) {
		  var res = '';
		  for (var i = 0; i < msg.length; i++)
		    res += zero2(msg[i].toString(16));
		  return res;
		}
		utils.toHex = toHex;

		utils.encode = function encode(arr, enc) {
		  if (enc === 'hex')
		    return toHex(arr);
		  else
		    return arr;
		}; 
	} (utils$2));
	return utils$2;
}

var hasRequiredUtils$2;

function requireUtils$2 () {
	if (hasRequiredUtils$2) return utils$3;
	hasRequiredUtils$2 = 1;
	(function (exports) {

		var utils = exports;
		var BN = requireBn$4();
		var minAssert = requireMinimalisticAssert();
		var minUtils = requireUtils$3();

		utils.assert = minAssert;
		utils.toArray = minUtils.toArray;
		utils.zero2 = minUtils.zero2;
		utils.toHex = minUtils.toHex;
		utils.encode = minUtils.encode;

		// Represent num in a w-NAF form
		function getNAF(num, w, bits) {
		  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
		  var i;
		  for (i = 0; i < naf.length; i += 1) {
		    naf[i] = 0;
		  }

		  var ws = 1 << (w + 1);
		  var k = num.clone();

		  for (i = 0; i < naf.length; i++) {
		    var z;
		    var mod = k.andln(ws - 1);
		    if (k.isOdd()) {
		      if (mod > (ws >> 1) - 1)
		        z = (ws >> 1) - mod;
		      else
		        z = mod;
		      k.isubn(z);
		    } else {
		      z = 0;
		    }

		    naf[i] = z;
		    k.iushrn(1);
		  }

		  return naf;
		}
		utils.getNAF = getNAF;

		// Represent k1, k2 in a Joint Sparse Form
		function getJSF(k1, k2) {
		  var jsf = [
		    [],
		    [],
		  ];

		  k1 = k1.clone();
		  k2 = k2.clone();
		  var d1 = 0;
		  var d2 = 0;
		  var m8;
		  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
		    // First phase
		    var m14 = (k1.andln(3) + d1) & 3;
		    var m24 = (k2.andln(3) + d2) & 3;
		    if (m14 === 3)
		      m14 = -1;
		    if (m24 === 3)
		      m24 = -1;
		    var u1;
		    if ((m14 & 1) === 0) {
		      u1 = 0;
		    } else {
		      m8 = (k1.andln(7) + d1) & 7;
		      if ((m8 === 3 || m8 === 5) && m24 === 2)
		        u1 = -m14;
		      else
		        u1 = m14;
		    }
		    jsf[0].push(u1);

		    var u2;
		    if ((m24 & 1) === 0) {
		      u2 = 0;
		    } else {
		      m8 = (k2.andln(7) + d2) & 7;
		      if ((m8 === 3 || m8 === 5) && m14 === 2)
		        u2 = -m24;
		      else
		        u2 = m24;
		    }
		    jsf[1].push(u2);

		    // Second phase
		    if (2 * d1 === u1 + 1)
		      d1 = 1 - d1;
		    if (2 * d2 === u2 + 1)
		      d2 = 1 - d2;
		    k1.iushrn(1);
		    k2.iushrn(1);
		  }

		  return jsf;
		}
		utils.getJSF = getJSF;

		function cachedProperty(obj, name, computer) {
		  var key = '_' + name;
		  obj.prototype[name] = function cachedProperty() {
		    return this[key] !== undefined ? this[key] :
		      this[key] = computer.call(this);
		  };
		}
		utils.cachedProperty = cachedProperty;

		function parseBytes(bytes) {
		  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
		    bytes;
		}
		utils.parseBytes = parseBytes;

		function intFromLE(bytes) {
		  return new BN(bytes, 'hex', 'le');
		}
		utils.intFromLE = intFromLE; 
	} (utils$3));
	return utils$3;
}

var curve$1 = {};

var base$2;
var hasRequiredBase$2;

function requireBase$2 () {
	if (hasRequiredBase$2) return base$2;
	hasRequiredBase$2 = 1;

	var BN = requireBn$4();
	var utils = requireUtils$2();
	var getNAF = utils.getNAF;
	var getJSF = utils.getJSF;
	var assert = utils.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new BN(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

	  // Useful for many curves
	  this.zero = new BN(0).toRed(this.red);
	  this.one = new BN(1).toRed(this.red);
	  this.two = new BN(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new BN(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);

	  this._bitLength = this.n ? this.n.bitLength() : 0;

	  // Generalized Greg Maxwell's trick
	  var adjustCount = this.n && this.p.div(this.n);
	  if (!adjustCount || adjustCount.cmpn(100) > 0) {
	    this.redN = null;
	  } else {
	    this._maxwellTrick = true;
	    this.redN = this.n.toRed(this.red);
	  }
	}
	base$2 = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1, this._bitLength);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  var j;
	  var nafW;
	  for (j = 0; j < naf.length; j += doubles.step) {
	    nafW = 0;
	    for (var l = j + doubles.step - 1; l >= j; l--)
	      nafW = (nafW << 1) + naf[l];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (j = 0; j < repr.length; j++) {
	      nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w, this._bitLength);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var l = 0; i >= 0 && naf[i] === 0; i--)
	      l++;
	    if (i >= 0)
	      l++;
	    acc = acc.dblp(l);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	  points,
	  coeffs,
	  len,
	  jacobianResult) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  var i;
	  var j;
	  var p;
	  for (i = 0; i < len; i++) {
	    p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
	      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b], /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3,  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (j = 0; j < len; j++) {
	      var z = tmp[j];
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (i = 0; i < len; i++)
	    wnd[i] = null;

	  if (jacobianResult)
	    return acc;
	  else
	    return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils.toArray(bytes, enc);

	  var len = this.p.byteLength();

	  // uncompressed, hybrid-odd, hybrid-even
	  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
	      bytes.length - 1 === 2 * len) {
	    if (bytes[0] === 0x06)
	      assert(bytes[bytes.length - 1] % 2 === 0);
	    else if (bytes[0] === 0x07)
	      assert(bytes[bytes.length - 1] % 2 === 1);

	    var res =  this.point(bytes.slice(1, 1 + len),
	      bytes.slice(1 + len, 1 + 2 * len));

	    return res;
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null,
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles,
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res,
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};
	return base$2;
}

var short$1;
var hasRequiredShort$1;

function requireShort$1 () {
	if (hasRequiredShort$1) return short$1;
	hasRequiredShort$1 = 1;

	var utils = requireUtils$2();
	var BN = requireBn$4();
	var inherits = requireInherits_browser();
	var Base = requireBase$2();

	var assert = utils.assert;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits(ShortCurve, Base);
	short$1 = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new BN(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new BN(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new BN(vec.a, 16),
	        b: new BN(vec.b, 16),
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis,
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : BN.mont(num);
	  var tinv = new BN(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new BN(1);
	  var y1 = new BN(0);
	  var x2 = new BN(0);
	  var y2 = new BN(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 },
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
	      var npoints = this._endoWnafT1;
	      var ncoeffs = this._endoWnafT2;
	      for (var i = 0; i < points.length; i++) {
	        var split = this._endoSplit(coeffs[i]);
	        var p = points[i];
	        var beta = p._getBeta();

	        if (split.k1.negative) {
	          split.k1.ineg();
	          p = p.neg(true);
	        }
	        if (split.k2.negative) {
	          split.k2.ineg();
	          beta = beta.neg(true);
	        }

	        npoints[i * 2] = p;
	        npoints[i * 2 + 1] = beta;
	        ncoeffs[i * 2] = split.k1;
	        ncoeffs[i * 2 + 1] = split.k2;
	      }
	      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

	      // Clean-up references to points and coefficients
	      for (var j = 0; j < i * 2; j++) {
	        npoints[j] = null;
	        ncoeffs[j] = null;
	      }
	      return res;
	    };

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits(Point, Base.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul),
	      },
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1),
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1),
	    },
	  } ];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point)),
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point)),
	    },
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new BN(k, 16);
	  if (this.isInfinity())
	    return this;
	  else if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs, true);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate),
	      },
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new BN(0);
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = new BN(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits(JPoint, Base.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  var i;
	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new BN(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.eqXToP = function eqXToP(x) {
	  var zs = this.z.redSqr();
	  var rx = x.toRed(this.curve.red).redMul(zs);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(zs);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};
	return short$1;
}

var mont$1;
var hasRequiredMont$1;

function requireMont$1 () {
	if (hasRequiredMont$1) return mont$1;
	hasRequiredMont$1 = 1;

	var BN = requireBn$4();
	var inherits = requireInherits_browser();
	var Base = requireBase$2();

	var utils = requireUtils$2();

	function MontCurve(conf) {
	  Base.call(this, 'mont', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.i4 = new BN(4).toRed(this.red).redInvm();
	  this.two = new BN(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits(MontCurve, Base);
	mont$1 = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point(curve, x, z) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new BN(x, 16);
	    this.z = new BN(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits(Point, Base.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	Point.prototype.precompute = function precompute() {
	  // No-op
	};

	Point.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1] || curve.one);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.jumlAdd = function jumlAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};
	return mont$1;
}

var edwards$1;
var hasRequiredEdwards$1;

function requireEdwards$1 () {
	if (hasRequiredEdwards$1) return edwards$1;
	hasRequiredEdwards$1 = 1;

	var utils = requireUtils$2();
	var BN = requireBn$4();
	var inherits = requireInherits_browser();
	var Base = requireBase$2();

	var assert = utils.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'edwards', conf);

	  this.a = new BN(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new BN(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new BN(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits(EdwardsCurve, Base);
	edwards$1 = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y2 = rhs.redMul(lhs.redInvm());
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new BN(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.c2);
	  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.fromRed().isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = z ? new BN(z, 16) : this.curve.one;
	    this.t = t && new BN(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits(Point, Base.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	    (this.y.cmp(this.z) === 0 ||
	    (this.zOne && this.y.cmp(this.curve.c) === 0));
	};

	Point.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  var e;
	  var h;
	  var j;
	  if (this.curve.twisted) {
	    // E = a * C
	    e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      h = this.z.redSqr();
	      // J = F - 2 * H
	      j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    e = c.redAdd(d);
	    // H = (c * Z1)^2
	    h = this.curve._mulC(this.z).redSqr();
	    // J = E - 2 * H
	    j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	    this.y,
	    this.z,
	    this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	Point.prototype.eqXToP = function eqXToP(x) {
	  var rx = x.toRed(this.curve.red).redMul(this.z);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(this.z);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;
	return edwards$1;
}

var hasRequiredCurve$1;

function requireCurve$1 () {
	if (hasRequiredCurve$1) return curve$1;
	hasRequiredCurve$1 = 1;
	(function (exports) {

		var curve = exports;

		curve.base = requireBase$2();
		curve.short = requireShort$1();
		curve.mont = requireMont$1();
		curve.edwards = requireEdwards$1(); 
	} (curve$1));
	return curve$1;
}

var curves$1 = {};

var hash = {};

var utils$1 = {};

var hasRequiredUtils$1;

function requireUtils$1 () {
	if (hasRequiredUtils$1) return utils$1;
	hasRequiredUtils$1 = 1;

	var assert = requireMinimalisticAssert();
	var inherits = requireInherits_browser();

	utils$1.inherits = inherits;

	function isSurrogatePair(msg, i) {
	  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
	    return false;
	  }
	  if (i < 0 || i + 1 >= msg.length) {
	    return false;
	  }
	  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
	}

	function toArray(msg, enc) {
	  if (Array.isArray(msg))
	    return msg.slice();
	  if (!msg)
	    return [];
	  var res = [];
	  if (typeof msg === 'string') {
	    if (!enc) {
	      // Inspired by stringToUtf8ByteArray() in closure-library by Google
	      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
	      // Apache License 2.0
	      // https://github.com/google/closure-library/blob/master/LICENSE
	      var p = 0;
	      for (var i = 0; i < msg.length; i++) {
	        var c = msg.charCodeAt(i);
	        if (c < 128) {
	          res[p++] = c;
	        } else if (c < 2048) {
	          res[p++] = (c >> 6) | 192;
	          res[p++] = (c & 63) | 128;
	        } else if (isSurrogatePair(msg, i)) {
	          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
	          res[p++] = (c >> 18) | 240;
	          res[p++] = ((c >> 12) & 63) | 128;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        } else {
	          res[p++] = (c >> 12) | 224;
	          res[p++] = ((c >> 6) & 63) | 128;
	          res[p++] = (c & 63) | 128;
	        }
	      }
	    } else if (enc === 'hex') {
	      msg = msg.replace(/[^a-z0-9]+/ig, '');
	      if (msg.length % 2 !== 0)
	        msg = '0' + msg;
	      for (i = 0; i < msg.length; i += 2)
	        res.push(parseInt(msg[i] + msg[i + 1], 16));
	    }
	  } else {
	    for (i = 0; i < msg.length; i++)
	      res[i] = msg[i] | 0;
	  }
	  return res;
	}
	utils$1.toArray = toArray;

	function toHex(msg) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++)
	    res += zero2(msg[i].toString(16));
	  return res;
	}
	utils$1.toHex = toHex;

	function htonl(w) {
	  var res = (w >>> 24) |
	            ((w >>> 8) & 0xff00) |
	            ((w << 8) & 0xff0000) |
	            ((w & 0xff) << 24);
	  return res >>> 0;
	}
	utils$1.htonl = htonl;

	function toHex32(msg, endian) {
	  var res = '';
	  for (var i = 0; i < msg.length; i++) {
	    var w = msg[i];
	    if (endian === 'little')
	      w = htonl(w);
	    res += zero8(w.toString(16));
	  }
	  return res;
	}
	utils$1.toHex32 = toHex32;

	function zero2(word) {
	  if (word.length === 1)
	    return '0' + word;
	  else
	    return word;
	}
	utils$1.zero2 = zero2;

	function zero8(word) {
	  if (word.length === 7)
	    return '0' + word;
	  else if (word.length === 6)
	    return '00' + word;
	  else if (word.length === 5)
	    return '000' + word;
	  else if (word.length === 4)
	    return '0000' + word;
	  else if (word.length === 3)
	    return '00000' + word;
	  else if (word.length === 2)
	    return '000000' + word;
	  else if (word.length === 1)
	    return '0000000' + word;
	  else
	    return word;
	}
	utils$1.zero8 = zero8;

	function join32(msg, start, end, endian) {
	  var len = end - start;
	  assert(len % 4 === 0);
	  var res = new Array(len / 4);
	  for (var i = 0, k = start; i < res.length; i++, k += 4) {
	    var w;
	    if (endian === 'big')
	      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
	    else
	      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
	    res[i] = w >>> 0;
	  }
	  return res;
	}
	utils$1.join32 = join32;

	function split32(msg, endian) {
	  var res = new Array(msg.length * 4);
	  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
	    var m = msg[i];
	    if (endian === 'big') {
	      res[k] = m >>> 24;
	      res[k + 1] = (m >>> 16) & 0xff;
	      res[k + 2] = (m >>> 8) & 0xff;
	      res[k + 3] = m & 0xff;
	    } else {
	      res[k + 3] = m >>> 24;
	      res[k + 2] = (m >>> 16) & 0xff;
	      res[k + 1] = (m >>> 8) & 0xff;
	      res[k] = m & 0xff;
	    }
	  }
	  return res;
	}
	utils$1.split32 = split32;

	function rotr32(w, b) {
	  return (w >>> b) | (w << (32 - b));
	}
	utils$1.rotr32 = rotr32;

	function rotl32(w, b) {
	  return (w << b) | (w >>> (32 - b));
	}
	utils$1.rotl32 = rotl32;

	function sum32(a, b) {
	  return (a + b) >>> 0;
	}
	utils$1.sum32 = sum32;

	function sum32_3(a, b, c) {
	  return (a + b + c) >>> 0;
	}
	utils$1.sum32_3 = sum32_3;

	function sum32_4(a, b, c, d) {
	  return (a + b + c + d) >>> 0;
	}
	utils$1.sum32_4 = sum32_4;

	function sum32_5(a, b, c, d, e) {
	  return (a + b + c + d + e) >>> 0;
	}
	utils$1.sum32_5 = sum32_5;

	function sum64(buf, pos, ah, al) {
	  var bh = buf[pos];
	  var bl = buf[pos + 1];

	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  buf[pos] = hi >>> 0;
	  buf[pos + 1] = lo;
	}
	utils$1.sum64 = sum64;

	function sum64_hi(ah, al, bh, bl) {
	  var lo = (al + bl) >>> 0;
	  var hi = (lo < al ? 1 : 0) + ah + bh;
	  return hi >>> 0;
	}
	utils$1.sum64_hi = sum64_hi;

	function sum64_lo(ah, al, bh, bl) {
	  var lo = al + bl;
	  return lo >>> 0;
	}
	utils$1.sum64_lo = sum64_lo;

	function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;

	  var hi = ah + bh + ch + dh + carry;
	  return hi >>> 0;
	}
	utils$1.sum64_4_hi = sum64_4_hi;

	function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
	  var lo = al + bl + cl + dl;
	  return lo >>> 0;
	}
	utils$1.sum64_4_lo = sum64_4_lo;

	function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var carry = 0;
	  var lo = al;
	  lo = (lo + bl) >>> 0;
	  carry += lo < al ? 1 : 0;
	  lo = (lo + cl) >>> 0;
	  carry += lo < cl ? 1 : 0;
	  lo = (lo + dl) >>> 0;
	  carry += lo < dl ? 1 : 0;
	  lo = (lo + el) >>> 0;
	  carry += lo < el ? 1 : 0;

	  var hi = ah + bh + ch + dh + eh + carry;
	  return hi >>> 0;
	}
	utils$1.sum64_5_hi = sum64_5_hi;

	function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
	  var lo = al + bl + cl + dl + el;

	  return lo >>> 0;
	}
	utils$1.sum64_5_lo = sum64_5_lo;

	function rotr64_hi(ah, al, num) {
	  var r = (al << (32 - num)) | (ah >>> num);
	  return r >>> 0;
	}
	utils$1.rotr64_hi = rotr64_hi;

	function rotr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	utils$1.rotr64_lo = rotr64_lo;

	function shr64_hi(ah, al, num) {
	  return ah >>> num;
	}
	utils$1.shr64_hi = shr64_hi;

	function shr64_lo(ah, al, num) {
	  var r = (ah << (32 - num)) | (al >>> num);
	  return r >>> 0;
	}
	utils$1.shr64_lo = shr64_lo;
	return utils$1;
}

var common$1 = {};

var hasRequiredCommon$1;

function requireCommon$1 () {
	if (hasRequiredCommon$1) return common$1;
	hasRequiredCommon$1 = 1;

	var utils = requireUtils$1();
	var assert = requireMinimalisticAssert();

	function BlockHash() {
	  this.pending = null;
	  this.pendingTotal = 0;
	  this.blockSize = this.constructor.blockSize;
	  this.outSize = this.constructor.outSize;
	  this.hmacStrength = this.constructor.hmacStrength;
	  this.padLength = this.constructor.padLength / 8;
	  this.endian = 'big';

	  this._delta8 = this.blockSize / 8;
	  this._delta32 = this.blockSize / 32;
	}
	common$1.BlockHash = BlockHash;

	BlockHash.prototype.update = function update(msg, enc) {
	  // Convert message to array, pad it, and join into 32bit blocks
	  msg = utils.toArray(msg, enc);
	  if (!this.pending)
	    this.pending = msg;
	  else
	    this.pending = this.pending.concat(msg);
	  this.pendingTotal += msg.length;

	  // Enough data, try updating
	  if (this.pending.length >= this._delta8) {
	    msg = this.pending;

	    // Process pending data in blocks
	    var r = msg.length % this._delta8;
	    this.pending = msg.slice(msg.length - r, msg.length);
	    if (this.pending.length === 0)
	      this.pending = null;

	    msg = utils.join32(msg, 0, msg.length - r, this.endian);
	    for (var i = 0; i < msg.length; i += this._delta32)
	      this._update(msg, i, i + this._delta32);
	  }

	  return this;
	};

	BlockHash.prototype.digest = function digest(enc) {
	  this.update(this._pad());
	  assert(this.pending === null);

	  return this._digest(enc);
	};

	BlockHash.prototype._pad = function pad() {
	  var len = this.pendingTotal;
	  var bytes = this._delta8;
	  var k = bytes - ((len + this.padLength) % bytes);
	  var res = new Array(k + this.padLength);
	  res[0] = 0x80;
	  for (var i = 1; i < k; i++)
	    res[i] = 0;

	  // Append length
	  len <<= 3;
	  if (this.endian === 'big') {
	    for (var t = 8; t < this.padLength; t++)
	      res[i++] = 0;

	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = len & 0xff;
	  } else {
	    res[i++] = len & 0xff;
	    res[i++] = (len >>> 8) & 0xff;
	    res[i++] = (len >>> 16) & 0xff;
	    res[i++] = (len >>> 24) & 0xff;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;
	    res[i++] = 0;

	    for (t = 8; t < this.padLength; t++)
	      res[i++] = 0;
	  }

	  return res;
	};
	return common$1;
}

var sha = {};

var common = {};

var hasRequiredCommon;

function requireCommon () {
	if (hasRequiredCommon) return common;
	hasRequiredCommon = 1;

	var utils = requireUtils$1();
	var rotr32 = utils.rotr32;

	function ft_1(s, x, y, z) {
	  if (s === 0)
	    return ch32(x, y, z);
	  if (s === 1 || s === 3)
	    return p32(x, y, z);
	  if (s === 2)
	    return maj32(x, y, z);
	}
	common.ft_1 = ft_1;

	function ch32(x, y, z) {
	  return (x & y) ^ ((~x) & z);
	}
	common.ch32 = ch32;

	function maj32(x, y, z) {
	  return (x & y) ^ (x & z) ^ (y & z);
	}
	common.maj32 = maj32;

	function p32(x, y, z) {
	  return x ^ y ^ z;
	}
	common.p32 = p32;

	function s0_256(x) {
	  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
	}
	common.s0_256 = s0_256;

	function s1_256(x) {
	  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
	}
	common.s1_256 = s1_256;

	function g0_256(x) {
	  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
	}
	common.g0_256 = g0_256;

	function g1_256(x) {
	  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
	}
	common.g1_256 = g1_256;
	return common;
}

var _1;
var hasRequired_1;

function require_1 () {
	if (hasRequired_1) return _1;
	hasRequired_1 = 1;

	var utils = requireUtils$1();
	var common = requireCommon$1();
	var shaCommon = requireCommon();

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_5 = utils.sum32_5;
	var ft_1 = shaCommon.ft_1;
	var BlockHash = common.BlockHash;

	var sha1_K = [
	  0x5A827999, 0x6ED9EBA1,
	  0x8F1BBCDC, 0xCA62C1D6
	];

	function SHA1() {
	  if (!(this instanceof SHA1))
	    return new SHA1();

	  BlockHash.call(this);
	  this.h = [
	    0x67452301, 0xefcdab89, 0x98badcfe,
	    0x10325476, 0xc3d2e1f0 ];
	  this.W = new Array(80);
	}

	utils.inherits(SHA1, BlockHash);
	_1 = SHA1;

	SHA1.blockSize = 512;
	SHA1.outSize = 160;
	SHA1.hmacStrength = 80;
	SHA1.padLength = 64;

	SHA1.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];

	  for(; i < W.length; i++)
	    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];

	  for (i = 0; i < W.length; i++) {
	    var s = ~~(i / 20);
	    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
	    e = d;
	    d = c;
	    c = rotl32(b, 30);
	    b = a;
	    a = t;
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	};

	SHA1.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};
	return _1;
}

var _256;
var hasRequired_256;

function require_256 () {
	if (hasRequired_256) return _256;
	hasRequired_256 = 1;

	var utils = requireUtils$1();
	var common = requireCommon$1();
	var shaCommon = requireCommon();
	var assert = requireMinimalisticAssert();

	var sum32 = utils.sum32;
	var sum32_4 = utils.sum32_4;
	var sum32_5 = utils.sum32_5;
	var ch32 = shaCommon.ch32;
	var maj32 = shaCommon.maj32;
	var s0_256 = shaCommon.s0_256;
	var s1_256 = shaCommon.s1_256;
	var g0_256 = shaCommon.g0_256;
	var g1_256 = shaCommon.g1_256;

	var BlockHash = common.BlockHash;

	var sha256_K = [
	  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
	  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
	  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
	  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
	  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
	  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
	  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
	  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
	  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
	  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
	  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
	  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
	  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
	  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
	  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
	  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
	];

	function SHA256() {
	  if (!(this instanceof SHA256))
	    return new SHA256();

	  BlockHash.call(this);
	  this.h = [
	    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
	    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
	  ];
	  this.k = sha256_K;
	  this.W = new Array(64);
	}
	utils.inherits(SHA256, BlockHash);
	_256 = SHA256;

	SHA256.blockSize = 512;
	SHA256.outSize = 256;
	SHA256.hmacStrength = 192;
	SHA256.padLength = 64;

	SHA256.prototype._update = function _update(msg, start) {
	  var W = this.W;

	  for (var i = 0; i < 16; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i++)
	    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

	  var a = this.h[0];
	  var b = this.h[1];
	  var c = this.h[2];
	  var d = this.h[3];
	  var e = this.h[4];
	  var f = this.h[5];
	  var g = this.h[6];
	  var h = this.h[7];

	  assert(this.k.length === W.length);
	  for (i = 0; i < W.length; i++) {
	    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
	    var T2 = sum32(s0_256(a), maj32(a, b, c));
	    h = g;
	    g = f;
	    f = e;
	    e = sum32(d, T1);
	    d = c;
	    c = b;
	    b = a;
	    a = sum32(T1, T2);
	  }

	  this.h[0] = sum32(this.h[0], a);
	  this.h[1] = sum32(this.h[1], b);
	  this.h[2] = sum32(this.h[2], c);
	  this.h[3] = sum32(this.h[3], d);
	  this.h[4] = sum32(this.h[4], e);
	  this.h[5] = sum32(this.h[5], f);
	  this.h[6] = sum32(this.h[6], g);
	  this.h[7] = sum32(this.h[7], h);
	};

	SHA256.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};
	return _256;
}

var _224;
var hasRequired_224;

function require_224 () {
	if (hasRequired_224) return _224;
	hasRequired_224 = 1;

	var utils = requireUtils$1();
	var SHA256 = require_256();

	function SHA224() {
	  if (!(this instanceof SHA224))
	    return new SHA224();

	  SHA256.call(this);
	  this.h = [
	    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
	    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
	}
	utils.inherits(SHA224, SHA256);
	_224 = SHA224;

	SHA224.blockSize = 512;
	SHA224.outSize = 224;
	SHA224.hmacStrength = 192;
	SHA224.padLength = 64;

	SHA224.prototype._digest = function digest(enc) {
	  // Just truncate output
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 7), 'big');
	  else
	    return utils.split32(this.h.slice(0, 7), 'big');
	};
	return _224;
}

var _512;
var hasRequired_512;

function require_512 () {
	if (hasRequired_512) return _512;
	hasRequired_512 = 1;

	var utils = requireUtils$1();
	var common = requireCommon$1();
	var assert = requireMinimalisticAssert();

	var rotr64_hi = utils.rotr64_hi;
	var rotr64_lo = utils.rotr64_lo;
	var shr64_hi = utils.shr64_hi;
	var shr64_lo = utils.shr64_lo;
	var sum64 = utils.sum64;
	var sum64_hi = utils.sum64_hi;
	var sum64_lo = utils.sum64_lo;
	var sum64_4_hi = utils.sum64_4_hi;
	var sum64_4_lo = utils.sum64_4_lo;
	var sum64_5_hi = utils.sum64_5_hi;
	var sum64_5_lo = utils.sum64_5_lo;

	var BlockHash = common.BlockHash;

	var sha512_K = [
	  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
	  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
	  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
	  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
	  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
	  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
	  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
	  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
	  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
	  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
	  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
	  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
	  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
	  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
	  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
	  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
	  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
	  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
	  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
	  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
	  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
	  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
	  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
	  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
	  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
	  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
	  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
	  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
	  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
	  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
	  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
	  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
	  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
	  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
	  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
	  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
	  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
	  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
	  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
	  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
	];

	function SHA512() {
	  if (!(this instanceof SHA512))
	    return new SHA512();

	  BlockHash.call(this);
	  this.h = [
	    0x6a09e667, 0xf3bcc908,
	    0xbb67ae85, 0x84caa73b,
	    0x3c6ef372, 0xfe94f82b,
	    0xa54ff53a, 0x5f1d36f1,
	    0x510e527f, 0xade682d1,
	    0x9b05688c, 0x2b3e6c1f,
	    0x1f83d9ab, 0xfb41bd6b,
	    0x5be0cd19, 0x137e2179 ];
	  this.k = sha512_K;
	  this.W = new Array(160);
	}
	utils.inherits(SHA512, BlockHash);
	_512 = SHA512;

	SHA512.blockSize = 1024;
	SHA512.outSize = 512;
	SHA512.hmacStrength = 192;
	SHA512.padLength = 128;

	SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
	  var W = this.W;

	  // 32 x 32bit words
	  for (var i = 0; i < 32; i++)
	    W[i] = msg[start + i];
	  for (; i < W.length; i += 2) {
	    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
	    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
	    var c1_hi = W[i - 14];  // i - 7
	    var c1_lo = W[i - 13];
	    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
	    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
	    var c3_hi = W[i - 32];  // i - 16
	    var c3_lo = W[i - 31];

	    W[i] = sum64_4_hi(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	    W[i + 1] = sum64_4_lo(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo);
	  }
	};

	SHA512.prototype._update = function _update(msg, start) {
	  this._prepareBlock(msg, start);

	  var W = this.W;

	  var ah = this.h[0];
	  var al = this.h[1];
	  var bh = this.h[2];
	  var bl = this.h[3];
	  var ch = this.h[4];
	  var cl = this.h[5];
	  var dh = this.h[6];
	  var dl = this.h[7];
	  var eh = this.h[8];
	  var el = this.h[9];
	  var fh = this.h[10];
	  var fl = this.h[11];
	  var gh = this.h[12];
	  var gl = this.h[13];
	  var hh = this.h[14];
	  var hl = this.h[15];

	  assert(this.k.length === W.length);
	  for (var i = 0; i < W.length; i += 2) {
	    var c0_hi = hh;
	    var c0_lo = hl;
	    var c1_hi = s1_512_hi(eh, el);
	    var c1_lo = s1_512_lo(eh, el);
	    var c2_hi = ch64_hi(eh, el, fh, fl, gh);
	    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
	    var c3_hi = this.k[i];
	    var c3_lo = this.k[i + 1];
	    var c4_hi = W[i];
	    var c4_lo = W[i + 1];

	    var T1_hi = sum64_5_hi(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);
	    var T1_lo = sum64_5_lo(
	      c0_hi, c0_lo,
	      c1_hi, c1_lo,
	      c2_hi, c2_lo,
	      c3_hi, c3_lo,
	      c4_hi, c4_lo);

	    c0_hi = s0_512_hi(ah, al);
	    c0_lo = s0_512_lo(ah, al);
	    c1_hi = maj64_hi(ah, al, bh, bl, ch);
	    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

	    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
	    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

	    hh = gh;
	    hl = gl;

	    gh = fh;
	    gl = fl;

	    fh = eh;
	    fl = el;

	    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
	    el = sum64_lo(dl, dl, T1_hi, T1_lo);

	    dh = ch;
	    dl = cl;

	    ch = bh;
	    cl = bl;

	    bh = ah;
	    bl = al;

	    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
	    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
	  }

	  sum64(this.h, 0, ah, al);
	  sum64(this.h, 2, bh, bl);
	  sum64(this.h, 4, ch, cl);
	  sum64(this.h, 6, dh, dl);
	  sum64(this.h, 8, eh, el);
	  sum64(this.h, 10, fh, fl);
	  sum64(this.h, 12, gh, gl);
	  sum64(this.h, 14, hh, hl);
	};

	SHA512.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'big');
	  else
	    return utils.split32(this.h, 'big');
	};

	function ch64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ ((~xh) & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function ch64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ ((~xl) & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_hi(xh, xl, yh, yl, zh) {
	  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function maj64_lo(xh, xl, yh, yl, zh, zl) {
	  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 28);
	  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
	  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 28);
	  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
	  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 14);
	  var c1_hi = rotr64_hi(xh, xl, 18);
	  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function s1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 14);
	  var c1_lo = rotr64_lo(xh, xl, 18);
	  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 1);
	  var c1_hi = rotr64_hi(xh, xl, 8);
	  var c2_hi = shr64_hi(xh, xl, 7);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g0_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 1);
	  var c1_lo = rotr64_lo(xh, xl, 8);
	  var c2_lo = shr64_lo(xh, xl, 7);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_hi(xh, xl) {
	  var c0_hi = rotr64_hi(xh, xl, 19);
	  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
	  var c2_hi = shr64_hi(xh, xl, 6);

	  var r = c0_hi ^ c1_hi ^ c2_hi;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}

	function g1_512_lo(xh, xl) {
	  var c0_lo = rotr64_lo(xh, xl, 19);
	  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
	  var c2_lo = shr64_lo(xh, xl, 6);

	  var r = c0_lo ^ c1_lo ^ c2_lo;
	  if (r < 0)
	    r += 0x100000000;
	  return r;
	}
	return _512;
}

var _384;
var hasRequired_384;

function require_384 () {
	if (hasRequired_384) return _384;
	hasRequired_384 = 1;

	var utils = requireUtils$1();

	var SHA512 = require_512();

	function SHA384() {
	  if (!(this instanceof SHA384))
	    return new SHA384();

	  SHA512.call(this);
	  this.h = [
	    0xcbbb9d5d, 0xc1059ed8,
	    0x629a292a, 0x367cd507,
	    0x9159015a, 0x3070dd17,
	    0x152fecd8, 0xf70e5939,
	    0x67332667, 0xffc00b31,
	    0x8eb44a87, 0x68581511,
	    0xdb0c2e0d, 0x64f98fa7,
	    0x47b5481d, 0xbefa4fa4 ];
	}
	utils.inherits(SHA384, SHA512);
	_384 = SHA384;

	SHA384.blockSize = 1024;
	SHA384.outSize = 384;
	SHA384.hmacStrength = 192;
	SHA384.padLength = 128;

	SHA384.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h.slice(0, 12), 'big');
	  else
	    return utils.split32(this.h.slice(0, 12), 'big');
	};
	return _384;
}

var hasRequiredSha;

function requireSha () {
	if (hasRequiredSha) return sha;
	hasRequiredSha = 1;

	sha.sha1 = require_1();
	sha.sha224 = require_224();
	sha.sha256 = require_256();
	sha.sha384 = require_384();
	sha.sha512 = require_512();
	return sha;
}

var ripemd = {};

var hasRequiredRipemd;

function requireRipemd () {
	if (hasRequiredRipemd) return ripemd;
	hasRequiredRipemd = 1;

	var utils = requireUtils$1();
	var common = requireCommon$1();

	var rotl32 = utils.rotl32;
	var sum32 = utils.sum32;
	var sum32_3 = utils.sum32_3;
	var sum32_4 = utils.sum32_4;
	var BlockHash = common.BlockHash;

	function RIPEMD160() {
	  if (!(this instanceof RIPEMD160))
	    return new RIPEMD160();

	  BlockHash.call(this);

	  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
	  this.endian = 'little';
	}
	utils.inherits(RIPEMD160, BlockHash);
	ripemd.ripemd160 = RIPEMD160;

	RIPEMD160.blockSize = 512;
	RIPEMD160.outSize = 160;
	RIPEMD160.hmacStrength = 192;
	RIPEMD160.padLength = 64;

	RIPEMD160.prototype._update = function update(msg, start) {
	  var A = this.h[0];
	  var B = this.h[1];
	  var C = this.h[2];
	  var D = this.h[3];
	  var E = this.h[4];
	  var Ah = A;
	  var Bh = B;
	  var Ch = C;
	  var Dh = D;
	  var Eh = E;
	  for (var j = 0; j < 80; j++) {
	    var T = sum32(
	      rotl32(
	        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
	        s[j]),
	      E);
	    A = E;
	    E = D;
	    D = rotl32(C, 10);
	    C = B;
	    B = T;
	    T = sum32(
	      rotl32(
	        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
	        sh[j]),
	      Eh);
	    Ah = Eh;
	    Eh = Dh;
	    Dh = rotl32(Ch, 10);
	    Ch = Bh;
	    Bh = T;
	  }
	  T = sum32_3(this.h[1], C, Dh);
	  this.h[1] = sum32_3(this.h[2], D, Eh);
	  this.h[2] = sum32_3(this.h[3], E, Ah);
	  this.h[3] = sum32_3(this.h[4], A, Bh);
	  this.h[4] = sum32_3(this.h[0], B, Ch);
	  this.h[0] = T;
	};

	RIPEMD160.prototype._digest = function digest(enc) {
	  if (enc === 'hex')
	    return utils.toHex32(this.h, 'little');
	  else
	    return utils.split32(this.h, 'little');
	};

	function f(j, x, y, z) {
	  if (j <= 15)
	    return x ^ y ^ z;
	  else if (j <= 31)
	    return (x & y) | ((~x) & z);
	  else if (j <= 47)
	    return (x | (~y)) ^ z;
	  else if (j <= 63)
	    return (x & z) | (y & (~z));
	  else
	    return x ^ (y | (~z));
	}

	function K(j) {
	  if (j <= 15)
	    return 0x00000000;
	  else if (j <= 31)
	    return 0x5a827999;
	  else if (j <= 47)
	    return 0x6ed9eba1;
	  else if (j <= 63)
	    return 0x8f1bbcdc;
	  else
	    return 0xa953fd4e;
	}

	function Kh(j) {
	  if (j <= 15)
	    return 0x50a28be6;
	  else if (j <= 31)
	    return 0x5c4dd124;
	  else if (j <= 47)
	    return 0x6d703ef3;
	  else if (j <= 63)
	    return 0x7a6d76e9;
	  else
	    return 0x00000000;
	}

	var r = [
	  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
	  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
	  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
	  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
	  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
	];

	var rh = [
	  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
	  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
	  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
	  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
	  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
	];

	var s = [
	  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
	  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
	  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
	  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
	  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
	];

	var sh = [
	  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
	  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
	  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
	  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
	  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
	];
	return ripemd;
}

var hmac;
var hasRequiredHmac;

function requireHmac () {
	if (hasRequiredHmac) return hmac;
	hasRequiredHmac = 1;

	var utils = requireUtils$1();
	var assert = requireMinimalisticAssert();

	function Hmac(hash, key, enc) {
	  if (!(this instanceof Hmac))
	    return new Hmac(hash, key, enc);
	  this.Hash = hash;
	  this.blockSize = hash.blockSize / 8;
	  this.outSize = hash.outSize / 8;
	  this.inner = null;
	  this.outer = null;

	  this._init(utils.toArray(key, enc));
	}
	hmac = Hmac;

	Hmac.prototype._init = function init(key) {
	  // Shorten key, if needed
	  if (key.length > this.blockSize)
	    key = new this.Hash().update(key).digest();
	  assert(key.length <= this.blockSize);

	  // Add padding to key
	  for (var i = key.length; i < this.blockSize; i++)
	    key.push(0);

	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x36;
	  this.inner = new this.Hash().update(key);

	  // 0x36 ^ 0x5c = 0x6a
	  for (i = 0; i < key.length; i++)
	    key[i] ^= 0x6a;
	  this.outer = new this.Hash().update(key);
	};

	Hmac.prototype.update = function update(msg, enc) {
	  this.inner.update(msg, enc);
	  return this;
	};

	Hmac.prototype.digest = function digest(enc) {
	  this.outer.update(this.inner.digest());
	  return this.outer.digest(enc);
	};
	return hmac;
}

var hasRequiredHash;

function requireHash () {
	if (hasRequiredHash) return hash;
	hasRequiredHash = 1;
	(function (exports) {
		var hash = exports;

		hash.utils = requireUtils$1();
		hash.common = requireCommon$1();
		hash.sha = requireSha();
		hash.ripemd = requireRipemd();
		hash.hmac = requireHmac();

		// Proxy hash functions to the main object
		hash.sha1 = hash.sha.sha1;
		hash.sha256 = hash.sha.sha256;
		hash.sha224 = hash.sha.sha224;
		hash.sha384 = hash.sha.sha384;
		hash.sha512 = hash.sha.sha512;
		hash.ripemd160 = hash.ripemd.ripemd160; 
	} (hash));
	return hash;
}

var secp256k1$1;
var hasRequiredSecp256k1$1;

function requireSecp256k1$1 () {
	if (hasRequiredSecp256k1$1) return secp256k1$1;
	hasRequiredSecp256k1$1 = 1;
	secp256k1$1 = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
	      ],
	    ],
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
	      ],
	    ],
	  },
	};
	return secp256k1$1;
}

var hasRequiredCurves$1;

function requireCurves$1 () {
	if (hasRequiredCurves$1) return curves$1;
	hasRequiredCurves$1 = 1;
	(function (exports) {

		var curves = exports;

		var hash = requireHash();
		var curve = requireCurve$1();
		var utils = requireUtils$2();

		var assert = utils.assert;

		function PresetCurve(options) {
		  if (options.type === 'short')
		    this.curve = new curve.short(options);
		  else if (options.type === 'edwards')
		    this.curve = new curve.edwards(options);
		  else
		    this.curve = new curve.mont(options);
		  this.g = this.curve.g;
		  this.n = this.curve.n;
		  this.hash = options.hash;

		  assert(this.g.validate(), 'Invalid curve');
		  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
		}
		curves.PresetCurve = PresetCurve;

		function defineCurve(name, options) {
		  Object.defineProperty(curves, name, {
		    configurable: true,
		    enumerable: true,
		    get: function() {
		      var curve = new PresetCurve(options);
		      Object.defineProperty(curves, name, {
		        configurable: true,
		        enumerable: true,
		        value: curve,
		      });
		      return curve;
		    },
		  });
		}

		defineCurve('p192', {
		  type: 'short',
		  prime: 'p192',
		  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
		  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
		  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
		    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
		  ],
		});

		defineCurve('p224', {
		  type: 'short',
		  prime: 'p224',
		  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
		  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
		  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
		    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
		  ],
		});

		defineCurve('p256', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
		  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
		  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
		  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
		    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
		  ],
		});

		defineCurve('p384', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 ffffffff',
		  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 fffffffc',
		  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
		     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
		  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
		     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
		  hash: hash.sha384,
		  gRed: false,
		  g: [
		    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
		    '5502f25d bf55296c 3a545e38 72760ab7',
		    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
		    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
		  ],
		});

		defineCurve('p521', {
		  type: 'short',
		  prime: null,
		  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff',
		  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff fffffffc',
		  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
		     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
		     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
		  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
		     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
		  hash: hash.sha512,
		  gRed: false,
		  g: [
		    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
		    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
		    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
		    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
		    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
		    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
		  ],
		});

		defineCurve('curve25519', {
		  type: 'mont',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '76d06',
		  b: '1',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '9',
		  ],
		});

		defineCurve('ed25519', {
		  type: 'edwards',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '-1',
		  c: '1',
		  // -121665 * (121666^(-1)) (mod P)
		  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

		    // 4/5
		    '6666666666666666666666666666666666666666666666666666666666666658',
		  ],
		});

		var pre;
		try {
		  pre = requireSecp256k1$1();
		} catch (e) {
		  pre = undefined;
		}

		defineCurve('secp256k1', {
		  type: 'short',
		  prime: 'k256',
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
		  a: '0',
		  b: '7',
		  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
		  h: '1',
		  hash: hash.sha256,

		  // Precomputed endomorphism
		  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
		  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
		  basis: [
		    {
		      a: '3086d221a7d46bcde86c90e49284eb15',
		      b: '-e4437ed6010e88286f547fa90abfe4c3',
		    },
		    {
		      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
		      b: '3086d221a7d46bcde86c90e49284eb15',
		    },
		  ],

		  gRed: false,
		  g: [
		    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
		    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
		    pre,
		  ],
		}); 
	} (curves$1));
	return curves$1;
}

var hmacDrbg;
var hasRequiredHmacDrbg;

function requireHmacDrbg () {
	if (hasRequiredHmacDrbg) return hmacDrbg;
	hasRequiredHmacDrbg = 1;

	var hash = requireHash();
	var utils = requireUtils$3();
	var assert = requireMinimalisticAssert();

	function HmacDRBG(options) {
	  if (!(this instanceof HmacDRBG))
	    return new HmacDRBG(options);
	  this.hash = options.hash;
	  this.predResist = !!options.predResist;

	  this.outLen = this.hash.outSize;
	  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

	  this._reseed = null;
	  this.reseedInterval = null;
	  this.K = null;
	  this.V = null;

	  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
	  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
	  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
	  this._init(entropy, nonce, pers);
	}
	hmacDrbg = HmacDRBG;

	HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
	  var seed = entropy.concat(nonce).concat(pers);

	  this.K = new Array(this.outLen / 8);
	  this.V = new Array(this.outLen / 8);
	  for (var i = 0; i < this.V.length; i++) {
	    this.K[i] = 0x00;
	    this.V[i] = 0x01;
	  }

	  this._update(seed);
	  this._reseed = 1;
	  this.reseedInterval = 0x1000000000000;  // 2^48
	};

	HmacDRBG.prototype._hmac = function hmac() {
	  return new hash.hmac(this.hash, this.K);
	};

	HmacDRBG.prototype._update = function update(seed) {
	  var kmac = this._hmac()
	                 .update(this.V)
	                 .update([ 0x00 ]);
	  if (seed)
	    kmac = kmac.update(seed);
	  this.K = kmac.digest();
	  this.V = this._hmac().update(this.V).digest();
	  if (!seed)
	    return;

	  this.K = this._hmac()
	               .update(this.V)
	               .update([ 0x01 ])
	               .update(seed)
	               .digest();
	  this.V = this._hmac().update(this.V).digest();
	};

	HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
	  // Optional entropy enc
	  if (typeof entropyEnc !== 'string') {
	    addEnc = add;
	    add = entropyEnc;
	    entropyEnc = null;
	  }

	  entropy = utils.toArray(entropy, entropyEnc);
	  add = utils.toArray(add, addEnc);

	  assert(entropy.length >= (this.minEntropy / 8),
	         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

	  this._update(entropy.concat(add || []));
	  this._reseed = 1;
	};

	HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
	  if (this._reseed > this.reseedInterval)
	    throw new Error('Reseed is required');

	  // Optional encoding
	  if (typeof enc !== 'string') {
	    addEnc = add;
	    add = enc;
	    enc = null;
	  }

	  // Optional additional data
	  if (add) {
	    add = utils.toArray(add, addEnc || 'hex');
	    this._update(add);
	  }

	  var temp = [];
	  while (temp.length < len) {
	    this.V = this._hmac().update(this.V).digest();
	    temp = temp.concat(this.V);
	  }

	  var res = temp.slice(0, len);
	  this._update(add);
	  this._reseed++;
	  return utils.encode(res, enc);
	};
	return hmacDrbg;
}

var key$3;
var hasRequiredKey$3;

function requireKey$3 () {
	if (hasRequiredKey$3) return key$3;
	hasRequiredKey$3 = 1;

	var BN = requireBn$4();
	var utils = requireUtils$2();
	var assert = utils.assert;

	function KeyPair(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	key$3 = KeyPair;

	KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair)
	    return pub;

	  return new KeyPair(ec, {
	    pub: pub,
	    pubEnc: enc,
	  });
	};

	KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair)
	    return priv;

	  return new KeyPair(ec, {
	    priv: priv,
	    privEnc: enc,
	  });
	};

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new BN(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    // Montgomery points only have an `x` coordinate.
	    // Weierstrass/Edwards points on the other hand have both `x` and
	    // `y` coordinates.
	    if (this.ec.curve.type === 'mont') {
	      assert(key.x, 'Need x coordinate');
	    } else if (this.ec.curve.type === 'short' ||
	               this.ec.curve.type === 'edwards') {
	      assert(key.x && key.y, 'Need both x and y coordinate');
	    }
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  if(!pub.validate()) {
	    assert(pub.validate(), 'public point not validated');
	  }
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};
	return key$3;
}

var signature$3;
var hasRequiredSignature$3;

function requireSignature$3 () {
	if (hasRequiredSignature$3) return signature$3;
	hasRequiredSignature$3 = 1;

	var BN = requireBn$4();

	var utils = requireUtils$2();
	var assert = utils.assert;

	function Signature(options, enc) {
	  if (options instanceof Signature)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert(options.r && options.s, 'Signature without r or s');
	  this.r = new BN(options.r, 16);
	  this.s = new BN(options.s, 16);
	  if (options.recoveryParam === undefined)
	    this.recoveryParam = null;
	  else
	    this.recoveryParam = options.recoveryParam;
	}
	signature$3 = Signature;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;

	  // Indefinite length or overflow
	  if (octetLen === 0 || octetLen > 4) {
	    return false;
	  }

	  if(buf[p.place] === 0x00) {
	    return false;
	  }

	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	    val >>>= 0;
	  }

	  // Leading zeroes
	  if (val <= 0x7f) {
	    return false;
	  }

	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if (len === false) {
	    return false;
	  }
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  if (rlen === false) {
	    return false;
	  }
	  if ((data[p.place] & 128) !== 0) {
	    return false;
	  }
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (slen === false) {
	    return false;
	  }
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  if ((data[p.place] & 128) !== 0) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0) {
	    if (r[1] & 0x80) {
	      r = r.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }
	  if (s[0] === 0) {
	    if (s[1] & 0x80) {
	      s = s.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }

	  this.r = new BN(r);
	  this.s = new BN(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils.encode(res, enc);
	};
	return signature$3;
}

var ec$1;
var hasRequiredEc$1;

function requireEc$1 () {
	if (hasRequiredEc$1) return ec$1;
	hasRequiredEc$1 = 1;

	var BN = requireBn$4();
	var HmacDRBG = requireHmacDrbg();
	var utils = requireUtils$2();
	var curves = requireCurves$1();
	var rand = requireBrorand();
	var assert = utils.assert;

	var KeyPair = requireKey$3();
	var Signature = requireSignature$3();

	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert(Object.prototype.hasOwnProperty.call(curves, options),
	      'Unknown curve ' + options);

	    options = curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.ushrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	ec$1 = EC;

	EC.prototype.keyPair = function keyPair(options) {
	  return new KeyPair(this, options);
	};

	EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
	  return KeyPair.fromPrivate(this, priv, enc);
	};

	EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
	  return KeyPair.fromPublic(this, pub, enc);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new HmacDRBG({
	    hash: this.hash,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	    entropy: options.entropy || rand(this.hash.hmacStrength),
	    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
	    nonce: this.n.toArray(),
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new BN(2));
	  for (;;) {
	    var priv = new BN(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyFromPrivate(priv);
	  }
	};

	EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.ushrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, enc, options) {
	  if (typeof enc === 'object') {
	    options = enc;
	    enc = null;
	  }
	  if (!options)
	    options = {};

	  key = this.keyFromPrivate(key, enc);
	  msg = this._truncateToN(new BN(msg, 16));

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray('be', bytes);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray('be', bytes);

	  // Instantiate Hmac_DRBG
	  var drbg = new HmacDRBG({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new BN(1));

	  for (var iter = 0; ; iter++) {
	    var k = options.k ?
	      options.k(iter) :
	      new BN(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var kpX = kp.getX();
	    var r = kpX.umod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
	    s = s.umod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
	                        (kpX.cmp(r) !== 0 ? 2 : 0);

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0) {
	      s = this.n.sub(s);
	      recoveryParam ^= 1;
	    }

	    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
	  }
	};

	EC.prototype.verify = function verify(msg, signature, key, enc) {
	  msg = this._truncateToN(new BN(msg, 16));
	  key = this.keyFromPublic(key, enc);
	  signature = new Signature(signature, 'hex');

	  // Perform primitive values validation
	  var r = signature.r;
	  var s = signature.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).umod(this.n);
	  var u2 = sinv.mul(r).umod(this.n);
	  var p;

	  if (!this.curve._maxwellTrick) {
	    p = this.g.mulAdd(u1, key.getPublic(), u2);
	    if (p.isInfinity())
	      return false;

	    return p.getX().umod(this.n).cmp(r) === 0;
	  }

	  // NOTE: Greg Maxwell's trick, inspired by:
	  // https://git.io/vad3K

	  p = this.g.jmulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  // Compare `p.x` of Jacobian point with `r`,
	  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
	  // inverse of `p.z^2`
	  return p.eqXToP(r);
	};

	EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
	  assert((3 & j) === j, 'The recovery param is more than two bits');
	  signature = new Signature(signature, enc);

	  var n = this.n;
	  var e = new BN(msg);
	  var r = signature.r;
	  var s = signature.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = j & 1;
	  var isSecondKey = j >> 1;
	  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
	    throw new Error('Unable to find sencond key candinate');

	  // 1.1. Let x = r + jn.
	  if (isSecondKey)
	    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
	  else
	    r = this.curve.pointFromX(r, isYOdd);

	  var rInv = signature.r.invm(n);
	  var s1 = n.sub(e).mul(rInv).umod(n);
	  var s2 = s.mul(rInv).umod(n);

	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  return this.g.mulAdd(s1, r, s2);
	};

	EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
	  signature = new Signature(signature, enc);
	  if (signature.recoveryParam !== null)
	    return signature.recoveryParam;

	  for (var i = 0; i < 4; i++) {
	    var Qprime;
	    try {
	      Qprime = this.recoverPubKey(e, signature, i);
	    } catch (e) {
	      continue;
	    }

	    if (Qprime.eq(Q))
	      return i;
	  }
	  throw new Error('Unable to find valid recovery factor');
	};
	return ec$1;
}

var key$2;
var hasRequiredKey$2;

function requireKey$2 () {
	if (hasRequiredKey$2) return key$2;
	hasRequiredKey$2 = 1;

	var utils = requireUtils$2();
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var cachedProperty = utils.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes(params.pub);
	}

	KeyPair.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair)
	    return pub;
	  return new KeyPair(eddsa, { pub: pub });
	};

	KeyPair.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair)
	    return secret;
	  return new KeyPair(eddsa, { secret: secret });
	};

	KeyPair.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty(KeyPair, 'pub', function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty(KeyPair, 'privBytes', function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty(KeyPair, 'priv', function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty(KeyPair, 'hash', function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair.prototype.sign = function sign(message) {
	  assert(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair.prototype.getSecret = function getSecret(enc) {
	  assert(this._secret, 'KeyPair is public only');
	  return utils.encode(this.secret(), enc);
	};

	KeyPair.prototype.getPublic = function getPublic(enc) {
	  return utils.encode(this.pubBytes(), enc);
	};

	key$2 = KeyPair;
	return key$2;
}

var signature$2;
var hasRequiredSignature$2;

function requireSignature$2 () {
	if (hasRequiredSignature$2) return signature$2;
	hasRequiredSignature$2 = 1;

	var BN = requireBn$4();
	var utils = requireUtils$2();
	var assert = utils.assert;
	var cachedProperty = utils.cachedProperty;
	var parseBytes = utils.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes(sig);

	  if (Array.isArray(sig)) {
	    assert(sig.length === eddsa.encodingLength * 2, 'Signature has invalid size');
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength),
	    };
	  }

	  assert(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof BN)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty(Signature, 'S', function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty(Signature, 'R', function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty(Signature, 'Rencoded', function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty(Signature, 'Sencoded', function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature.prototype.toHex = function toHex() {
	  return utils.encode(this.toBytes(), 'hex').toUpperCase();
	};

	signature$2 = Signature;
	return signature$2;
}

var eddsa$1;
var hasRequiredEddsa$1;

function requireEddsa$1 () {
	if (hasRequiredEddsa$1) return eddsa$1;
	hasRequiredEddsa$1 = 1;

	var hash = requireHash();
	var curves = requireCurves$1();
	var utils = requireUtils$2();
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var KeyPair = requireKey$2();
	var Signature = requireSignature$2();

	function EDDSA(curve) {
	  assert(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  curve = curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash.sha512;
	}

	eddsa$1 = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	    .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes(message);
	  sig = this.makeSignature(sig);
	  if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
	    return false;
	  }
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return KeyPair.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return KeyPair.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof Signature)
	    return sig;
	  return new Signature(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};
	return eddsa$1;
}

var hasRequiredElliptic$1;

function requireElliptic$1 () {
	if (hasRequiredElliptic$1) return elliptic$1;
	hasRequiredElliptic$1 = 1;
	(function (exports) {

		var elliptic = exports;

		elliptic.version = require$$0$1.version;
		elliptic.utils = requireUtils$2();
		elliptic.rand = requireBrorand();
		elliptic.curve = requireCurve$1();
		elliptic.curves = requireCurves$1();

		// Protocols
		elliptic.ec = requireEc$1();
		elliptic.eddsa = requireEddsa$1(); 
	} (elliptic$1));
	return elliptic$1;
}

var asn1$1 = {};

var asn1 = {};

var bn$7 = {exports: {}};

var bn$6 = bn$7.exports;

var hasRequiredBn$3;

function requireBn$3 () {
	if (hasRequiredBn$3) return bn$7.exports;
	hasRequiredBn$3 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$6); 
	} (bn$7));
	return bn$7.exports;
}

var api = {};

var vmBrowserify = {};

var hasRequiredVmBrowserify;

function requireVmBrowserify () {
	if (hasRequiredVmBrowserify) return vmBrowserify;
	hasRequiredVmBrowserify = 1;
	(function (exports) {
		var indexOf = function (xs, item) {
		    if (xs.indexOf) return xs.indexOf(item);
		    else for (var i = 0; i < xs.length; i++) {
		        if (xs[i] === item) return i;
		    }
		    return -1;
		};
		var Object_keys = function (obj) {
		    if (Object.keys) return Object.keys(obj)
		    else {
		        var res = [];
		        for (var key in obj) res.push(key);
		        return res;
		    }
		};

		var forEach = function (xs, fn) {
		    if (xs.forEach) return xs.forEach(fn)
		    else for (var i = 0; i < xs.length; i++) {
		        fn(xs[i], i, xs);
		    }
		};

		var defineProp = (function() {
		    try {
		        Object.defineProperty({}, '_', {});
		        return function(obj, name, value) {
		            Object.defineProperty(obj, name, {
		                writable: true,
		                enumerable: false,
		                configurable: true,
		                value: value
		            });
		        };
		    } catch(e) {
		        return function(obj, name, value) {
		            obj[name] = value;
		        };
		    }
		}());

		var globals = ['Array', 'Boolean', 'Date', 'Error', 'EvalError', 'Function',
		'Infinity', 'JSON', 'Math', 'NaN', 'Number', 'Object', 'RangeError',
		'ReferenceError', 'RegExp', 'String', 'SyntaxError', 'TypeError', 'URIError',
		'decodeURI', 'decodeURIComponent', 'encodeURI', 'encodeURIComponent', 'escape',
		'eval', 'isFinite', 'isNaN', 'parseFloat', 'parseInt', 'undefined', 'unescape'];

		function Context() {}
		Context.prototype = {};

		var Script = exports.Script = function NodeScript (code) {
		    if (!(this instanceof Script)) return new Script(code);
		    this.code = code;
		};

		Script.prototype.runInContext = function (context) {
		    if (!(context instanceof Context)) {
		        throw new TypeError("needs a 'context' argument.");
		    }
		    
		    var iframe = document.createElement('iframe');
		    if (!iframe.style) iframe.style = {};
		    iframe.style.display = 'none';
		    
		    document.body.appendChild(iframe);
		    
		    var win = iframe.contentWindow;
		    var wEval = win.eval, wExecScript = win.execScript;

		    if (!wEval && wExecScript) {
		        // win.eval() magically appears when this is called in IE:
		        wExecScript.call(win, 'null');
		        wEval = win.eval;
		    }
		    
		    forEach(Object_keys(context), function (key) {
		        win[key] = context[key];
		    });
		    forEach(globals, function (key) {
		        if (context[key]) {
		            win[key] = context[key];
		        }
		    });
		    
		    var winKeys = Object_keys(win);

		    var res = wEval.call(win, this.code);
		    
		    forEach(Object_keys(win), function (key) {
		        // Avoid copying circular objects like `top` and `window` by only
		        // updating existing context properties or new properties in the `win`
		        // that was only introduced after the eval.
		        if (key in context || indexOf(winKeys, key) === -1) {
		            context[key] = win[key];
		        }
		    });

		    forEach(globals, function (key) {
		        if (!(key in context)) {
		            defineProp(context, key, win[key]);
		        }
		    });
		    
		    document.body.removeChild(iframe);
		    
		    return res;
		};

		Script.prototype.runInThisContext = function () {
		    return eval(this.code); // maybe...
		};

		Script.prototype.runInNewContext = function (context) {
		    var ctx = Script.createContext(context);
		    var res = this.runInContext(ctx);

		    if (context) {
		        forEach(Object_keys(ctx), function (key) {
		            context[key] = ctx[key];
		        });
		    }

		    return res;
		};

		forEach(Object_keys(Script.prototype), function (name) {
		    exports[name] = Script[name] = function (code) {
		        var s = Script(code);
		        return s[name].apply(s, [].slice.call(arguments, 1));
		    };
		});

		exports.isContext = function (context) {
		    return context instanceof Context;
		};

		exports.createScript = function (code) {
		    return exports.Script(code);
		};

		exports.createContext = Script.createContext = function (context) {
		    var copy = new Context();
		    if(typeof context === 'object') {
		        forEach(Object_keys(context), function (key) {
		            copy[key] = context[key];
		        });
		    }
		    return copy;
		}; 
	} (vmBrowserify));
	return vmBrowserify;
}

var hasRequiredApi;

function requireApi () {
	if (hasRequiredApi) return api;
	hasRequiredApi = 1;
	(function (exports) {
		var asn1 = requireAsn1$1();
		var inherits = requireInherits_browser();

		var api = exports;

		api.define = function define(name, body) {
		  return new Entity(name, body);
		};

		function Entity(name, body) {
		  this.name = name;
		  this.body = body;

		  this.decoders = {};
		  this.encoders = {};
		}
		Entity.prototype._createNamed = function createNamed(base) {
		  var named;
		  try {
		    named = requireVmBrowserify().runInThisContext(
		      '(function ' + this.name + '(entity) {\n' +
		      '  this._initNamed(entity);\n' +
		      '})'
		    );
		  } catch (e) {
		    named = function (entity) {
		      this._initNamed(entity);
		    };
		  }
		  inherits(named, base);
		  named.prototype._initNamed = function initnamed(entity) {
		    base.call(this, entity);
		  };

		  return new named(this);
		};

		Entity.prototype._getDecoder = function _getDecoder(enc) {
		  enc = enc || 'der';
		  // Lazily create decoder
		  if (!this.decoders.hasOwnProperty(enc))
		    this.decoders[enc] = this._createNamed(asn1.decoders[enc]);
		  return this.decoders[enc];
		};

		Entity.prototype.decode = function decode(data, enc, options) {
		  return this._getDecoder(enc).decode(data, options);
		};

		Entity.prototype._getEncoder = function _getEncoder(enc) {
		  enc = enc || 'der';
		  // Lazily create encoder
		  if (!this.encoders.hasOwnProperty(enc))
		    this.encoders[enc] = this._createNamed(asn1.encoders[enc]);
		  return this.encoders[enc];
		};

		Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
		  return this._getEncoder(enc).encode(data, reporter);
		}; 
	} (api));
	return api;
}

var base$1 = {};

var reporter = {};

var hasRequiredReporter;

function requireReporter () {
	if (hasRequiredReporter) return reporter;
	hasRequiredReporter = 1;
	var inherits = requireInherits_browser();

	function Reporter(options) {
	  this._reporterState = {
	    obj: null,
	    path: [],
	    options: options || {},
	    errors: []
	  };
	}
	reporter.Reporter = Reporter;

	Reporter.prototype.isError = function isError(obj) {
	  return obj instanceof ReporterError;
	};

	Reporter.prototype.save = function save() {
	  var state = this._reporterState;

	  return { obj: state.obj, pathLen: state.path.length };
	};

	Reporter.prototype.restore = function restore(data) {
	  var state = this._reporterState;

	  state.obj = data.obj;
	  state.path = state.path.slice(0, data.pathLen);
	};

	Reporter.prototype.enterKey = function enterKey(key) {
	  return this._reporterState.path.push(key);
	};

	Reporter.prototype.exitKey = function exitKey(index) {
	  var state = this._reporterState;

	  state.path = state.path.slice(0, index - 1);
	};

	Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
	  var state = this._reporterState;

	  this.exitKey(index);
	  if (state.obj !== null)
	    state.obj[key] = value;
	};

	Reporter.prototype.path = function path() {
	  return this._reporterState.path.join('/');
	};

	Reporter.prototype.enterObject = function enterObject() {
	  var state = this._reporterState;

	  var prev = state.obj;
	  state.obj = {};
	  return prev;
	};

	Reporter.prototype.leaveObject = function leaveObject(prev) {
	  var state = this._reporterState;

	  var now = state.obj;
	  state.obj = prev;
	  return now;
	};

	Reporter.prototype.error = function error(msg) {
	  var err;
	  var state = this._reporterState;

	  var inherited = msg instanceof ReporterError;
	  if (inherited) {
	    err = msg;
	  } else {
	    err = new ReporterError(state.path.map(function(elem) {
	      return '[' + JSON.stringify(elem) + ']';
	    }).join(''), msg.message || msg, msg.stack);
	  }

	  if (!state.options.partial)
	    throw err;

	  if (!inherited)
	    state.errors.push(err);

	  return err;
	};

	Reporter.prototype.wrapResult = function wrapResult(result) {
	  var state = this._reporterState;
	  if (!state.options.partial)
	    return result;

	  return {
	    result: this.isError(result) ? null : result,
	    errors: state.errors
	  };
	};

	function ReporterError(path, msg) {
	  this.path = path;
	  this.rethrow(msg);
	}	inherits(ReporterError, Error);

	ReporterError.prototype.rethrow = function rethrow(msg) {
	  this.message = msg + ' at: ' + (this.path || '(shallow)');
	  if (Error.captureStackTrace)
	    Error.captureStackTrace(this, ReporterError);

	  if (!this.stack) {
	    try {
	      // IE only adds stack when thrown
	      throw new Error(this.message);
	    } catch (e) {
	      this.stack = e.stack;
	    }
	  }
	  return this;
	};
	return reporter;
}

var buffer = {};

var hasRequiredBuffer;

function requireBuffer () {
	if (hasRequiredBuffer) return buffer;
	hasRequiredBuffer = 1;
	var inherits = requireInherits_browser();
	var Reporter = requireBase$1().Reporter;
	var Buffer = requireDist().Buffer;

	function DecoderBuffer(base, options) {
	  Reporter.call(this, options);
	  if (!Buffer.isBuffer(base)) {
	    this.error('Input not Buffer');
	    return;
	  }

	  this.base = base;
	  this.offset = 0;
	  this.length = base.length;
	}
	inherits(DecoderBuffer, Reporter);
	buffer.DecoderBuffer = DecoderBuffer;

	DecoderBuffer.prototype.save = function save() {
	  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
	};

	DecoderBuffer.prototype.restore = function restore(save) {
	  // Return skipped data
	  var res = new DecoderBuffer(this.base);
	  res.offset = save.offset;
	  res.length = this.offset;

	  this.offset = save.offset;
	  Reporter.prototype.restore.call(this, save.reporter);

	  return res;
	};

	DecoderBuffer.prototype.isEmpty = function isEmpty() {
	  return this.offset === this.length;
	};

	DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
	  if (this.offset + 1 <= this.length)
	    return this.base.readUInt8(this.offset++, true);
	  else
	    return this.error(fail || 'DecoderBuffer overrun');
	};

	DecoderBuffer.prototype.skip = function skip(bytes, fail) {
	  if (!(this.offset + bytes <= this.length))
	    return this.error(fail || 'DecoderBuffer overrun');

	  var res = new DecoderBuffer(this.base);

	  // Share reporter state
	  res._reporterState = this._reporterState;

	  res.offset = this.offset;
	  res.length = this.offset + bytes;
	  this.offset += bytes;
	  return res;
	};

	DecoderBuffer.prototype.raw = function raw(save) {
	  return this.base.slice(save ? save.offset : this.offset, this.length);
	};

	function EncoderBuffer(value, reporter) {
	  if (Array.isArray(value)) {
	    this.length = 0;
	    this.value = value.map(function(item) {
	      if (!(item instanceof EncoderBuffer))
	        item = new EncoderBuffer(item, reporter);
	      this.length += item.length;
	      return item;
	    }, this);
	  } else if (typeof value === 'number') {
	    if (!(0 <= value && value <= 0xff))
	      return reporter.error('non-byte EncoderBuffer value');
	    this.value = value;
	    this.length = 1;
	  } else if (typeof value === 'string') {
	    this.value = value;
	    this.length = Buffer.byteLength(value);
	  } else if (Buffer.isBuffer(value)) {
	    this.value = value;
	    this.length = value.length;
	  } else {
	    return reporter.error('Unsupported type: ' + typeof value);
	  }
	}
	buffer.EncoderBuffer = EncoderBuffer;

	EncoderBuffer.prototype.join = function join(out, offset) {
	  if (!out)
	    out = new Buffer(this.length);
	  if (!offset)
	    offset = 0;

	  if (this.length === 0)
	    return out;

	  if (Array.isArray(this.value)) {
	    this.value.forEach(function(item) {
	      item.join(out, offset);
	      offset += item.length;
	    });
	  } else {
	    if (typeof this.value === 'number')
	      out[offset] = this.value;
	    else if (typeof this.value === 'string')
	      out.write(this.value, offset);
	    else if (Buffer.isBuffer(this.value))
	      this.value.copy(out, offset);
	    offset += this.length;
	  }

	  return out;
	};
	return buffer;
}

var node;
var hasRequiredNode;

function requireNode () {
	if (hasRequiredNode) return node;
	hasRequiredNode = 1;
	var Reporter = requireBase$1().Reporter;
	var EncoderBuffer = requireBase$1().EncoderBuffer;
	var DecoderBuffer = requireBase$1().DecoderBuffer;
	var assert = requireMinimalisticAssert();

	// Supported tags
	var tags = [
	  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
	  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
	  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
	  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
	];

	// Public methods list
	var methods = [
	  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
	  'any', 'contains'
	].concat(tags);

	// Overrided methods list
	var overrided = [
	  '_peekTag', '_decodeTag', '_use',
	  '_decodeStr', '_decodeObjid', '_decodeTime',
	  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

	  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
	  '_encodeNull', '_encodeInt', '_encodeBool'
	];

	function Node(enc, parent) {
	  var state = {};
	  this._baseState = state;

	  state.enc = enc;

	  state.parent = parent || null;
	  state.children = null;

	  // State
	  state.tag = null;
	  state.args = null;
	  state.reverseArgs = null;
	  state.choice = null;
	  state.optional = false;
	  state.any = false;
	  state.obj = false;
	  state.use = null;
	  state.useDecoder = null;
	  state.key = null;
	  state['default'] = null;
	  state.explicit = null;
	  state.implicit = null;
	  state.contains = null;

	  // Should create new instance on each method
	  if (!state.parent) {
	    state.children = [];
	    this._wrap();
	  }
	}
	node = Node;

	var stateProps = [
	  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
	  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
	  'implicit', 'contains'
	];

	Node.prototype.clone = function clone() {
	  var state = this._baseState;
	  var cstate = {};
	  stateProps.forEach(function(prop) {
	    cstate[prop] = state[prop];
	  });
	  var res = new this.constructor(cstate.parent);
	  res._baseState = cstate;
	  return res;
	};

	Node.prototype._wrap = function wrap() {
	  var state = this._baseState;
	  methods.forEach(function(method) {
	    this[method] = function _wrappedMethod() {
	      var clone = new this.constructor(this);
	      state.children.push(clone);
	      return clone[method].apply(clone, arguments);
	    };
	  }, this);
	};

	Node.prototype._init = function init(body) {
	  var state = this._baseState;

	  assert(state.parent === null);
	  body.call(this);

	  // Filter children
	  state.children = state.children.filter(function(child) {
	    return child._baseState.parent === this;
	  }, this);
	  assert.equal(state.children.length, 1, 'Root node can have only one child');
	};

	Node.prototype._useArgs = function useArgs(args) {
	  var state = this._baseState;

	  // Filter children and args
	  var children = args.filter(function(arg) {
	    return arg instanceof this.constructor;
	  }, this);
	  args = args.filter(function(arg) {
	    return !(arg instanceof this.constructor);
	  }, this);

	  if (children.length !== 0) {
	    assert(state.children === null);
	    state.children = children;

	    // Replace parent to maintain backward link
	    children.forEach(function(child) {
	      child._baseState.parent = this;
	    }, this);
	  }
	  if (args.length !== 0) {
	    assert(state.args === null);
	    state.args = args;
	    state.reverseArgs = args.map(function(arg) {
	      if (typeof arg !== 'object' || arg.constructor !== Object)
	        return arg;

	      var res = {};
	      Object.keys(arg).forEach(function(key) {
	        if (key == (key | 0))
	          key |= 0;
	        var value = arg[key];
	        res[value] = key;
	      });
	      return res;
	    });
	  }
	};

	//
	// Overrided methods
	//

	overrided.forEach(function(method) {
	  Node.prototype[method] = function _overrided() {
	    var state = this._baseState;
	    throw new Error(method + ' not implemented for encoding: ' + state.enc);
	  };
	});

	//
	// Public methods
	//

	tags.forEach(function(tag) {
	  Node.prototype[tag] = function _tagMethod() {
	    var state = this._baseState;
	    var args = Array.prototype.slice.call(arguments);

	    assert(state.tag === null);
	    state.tag = tag;

	    this._useArgs(args);

	    return this;
	  };
	});

	Node.prototype.use = function use(item) {
	  assert(item);
	  var state = this._baseState;

	  assert(state.use === null);
	  state.use = item;

	  return this;
	};

	Node.prototype.optional = function optional() {
	  var state = this._baseState;

	  state.optional = true;

	  return this;
	};

	Node.prototype.def = function def(val) {
	  var state = this._baseState;

	  assert(state['default'] === null);
	  state['default'] = val;
	  state.optional = true;

	  return this;
	};

	Node.prototype.explicit = function explicit(num) {
	  var state = this._baseState;

	  assert(state.explicit === null && state.implicit === null);
	  state.explicit = num;

	  return this;
	};

	Node.prototype.implicit = function implicit(num) {
	  var state = this._baseState;

	  assert(state.explicit === null && state.implicit === null);
	  state.implicit = num;

	  return this;
	};

	Node.prototype.obj = function obj() {
	  var state = this._baseState;
	  var args = Array.prototype.slice.call(arguments);

	  state.obj = true;

	  if (args.length !== 0)
	    this._useArgs(args);

	  return this;
	};

	Node.prototype.key = function key(newKey) {
	  var state = this._baseState;

	  assert(state.key === null);
	  state.key = newKey;

	  return this;
	};

	Node.prototype.any = function any() {
	  var state = this._baseState;

	  state.any = true;

	  return this;
	};

	Node.prototype.choice = function choice(obj) {
	  var state = this._baseState;

	  assert(state.choice === null);
	  state.choice = obj;
	  this._useArgs(Object.keys(obj).map(function(key) {
	    return obj[key];
	  }));

	  return this;
	};

	Node.prototype.contains = function contains(item) {
	  var state = this._baseState;

	  assert(state.use === null);
	  state.contains = item;

	  return this;
	};

	//
	// Decoding
	//

	Node.prototype._decode = function decode(input, options) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return input.wrapResult(state.children[0]._decode(input, options));

	  var result = state['default'];
	  var present = true;

	  var prevKey = null;
	  if (state.key !== null)
	    prevKey = input.enterKey(state.key);

	  // Check if tag is there
	  if (state.optional) {
	    var tag = null;
	    if (state.explicit !== null)
	      tag = state.explicit;
	    else if (state.implicit !== null)
	      tag = state.implicit;
	    else if (state.tag !== null)
	      tag = state.tag;

	    if (tag === null && !state.any) {
	      // Trial and Error
	      var save = input.save();
	      try {
	        if (state.choice === null)
	          this._decodeGeneric(state.tag, input, options);
	        else
	          this._decodeChoice(input, options);
	        present = true;
	      } catch (e) {
	        present = false;
	      }
	      input.restore(save);
	    } else {
	      present = this._peekTag(input, tag, state.any);

	      if (input.isError(present))
	        return present;
	    }
	  }

	  // Push object on stack
	  var prevObj;
	  if (state.obj && present)
	    prevObj = input.enterObject();

	  if (present) {
	    // Unwrap explicit values
	    if (state.explicit !== null) {
	      var explicit = this._decodeTag(input, state.explicit);
	      if (input.isError(explicit))
	        return explicit;
	      input = explicit;
	    }

	    var start = input.offset;

	    // Unwrap implicit and normal values
	    if (state.use === null && state.choice === null) {
	      if (state.any)
	        var save = input.save();
	      var body = this._decodeTag(
	        input,
	        state.implicit !== null ? state.implicit : state.tag,
	        state.any
	      );
	      if (input.isError(body))
	        return body;

	      if (state.any)
	        result = input.raw(save);
	      else
	        input = body;
	    }

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), start, input.length, 'tagged');

	    if (options && options.track && state.tag !== null)
	      options.track(input.path(), input.offset, input.length, 'content');

	    // Select proper method for tag
	    if (state.any)
	      result = result;
	    else if (state.choice === null)
	      result = this._decodeGeneric(state.tag, input, options);
	    else
	      result = this._decodeChoice(input, options);

	    if (input.isError(result))
	      return result;

	    // Decode children
	    if (!state.any && state.choice === null && state.children !== null) {
	      state.children.forEach(function decodeChildren(child) {
	        // NOTE: We are ignoring errors here, to let parser continue with other
	        // parts of encoded data
	        child._decode(input, options);
	      });
	    }

	    // Decode contained/encoded by schema, only in bit or octet strings
	    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
	      var data = new DecoderBuffer(result);
	      result = this._getUse(state.contains, input._reporterState.obj)
	          ._decode(data, options);
	    }
	  }

	  // Pop object
	  if (state.obj && present)
	    result = input.leaveObject(prevObj);

	  // Set key
	  if (state.key !== null && (result !== null || present === true))
	    input.leaveKey(prevKey, state.key, result);
	  else if (prevKey !== null)
	    input.exitKey(prevKey);

	  return result;
	};

	Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
	  var state = this._baseState;

	  if (tag === 'seq' || tag === 'set')
	    return null;
	  if (tag === 'seqof' || tag === 'setof')
	    return this._decodeList(input, tag, state.args[0], options);
	  else if (/str$/.test(tag))
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'objid' && state.args)
	    return this._decodeObjid(input, state.args[0], state.args[1], options);
	  else if (tag === 'objid')
	    return this._decodeObjid(input, null, null, options);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._decodeTime(input, tag, options);
	  else if (tag === 'null_')
	    return this._decodeNull(input, options);
	  else if (tag === 'bool')
	    return this._decodeBool(input, options);
	  else if (tag === 'objDesc')
	    return this._decodeStr(input, tag, options);
	  else if (tag === 'int' || tag === 'enum')
	    return this._decodeInt(input, state.args && state.args[0], options);

	  if (state.use !== null) {
	    return this._getUse(state.use, input._reporterState.obj)
	        ._decode(input, options);
	  } else {
	    return input.error('unknown tag: ' + tag);
	  }
	};

	Node.prototype._getUse = function _getUse(entity, obj) {

	  var state = this._baseState;
	  // Create altered use decoder if implicit is set
	  state.useDecoder = this._use(entity, obj);
	  assert(state.useDecoder._baseState.parent === null);
	  state.useDecoder = state.useDecoder._baseState.children[0];
	  if (state.implicit !== state.useDecoder._baseState.implicit) {
	    state.useDecoder = state.useDecoder.clone();
	    state.useDecoder._baseState.implicit = state.implicit;
	  }
	  return state.useDecoder;
	};

	Node.prototype._decodeChoice = function decodeChoice(input, options) {
	  var state = this._baseState;
	  var result = null;
	  var match = false;

	  Object.keys(state.choice).some(function(key) {
	    var save = input.save();
	    var node = state.choice[key];
	    try {
	      var value = node._decode(input, options);
	      if (input.isError(value))
	        return false;

	      result = { type: key, value: value };
	      match = true;
	    } catch (e) {
	      input.restore(save);
	      return false;
	    }
	    return true;
	  }, this);

	  if (!match)
	    return input.error('Choice not matched');

	  return result;
	};

	//
	// Encoding
	//

	Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
	  return new EncoderBuffer(data, this.reporter);
	};

	Node.prototype._encode = function encode(data, reporter, parent) {
	  var state = this._baseState;
	  if (state['default'] !== null && state['default'] === data)
	    return;

	  var result = this._encodeValue(data, reporter, parent);
	  if (result === undefined)
	    return;

	  if (this._skipDefault(result, reporter, parent))
	    return;

	  return result;
	};

	Node.prototype._encodeValue = function encode(data, reporter, parent) {
	  var state = this._baseState;

	  // Decode root node
	  if (state.parent === null)
	    return state.children[0]._encode(data, reporter || new Reporter());

	  var result = null;

	  // Set reporter to share it with a child class
	  this.reporter = reporter;

	  // Check if data is there
	  if (state.optional && data === undefined) {
	    if (state['default'] !== null)
	      data = state['default'];
	    else
	      return;
	  }

	  // Encode children first
	  var content = null;
	  var primitive = false;
	  if (state.any) {
	    // Anything that was given is translated to buffer
	    result = this._createEncoderBuffer(data);
	  } else if (state.choice) {
	    result = this._encodeChoice(data, reporter);
	  } else if (state.contains) {
	    content = this._getUse(state.contains, parent)._encode(data, reporter);
	    primitive = true;
	  } else if (state.children) {
	    content = state.children.map(function(child) {
	      if (child._baseState.tag === 'null_')
	        return child._encode(null, reporter, data);

	      if (child._baseState.key === null)
	        return reporter.error('Child should have a key');
	      var prevKey = reporter.enterKey(child._baseState.key);

	      if (typeof data !== 'object')
	        return reporter.error('Child expected, but input is not object');

	      var res = child._encode(data[child._baseState.key], reporter, data);
	      reporter.leaveKey(prevKey);

	      return res;
	    }, this).filter(function(child) {
	      return child;
	    });
	    content = this._createEncoderBuffer(content);
	  } else {
	    if (state.tag === 'seqof' || state.tag === 'setof') {
	      // TODO(indutny): this should be thrown on DSL level
	      if (!(state.args && state.args.length === 1))
	        return reporter.error('Too many args for : ' + state.tag);

	      if (!Array.isArray(data))
	        return reporter.error('seqof/setof, but data is not Array');

	      var child = this.clone();
	      child._baseState.implicit = null;
	      content = this._createEncoderBuffer(data.map(function(item) {
	        var state = this._baseState;

	        return this._getUse(state.args[0], data)._encode(item, reporter);
	      }, child));
	    } else if (state.use !== null) {
	      result = this._getUse(state.use, parent)._encode(data, reporter);
	    } else {
	      content = this._encodePrimitive(state.tag, data);
	      primitive = true;
	    }
	  }

	  // Encode data itself
	  var result;
	  if (!state.any && state.choice === null) {
	    var tag = state.implicit !== null ? state.implicit : state.tag;
	    var cls = state.implicit === null ? 'universal' : 'context';

	    if (tag === null) {
	      if (state.use === null)
	        reporter.error('Tag could be omitted only for .use()');
	    } else {
	      if (state.use === null)
	        result = this._encodeComposite(tag, primitive, cls, content);
	    }
	  }

	  // Wrap in explicit
	  if (state.explicit !== null)
	    result = this._encodeComposite(state.explicit, false, 'context', result);

	  return result;
	};

	Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
	  var state = this._baseState;

	  var node = state.choice[data.type];
	  if (!node) {
	    assert(
	        false,
	        data.type + ' not found in ' +
	            JSON.stringify(Object.keys(state.choice)));
	  }
	  return node._encode(data.value, reporter);
	};

	Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
	  var state = this._baseState;

	  if (/str$/.test(tag))
	    return this._encodeStr(data, tag);
	  else if (tag === 'objid' && state.args)
	    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
	  else if (tag === 'objid')
	    return this._encodeObjid(data, null, null);
	  else if (tag === 'gentime' || tag === 'utctime')
	    return this._encodeTime(data, tag);
	  else if (tag === 'null_')
	    return this._encodeNull();
	  else if (tag === 'int' || tag === 'enum')
	    return this._encodeInt(data, state.args && state.reverseArgs[0]);
	  else if (tag === 'bool')
	    return this._encodeBool(data);
	  else if (tag === 'objDesc')
	    return this._encodeStr(data, tag);
	  else
	    throw new Error('Unsupported tag: ' + tag);
	};

	Node.prototype._isNumstr = function isNumstr(str) {
	  return /^[0-9 ]*$/.test(str);
	};

	Node.prototype._isPrintstr = function isPrintstr(str) {
	  return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(str);
	};
	return node;
}

var hasRequiredBase$1;

function requireBase$1 () {
	if (hasRequiredBase$1) return base$1;
	hasRequiredBase$1 = 1;
	(function (exports) {
		var base = exports;

		base.Reporter = requireReporter().Reporter;
		base.DecoderBuffer = requireBuffer().DecoderBuffer;
		base.EncoderBuffer = requireBuffer().EncoderBuffer;
		base.Node = requireNode(); 
	} (base$1));
	return base$1;
}

var constants = {};

var der = {};

var hasRequiredDer$2;

function requireDer$2 () {
	if (hasRequiredDer$2) return der;
	hasRequiredDer$2 = 1;
	(function (exports) {
		var constants = requireConstants();

		exports.tagClass = {
		  0: 'universal',
		  1: 'application',
		  2: 'context',
		  3: 'private'
		};
		exports.tagClassByName = constants._reverse(exports.tagClass);

		exports.tag = {
		  0x00: 'end',
		  0x01: 'bool',
		  0x02: 'int',
		  0x03: 'bitstr',
		  0x04: 'octstr',
		  0x05: 'null_',
		  0x06: 'objid',
		  0x07: 'objDesc',
		  0x08: 'external',
		  0x09: 'real',
		  0x0a: 'enum',
		  0x0b: 'embed',
		  0x0c: 'utf8str',
		  0x0d: 'relativeOid',
		  0x10: 'seq',
		  0x11: 'set',
		  0x12: 'numstr',
		  0x13: 'printstr',
		  0x14: 't61str',
		  0x15: 'videostr',
		  0x16: 'ia5str',
		  0x17: 'utctime',
		  0x18: 'gentime',
		  0x19: 'graphstr',
		  0x1a: 'iso646str',
		  0x1b: 'genstr',
		  0x1c: 'unistr',
		  0x1d: 'charstr',
		  0x1e: 'bmpstr'
		};
		exports.tagByName = constants._reverse(exports.tag); 
	} (der));
	return der;
}

var hasRequiredConstants;

function requireConstants () {
	if (hasRequiredConstants) return constants;
	hasRequiredConstants = 1;
	(function (exports) {
		var constants = exports;

		// Helper
		constants._reverse = function reverse(map) {
		  var res = {};

		  Object.keys(map).forEach(function(key) {
		    // Convert key to integer if it is stringified
		    if ((key | 0) == key)
		      key = key | 0;

		    var value = map[key];
		    res[value] = key;
		  });

		  return res;
		};

		constants.der = requireDer$2(); 
	} (constants));
	return constants;
}

var decoders = {};

var der_1$1;
var hasRequiredDer$1;

function requireDer$1 () {
	if (hasRequiredDer$1) return der_1$1;
	hasRequiredDer$1 = 1;
	var inherits = requireInherits_browser();

	var asn1 = requireAsn1$1();
	var base = asn1.base;
	var bignum = asn1.bignum;

	// Import DER constants
	var der = asn1.constants.der;

	function DERDecoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	}	der_1$1 = DERDecoder;

	DERDecoder.prototype.decode = function decode(data, options) {
	  if (!(data instanceof base.DecoderBuffer))
	    data = new base.DecoderBuffer(data, options);

	  return this.tree._decode(data, options);
	};

	// Tree methods

	function DERNode(parent) {
	  base.Node.call(this, 'der', parent);
	}
	inherits(DERNode, base.Node);

	DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
	  if (buffer.isEmpty())
	    return false;

	  var state = buffer.save();
	  var decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  buffer.restore(state);

	  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
	    (decodedTag.tagStr + 'of') === tag || any;
	};

	DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
	  var decodedTag = derDecodeTag(buffer,
	                                'Failed to decode tag of "' + tag + '"');
	  if (buffer.isError(decodedTag))
	    return decodedTag;

	  var len = derDecodeLen(buffer,
	                         decodedTag.primitive,
	                         'Failed to get length of "' + tag + '"');

	  // Failure
	  if (buffer.isError(len))
	    return len;

	  if (!any &&
	      decodedTag.tag !== tag &&
	      decodedTag.tagStr !== tag &&
	      decodedTag.tagStr + 'of' !== tag) {
	    return buffer.error('Failed to match tag: "' + tag + '"');
	  }

	  if (decodedTag.primitive || len !== null)
	    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

	  // Indefinite length... find END tag
	  var state = buffer.save();
	  var res = this._skipUntilEnd(
	      buffer,
	      'Failed to skip indefinite length body: "' + this.tag + '"');
	  if (buffer.isError(res))
	    return res;

	  len = buffer.offset - state.offset;
	  buffer.restore(state);
	  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
	};

	DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
	  while (true) {
	    var tag = derDecodeTag(buffer, fail);
	    if (buffer.isError(tag))
	      return tag;
	    var len = derDecodeLen(buffer, tag.primitive, fail);
	    if (buffer.isError(len))
	      return len;

	    var res;
	    if (tag.primitive || len !== null)
	      res = buffer.skip(len);
	    else
	      res = this._skipUntilEnd(buffer, fail);

	    // Failure
	    if (buffer.isError(res))
	      return res;

	    if (tag.tagStr === 'end')
	      break;
	  }
	};

	DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
	                                                    options) {
	  var result = [];
	  while (!buffer.isEmpty()) {
	    var possibleEnd = this._peekTag(buffer, 'end');
	    if (buffer.isError(possibleEnd))
	      return possibleEnd;

	    var res = decoder.decode(buffer, 'der', options);
	    if (buffer.isError(res) && possibleEnd)
	      break;
	    result.push(res);
	  }
	  return result;
	};

	DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
	  if (tag === 'bitstr') {
	    var unused = buffer.readUInt8();
	    if (buffer.isError(unused))
	      return unused;
	    return { unused: unused, data: buffer.raw() };
	  } else if (tag === 'bmpstr') {
	    var raw = buffer.raw();
	    if (raw.length % 2 === 1)
	      return buffer.error('Decoding of string type: bmpstr length mismatch');

	    var str = '';
	    for (var i = 0; i < raw.length / 2; i++) {
	      str += String.fromCharCode(raw.readUInt16BE(i * 2));
	    }
	    return str;
	  } else if (tag === 'numstr') {
	    var numstr = buffer.raw().toString('ascii');
	    if (!this._isNumstr(numstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'numstr unsupported characters');
	    }
	    return numstr;
	  } else if (tag === 'octstr') {
	    return buffer.raw();
	  } else if (tag === 'objDesc') {
	    return buffer.raw();
	  } else if (tag === 'printstr') {
	    var printstr = buffer.raw().toString('ascii');
	    if (!this._isPrintstr(printstr)) {
	      return buffer.error('Decoding of string type: ' +
	                          'printstr unsupported characters');
	    }
	    return printstr;
	  } else if (/str$/.test(tag)) {
	    return buffer.raw().toString();
	  } else {
	    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
	  }
	};

	DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
	  var result;
	  var identifiers = [];
	  var ident = 0;
	  while (!buffer.isEmpty()) {
	    var subident = buffer.readUInt8();
	    ident <<= 7;
	    ident |= subident & 0x7f;
	    if ((subident & 0x80) === 0) {
	      identifiers.push(ident);
	      ident = 0;
	    }
	  }
	  if (subident & 0x80)
	    identifiers.push(ident);

	  var first = (identifiers[0] / 40) | 0;
	  var second = identifiers[0] % 40;

	  if (relative)
	    result = identifiers;
	  else
	    result = [first, second].concat(identifiers.slice(1));

	  if (values) {
	    var tmp = values[result.join(' ')];
	    if (tmp === undefined)
	      tmp = values[result.join('.')];
	    if (tmp !== undefined)
	      result = tmp;
	  }

	  return result;
	};

	DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
	  var str = buffer.raw().toString();
	  if (tag === 'gentime') {
	    var year = str.slice(0, 4) | 0;
	    var mon = str.slice(4, 6) | 0;
	    var day = str.slice(6, 8) | 0;
	    var hour = str.slice(8, 10) | 0;
	    var min = str.slice(10, 12) | 0;
	    var sec = str.slice(12, 14) | 0;
	  } else if (tag === 'utctime') {
	    var year = str.slice(0, 2) | 0;
	    var mon = str.slice(2, 4) | 0;
	    var day = str.slice(4, 6) | 0;
	    var hour = str.slice(6, 8) | 0;
	    var min = str.slice(8, 10) | 0;
	    var sec = str.slice(10, 12) | 0;
	    if (year < 70)
	      year = 2000 + year;
	    else
	      year = 1900 + year;
	  } else {
	    return buffer.error('Decoding ' + tag + ' time is not supported yet');
	  }

	  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
	};

	DERNode.prototype._decodeNull = function decodeNull(buffer) {
	  return null;
	};

	DERNode.prototype._decodeBool = function decodeBool(buffer) {
	  var res = buffer.readUInt8();
	  if (buffer.isError(res))
	    return res;
	  else
	    return res !== 0;
	};

	DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
	  // Bigint, return as it is (assume big endian)
	  var raw = buffer.raw();
	  var res = new bignum(raw);

	  if (values)
	    res = values[res.toString(10)] || res;

	  return res;
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getDecoder('der').tree;
	};

	// Utility methods

	function derDecodeTag(buf, fail) {
	  var tag = buf.readUInt8(fail);
	  if (buf.isError(tag))
	    return tag;

	  var cls = der.tagClass[tag >> 6];
	  var primitive = (tag & 0x20) === 0;

	  // Multi-octet tag - load
	  if ((tag & 0x1f) === 0x1f) {
	    var oct = tag;
	    tag = 0;
	    while ((oct & 0x80) === 0x80) {
	      oct = buf.readUInt8(fail);
	      if (buf.isError(oct))
	        return oct;

	      tag <<= 7;
	      tag |= oct & 0x7f;
	    }
	  } else {
	    tag &= 0x1f;
	  }
	  var tagStr = der.tag[tag];

	  return {
	    cls: cls,
	    primitive: primitive,
	    tag: tag,
	    tagStr: tagStr
	  };
	}

	function derDecodeLen(buf, primitive, fail) {
	  var len = buf.readUInt8(fail);
	  if (buf.isError(len))
	    return len;

	  // Indefinite form
	  if (!primitive && len === 0x80)
	    return null;

	  // Definite form
	  if ((len & 0x80) === 0) {
	    // Short form
	    return len;
	  }

	  // Long form
	  var num = len & 0x7f;
	  if (num > 4)
	    return buf.error('length octect is too long');

	  len = 0;
	  for (var i = 0; i < num; i++) {
	    len <<= 8;
	    var j = buf.readUInt8(fail);
	    if (buf.isError(j))
	      return j;
	    len |= j;
	  }

	  return len;
	}
	return der_1$1;
}

var pem$1;
var hasRequiredPem$1;

function requirePem$1 () {
	if (hasRequiredPem$1) return pem$1;
	hasRequiredPem$1 = 1;
	var inherits = requireInherits_browser();
	var Buffer = requireDist().Buffer;

	var DERDecoder = requireDer$1();

	function PEMDecoder(entity) {
	  DERDecoder.call(this, entity);
	  this.enc = 'pem';
	}	inherits(PEMDecoder, DERDecoder);
	pem$1 = PEMDecoder;

	PEMDecoder.prototype.decode = function decode(data, options) {
	  var lines = data.toString().split(/[\r\n]+/g);

	  var label = options.label.toUpperCase();

	  var re = /^-----(BEGIN|END) ([^-]+)-----$/;
	  var start = -1;
	  var end = -1;
	  for (var i = 0; i < lines.length; i++) {
	    var match = lines[i].match(re);
	    if (match === null)
	      continue;

	    if (match[2] !== label)
	      continue;

	    if (start === -1) {
	      if (match[1] !== 'BEGIN')
	        break;
	      start = i;
	    } else {
	      if (match[1] !== 'END')
	        break;
	      end = i;
	      break;
	    }
	  }
	  if (start === -1 || end === -1)
	    throw new Error('PEM section not found for: ' + label);

	  var base64 = lines.slice(start + 1, end).join('');
	  // Remove excessive symbols
	  base64.replace(/[^a-z0-9\+\/=]+/gi, '');

	  var input = new Buffer(base64, 'base64');
	  return DERDecoder.prototype.decode.call(this, input, options);
	};
	return pem$1;
}

var hasRequiredDecoders;

function requireDecoders () {
	if (hasRequiredDecoders) return decoders;
	hasRequiredDecoders = 1;
	(function (exports) {
		var decoders = exports;

		decoders.der = requireDer$1();
		decoders.pem = requirePem$1(); 
	} (decoders));
	return decoders;
}

var encoders = {};

var der_1;
var hasRequiredDer;

function requireDer () {
	if (hasRequiredDer) return der_1;
	hasRequiredDer = 1;
	var inherits = requireInherits_browser();
	var Buffer = requireDist().Buffer;

	var asn1 = requireAsn1$1();
	var base = asn1.base;

	// Import DER constants
	var der = asn1.constants.der;

	function DEREncoder(entity) {
	  this.enc = 'der';
	  this.name = entity.name;
	  this.entity = entity;

	  // Construct base tree
	  this.tree = new DERNode();
	  this.tree._init(entity.body);
	}	der_1 = DEREncoder;

	DEREncoder.prototype.encode = function encode(data, reporter) {
	  return this.tree._encode(data, reporter).join();
	};

	// Tree methods

	function DERNode(parent) {
	  base.Node.call(this, 'der', parent);
	}
	inherits(DERNode, base.Node);

	DERNode.prototype._encodeComposite = function encodeComposite(tag,
	                                                              primitive,
	                                                              cls,
	                                                              content) {
	  var encodedTag = encodeTag(tag, primitive, cls, this.reporter);

	  // Short form
	  if (content.length < 0x80) {
	    var header = new Buffer(2);
	    header[0] = encodedTag;
	    header[1] = content.length;
	    return this._createEncoderBuffer([ header, content ]);
	  }

	  // Long form
	  // Count octets required to store length
	  var lenOctets = 1;
	  for (var i = content.length; i >= 0x100; i >>= 8)
	    lenOctets++;

	  var header = new Buffer(1 + 1 + lenOctets);
	  header[0] = encodedTag;
	  header[1] = 0x80 | lenOctets;

	  for (var i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
	    header[i] = j & 0xff;

	  return this._createEncoderBuffer([ header, content ]);
	};

	DERNode.prototype._encodeStr = function encodeStr(str, tag) {
	  if (tag === 'bitstr') {
	    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
	  } else if (tag === 'bmpstr') {
	    var buf = new Buffer(str.length * 2);
	    for (var i = 0; i < str.length; i++) {
	      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
	    }
	    return this._createEncoderBuffer(buf);
	  } else if (tag === 'numstr') {
	    if (!this._isNumstr(str)) {
	      return this.reporter.error('Encoding of string type: numstr supports ' +
	                                 'only digits and space');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'printstr') {
	    if (!this._isPrintstr(str)) {
	      return this.reporter.error('Encoding of string type: printstr supports ' +
	                                 'only latin upper and lower case letters, ' +
	                                 'digits, space, apostrophe, left and rigth ' +
	                                 'parenthesis, plus sign, comma, hyphen, ' +
	                                 'dot, slash, colon, equal sign, ' +
	                                 'question mark');
	    }
	    return this._createEncoderBuffer(str);
	  } else if (/str$/.test(tag)) {
	    return this._createEncoderBuffer(str);
	  } else if (tag === 'objDesc') {
	    return this._createEncoderBuffer(str);
	  } else {
	    return this.reporter.error('Encoding of string type: ' + tag +
	                               ' unsupported');
	  }
	};

	DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
	  if (typeof id === 'string') {
	    if (!values)
	      return this.reporter.error('string objid given, but no values map found');
	    if (!values.hasOwnProperty(id))
	      return this.reporter.error('objid not found in values map');
	    id = values[id].split(/[\s\.]+/g);
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  } else if (Array.isArray(id)) {
	    id = id.slice();
	    for (var i = 0; i < id.length; i++)
	      id[i] |= 0;
	  }

	  if (!Array.isArray(id)) {
	    return this.reporter.error('objid() should be either array or string, ' +
	                               'got: ' + JSON.stringify(id));
	  }

	  if (!relative) {
	    if (id[1] >= 40)
	      return this.reporter.error('Second objid identifier OOB');
	    id.splice(0, 2, id[0] * 40 + id[1]);
	  }

	  // Count number of octets
	  var size = 0;
	  for (var i = 0; i < id.length; i++) {
	    var ident = id[i];
	    for (size++; ident >= 0x80; ident >>= 7)
	      size++;
	  }

	  var objid = new Buffer(size);
	  var offset = objid.length - 1;
	  for (var i = id.length - 1; i >= 0; i--) {
	    var ident = id[i];
	    objid[offset--] = ident & 0x7f;
	    while ((ident >>= 7) > 0)
	      objid[offset--] = 0x80 | (ident & 0x7f);
	  }

	  return this._createEncoderBuffer(objid);
	};

	function two(num) {
	  if (num < 10)
	    return '0' + num;
	  else
	    return num;
	}

	DERNode.prototype._encodeTime = function encodeTime(time, tag) {
	  var str;
	  var date = new Date(time);

	  if (tag === 'gentime') {
	    str = [
	      two(date.getFullYear()),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else if (tag === 'utctime') {
	    str = [
	      two(date.getFullYear() % 100),
	      two(date.getUTCMonth() + 1),
	      two(date.getUTCDate()),
	      two(date.getUTCHours()),
	      two(date.getUTCMinutes()),
	      two(date.getUTCSeconds()),
	      'Z'
	    ].join('');
	  } else {
	    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
	  }

	  return this._encodeStr(str, 'octstr');
	};

	DERNode.prototype._encodeNull = function encodeNull() {
	  return this._createEncoderBuffer('');
	};

	DERNode.prototype._encodeInt = function encodeInt(num, values) {
	  if (typeof num === 'string') {
	    if (!values)
	      return this.reporter.error('String int or enum given, but no values map');
	    if (!values.hasOwnProperty(num)) {
	      return this.reporter.error('Values map doesn\'t contain: ' +
	                                 JSON.stringify(num));
	    }
	    num = values[num];
	  }

	  // Bignum, assume big endian
	  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
	    var numArray = num.toArray();
	    if (!num.sign && numArray[0] & 0x80) {
	      numArray.unshift(0);
	    }
	    num = new Buffer(numArray);
	  }

	  if (Buffer.isBuffer(num)) {
	    var size = num.length;
	    if (num.length === 0)
	      size++;

	    var out = new Buffer(size);
	    num.copy(out);
	    if (num.length === 0)
	      out[0] = 0;
	    return this._createEncoderBuffer(out);
	  }

	  if (num < 0x80)
	    return this._createEncoderBuffer(num);

	  if (num < 0x100)
	    return this._createEncoderBuffer([0, num]);

	  var size = 1;
	  for (var i = num; i >= 0x100; i >>= 8)
	    size++;

	  var out = new Array(size);
	  for (var i = out.length - 1; i >= 0; i--) {
	    out[i] = num & 0xff;
	    num >>= 8;
	  }
	  if(out[0] & 0x80) {
	    out.unshift(0);
	  }

	  return this._createEncoderBuffer(new Buffer(out));
	};

	DERNode.prototype._encodeBool = function encodeBool(value) {
	  return this._createEncoderBuffer(value ? 0xff : 0);
	};

	DERNode.prototype._use = function use(entity, obj) {
	  if (typeof entity === 'function')
	    entity = entity(obj);
	  return entity._getEncoder('der').tree;
	};

	DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
	  var state = this._baseState;
	  var i;
	  if (state['default'] === null)
	    return false;

	  var data = dataBuffer.join();
	  if (state.defaultBuffer === undefined)
	    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

	  if (data.length !== state.defaultBuffer.length)
	    return false;

	  for (i=0; i < data.length; i++)
	    if (data[i] !== state.defaultBuffer[i])
	      return false;

	  return true;
	};

	// Utility methods

	function encodeTag(tag, primitive, cls, reporter) {
	  var res;

	  if (tag === 'seqof')
	    tag = 'seq';
	  else if (tag === 'setof')
	    tag = 'set';

	  if (der.tagByName.hasOwnProperty(tag))
	    res = der.tagByName[tag];
	  else if (typeof tag === 'number' && (tag | 0) === tag)
	    res = tag;
	  else
	    return reporter.error('Unknown tag: ' + tag);

	  if (res >= 0x1f)
	    return reporter.error('Multi-octet tag encoding unsupported');

	  if (!primitive)
	    res |= 0x20;

	  res |= (der.tagClassByName[cls || 'universal'] << 6);

	  return res;
	}
	return der_1;
}

var pem;
var hasRequiredPem;

function requirePem () {
	if (hasRequiredPem) return pem;
	hasRequiredPem = 1;
	var inherits = requireInherits_browser();

	var DEREncoder = requireDer();

	function PEMEncoder(entity) {
	  DEREncoder.call(this, entity);
	  this.enc = 'pem';
	}	inherits(PEMEncoder, DEREncoder);
	pem = PEMEncoder;

	PEMEncoder.prototype.encode = function encode(data, options) {
	  var buf = DEREncoder.prototype.encode.call(this, data);

	  var p = buf.toString('base64');
	  var out = [ '-----BEGIN ' + options.label + '-----' ];
	  for (var i = 0; i < p.length; i += 64)
	    out.push(p.slice(i, i + 64));
	  out.push('-----END ' + options.label + '-----');
	  return out.join('\n');
	};
	return pem;
}

var hasRequiredEncoders;

function requireEncoders () {
	if (hasRequiredEncoders) return encoders;
	hasRequiredEncoders = 1;
	(function (exports) {
		var encoders = exports;

		encoders.der = requireDer();
		encoders.pem = requirePem(); 
	} (encoders));
	return encoders;
}

var hasRequiredAsn1$1;

function requireAsn1$1 () {
	if (hasRequiredAsn1$1) return asn1;
	hasRequiredAsn1$1 = 1;
	(function (exports) {
		var asn1 = exports;

		asn1.bignum = requireBn$3();

		asn1.define = requireApi().define;
		asn1.base = requireBase$1();
		asn1.constants = requireConstants();
		asn1.decoders = requireDecoders();
		asn1.encoders = requireEncoders(); 
	} (asn1));
	return asn1;
}

var certificate;
var hasRequiredCertificate;

function requireCertificate () {
	if (hasRequiredCertificate) return certificate;
	hasRequiredCertificate = 1;

	var asn = requireAsn1$1();

	var Time = asn.define('Time', function () {
		this.choice({
			utcTime: this.utctime(),
			generalTime: this.gentime()
		});
	});

	var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
		this.seq().obj(
			this.key('type').objid(),
			this.key('value').any()
		);
	});

	var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
		this.seq().obj(
			this.key('algorithm').objid(),
			this.key('parameters').optional(),
			this.key('curve').objid().optional()
		);
	});

	var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
		this.seq().obj(
			this.key('algorithm').use(AlgorithmIdentifier),
			this.key('subjectPublicKey').bitstr()
		);
	});

	var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
		this.setof(AttributeTypeValue);
	});

	var RDNSequence = asn.define('RDNSequence', function () {
		this.seqof(RelativeDistinguishedName);
	});

	var Name = asn.define('Name', function () {
		this.choice({
			rdnSequence: this.use(RDNSequence)
		});
	});

	var Validity = asn.define('Validity', function () {
		this.seq().obj(
			this.key('notBefore').use(Time),
			this.key('notAfter').use(Time)
		);
	});

	var Extension = asn.define('Extension', function () {
		this.seq().obj(
			this.key('extnID').objid(),
			this.key('critical').bool().def(false),
			this.key('extnValue').octstr()
		);
	});

	var TBSCertificate = asn.define('TBSCertificate', function () {
		this.seq().obj(
			this.key('version').explicit(0)['int']().optional(),
			this.key('serialNumber')['int'](),
			this.key('signature').use(AlgorithmIdentifier),
			this.key('issuer').use(Name),
			this.key('validity').use(Validity),
			this.key('subject').use(Name),
			this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
			this.key('issuerUniqueID').implicit(1).bitstr().optional(),
			this.key('subjectUniqueID').implicit(2).bitstr().optional(),
			this.key('extensions').explicit(3).seqof(Extension).optional()
		);
	});

	var X509Certificate = asn.define('X509Certificate', function () {
		this.seq().obj(
			this.key('tbsCertificate').use(TBSCertificate),
			this.key('signatureAlgorithm').use(AlgorithmIdentifier),
			this.key('signatureValue').bitstr()
		);
	});

	certificate = X509Certificate;
	return certificate;
}

var hasRequiredAsn1;

function requireAsn1 () {
	if (hasRequiredAsn1) return asn1$1;
	hasRequiredAsn1 = 1;

	var asn1 = requireAsn1$1();

	asn1$1.certificate = requireCertificate();

	var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
		this.seq().obj(
			this.key('version')['int'](),
			this.key('modulus')['int'](),
			this.key('publicExponent')['int'](),
			this.key('privateExponent')['int'](),
			this.key('prime1')['int'](),
			this.key('prime2')['int'](),
			this.key('exponent1')['int'](),
			this.key('exponent2')['int'](),
			this.key('coefficient')['int']()
		);
	});
	asn1$1.RSAPrivateKey = RSAPrivateKey;

	var RSAPublicKey = asn1.define('RSAPublicKey', function () {
		this.seq().obj(
			this.key('modulus')['int'](),
			this.key('publicExponent')['int']()
		);
	});
	asn1$1.RSAPublicKey = RSAPublicKey;

	var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
		this.seq().obj(
			this.key('algorithm').objid(),
			this.key('none').null_().optional(),
			this.key('curve').objid().optional(),
			this.key('params').seq().obj(
				this.key('p')['int'](),
				this.key('q')['int'](),
				this.key('g')['int']()
			).optional()
		);
	});

	var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
		this.seq().obj(
			this.key('algorithm').use(AlgorithmIdentifier),
			this.key('subjectPublicKey').bitstr()
		);
	});
	asn1$1.PublicKey = PublicKey;

	var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
		this.seq().obj(
			this.key('version')['int'](),
			this.key('algorithm').use(AlgorithmIdentifier),
			this.key('subjectPrivateKey').octstr()
		);
	});
	asn1$1.PrivateKey = PrivateKeyInfo;
	var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
		this.seq().obj(
			this.key('algorithm').seq().obj(
				this.key('id').objid(),
				this.key('decrypt').seq().obj(
					this.key('kde').seq().obj(
						this.key('id').objid(),
						this.key('kdeparams').seq().obj(
							this.key('salt').octstr(),
							this.key('iters')['int']()
						)
					),
					this.key('cipher').seq().obj(
						this.key('algo').objid(),
						this.key('iv').octstr()
					)
				)
			),
			this.key('subjectPrivateKey').octstr()
		);
	});

	asn1$1.EncryptedPrivateKey = EncryptedPrivateKeyInfo;

	var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
		this.seq().obj(
			this.key('version')['int'](),
			this.key('p')['int'](),
			this.key('q')['int'](),
			this.key('g')['int'](),
			this.key('pub_key')['int'](),
			this.key('priv_key')['int']()
		);
	});
	asn1$1.DSAPrivateKey = DSAPrivateKey;

	asn1$1.DSAparam = asn1.define('DSAparam', function () {
		this['int']();
	});

	var ECParameters = asn1.define('ECParameters', function () {
		this.choice({
			namedCurve: this.objid()
		});
	});

	var ECPrivateKey = asn1.define('ECPrivateKey', function () {
		this.seq().obj(
			this.key('version')['int'](),
			this.key('privateKey').octstr(),
			this.key('parameters').optional().explicit(0).use(ECParameters),
			this.key('publicKey').optional().explicit(1).bitstr()
		);
	});
	asn1$1.ECPrivateKey = ECPrivateKey;

	asn1$1.signature = asn1.define('signature', function () {
		this.seq().obj(
			this.key('r')['int'](),
			this.key('s')['int']()
		);
	});
	return asn1$1;
}

const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb",
};

var fixProc;
var hasRequiredFixProc;

function requireFixProc () {
	if (hasRequiredFixProc) return fixProc;
	hasRequiredFixProc = 1;

	// adapted from https://github.com/apatil/pemstrip
	var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m;
	var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m;
	var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m;
	var evp = requireEvp_bytestokey();
	var ciphers = requireBrowser$6();
	var Buffer = requireSafeBuffer$2().Buffer;
	fixProc = function (okey, password) {
		var key = okey.toString();
		var match = key.match(findProc);
		var decrypted;
		if (!match) {
			var match2 = key.match(fullRegex);
			decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64');
		} else {
			var suite = 'aes' + match[1];
			var iv = Buffer.from(match[2], 'hex');
			var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64');
			var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key;
			var out = [];
			var cipher = ciphers.createDecipheriv(suite, cipherKey, iv);
			out.push(cipher.update(cipherText));
			out.push(cipher['final']());
			decrypted = Buffer.concat(out);
		}
		var tag = key.match(startRegex)[1];
		return {
			tag: tag,
			data: decrypted
		};
	};
	return fixProc;
}

var parseAsn1;
var hasRequiredParseAsn1;

function requireParseAsn1 () {
	if (hasRequiredParseAsn1) return parseAsn1;
	hasRequiredParseAsn1 = 1;

	var asn1 = requireAsn1();
	var aesid = require$$1;
	var fixProc = requireFixProc();
	var ciphers = requireBrowser$6();
	var compat = requireBrowser$7();
	var Buffer = requireSafeBuffer$2().Buffer;

	function decrypt(data, password) {
		var salt = data.algorithm.decrypt.kde.kdeparams.salt;
		var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10);
		var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')];
		var iv = data.algorithm.decrypt.cipher.iv;
		var cipherText = data.subjectPrivateKey;
		var keylen = parseInt(algo.split('-')[1], 10) / 8;
		var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1');
		var cipher = ciphers.createDecipheriv(algo, key, iv);
		var out = [];
		out.push(cipher.update(cipherText));
		out.push(cipher['final']());
		return Buffer.concat(out);
	}

	function parseKeys(buffer) {
		var password;
		if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
			password = buffer.passphrase;
			buffer = buffer.key;
		}
		if (typeof buffer === 'string') {
			buffer = Buffer.from(buffer);
		}

		var stripped = fixProc(buffer, password);

		var type = stripped.tag;
		var data = stripped.data;
		var subtype, ndata;
		switch (type) {
			case 'CERTIFICATE':
				ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo;
				// falls through
			case 'PUBLIC KEY':
				if (!ndata) {
					ndata = asn1.PublicKey.decode(data, 'der');
				}
				subtype = ndata.algorithm.algorithm.join('.');
				switch (subtype) {
					case '1.2.840.113549.1.1.1':
						return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der');
					case '1.2.840.10045.2.1':
						ndata.subjectPrivateKey = ndata.subjectPublicKey;
						return {
							type: 'ec',
							data: ndata
						};
					case '1.2.840.10040.4.1':
						ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der');
						return {
							type: 'dsa',
							data: ndata.algorithm.params
						};
					default: throw new Error('unknown key id ' + subtype);
				}
				// throw new Error('unknown key type ' + type)
			case 'ENCRYPTED PRIVATE KEY':
				data = asn1.EncryptedPrivateKey.decode(data, 'der');
				data = decrypt(data, password);
				// falls through
			case 'PRIVATE KEY':
				ndata = asn1.PrivateKey.decode(data, 'der');
				subtype = ndata.algorithm.algorithm.join('.');
				switch (subtype) {
					case '1.2.840.113549.1.1.1':
						return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der');
					case '1.2.840.10045.2.1':
						return {
							curve: ndata.algorithm.curve,
							privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
						};
					case '1.2.840.10040.4.1':
						ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der');
						return {
							type: 'dsa',
							params: ndata.algorithm.params
						};
					default: throw new Error('unknown key id ' + subtype);
				}
				// throw new Error('unknown key type ' + type)
			case 'RSA PUBLIC KEY':
				return asn1.RSAPublicKey.decode(data, 'der');
			case 'RSA PRIVATE KEY':
				return asn1.RSAPrivateKey.decode(data, 'der');
			case 'DSA PRIVATE KEY':
				return {
					type: 'dsa',
					params: asn1.DSAPrivateKey.decode(data, 'der')
				};
			case 'EC PRIVATE KEY':
				data = asn1.ECPrivateKey.decode(data, 'der');
				return {
					curve: data.parameters.value,
					privateKey: data.privateKey
				};
			default: throw new Error('unknown key type ' + type);
		}
	}
	parseKeys.signature = asn1.signature;

	parseAsn1 = parseKeys;
	return parseAsn1;
}

const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521",
};

var hasRequiredSign;

function requireSign () {
	if (hasRequiredSign) return sign.exports;
	hasRequiredSign = 1;

	// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
	var Buffer = requireSafeBuffer$2().Buffer;
	var createHmac = requireBrowser$8();
	var crt = requireBrowserifyRsa();
	var EC = requireElliptic$1().ec;
	var BN = requireBn$5();
	var parseKeys = requireParseAsn1();
	var curves = require$$4;

	var RSA_PKCS1_PADDING = 1;

	function sign$1(hash, key, hashType, signType, tag) {
	  var priv = parseKeys(key);
	  if (priv.curve) {
	    // rsa keys can be interpreted as ecdsa ones in openssl
	    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
	    return ecSign(hash, priv);
	  } else if (priv.type === 'dsa') {
	    if (signType !== 'dsa') { throw new Error('wrong private key type'); }
	    return dsaSign(hash, priv, hashType);
	  }
	  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong private key type'); }
	  if (key.padding !== undefined && key.padding !== RSA_PKCS1_PADDING) { throw new Error('illegal or unsupported padding mode'); }

	  hash = Buffer.concat([tag, hash]);
	  var len = priv.modulus.byteLength();
	  var pad = [0, 1];
	  while (hash.length + pad.length + 1 < len) { pad.push(0xff); }
	  pad.push(0x00);
	  var i = -1;
	  while (++i < hash.length) { pad.push(hash[i]); }

	  var out = crt(pad, priv);
	  return out;
	}

	function ecSign(hash, priv) {
	  var curveId = curves[priv.curve.join('.')];
	  if (!curveId) { throw new Error('unknown curve ' + priv.curve.join('.')); }

	  var curve = new EC(curveId);
	  var key = curve.keyFromPrivate(priv.privateKey);
	  var out = key.sign(hash);

	  return Buffer.from(out.toDER());
	}

	function dsaSign(hash, priv, algo) {
	  var x = priv.params.priv_key;
	  var p = priv.params.p;
	  var q = priv.params.q;
	  var g = priv.params.g;
	  var r = new BN(0);
	  var k;
	  var H = bits2int(hash, q).mod(q);
	  var s = false;
	  var kv = getKey(x, q, hash, algo);
	  while (s === false) {
	    k = makeKey(q, kv, algo);
	    r = makeR(g, k, p, q);
	    s = k.invm(q).imul(H.add(x.mul(r))).mod(q);
	    if (s.cmpn(0) === 0) {
	      s = false;
	      r = new BN(0);
	    }
	  }
	  return toDER(r, s);
	}

	function toDER(r, s) {
	  r = r.toArray();
	  s = s.toArray();

	  // Pad values
	  if (r[0] & 0x80) { r = [0].concat(r); }
	  if (s[0] & 0x80) { s = [0].concat(s); }

	  var total = r.length + s.length + 4;
	  var res = [
	    0x30, total, 0x02, r.length
	  ];
	  res = res.concat(r, [0x02, s.length], s);
	  return Buffer.from(res);
	}

	function getKey(x, q, hash, algo) {
	  x = Buffer.from(x.toArray());
	  if (x.length < q.byteLength()) {
	    var zeros = Buffer.alloc(q.byteLength() - x.length);
	    x = Buffer.concat([zeros, x]);
	  }
	  var hlen = hash.length;
	  var hbits = bits2octets(hash, q);
	  var v = Buffer.alloc(hlen);
	  v.fill(1);
	  var k = Buffer.alloc(hlen);
	  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest();
	  v = createHmac(algo, k).update(v).digest();
	  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest();
	  v = createHmac(algo, k).update(v).digest();
	  return { k: k, v: v };
	}

	function bits2int(obits, q) {
	  var bits = new BN(obits);
	  var shift = (obits.length << 3) - q.bitLength();
	  if (shift > 0) { bits.ishrn(shift); }
	  return bits;
	}

	function bits2octets(bits, q) {
	  bits = bits2int(bits, q);
	  bits = bits.mod(q);
	  var out = Buffer.from(bits.toArray());
	  if (out.length < q.byteLength()) {
	    var zeros = Buffer.alloc(q.byteLength() - out.length);
	    out = Buffer.concat([zeros, out]);
	  }
	  return out;
	}

	function makeKey(q, kv, algo) {
	  var t;
	  var k;

	  do {
	    t = Buffer.alloc(0);

	    while (t.length * 8 < q.bitLength()) {
	      kv.v = createHmac(algo, kv.k).update(kv.v).digest();
	      t = Buffer.concat([t, kv.v]);
	    }

	    k = bits2int(t, q);
	    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest();
	    kv.v = createHmac(algo, kv.k).update(kv.v).digest();
	  } while (k.cmp(q) !== -1);

	  return k;
	}

	function makeR(g, k, p, q) {
	  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q);
	}

	sign.exports = sign$1;
	sign.exports.getKey = getKey;
	sign.exports.makeKey = makeKey;
	return sign.exports;
}

var verify_1;
var hasRequiredVerify;

function requireVerify () {
	if (hasRequiredVerify) return verify_1;
	hasRequiredVerify = 1;

	// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
	var Buffer = requireSafeBuffer$2().Buffer;
	var BN = requireBn$5();
	var EC = requireElliptic$1().ec;
	var parseKeys = requireParseAsn1();
	var curves = require$$4;

	function verify(sig, hash, key, signType, tag) {
	  var pub = parseKeys(key);
	  if (pub.type === 'ec') {
	    // rsa keys can be interpreted as ecdsa ones in openssl
	    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }
	    return ecVerify(sig, hash, pub);
	  } else if (pub.type === 'dsa') {
	    if (signType !== 'dsa') { throw new Error('wrong public key type'); }
	    return dsaVerify(sig, hash, pub);
	  }
	  if (signType !== 'rsa' && signType !== 'ecdsa/rsa') { throw new Error('wrong public key type'); }

	  hash = Buffer.concat([tag, hash]);
	  var len = pub.modulus.byteLength();
	  var pad = [1];
	  var padNum = 0;
	  while (hash.length + pad.length + 2 < len) {
	    pad.push(0xff);
	    padNum += 1;
	  }
	  pad.push(0x00);
	  var i = -1;
	  while (++i < hash.length) {
	    pad.push(hash[i]);
	  }
	  pad = Buffer.from(pad);
	  var red = BN.mont(pub.modulus);
	  sig = new BN(sig).toRed(red);

	  sig = sig.redPow(new BN(pub.publicExponent));
	  sig = Buffer.from(sig.fromRed().toArray());
	  var out = padNum < 8 ? 1 : 0;
	  len = Math.min(sig.length, pad.length);
	  if (sig.length !== pad.length) { out = 1; }

	  i = -1;
	  while (++i < len) { out |= sig[i] ^ pad[i]; }
	  return out === 0;
	}

	function ecVerify(sig, hash, pub) {
	  var curveId = curves[pub.data.algorithm.curve.join('.')];
	  if (!curveId) { throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.')); }

	  var curve = new EC(curveId);
	  var pubkey = pub.data.subjectPrivateKey.data;

	  return curve.verify(hash, sig, pubkey);
	}

	function dsaVerify(sig, hash, pub) {
	  var p = pub.data.p;
	  var q = pub.data.q;
	  var g = pub.data.g;
	  var y = pub.data.pub_key;
	  var unpacked = parseKeys.signature.decode(sig, 'der');
	  var s = unpacked.s;
	  var r = unpacked.r;
	  checkValue(s, q);
	  checkValue(r, q);
	  var montp = BN.mont(p);
	  var w = s.invm(q);
	  var v = g.toRed(montp)
	    .redPow(new BN(hash).mul(w).mod(q))
	    .fromRed()
	    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
	    .mod(p)
	    .mod(q);
	  return v.cmp(r) === 0;
	}

	function checkValue(b, q) {
	  if (b.cmpn(0) <= 0) { throw new Error('invalid sig'); }
	  if (b.cmp(q) >= 0) { throw new Error('invalid sig'); }
	}

	verify_1 = verify;
	return verify_1;
}

var browser$3;
var hasRequiredBrowser$3;

function requireBrowser$3 () {
	if (hasRequiredBrowser$3) return browser$3;
	hasRequiredBrowser$3 = 1;

	var Buffer = requireSafeBuffer$2().Buffer;
	var createHash = requireBrowser$9();
	var stream = requireReadableBrowser();
	var inherits = requireInherits_browser();
	var sign = requireSign();
	var verify = requireVerify();

	var algorithms = require$$6;
	Object.keys(algorithms).forEach(function (key) {
	  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex');
	  algorithms[key.toLowerCase()] = algorithms[key];
	});

	function Sign(algorithm) {
	  stream.Writable.call(this);

	  var data = algorithms[algorithm];
	  if (!data) { throw new Error('Unknown message digest'); }

	  this._hashType = data.hash;
	  this._hash = createHash(data.hash);
	  this._tag = data.id;
	  this._signType = data.sign;
	}
	inherits(Sign, stream.Writable);

	Sign.prototype._write = function _write(data, _, done) {
	  this._hash.update(data);
	  done();
	};

	Sign.prototype.update = function update(data, enc) {
	  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

	  return this;
	};

	Sign.prototype.sign = function signMethod(key, enc) {
	  this.end();
	  var hash = this._hash.digest();
	  var sig = sign(hash, key, this._hashType, this._signType, this._tag);

	  return enc ? sig.toString(enc) : sig;
	};

	function Verify(algorithm) {
	  stream.Writable.call(this);

	  var data = algorithms[algorithm];
	  if (!data) { throw new Error('Unknown message digest'); }

	  this._hash = createHash(data.hash);
	  this._tag = data.id;
	  this._signType = data.sign;
	}
	inherits(Verify, stream.Writable);

	Verify.prototype._write = function _write(data, _, done) {
	  this._hash.update(data);
	  done();
	};

	Verify.prototype.update = function update(data, enc) {
	  this._hash.update(typeof data === 'string' ? Buffer.from(data, enc) : data);

	  return this;
	};

	Verify.prototype.verify = function verifyMethod(key, sig, enc) {
	  var sigBuffer = typeof sig === 'string' ? Buffer.from(sig, enc) : sig;

	  this.end();
	  var hash = this._hash.digest();
	  return verify(sigBuffer, hash, key, this._signType, this._tag);
	};

	function createSign(algorithm) {
	  return new Sign(algorithm);
	}

	function createVerify(algorithm) {
	  return new Verify(algorithm);
	}

	browser$3 = {
	  Sign: createSign,
	  Verify: createVerify,
	  createSign: createSign,
	  createVerify: createVerify
	};
	return browser$3;
}

var elliptic = {};

const version = "6.5.4";
const require$$0 = {
  version};

var utils = {};

var bn$5 = {exports: {}};

var bn$4 = bn$5.exports;

var hasRequiredBn$2;

function requireBn$2 () {
	if (hasRequiredBn$2) return bn$5.exports;
	hasRequiredBn$2 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$4); 
	} (bn$5));
	return bn$5.exports;
}

var hasRequiredUtils;

function requireUtils () {
	if (hasRequiredUtils) return utils;
	hasRequiredUtils = 1;
	(function (exports) {

		var utils = exports;
		var BN = requireBn$2();
		var minAssert = requireMinimalisticAssert();
		var minUtils = requireUtils$3();

		utils.assert = minAssert;
		utils.toArray = minUtils.toArray;
		utils.zero2 = minUtils.zero2;
		utils.toHex = minUtils.toHex;
		utils.encode = minUtils.encode;

		// Represent num in a w-NAF form
		function getNAF(num, w, bits) {
		  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
		  naf.fill(0);

		  var ws = 1 << (w + 1);
		  var k = num.clone();

		  for (var i = 0; i < naf.length; i++) {
		    var z;
		    var mod = k.andln(ws - 1);
		    if (k.isOdd()) {
		      if (mod > (ws >> 1) - 1)
		        z = (ws >> 1) - mod;
		      else
		        z = mod;
		      k.isubn(z);
		    } else {
		      z = 0;
		    }

		    naf[i] = z;
		    k.iushrn(1);
		  }

		  return naf;
		}
		utils.getNAF = getNAF;

		// Represent k1, k2 in a Joint Sparse Form
		function getJSF(k1, k2) {
		  var jsf = [
		    [],
		    [],
		  ];

		  k1 = k1.clone();
		  k2 = k2.clone();
		  var d1 = 0;
		  var d2 = 0;
		  var m8;
		  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
		    // First phase
		    var m14 = (k1.andln(3) + d1) & 3;
		    var m24 = (k2.andln(3) + d2) & 3;
		    if (m14 === 3)
		      m14 = -1;
		    if (m24 === 3)
		      m24 = -1;
		    var u1;
		    if ((m14 & 1) === 0) {
		      u1 = 0;
		    } else {
		      m8 = (k1.andln(7) + d1) & 7;
		      if ((m8 === 3 || m8 === 5) && m24 === 2)
		        u1 = -m14;
		      else
		        u1 = m14;
		    }
		    jsf[0].push(u1);

		    var u2;
		    if ((m24 & 1) === 0) {
		      u2 = 0;
		    } else {
		      m8 = (k2.andln(7) + d2) & 7;
		      if ((m8 === 3 || m8 === 5) && m14 === 2)
		        u2 = -m24;
		      else
		        u2 = m24;
		    }
		    jsf[1].push(u2);

		    // Second phase
		    if (2 * d1 === u1 + 1)
		      d1 = 1 - d1;
		    if (2 * d2 === u2 + 1)
		      d2 = 1 - d2;
		    k1.iushrn(1);
		    k2.iushrn(1);
		  }

		  return jsf;
		}
		utils.getJSF = getJSF;

		function cachedProperty(obj, name, computer) {
		  var key = '_' + name;
		  obj.prototype[name] = function cachedProperty() {
		    return this[key] !== undefined ? this[key] :
		      this[key] = computer.call(this);
		  };
		}
		utils.cachedProperty = cachedProperty;

		function parseBytes(bytes) {
		  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
		    bytes;
		}
		utils.parseBytes = parseBytes;

		function intFromLE(bytes) {
		  return new BN(bytes, 'hex', 'le');
		}
		utils.intFromLE = intFromLE; 
	} (utils));
	return utils;
}

var curve = {};

var base;
var hasRequiredBase;

function requireBase () {
	if (hasRequiredBase) return base;
	hasRequiredBase = 1;

	var BN = requireBn$2();
	var utils = requireUtils();
	var getNAF = utils.getNAF;
	var getJSF = utils.getJSF;
	var assert = utils.assert;

	function BaseCurve(type, conf) {
	  this.type = type;
	  this.p = new BN(conf.p, 16);

	  // Use Montgomery, when there is no fast reduction for the prime
	  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

	  // Useful for many curves
	  this.zero = new BN(0).toRed(this.red);
	  this.one = new BN(1).toRed(this.red);
	  this.two = new BN(2).toRed(this.red);

	  // Curve configuration, optional
	  this.n = conf.n && new BN(conf.n, 16);
	  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

	  // Temporary arrays
	  this._wnafT1 = new Array(4);
	  this._wnafT2 = new Array(4);
	  this._wnafT3 = new Array(4);
	  this._wnafT4 = new Array(4);

	  this._bitLength = this.n ? this.n.bitLength() : 0;

	  // Generalized Greg Maxwell's trick
	  var adjustCount = this.n && this.p.div(this.n);
	  if (!adjustCount || adjustCount.cmpn(100) > 0) {
	    this.redN = null;
	  } else {
	    this._maxwellTrick = true;
	    this.redN = this.n.toRed(this.red);
	  }
	}
	base = BaseCurve;

	BaseCurve.prototype.point = function point() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype.validate = function validate() {
	  throw new Error('Not implemented');
	};

	BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
	  assert(p.precomputed);
	  var doubles = p._getDoubles();

	  var naf = getNAF(k, 1, this._bitLength);
	  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
	  I /= 3;

	  // Translate into more windowed form
	  var repr = [];
	  var j;
	  var nafW;
	  for (j = 0; j < naf.length; j += doubles.step) {
	    nafW = 0;
	    for (var l = j + doubles.step - 1; l >= j; l--)
	      nafW = (nafW << 1) + naf[l];
	    repr.push(nafW);
	  }

	  var a = this.jpoint(null, null, null);
	  var b = this.jpoint(null, null, null);
	  for (var i = I; i > 0; i--) {
	    for (j = 0; j < repr.length; j++) {
	      nafW = repr[j];
	      if (nafW === i)
	        b = b.mixedAdd(doubles.points[j]);
	      else if (nafW === -i)
	        b = b.mixedAdd(doubles.points[j].neg());
	    }
	    a = a.add(b);
	  }
	  return a.toP();
	};

	BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
	  var w = 4;

	  // Precompute window
	  var nafPoints = p._getNAFPoints(w);
	  w = nafPoints.wnd;
	  var wnd = nafPoints.points;

	  // Get NAF form
	  var naf = getNAF(k, w, this._bitLength);

	  // Add `this`*(N+1) for every w-NAF index
	  var acc = this.jpoint(null, null, null);
	  for (var i = naf.length - 1; i >= 0; i--) {
	    // Count zeroes
	    for (var l = 0; i >= 0 && naf[i] === 0; i--)
	      l++;
	    if (i >= 0)
	      l++;
	    acc = acc.dblp(l);

	    if (i < 0)
	      break;
	    var z = naf[i];
	    assert(z !== 0);
	    if (p.type === 'affine') {
	      // J +- P
	      if (z > 0)
	        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
	    } else {
	      // J +- J
	      if (z > 0)
	        acc = acc.add(wnd[(z - 1) >> 1]);
	      else
	        acc = acc.add(wnd[(-z - 1) >> 1].neg());
	    }
	  }
	  return p.type === 'affine' ? acc.toP() : acc;
	};

	BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
	  points,
	  coeffs,
	  len,
	  jacobianResult) {
	  var wndWidth = this._wnafT1;
	  var wnd = this._wnafT2;
	  var naf = this._wnafT3;

	  // Fill all arrays
	  var max = 0;
	  var i;
	  var j;
	  var p;
	  for (i = 0; i < len; i++) {
	    p = points[i];
	    var nafPoints = p._getNAFPoints(defW);
	    wndWidth[i] = nafPoints.wnd;
	    wnd[i] = nafPoints.points;
	  }

	  // Comb small window NAFs
	  for (i = len - 1; i >= 1; i -= 2) {
	    var a = i - 1;
	    var b = i;
	    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
	      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
	      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
	      max = Math.max(naf[a].length, max);
	      max = Math.max(naf[b].length, max);
	      continue;
	    }

	    var comb = [
	      points[a], /* 1 */
	      null, /* 3 */
	      null, /* 5 */
	      points[b], /* 7 */
	    ];

	    // Try to avoid Projective points, if possible
	    if (points[a].y.cmp(points[b].y) === 0) {
	      comb[1] = points[a].add(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].add(points[b].neg());
	    } else {
	      comb[1] = points[a].toJ().mixedAdd(points[b]);
	      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
	    }

	    var index = [
	      -3, /* -1 -1 */
	      -1, /* -1 0 */
	      -5, /* -1 1 */
	      -7, /* 0 -1 */
	      0, /* 0 0 */
	      7, /* 0 1 */
	      5, /* 1 -1 */
	      1, /* 1 0 */
	      3,  /* 1 1 */
	    ];

	    var jsf = getJSF(coeffs[a], coeffs[b]);
	    max = Math.max(jsf[0].length, max);
	    naf[a] = new Array(max);
	    naf[b] = new Array(max);
	    for (j = 0; j < max; j++) {
	      var ja = jsf[0][j] | 0;
	      var jb = jsf[1][j] | 0;

	      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
	      naf[b][j] = 0;
	      wnd[a] = comb;
	    }
	  }

	  var acc = this.jpoint(null, null, null);
	  var tmp = this._wnafT4;
	  for (i = max; i >= 0; i--) {
	    var k = 0;

	    while (i >= 0) {
	      var zero = true;
	      for (j = 0; j < len; j++) {
	        tmp[j] = naf[j][i] | 0;
	        if (tmp[j] !== 0)
	          zero = false;
	      }
	      if (!zero)
	        break;
	      k++;
	      i--;
	    }
	    if (i >= 0)
	      k++;
	    acc = acc.dblp(k);
	    if (i < 0)
	      break;

	    for (j = 0; j < len; j++) {
	      var z = tmp[j];
	      if (z === 0)
	        continue;
	      else if (z > 0)
	        p = wnd[j][(z - 1) >> 1];
	      else if (z < 0)
	        p = wnd[j][(-z - 1) >> 1].neg();

	      if (p.type === 'affine')
	        acc = acc.mixedAdd(p);
	      else
	        acc = acc.add(p);
	    }
	  }
	  // Zeroify references
	  for (i = 0; i < len; i++)
	    wnd[i] = null;

	  if (jacobianResult)
	    return acc;
	  else
	    return acc.toP();
	};

	function BasePoint(curve, type) {
	  this.curve = curve;
	  this.type = type;
	  this.precomputed = null;
	}
	BaseCurve.BasePoint = BasePoint;

	BasePoint.prototype.eq = function eq(/*other*/) {
	  throw new Error('Not implemented');
	};

	BasePoint.prototype.validate = function validate() {
	  return this.curve.validate(this);
	};

	BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  bytes = utils.toArray(bytes, enc);

	  var len = this.p.byteLength();

	  // uncompressed, hybrid-odd, hybrid-even
	  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
	      bytes.length - 1 === 2 * len) {
	    if (bytes[0] === 0x06)
	      assert(bytes[bytes.length - 1] % 2 === 0);
	    else if (bytes[0] === 0x07)
	      assert(bytes[bytes.length - 1] % 2 === 1);

	    var res =  this.point(bytes.slice(1, 1 + len),
	      bytes.slice(1 + len, 1 + 2 * len));

	    return res;
	  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
	              bytes.length - 1 === len) {
	    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
	  }
	  throw new Error('Unknown point format');
	};

	BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
	  return this.encode(enc, true);
	};

	BasePoint.prototype._encode = function _encode(compact) {
	  var len = this.curve.p.byteLength();
	  var x = this.getX().toArray('be', len);

	  if (compact)
	    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

	  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
	};

	BasePoint.prototype.encode = function encode(enc, compact) {
	  return utils.encode(this._encode(compact), enc);
	};

	BasePoint.prototype.precompute = function precompute(power) {
	  if (this.precomputed)
	    return this;

	  var precomputed = {
	    doubles: null,
	    naf: null,
	    beta: null,
	  };
	  precomputed.naf = this._getNAFPoints(8);
	  precomputed.doubles = this._getDoubles(4, power);
	  precomputed.beta = this._getBeta();
	  this.precomputed = precomputed;

	  return this;
	};

	BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
	  if (!this.precomputed)
	    return false;

	  var doubles = this.precomputed.doubles;
	  if (!doubles)
	    return false;

	  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
	};

	BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
	  if (this.precomputed && this.precomputed.doubles)
	    return this.precomputed.doubles;

	  var doubles = [ this ];
	  var acc = this;
	  for (var i = 0; i < power; i += step) {
	    for (var j = 0; j < step; j++)
	      acc = acc.dbl();
	    doubles.push(acc);
	  }
	  return {
	    step: step,
	    points: doubles,
	  };
	};

	BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
	  if (this.precomputed && this.precomputed.naf)
	    return this.precomputed.naf;

	  var res = [ this ];
	  var max = (1 << wnd) - 1;
	  var dbl = max === 1 ? null : this.dbl();
	  for (var i = 1; i < max; i++)
	    res[i] = res[i - 1].add(dbl);
	  return {
	    wnd: wnd,
	    points: res,
	  };
	};

	BasePoint.prototype._getBeta = function _getBeta() {
	  return null;
	};

	BasePoint.prototype.dblp = function dblp(k) {
	  var r = this;
	  for (var i = 0; i < k; i++)
	    r = r.dbl();
	  return r;
	};
	return base;
}

var short;
var hasRequiredShort;

function requireShort () {
	if (hasRequiredShort) return short;
	hasRequiredShort = 1;

	var utils = requireUtils();
	var BN = requireBn$2();
	var inherits = requireInherits_browser();
	var Base = requireBase();

	var assert = utils.assert;

	function ShortCurve(conf) {
	  Base.call(this, 'short', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.tinv = this.two.redInvm();

	  this.zeroA = this.a.fromRed().cmpn(0) === 0;
	  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

	  // If the curve is endomorphic, precalculate beta and lambda
	  this.endo = this._getEndomorphism(conf);
	  this._endoWnafT1 = new Array(4);
	  this._endoWnafT2 = new Array(4);
	}
	inherits(ShortCurve, Base);
	short = ShortCurve;

	ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
	  // No efficient endomorphism
	  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
	    return;

	  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
	  var beta;
	  var lambda;
	  if (conf.beta) {
	    beta = new BN(conf.beta, 16).toRed(this.red);
	  } else {
	    var betas = this._getEndoRoots(this.p);
	    // Choose the smallest beta
	    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
	    beta = beta.toRed(this.red);
	  }
	  if (conf.lambda) {
	    lambda = new BN(conf.lambda, 16);
	  } else {
	    // Choose the lambda that is matching selected beta
	    var lambdas = this._getEndoRoots(this.n);
	    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
	      lambda = lambdas[0];
	    } else {
	      lambda = lambdas[1];
	      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
	    }
	  }

	  // Get basis vectors, used for balanced length-two representation
	  var basis;
	  if (conf.basis) {
	    basis = conf.basis.map(function(vec) {
	      return {
	        a: new BN(vec.a, 16),
	        b: new BN(vec.b, 16),
	      };
	    });
	  } else {
	    basis = this._getEndoBasis(lambda);
	  }

	  return {
	    beta: beta,
	    lambda: lambda,
	    basis: basis,
	  };
	};

	ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
	  // Find roots of for x^2 + x + 1 in F
	  // Root = (-1 +- Sqrt(-3)) / 2
	  //
	  var red = num === this.p ? this.red : BN.mont(num);
	  var tinv = new BN(2).toRed(red).redInvm();
	  var ntinv = tinv.redNeg();

	  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

	  var l1 = ntinv.redAdd(s).fromRed();
	  var l2 = ntinv.redSub(s).fromRed();
	  return [ l1, l2 ];
	};

	ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
	  // aprxSqrt >= sqrt(this.n)
	  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

	  // 3.74
	  // Run EGCD, until r(L + 1) < aprxSqrt
	  var u = lambda;
	  var v = this.n.clone();
	  var x1 = new BN(1);
	  var y1 = new BN(0);
	  var x2 = new BN(0);
	  var y2 = new BN(1);

	  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
	  var a0;
	  var b0;
	  // First vector
	  var a1;
	  var b1;
	  // Second vector
	  var a2;
	  var b2;

	  var prevR;
	  var i = 0;
	  var r;
	  var x;
	  while (u.cmpn(0) !== 0) {
	    var q = v.div(u);
	    r = v.sub(q.mul(u));
	    x = x2.sub(q.mul(x1));
	    var y = y2.sub(q.mul(y1));

	    if (!a1 && r.cmp(aprxSqrt) < 0) {
	      a0 = prevR.neg();
	      b0 = x1;
	      a1 = r.neg();
	      b1 = x;
	    } else if (a1 && ++i === 2) {
	      break;
	    }
	    prevR = r;

	    v = u;
	    u = r;
	    x2 = x1;
	    x1 = x;
	    y2 = y1;
	    y1 = y;
	  }
	  a2 = r.neg();
	  b2 = x;

	  var len1 = a1.sqr().add(b1.sqr());
	  var len2 = a2.sqr().add(b2.sqr());
	  if (len2.cmp(len1) >= 0) {
	    a2 = a0;
	    b2 = b0;
	  }

	  // Normalize signs
	  if (a1.negative) {
	    a1 = a1.neg();
	    b1 = b1.neg();
	  }
	  if (a2.negative) {
	    a2 = a2.neg();
	    b2 = b2.neg();
	  }

	  return [
	    { a: a1, b: b1 },
	    { a: a2, b: b2 },
	  ];
	};

	ShortCurve.prototype._endoSplit = function _endoSplit(k) {
	  var basis = this.endo.basis;
	  var v1 = basis[0];
	  var v2 = basis[1];

	  var c1 = v2.b.mul(k).divRound(this.n);
	  var c2 = v1.b.neg().mul(k).divRound(this.n);

	  var p1 = c1.mul(v1.a);
	  var p2 = c2.mul(v2.a);
	  var q1 = c1.mul(v1.b);
	  var q2 = c2.mul(v2.b);

	  // Calculate answer
	  var k1 = k.sub(p1).sub(p2);
	  var k2 = q1.add(q2).neg();
	  return { k1: k1, k2: k2 };
	};

	ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  // XXX Is there any way to tell if the number is odd without converting it
	  // to non-red form?
	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	ShortCurve.prototype.validate = function validate(point) {
	  if (point.inf)
	    return true;

	  var x = point.x;
	  var y = point.y;

	  var ax = this.a.redMul(x);
	  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
	  return y.redSqr().redISub(rhs).cmpn(0) === 0;
	};

	ShortCurve.prototype._endoWnafMulAdd =
	    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
	      var npoints = this._endoWnafT1;
	      var ncoeffs = this._endoWnafT2;
	      for (var i = 0; i < points.length; i++) {
	        var split = this._endoSplit(coeffs[i]);
	        var p = points[i];
	        var beta = p._getBeta();

	        if (split.k1.negative) {
	          split.k1.ineg();
	          p = p.neg(true);
	        }
	        if (split.k2.negative) {
	          split.k2.ineg();
	          beta = beta.neg(true);
	        }

	        npoints[i * 2] = p;
	        npoints[i * 2 + 1] = beta;
	        ncoeffs[i * 2] = split.k1;
	        ncoeffs[i * 2 + 1] = split.k2;
	      }
	      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

	      // Clean-up references to points and coefficients
	      for (var j = 0; j < i * 2; j++) {
	        npoints[j] = null;
	        ncoeffs[j] = null;
	      }
	      return res;
	    };

	function Point(curve, x, y, isRed) {
	  Base.BasePoint.call(this, curve, 'affine');
	  if (x === null && y === null) {
	    this.x = null;
	    this.y = null;
	    this.inf = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    // Force redgomery representation when loading from JSON
	    if (isRed) {
	      this.x.forceRed(this.curve.red);
	      this.y.forceRed(this.curve.red);
	    }
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    this.inf = false;
	  }
	}
	inherits(Point, Base.BasePoint);

	ShortCurve.prototype.point = function point(x, y, isRed) {
	  return new Point(this, x, y, isRed);
	};

	ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
	  return Point.fromJSON(this, obj, red);
	};

	Point.prototype._getBeta = function _getBeta() {
	  if (!this.curve.endo)
	    return;

	  var pre = this.precomputed;
	  if (pre && pre.beta)
	    return pre.beta;

	  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
	  if (pre) {
	    var curve = this.curve;
	    var endoMul = function(p) {
	      return curve.point(p.x.redMul(curve.endo.beta), p.y);
	    };
	    pre.beta = beta;
	    beta.precomputed = {
	      beta: null,
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(endoMul),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(endoMul),
	      },
	    };
	  }
	  return beta;
	};

	Point.prototype.toJSON = function toJSON() {
	  if (!this.precomputed)
	    return [ this.x, this.y ];

	  return [ this.x, this.y, this.precomputed && {
	    doubles: this.precomputed.doubles && {
	      step: this.precomputed.doubles.step,
	      points: this.precomputed.doubles.points.slice(1),
	    },
	    naf: this.precomputed.naf && {
	      wnd: this.precomputed.naf.wnd,
	      points: this.precomputed.naf.points.slice(1),
	    },
	  } ];
	};

	Point.fromJSON = function fromJSON(curve, obj, red) {
	  if (typeof obj === 'string')
	    obj = JSON.parse(obj);
	  var res = curve.point(obj[0], obj[1], red);
	  if (!obj[2])
	    return res;

	  function obj2point(obj) {
	    return curve.point(obj[0], obj[1], red);
	  }

	  var pre = obj[2];
	  res.precomputed = {
	    beta: null,
	    doubles: pre.doubles && {
	      step: pre.doubles.step,
	      points: [ res ].concat(pre.doubles.points.map(obj2point)),
	    },
	    naf: pre.naf && {
	      wnd: pre.naf.wnd,
	      points: [ res ].concat(pre.naf.points.map(obj2point)),
	    },
	  };
	  return res;
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  return this.inf;
	};

	Point.prototype.add = function add(p) {
	  // O + P = P
	  if (this.inf)
	    return p;

	  // P + O = P
	  if (p.inf)
	    return this;

	  // P + P = 2P
	  if (this.eq(p))
	    return this.dbl();

	  // P + (-P) = O
	  if (this.neg().eq(p))
	    return this.curve.point(null, null);

	  // P + Q = O
	  if (this.x.cmp(p.x) === 0)
	    return this.curve.point(null, null);

	  var c = this.y.redSub(p.y);
	  if (c.cmpn(0) !== 0)
	    c = c.redMul(this.x.redSub(p.x).redInvm());
	  var nx = c.redSqr().redISub(this.x).redISub(p.x);
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.inf)
	    return this;

	  // 2P = O
	  var ys1 = this.y.redAdd(this.y);
	  if (ys1.cmpn(0) === 0)
	    return this.curve.point(null, null);

	  var a = this.curve.a;

	  var x2 = this.x.redSqr();
	  var dyinv = ys1.redInvm();
	  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

	  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
	  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
	  return this.curve.point(nx, ny);
	};

	Point.prototype.getX = function getX() {
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  return this.y.fromRed();
	};

	Point.prototype.mul = function mul(k) {
	  k = new BN(k, 16);
	  if (this.isInfinity())
	    return this;
	  else if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else if (this.curve.endo)
	    return this.curve._endoWnafMulAdd([ this ], [ k ]);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
	  var points = [ this, p2 ];
	  var coeffs = [ k1, k2 ];
	  if (this.curve.endo)
	    return this.curve._endoWnafMulAdd(points, coeffs, true);
	  else
	    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
	};

	Point.prototype.eq = function eq(p) {
	  return this === p ||
	         this.inf === p.inf &&
	             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
	};

	Point.prototype.neg = function neg(_precompute) {
	  if (this.inf)
	    return this;

	  var res = this.curve.point(this.x, this.y.redNeg());
	  if (_precompute && this.precomputed) {
	    var pre = this.precomputed;
	    var negate = function(p) {
	      return p.neg();
	    };
	    res.precomputed = {
	      naf: pre.naf && {
	        wnd: pre.naf.wnd,
	        points: pre.naf.points.map(negate),
	      },
	      doubles: pre.doubles && {
	        step: pre.doubles.step,
	        points: pre.doubles.points.map(negate),
	      },
	    };
	  }
	  return res;
	};

	Point.prototype.toJ = function toJ() {
	  if (this.inf)
	    return this.curve.jpoint(null, null, null);

	  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
	  return res;
	};

	function JPoint(curve, x, y, z) {
	  Base.BasePoint.call(this, curve, 'jacobian');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.one;
	    this.y = this.curve.one;
	    this.z = new BN(0);
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = new BN(z, 16);
	  }
	  if (!this.x.red)
	    this.x = this.x.toRed(this.curve.red);
	  if (!this.y.red)
	    this.y = this.y.toRed(this.curve.red);
	  if (!this.z.red)
	    this.z = this.z.toRed(this.curve.red);

	  this.zOne = this.z === this.curve.one;
	}
	inherits(JPoint, Base.BasePoint);

	ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
	  return new JPoint(this, x, y, z);
	};

	JPoint.prototype.toP = function toP() {
	  if (this.isInfinity())
	    return this.curve.point(null, null);

	  var zinv = this.z.redInvm();
	  var zinv2 = zinv.redSqr();
	  var ax = this.x.redMul(zinv2);
	  var ay = this.y.redMul(zinv2).redMul(zinv);

	  return this.curve.point(ax, ay);
	};

	JPoint.prototype.neg = function neg() {
	  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
	};

	JPoint.prototype.add = function add(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p;

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 12M + 4S + 7A
	  var pz2 = p.z.redSqr();
	  var z2 = this.z.redSqr();
	  var u1 = this.x.redMul(pz2);
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y.redMul(pz2.redMul(p.z));
	  var s2 = p.y.redMul(z2.redMul(this.z));

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(p.z).redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mixedAdd = function mixedAdd(p) {
	  // O + P = P
	  if (this.isInfinity())
	    return p.toJ();

	  // P + O = P
	  if (p.isInfinity())
	    return this;

	  // 8M + 3S + 7A
	  var z2 = this.z.redSqr();
	  var u1 = this.x;
	  var u2 = p.x.redMul(z2);
	  var s1 = this.y;
	  var s2 = p.y.redMul(z2).redMul(this.z);

	  var h = u1.redSub(u2);
	  var r = s1.redSub(s2);
	  if (h.cmpn(0) === 0) {
	    if (r.cmpn(0) !== 0)
	      return this.curve.jpoint(null, null, null);
	    else
	      return this.dbl();
	  }

	  var h2 = h.redSqr();
	  var h3 = h2.redMul(h);
	  var v = u1.redMul(h2);

	  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
	  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
	  var nz = this.z.redMul(h);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.dblp = function dblp(pow) {
	  if (pow === 0)
	    return this;
	  if (this.isInfinity())
	    return this;
	  if (!pow)
	    return this.dbl();

	  var i;
	  if (this.curve.zeroA || this.curve.threeA) {
	    var r = this;
	    for (i = 0; i < pow; i++)
	      r = r.dbl();
	    return r;
	  }

	  // 1M + 2S + 1A + N * (4S + 5M + 8A)
	  // N = 1 => 6M + 6S + 9A
	  var a = this.curve.a;
	  var tinv = this.curve.tinv;

	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  // Reuse results
	  var jyd = jy.redAdd(jy);
	  for (i = 0; i < pow; i++) {
	    var jx2 = jx.redSqr();
	    var jyd2 = jyd.redSqr();
	    var jyd4 = jyd2.redSqr();
	    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	    var t1 = jx.redMul(jyd2);
	    var nx = c.redSqr().redISub(t1.redAdd(t1));
	    var t2 = t1.redISub(nx);
	    var dny = c.redMul(t2);
	    dny = dny.redIAdd(dny).redISub(jyd4);
	    var nz = jyd.redMul(jz);
	    if (i + 1 < pow)
	      jz4 = jz4.redMul(jyd4);

	    jx = nx;
	    jz = nz;
	    jyd = dny;
	  }

	  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
	};

	JPoint.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  if (this.curve.zeroA)
	    return this._zeroDbl();
	  else if (this.curve.threeA)
	    return this._threeDbl();
	  else
	    return this._dbl();
	};

	JPoint.prototype._zeroDbl = function _zeroDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 14A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a; a = 0
	    var m = xx.redAdd(xx).redIAdd(xx);
	    // T = M ^ 2 - 2*S
	    var t = m.redSqr().redISub(s).redISub(s);

	    // 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);

	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2*Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
	    //     #doubling-dbl-2009-l
	    // 2M + 5S + 13A

	    // A = X1^2
	    var a = this.x.redSqr();
	    // B = Y1^2
	    var b = this.y.redSqr();
	    // C = B^2
	    var c = b.redSqr();
	    // D = 2 * ((X1 + B)^2 - A - C)
	    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
	    d = d.redIAdd(d);
	    // E = 3 * A
	    var e = a.redAdd(a).redIAdd(a);
	    // F = E^2
	    var f = e.redSqr();

	    // 8 * C
	    var c8 = c.redIAdd(c);
	    c8 = c8.redIAdd(c8);
	    c8 = c8.redIAdd(c8);

	    // X3 = F - 2 * D
	    nx = f.redISub(d).redISub(d);
	    // Y3 = E * (D - X3) - 8 * C
	    ny = e.redMul(d.redISub(nx)).redISub(c8);
	    // Z3 = 2 * Y1 * Z1
	    nz = this.y.redMul(this.z);
	    nz = nz.redIAdd(nz);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._threeDbl = function _threeDbl() {
	  var nx;
	  var ny;
	  var nz;
	  // Z = 1
	  if (this.zOne) {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
	    //     #doubling-mdbl-2007-bl
	    // 1M + 5S + 15A

	    // XX = X1^2
	    var xx = this.x.redSqr();
	    // YY = Y1^2
	    var yy = this.y.redSqr();
	    // YYYY = YY^2
	    var yyyy = yy.redSqr();
	    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
	    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	    s = s.redIAdd(s);
	    // M = 3 * XX + a
	    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
	    // T = M^2 - 2 * S
	    var t = m.redSqr().redISub(s).redISub(s);
	    // X3 = T
	    nx = t;
	    // Y3 = M * (S - T) - 8 * YYYY
	    var yyyy8 = yyyy.redIAdd(yyyy);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    yyyy8 = yyyy8.redIAdd(yyyy8);
	    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
	    // Z3 = 2 * Y1
	    nz = this.y.redAdd(this.y);
	  } else {
	    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
	    // 3M + 5S

	    // delta = Z1^2
	    var delta = this.z.redSqr();
	    // gamma = Y1^2
	    var gamma = this.y.redSqr();
	    // beta = X1 * gamma
	    var beta = this.x.redMul(gamma);
	    // alpha = 3 * (X1 - delta) * (X1 + delta)
	    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
	    alpha = alpha.redAdd(alpha).redIAdd(alpha);
	    // X3 = alpha^2 - 8 * beta
	    var beta4 = beta.redIAdd(beta);
	    beta4 = beta4.redIAdd(beta4);
	    var beta8 = beta4.redAdd(beta4);
	    nx = alpha.redSqr().redISub(beta8);
	    // Z3 = (Y1 + Z1)^2 - gamma - delta
	    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
	    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
	    var ggamma8 = gamma.redSqr();
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ggamma8 = ggamma8.redIAdd(ggamma8);
	    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
	  }

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype._dbl = function _dbl() {
	  var a = this.curve.a;

	  // 4M + 6S + 10A
	  var jx = this.x;
	  var jy = this.y;
	  var jz = this.z;
	  var jz4 = jz.redSqr().redSqr();

	  var jx2 = jx.redSqr();
	  var jy2 = jy.redSqr();

	  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

	  var jxd4 = jx.redAdd(jx);
	  jxd4 = jxd4.redIAdd(jxd4);
	  var t1 = jxd4.redMul(jy2);
	  var nx = c.redSqr().redISub(t1.redAdd(t1));
	  var t2 = t1.redISub(nx);

	  var jyd8 = jy2.redSqr();
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  jyd8 = jyd8.redIAdd(jyd8);
	  var ny = c.redMul(t2).redISub(jyd8);
	  var nz = jy.redAdd(jy).redMul(jz);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.trpl = function trpl() {
	  if (!this.curve.zeroA)
	    return this.dbl().add(this);

	  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
	  // 5M + 10S + ...

	  // XX = X1^2
	  var xx = this.x.redSqr();
	  // YY = Y1^2
	  var yy = this.y.redSqr();
	  // ZZ = Z1^2
	  var zz = this.z.redSqr();
	  // YYYY = YY^2
	  var yyyy = yy.redSqr();
	  // M = 3 * XX + a * ZZ2; a = 0
	  var m = xx.redAdd(xx).redIAdd(xx);
	  // MM = M^2
	  var mm = m.redSqr();
	  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
	  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
	  e = e.redIAdd(e);
	  e = e.redAdd(e).redIAdd(e);
	  e = e.redISub(mm);
	  // EE = E^2
	  var ee = e.redSqr();
	  // T = 16*YYYY
	  var t = yyyy.redIAdd(yyyy);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  t = t.redIAdd(t);
	  // U = (M + E)^2 - MM - EE - T
	  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
	  // X3 = 4 * (X1 * EE - 4 * YY * U)
	  var yyu4 = yy.redMul(u);
	  yyu4 = yyu4.redIAdd(yyu4);
	  yyu4 = yyu4.redIAdd(yyu4);
	  var nx = this.x.redMul(ee).redISub(yyu4);
	  nx = nx.redIAdd(nx);
	  nx = nx.redIAdd(nx);
	  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
	  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  ny = ny.redIAdd(ny);
	  // Z3 = (Z1 + E)^2 - ZZ - EE
	  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

	  return this.curve.jpoint(nx, ny, nz);
	};

	JPoint.prototype.mul = function mul(k, kbase) {
	  k = new BN(k, kbase);

	  return this.curve._wnafMul(this, k);
	};

	JPoint.prototype.eq = function eq(p) {
	  if (p.type === 'affine')
	    return this.eq(p.toJ());

	  if (this === p)
	    return true;

	  // x1 * z2^2 == x2 * z1^2
	  var z2 = this.z.redSqr();
	  var pz2 = p.z.redSqr();
	  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
	    return false;

	  // y1 * z2^3 == y2 * z1^3
	  var z3 = z2.redMul(this.z);
	  var pz3 = pz2.redMul(p.z);
	  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
	};

	JPoint.prototype.eqXToP = function eqXToP(x) {
	  var zs = this.z.redSqr();
	  var rx = x.toRed(this.curve.red).redMul(zs);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(zs);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	JPoint.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC JPoint Infinity>';
	  return '<EC JPoint x: ' + this.x.toString(16, 2) +
	      ' y: ' + this.y.toString(16, 2) +
	      ' z: ' + this.z.toString(16, 2) + '>';
	};

	JPoint.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};
	return short;
}

var mont;
var hasRequiredMont;

function requireMont () {
	if (hasRequiredMont) return mont;
	hasRequiredMont = 1;

	var BN = requireBn$2();
	var inherits = requireInherits_browser();
	var Base = requireBase();

	var utils = requireUtils();

	function MontCurve(conf) {
	  Base.call(this, 'mont', conf);

	  this.a = new BN(conf.a, 16).toRed(this.red);
	  this.b = new BN(conf.b, 16).toRed(this.red);
	  this.i4 = new BN(4).toRed(this.red).redInvm();
	  this.two = new BN(2).toRed(this.red);
	  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
	}
	inherits(MontCurve, Base);
	mont = MontCurve;

	MontCurve.prototype.validate = function validate(point) {
	  var x = point.normalize().x;
	  var x2 = x.redSqr();
	  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
	  var y = rhs.redSqrt();

	  return y.redSqr().cmp(rhs) === 0;
	};

	function Point(curve, x, z) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && z === null) {
	    this.x = this.curve.one;
	    this.z = this.curve.zero;
	  } else {
	    this.x = new BN(x, 16);
	    this.z = new BN(z, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	  }
	}
	inherits(Point, Base.BasePoint);

	MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
	  return this.point(utils.toArray(bytes, enc), 1);
	};

	MontCurve.prototype.point = function point(x, z) {
	  return new Point(this, x, z);
	};

	MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	Point.prototype.precompute = function precompute() {
	  // No-op
	};

	Point.prototype._encode = function _encode() {
	  return this.getX().toArray('be', this.curve.p.byteLength());
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1] || curve.one);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.z.cmpn(0) === 0;
	};

	Point.prototype.dbl = function dbl() {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
	  // 2M + 2S + 4A

	  // A = X1 + Z1
	  var a = this.x.redAdd(this.z);
	  // AA = A^2
	  var aa = a.redSqr();
	  // B = X1 - Z1
	  var b = this.x.redSub(this.z);
	  // BB = B^2
	  var bb = b.redSqr();
	  // C = AA - BB
	  var c = aa.redSub(bb);
	  // X3 = AA * BB
	  var nx = aa.redMul(bb);
	  // Z3 = C * (BB + A24 * C)
	  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
	  return this.curve.point(nx, nz);
	};

	Point.prototype.add = function add() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.diffAdd = function diffAdd(p, diff) {
	  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
	  // 4M + 2S + 6A

	  // A = X2 + Z2
	  var a = this.x.redAdd(this.z);
	  // B = X2 - Z2
	  var b = this.x.redSub(this.z);
	  // C = X3 + Z3
	  var c = p.x.redAdd(p.z);
	  // D = X3 - Z3
	  var d = p.x.redSub(p.z);
	  // DA = D * A
	  var da = d.redMul(a);
	  // CB = C * B
	  var cb = c.redMul(b);
	  // X5 = Z1 * (DA + CB)^2
	  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
	  // Z5 = X1 * (DA - CB)^2
	  var nz = diff.x.redMul(da.redISub(cb).redSqr());
	  return this.curve.point(nx, nz);
	};

	Point.prototype.mul = function mul(k) {
	  var t = k.clone();
	  var a = this; // (N / 2) * Q + Q
	  var b = this.curve.point(null, null); // (N / 2) * Q
	  var c = this; // Q

	  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
	    bits.push(t.andln(1));

	  for (var i = bits.length - 1; i >= 0; i--) {
	    if (bits[i] === 0) {
	      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
	      a = a.diffAdd(b, c);
	      // N * Q = 2 * ((N / 2) * Q + Q))
	      b = b.dbl();
	    } else {
	      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
	      b = a.diffAdd(b, c);
	      // N * Q + Q = 2 * ((N / 2) * Q + Q)
	      a = a.dbl();
	    }
	  }
	  return b;
	};

	Point.prototype.mulAdd = function mulAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.jumlAdd = function jumlAdd() {
	  throw new Error('Not supported on Montgomery curve');
	};

	Point.prototype.eq = function eq(other) {
	  return this.getX().cmp(other.getX()) === 0;
	};

	Point.prototype.normalize = function normalize() {
	  this.x = this.x.redMul(this.z.redInvm());
	  this.z = this.curve.one;
	  return this;
	};

	Point.prototype.getX = function getX() {
	  // Normalize coordinates
	  this.normalize();

	  return this.x.fromRed();
	};
	return mont;
}

var edwards;
var hasRequiredEdwards;

function requireEdwards () {
	if (hasRequiredEdwards) return edwards;
	hasRequiredEdwards = 1;

	var utils = requireUtils();
	var BN = requireBn$2();
	var inherits = requireInherits_browser();
	var Base = requireBase();

	var assert = utils.assert;

	function EdwardsCurve(conf) {
	  // NOTE: Important as we are creating point in Base.call()
	  this.twisted = (conf.a | 0) !== 1;
	  this.mOneA = this.twisted && (conf.a | 0) === -1;
	  this.extended = this.mOneA;

	  Base.call(this, 'edwards', conf);

	  this.a = new BN(conf.a, 16).umod(this.red.m);
	  this.a = this.a.toRed(this.red);
	  this.c = new BN(conf.c, 16).toRed(this.red);
	  this.c2 = this.c.redSqr();
	  this.d = new BN(conf.d, 16).toRed(this.red);
	  this.dd = this.d.redAdd(this.d);

	  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
	  this.oneC = (conf.c | 0) === 1;
	}
	inherits(EdwardsCurve, Base);
	edwards = EdwardsCurve;

	EdwardsCurve.prototype._mulA = function _mulA(num) {
	  if (this.mOneA)
	    return num.redNeg();
	  else
	    return this.a.redMul(num);
	};

	EdwardsCurve.prototype._mulC = function _mulC(num) {
	  if (this.oneC)
	    return num;
	  else
	    return this.c.redMul(num);
	};

	// Just for compatibility with Short curve
	EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
	  return this.point(x, y, z, t);
	};

	EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
	  x = new BN(x, 16);
	  if (!x.red)
	    x = x.toRed(this.red);

	  var x2 = x.redSqr();
	  var rhs = this.c2.redSub(this.a.redMul(x2));
	  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

	  var y2 = rhs.redMul(lhs.redInvm());
	  var y = y2.redSqrt();
	  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  var isOdd = y.fromRed().isOdd();
	  if (odd && !isOdd || !odd && isOdd)
	    y = y.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
	  y = new BN(y, 16);
	  if (!y.red)
	    y = y.toRed(this.red);

	  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
	  var y2 = y.redSqr();
	  var lhs = y2.redSub(this.c2);
	  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
	  var x2 = lhs.redMul(rhs.redInvm());

	  if (x2.cmp(this.zero) === 0) {
	    if (odd)
	      throw new Error('invalid point');
	    else
	      return this.point(this.zero, y);
	  }

	  var x = x2.redSqrt();
	  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
	    throw new Error('invalid point');

	  if (x.fromRed().isOdd() !== odd)
	    x = x.redNeg();

	  return this.point(x, y);
	};

	EdwardsCurve.prototype.validate = function validate(point) {
	  if (point.isInfinity())
	    return true;

	  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
	  point.normalize();

	  var x2 = point.x.redSqr();
	  var y2 = point.y.redSqr();
	  var lhs = x2.redMul(this.a).redAdd(y2);
	  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

	  return lhs.cmp(rhs) === 0;
	};

	function Point(curve, x, y, z, t) {
	  Base.BasePoint.call(this, curve, 'projective');
	  if (x === null && y === null && z === null) {
	    this.x = this.curve.zero;
	    this.y = this.curve.one;
	    this.z = this.curve.one;
	    this.t = this.curve.zero;
	    this.zOne = true;
	  } else {
	    this.x = new BN(x, 16);
	    this.y = new BN(y, 16);
	    this.z = z ? new BN(z, 16) : this.curve.one;
	    this.t = t && new BN(t, 16);
	    if (!this.x.red)
	      this.x = this.x.toRed(this.curve.red);
	    if (!this.y.red)
	      this.y = this.y.toRed(this.curve.red);
	    if (!this.z.red)
	      this.z = this.z.toRed(this.curve.red);
	    if (this.t && !this.t.red)
	      this.t = this.t.toRed(this.curve.red);
	    this.zOne = this.z === this.curve.one;

	    // Use extended coordinates
	    if (this.curve.extended && !this.t) {
	      this.t = this.x.redMul(this.y);
	      if (!this.zOne)
	        this.t = this.t.redMul(this.z.redInvm());
	    }
	  }
	}
	inherits(Point, Base.BasePoint);

	EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
	  return Point.fromJSON(this, obj);
	};

	EdwardsCurve.prototype.point = function point(x, y, z, t) {
	  return new Point(this, x, y, z, t);
	};

	Point.fromJSON = function fromJSON(curve, obj) {
	  return new Point(curve, obj[0], obj[1], obj[2]);
	};

	Point.prototype.inspect = function inspect() {
	  if (this.isInfinity())
	    return '<EC Point Infinity>';
	  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
	      ' y: ' + this.y.fromRed().toString(16, 2) +
	      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
	};

	Point.prototype.isInfinity = function isInfinity() {
	  // XXX This code assumes that zero is always zero in red
	  return this.x.cmpn(0) === 0 &&
	    (this.y.cmp(this.z) === 0 ||
	    (this.zOne && this.y.cmp(this.curve.c) === 0));
	};

	Point.prototype._extDbl = function _extDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #doubling-dbl-2008-hwcd
	  // 4M + 4S

	  // A = X1^2
	  var a = this.x.redSqr();
	  // B = Y1^2
	  var b = this.y.redSqr();
	  // C = 2 * Z1^2
	  var c = this.z.redSqr();
	  c = c.redIAdd(c);
	  // D = a * A
	  var d = this.curve._mulA(a);
	  // E = (X1 + Y1)^2 - A - B
	  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
	  // G = D + B
	  var g = d.redAdd(b);
	  // F = G - C
	  var f = g.redSub(c);
	  // H = D - B
	  var h = d.redSub(b);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projDbl = function _projDbl() {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #doubling-dbl-2008-bbjlp
	  //     #doubling-dbl-2007-bl
	  // and others
	  // Generally 3M + 4S or 2M + 4S

	  // B = (X1 + Y1)^2
	  var b = this.x.redAdd(this.y).redSqr();
	  // C = X1^2
	  var c = this.x.redSqr();
	  // D = Y1^2
	  var d = this.y.redSqr();

	  var nx;
	  var ny;
	  var nz;
	  var e;
	  var h;
	  var j;
	  if (this.curve.twisted) {
	    // E = a * C
	    e = this.curve._mulA(c);
	    // F = E + D
	    var f = e.redAdd(d);
	    if (this.zOne) {
	      // X3 = (B - C - D) * (F - 2)
	      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F^2 - 2 * F
	      nz = f.redSqr().redSub(f).redSub(f);
	    } else {
	      // H = Z1^2
	      h = this.z.redSqr();
	      // J = F - 2 * H
	      j = f.redSub(h).redISub(h);
	      // X3 = (B-C-D)*J
	      nx = b.redSub(c).redISub(d).redMul(j);
	      // Y3 = F * (E - D)
	      ny = f.redMul(e.redSub(d));
	      // Z3 = F * J
	      nz = f.redMul(j);
	    }
	  } else {
	    // E = C + D
	    e = c.redAdd(d);
	    // H = (c * Z1)^2
	    h = this.curve._mulC(this.z).redSqr();
	    // J = E - 2 * H
	    j = e.redSub(h).redSub(h);
	    // X3 = c * (B - E) * J
	    nx = this.curve._mulC(b.redISub(e)).redMul(j);
	    // Y3 = c * E * (C - D)
	    ny = this.curve._mulC(e).redMul(c.redISub(d));
	    // Z3 = E * J
	    nz = e.redMul(j);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.dbl = function dbl() {
	  if (this.isInfinity())
	    return this;

	  // Double in extended coordinates
	  if (this.curve.extended)
	    return this._extDbl();
	  else
	    return this._projDbl();
	};

	Point.prototype._extAdd = function _extAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
	  //     #addition-add-2008-hwcd-3
	  // 8M

	  // A = (Y1 - X1) * (Y2 - X2)
	  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
	  // B = (Y1 + X1) * (Y2 + X2)
	  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
	  // C = T1 * k * T2
	  var c = this.t.redMul(this.curve.dd).redMul(p.t);
	  // D = Z1 * 2 * Z2
	  var d = this.z.redMul(p.z.redAdd(p.z));
	  // E = B - A
	  var e = b.redSub(a);
	  // F = D - C
	  var f = d.redSub(c);
	  // G = D + C
	  var g = d.redAdd(c);
	  // H = B + A
	  var h = b.redAdd(a);
	  // X3 = E * F
	  var nx = e.redMul(f);
	  // Y3 = G * H
	  var ny = g.redMul(h);
	  // T3 = E * H
	  var nt = e.redMul(h);
	  // Z3 = F * G
	  var nz = f.redMul(g);
	  return this.curve.point(nx, ny, nz, nt);
	};

	Point.prototype._projAdd = function _projAdd(p) {
	  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
	  //     #addition-add-2008-bbjlp
	  //     #addition-add-2007-bl
	  // 10M + 1S

	  // A = Z1 * Z2
	  var a = this.z.redMul(p.z);
	  // B = A^2
	  var b = a.redSqr();
	  // C = X1 * X2
	  var c = this.x.redMul(p.x);
	  // D = Y1 * Y2
	  var d = this.y.redMul(p.y);
	  // E = d * C * D
	  var e = this.curve.d.redMul(c).redMul(d);
	  // F = B - E
	  var f = b.redSub(e);
	  // G = B + E
	  var g = b.redAdd(e);
	  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
	  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
	  var nx = a.redMul(f).redMul(tmp);
	  var ny;
	  var nz;
	  if (this.curve.twisted) {
	    // Y3 = A * G * (D - a * C)
	    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
	    // Z3 = F * G
	    nz = f.redMul(g);
	  } else {
	    // Y3 = A * G * (D - C)
	    ny = a.redMul(g).redMul(d.redSub(c));
	    // Z3 = c * F * G
	    nz = this.curve._mulC(f).redMul(g);
	  }
	  return this.curve.point(nx, ny, nz);
	};

	Point.prototype.add = function add(p) {
	  if (this.isInfinity())
	    return p;
	  if (p.isInfinity())
	    return this;

	  if (this.curve.extended)
	    return this._extAdd(p);
	  else
	    return this._projAdd(p);
	};

	Point.prototype.mul = function mul(k) {
	  if (this._hasDoubles(k))
	    return this.curve._fixedNafMul(this, k);
	  else
	    return this.curve._wnafMul(this, k);
	};

	Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
	};

	Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
	  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
	};

	Point.prototype.normalize = function normalize() {
	  if (this.zOne)
	    return this;

	  // Normalize coordinates
	  var zi = this.z.redInvm();
	  this.x = this.x.redMul(zi);
	  this.y = this.y.redMul(zi);
	  if (this.t)
	    this.t = this.t.redMul(zi);
	  this.z = this.curve.one;
	  this.zOne = true;
	  return this;
	};

	Point.prototype.neg = function neg() {
	  return this.curve.point(this.x.redNeg(),
	    this.y,
	    this.z,
	    this.t && this.t.redNeg());
	};

	Point.prototype.getX = function getX() {
	  this.normalize();
	  return this.x.fromRed();
	};

	Point.prototype.getY = function getY() {
	  this.normalize();
	  return this.y.fromRed();
	};

	Point.prototype.eq = function eq(other) {
	  return this === other ||
	         this.getX().cmp(other.getX()) === 0 &&
	         this.getY().cmp(other.getY()) === 0;
	};

	Point.prototype.eqXToP = function eqXToP(x) {
	  var rx = x.toRed(this.curve.red).redMul(this.z);
	  if (this.x.cmp(rx) === 0)
	    return true;

	  var xc = x.clone();
	  var t = this.curve.redN.redMul(this.z);
	  for (;;) {
	    xc.iadd(this.curve.n);
	    if (xc.cmp(this.curve.p) >= 0)
	      return false;

	    rx.redIAdd(t);
	    if (this.x.cmp(rx) === 0)
	      return true;
	  }
	};

	// Compatibility with BaseCurve
	Point.prototype.toP = Point.prototype.normalize;
	Point.prototype.mixedAdd = Point.prototype.add;
	return edwards;
}

var hasRequiredCurve;

function requireCurve () {
	if (hasRequiredCurve) return curve;
	hasRequiredCurve = 1;
	(function (exports) {

		var curve = exports;

		curve.base = requireBase();
		curve.short = requireShort();
		curve.mont = requireMont();
		curve.edwards = requireEdwards(); 
	} (curve));
	return curve;
}

var curves = {};

var secp256k1;
var hasRequiredSecp256k1;

function requireSecp256k1 () {
	if (hasRequiredSecp256k1) return secp256k1;
	hasRequiredSecp256k1 = 1;
	secp256k1 = {
	  doubles: {
	    step: 4,
	    points: [
	      [
	        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
	        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
	      ],
	      [
	        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
	        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
	      ],
	      [
	        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
	        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
	      ],
	      [
	        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
	        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
	      ],
	      [
	        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
	        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
	      ],
	      [
	        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
	        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
	      ],
	      [
	        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
	        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
	      ],
	      [
	        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
	        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
	      ],
	      [
	        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
	        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
	      ],
	      [
	        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
	        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
	      ],
	      [
	        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
	        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
	      ],
	      [
	        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
	        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
	      ],
	      [
	        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
	        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
	      ],
	      [
	        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
	        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
	      ],
	      [
	        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
	        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
	      ],
	      [
	        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
	        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
	      ],
	      [
	        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
	        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
	      ],
	      [
	        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
	        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
	      ],
	      [
	        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
	        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
	      ],
	      [
	        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
	        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
	      ],
	      [
	        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
	        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
	      ],
	      [
	        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
	        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
	      ],
	      [
	        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
	        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
	      ],
	      [
	        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
	        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
	      ],
	      [
	        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
	        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
	      ],
	      [
	        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
	        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
	      ],
	      [
	        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
	        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
	      ],
	      [
	        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
	        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
	      ],
	      [
	        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
	        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
	      ],
	      [
	        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
	        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
	      ],
	      [
	        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
	        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
	      ],
	      [
	        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
	        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
	      ],
	      [
	        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
	        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
	      ],
	      [
	        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
	        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
	      ],
	      [
	        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
	        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
	      ],
	      [
	        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
	        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
	      ],
	      [
	        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
	        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
	      ],
	      [
	        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
	        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
	      ],
	      [
	        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
	        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
	      ],
	      [
	        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
	        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
	      ],
	      [
	        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
	        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
	      ],
	      [
	        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
	        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
	      ],
	      [
	        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
	        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
	      ],
	      [
	        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
	        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
	      ],
	      [
	        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
	        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
	      ],
	      [
	        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
	        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
	      ],
	      [
	        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
	        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
	      ],
	      [
	        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
	        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
	      ],
	      [
	        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
	        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
	      ],
	      [
	        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
	        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
	      ],
	      [
	        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
	        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
	      ],
	      [
	        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
	        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
	      ],
	      [
	        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
	        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
	      ],
	      [
	        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
	        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
	      ],
	      [
	        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
	        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
	      ],
	      [
	        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
	        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
	      ],
	      [
	        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
	        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
	      ],
	      [
	        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
	        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
	      ],
	      [
	        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
	        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
	      ],
	      [
	        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
	        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
	      ],
	      [
	        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
	        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
	      ],
	      [
	        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
	        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
	      ],
	      [
	        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
	        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
	      ],
	      [
	        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
	        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
	      ],
	      [
	        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
	        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
	      ],
	    ],
	  },
	  naf: {
	    wnd: 7,
	    points: [
	      [
	        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
	        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
	      ],
	      [
	        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
	        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
	      ],
	      [
	        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
	        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
	      ],
	      [
	        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
	        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
	      ],
	      [
	        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
	        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
	      ],
	      [
	        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
	        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
	      ],
	      [
	        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
	        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
	      ],
	      [
	        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
	        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
	      ],
	      [
	        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
	        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
	      ],
	      [
	        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
	        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
	      ],
	      [
	        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
	        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
	      ],
	      [
	        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
	        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
	      ],
	      [
	        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
	        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
	      ],
	      [
	        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
	        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
	      ],
	      [
	        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
	        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
	      ],
	      [
	        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
	        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
	      ],
	      [
	        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
	        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
	      ],
	      [
	        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
	        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
	      ],
	      [
	        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
	        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
	      ],
	      [
	        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
	        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
	      ],
	      [
	        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
	        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
	      ],
	      [
	        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
	        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
	      ],
	      [
	        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
	        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
	      ],
	      [
	        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
	        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
	      ],
	      [
	        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
	        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
	      ],
	      [
	        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
	        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
	      ],
	      [
	        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
	        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
	      ],
	      [
	        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
	        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
	      ],
	      [
	        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
	        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
	      ],
	      [
	        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
	        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
	      ],
	      [
	        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
	        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
	      ],
	      [
	        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
	        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
	      ],
	      [
	        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
	        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
	      ],
	      [
	        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
	        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
	      ],
	      [
	        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
	        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
	      ],
	      [
	        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
	        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
	      ],
	      [
	        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
	        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
	      ],
	      [
	        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
	        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
	      ],
	      [
	        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
	        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
	      ],
	      [
	        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
	        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
	      ],
	      [
	        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
	        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
	      ],
	      [
	        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
	        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
	      ],
	      [
	        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
	        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
	      ],
	      [
	        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
	        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
	      ],
	      [
	        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
	        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
	      ],
	      [
	        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
	        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
	      ],
	      [
	        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
	        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
	      ],
	      [
	        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
	        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
	      ],
	      [
	        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
	        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
	      ],
	      [
	        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
	        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
	      ],
	      [
	        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
	        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
	      ],
	      [
	        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
	        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
	      ],
	      [
	        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
	        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
	      ],
	      [
	        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
	        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
	      ],
	      [
	        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
	        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
	      ],
	      [
	        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
	        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
	      ],
	      [
	        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
	        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
	      ],
	      [
	        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
	        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
	      ],
	      [
	        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
	        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
	      ],
	      [
	        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
	        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
	      ],
	      [
	        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
	        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
	      ],
	      [
	        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
	        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
	      ],
	      [
	        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
	        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
	      ],
	      [
	        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
	        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
	      ],
	      [
	        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
	        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
	      ],
	      [
	        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
	        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
	      ],
	      [
	        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
	        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
	      ],
	      [
	        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
	        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
	      ],
	      [
	        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
	        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
	      ],
	      [
	        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
	        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
	      ],
	      [
	        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
	        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
	      ],
	      [
	        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
	        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
	      ],
	      [
	        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
	        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
	      ],
	      [
	        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
	        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
	      ],
	      [
	        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
	        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
	      ],
	      [
	        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
	        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
	      ],
	      [
	        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
	        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
	      ],
	      [
	        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
	        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
	      ],
	      [
	        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
	        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
	      ],
	      [
	        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
	        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
	      ],
	      [
	        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
	        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
	      ],
	      [
	        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
	        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
	      ],
	      [
	        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
	        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
	      ],
	      [
	        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
	        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
	      ],
	      [
	        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
	        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
	      ],
	      [
	        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
	        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
	      ],
	      [
	        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
	        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
	      ],
	      [
	        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
	        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
	      ],
	      [
	        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
	        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
	      ],
	      [
	        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
	        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
	      ],
	      [
	        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
	        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
	      ],
	      [
	        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
	        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
	      ],
	      [
	        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
	        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
	      ],
	      [
	        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
	        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
	      ],
	      [
	        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
	        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
	      ],
	      [
	        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
	        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
	      ],
	      [
	        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
	        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
	      ],
	      [
	        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
	        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
	      ],
	      [
	        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
	        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
	      ],
	      [
	        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
	        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
	      ],
	      [
	        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
	        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
	      ],
	      [
	        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
	        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
	      ],
	      [
	        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
	        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
	      ],
	      [
	        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
	        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
	      ],
	      [
	        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
	        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
	      ],
	      [
	        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
	        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
	      ],
	      [
	        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
	        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
	      ],
	      [
	        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
	        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
	      ],
	      [
	        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
	        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
	      ],
	      [
	        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
	        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
	      ],
	      [
	        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
	        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
	      ],
	      [
	        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
	        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
	      ],
	      [
	        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
	        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
	      ],
	      [
	        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
	        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
	      ],
	      [
	        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
	        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
	      ],
	      [
	        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
	        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
	      ],
	      [
	        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
	        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
	      ],
	      [
	        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
	        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
	      ],
	      [
	        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
	        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
	      ],
	      [
	        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
	        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
	      ],
	      [
	        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
	        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
	      ],
	      [
	        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
	        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
	      ],
	      [
	        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
	        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
	      ],
	      [
	        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
	        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
	      ],
	      [
	        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
	        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
	      ],
	      [
	        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
	        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
	      ],
	      [
	        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
	        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
	      ],
	    ],
	  },
	};
	return secp256k1;
}

var hasRequiredCurves;

function requireCurves () {
	if (hasRequiredCurves) return curves;
	hasRequiredCurves = 1;
	(function (exports) {

		var curves = exports;

		var hash = requireHash();
		var curve = requireCurve();
		var utils = requireUtils();

		var assert = utils.assert;

		function PresetCurve(options) {
		  if (options.type === 'short')
		    this.curve = new curve.short(options);
		  else if (options.type === 'edwards')
		    this.curve = new curve.edwards(options);
		  else
		    this.curve = new curve.mont(options);
		  this.g = this.curve.g;
		  this.n = this.curve.n;
		  this.hash = options.hash;

		  assert(this.g.validate(), 'Invalid curve');
		  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
		}
		curves.PresetCurve = PresetCurve;

		function defineCurve(name, options) {
		  Object.defineProperty(curves, name, {
		    configurable: true,
		    enumerable: true,
		    get: function() {
		      var curve = new PresetCurve(options);
		      Object.defineProperty(curves, name, {
		        configurable: true,
		        enumerable: true,
		        value: curve,
		      });
		      return curve;
		    },
		  });
		}

		defineCurve('p192', {
		  type: 'short',
		  prime: 'p192',
		  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
		  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
		  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
		    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
		  ],
		});

		defineCurve('p224', {
		  type: 'short',
		  prime: 'p224',
		  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
		  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
		  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
		  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
		    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
		  ],
		});

		defineCurve('p256', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
		  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
		  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
		  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
		    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
		  ],
		});

		defineCurve('p384', {
		  type: 'short',
		  prime: null,
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 ffffffff',
		  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'fffffffe ffffffff 00000000 00000000 fffffffc',
		  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
		     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
		  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
		     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
		  hash: hash.sha384,
		  gRed: false,
		  g: [
		    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
		    '5502f25d bf55296c 3a545e38 72760ab7',
		    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
		    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
		  ],
		});

		defineCurve('p521', {
		  type: 'short',
		  prime: null,
		  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff',
		  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff ffffffff ffffffff fffffffc',
		  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
		     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
		     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
		  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
		     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
		     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
		  hash: hash.sha512,
		  gRed: false,
		  g: [
		    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
		    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
		    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
		    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
		    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
		    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
		  ],
		});

		defineCurve('curve25519', {
		  type: 'mont',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '76d06',
		  b: '1',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '9',
		  ],
		});

		defineCurve('ed25519', {
		  type: 'edwards',
		  prime: 'p25519',
		  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
		  a: '-1',
		  c: '1',
		  // -121665 * (121666^(-1)) (mod P)
		  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
		  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
		  hash: hash.sha256,
		  gRed: false,
		  g: [
		    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

		    // 4/5
		    '6666666666666666666666666666666666666666666666666666666666666658',
		  ],
		});

		var pre;
		try {
		  pre = requireSecp256k1();
		} catch (e) {
		  pre = undefined;
		}

		defineCurve('secp256k1', {
		  type: 'short',
		  prime: 'k256',
		  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
		  a: '0',
		  b: '7',
		  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
		  h: '1',
		  hash: hash.sha256,

		  // Precomputed endomorphism
		  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
		  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
		  basis: [
		    {
		      a: '3086d221a7d46bcde86c90e49284eb15',
		      b: '-e4437ed6010e88286f547fa90abfe4c3',
		    },
		    {
		      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
		      b: '3086d221a7d46bcde86c90e49284eb15',
		    },
		  ],

		  gRed: false,
		  g: [
		    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
		    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
		    pre,
		  ],
		}); 
	} (curves));
	return curves;
}

var key$1;
var hasRequiredKey$1;

function requireKey$1 () {
	if (hasRequiredKey$1) return key$1;
	hasRequiredKey$1 = 1;

	var BN = requireBn$2();
	var utils = requireUtils();
	var assert = utils.assert;

	function KeyPair(ec, options) {
	  this.ec = ec;
	  this.priv = null;
	  this.pub = null;

	  // KeyPair(ec, { priv: ..., pub: ... })
	  if (options.priv)
	    this._importPrivate(options.priv, options.privEnc);
	  if (options.pub)
	    this._importPublic(options.pub, options.pubEnc);
	}
	key$1 = KeyPair;

	KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
	  if (pub instanceof KeyPair)
	    return pub;

	  return new KeyPair(ec, {
	    pub: pub,
	    pubEnc: enc,
	  });
	};

	KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
	  if (priv instanceof KeyPair)
	    return priv;

	  return new KeyPair(ec, {
	    priv: priv,
	    privEnc: enc,
	  });
	};

	KeyPair.prototype.validate = function validate() {
	  var pub = this.getPublic();

	  if (pub.isInfinity())
	    return { result: false, reason: 'Invalid public key' };
	  if (!pub.validate())
	    return { result: false, reason: 'Public key is not a point' };
	  if (!pub.mul(this.ec.curve.n).isInfinity())
	    return { result: false, reason: 'Public key * N != O' };

	  return { result: true, reason: null };
	};

	KeyPair.prototype.getPublic = function getPublic(compact, enc) {
	  // compact is optional argument
	  if (typeof compact === 'string') {
	    enc = compact;
	    compact = null;
	  }

	  if (!this.pub)
	    this.pub = this.ec.g.mul(this.priv);

	  if (!enc)
	    return this.pub;

	  return this.pub.encode(enc, compact);
	};

	KeyPair.prototype.getPrivate = function getPrivate(enc) {
	  if (enc === 'hex')
	    return this.priv.toString(16, 2);
	  else
	    return this.priv;
	};

	KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
	  this.priv = new BN(key, enc || 16);

	  // Ensure that the priv won't be bigger than n, otherwise we may fail
	  // in fixed multiplication method
	  this.priv = this.priv.umod(this.ec.curve.n);
	};

	KeyPair.prototype._importPublic = function _importPublic(key, enc) {
	  if (key.x || key.y) {
	    // Montgomery points only have an `x` coordinate.
	    // Weierstrass/Edwards points on the other hand have both `x` and
	    // `y` coordinates.
	    if (this.ec.curve.type === 'mont') {
	      assert(key.x, 'Need x coordinate');
	    } else if (this.ec.curve.type === 'short' ||
	               this.ec.curve.type === 'edwards') {
	      assert(key.x && key.y, 'Need both x and y coordinate');
	    }
	    this.pub = this.ec.curve.point(key.x, key.y);
	    return;
	  }
	  this.pub = this.ec.curve.decodePoint(key, enc);
	};

	// ECDH
	KeyPair.prototype.derive = function derive(pub) {
	  if(!pub.validate()) {
	    assert(pub.validate(), 'public point not validated');
	  }
	  return pub.mul(this.priv).getX();
	};

	// ECDSA
	KeyPair.prototype.sign = function sign(msg, enc, options) {
	  return this.ec.sign(msg, this, enc, options);
	};

	KeyPair.prototype.verify = function verify(msg, signature) {
	  return this.ec.verify(msg, signature, this);
	};

	KeyPair.prototype.inspect = function inspect() {
	  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
	         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
	};
	return key$1;
}

var signature$1;
var hasRequiredSignature$1;

function requireSignature$1 () {
	if (hasRequiredSignature$1) return signature$1;
	hasRequiredSignature$1 = 1;

	var BN = requireBn$2();

	var utils = requireUtils();
	var assert = utils.assert;

	function Signature(options, enc) {
	  if (options instanceof Signature)
	    return options;

	  if (this._importDER(options, enc))
	    return;

	  assert(options.r && options.s, 'Signature without r or s');
	  this.r = new BN(options.r, 16);
	  this.s = new BN(options.s, 16);
	  if (options.recoveryParam === undefined)
	    this.recoveryParam = null;
	  else
	    this.recoveryParam = options.recoveryParam;
	}
	signature$1 = Signature;

	function Position() {
	  this.place = 0;
	}

	function getLength(buf, p) {
	  var initial = buf[p.place++];
	  if (!(initial & 0x80)) {
	    return initial;
	  }
	  var octetLen = initial & 0xf;

	  // Indefinite length or overflow
	  if (octetLen === 0 || octetLen > 4) {
	    return false;
	  }

	  var val = 0;
	  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
	    val <<= 8;
	    val |= buf[off];
	    val >>>= 0;
	  }

	  // Leading zeroes
	  if (val <= 0x7f) {
	    return false;
	  }

	  p.place = off;
	  return val;
	}

	function rmPadding(buf) {
	  var i = 0;
	  var len = buf.length - 1;
	  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
	    i++;
	  }
	  if (i === 0) {
	    return buf;
	  }
	  return buf.slice(i);
	}

	Signature.prototype._importDER = function _importDER(data, enc) {
	  data = utils.toArray(data, enc);
	  var p = new Position();
	  if (data[p.place++] !== 0x30) {
	    return false;
	  }
	  var len = getLength(data, p);
	  if (len === false) {
	    return false;
	  }
	  if ((len + p.place) !== data.length) {
	    return false;
	  }
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var rlen = getLength(data, p);
	  if (rlen === false) {
	    return false;
	  }
	  var r = data.slice(p.place, rlen + p.place);
	  p.place += rlen;
	  if (data[p.place++] !== 0x02) {
	    return false;
	  }
	  var slen = getLength(data, p);
	  if (slen === false) {
	    return false;
	  }
	  if (data.length !== slen + p.place) {
	    return false;
	  }
	  var s = data.slice(p.place, slen + p.place);
	  if (r[0] === 0) {
	    if (r[1] & 0x80) {
	      r = r.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }
	  if (s[0] === 0) {
	    if (s[1] & 0x80) {
	      s = s.slice(1);
	    } else {
	      // Leading zeroes
	      return false;
	    }
	  }

	  this.r = new BN(r);
	  this.s = new BN(s);
	  this.recoveryParam = null;

	  return true;
	};

	function constructLength(arr, len) {
	  if (len < 0x80) {
	    arr.push(len);
	    return;
	  }
	  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
	  arr.push(octets | 0x80);
	  while (--octets) {
	    arr.push((len >>> (octets << 3)) & 0xff);
	  }
	  arr.push(len);
	}

	Signature.prototype.toDER = function toDER(enc) {
	  var r = this.r.toArray();
	  var s = this.s.toArray();

	  // Pad values
	  if (r[0] & 0x80)
	    r = [ 0 ].concat(r);
	  // Pad values
	  if (s[0] & 0x80)
	    s = [ 0 ].concat(s);

	  r = rmPadding(r);
	  s = rmPadding(s);

	  while (!s[0] && !(s[1] & 0x80)) {
	    s = s.slice(1);
	  }
	  var arr = [ 0x02 ];
	  constructLength(arr, r.length);
	  arr = arr.concat(r);
	  arr.push(0x02);
	  constructLength(arr, s.length);
	  var backHalf = arr.concat(s);
	  var res = [ 0x30 ];
	  constructLength(res, backHalf.length);
	  res = res.concat(backHalf);
	  return utils.encode(res, enc);
	};
	return signature$1;
}

var ec;
var hasRequiredEc;

function requireEc () {
	if (hasRequiredEc) return ec;
	hasRequiredEc = 1;

	var BN = requireBn$2();
	var HmacDRBG = requireHmacDrbg();
	var utils = requireUtils();
	var curves = requireCurves();
	var rand = requireBrorand();
	var assert = utils.assert;

	var KeyPair = requireKey$1();
	var Signature = requireSignature$1();

	function EC(options) {
	  if (!(this instanceof EC))
	    return new EC(options);

	  // Shortcut `elliptic.ec(curve-name)`
	  if (typeof options === 'string') {
	    assert(Object.prototype.hasOwnProperty.call(curves, options),
	      'Unknown curve ' + options);

	    options = curves[options];
	  }

	  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
	  if (options instanceof curves.PresetCurve)
	    options = { curve: options };

	  this.curve = options.curve.curve;
	  this.n = this.curve.n;
	  this.nh = this.n.ushrn(1);
	  this.g = this.curve.g;

	  // Point on curve
	  this.g = options.curve.g;
	  this.g.precompute(options.curve.n.bitLength() + 1);

	  // Hash for function for DRBG
	  this.hash = options.hash || options.curve.hash;
	}
	ec = EC;

	EC.prototype.keyPair = function keyPair(options) {
	  return new KeyPair(this, options);
	};

	EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
	  return KeyPair.fromPrivate(this, priv, enc);
	};

	EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
	  return KeyPair.fromPublic(this, pub, enc);
	};

	EC.prototype.genKeyPair = function genKeyPair(options) {
	  if (!options)
	    options = {};

	  // Instantiate Hmac_DRBG
	  var drbg = new HmacDRBG({
	    hash: this.hash,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	    entropy: options.entropy || rand(this.hash.hmacStrength),
	    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
	    nonce: this.n.toArray(),
	  });

	  var bytes = this.n.byteLength();
	  var ns2 = this.n.sub(new BN(2));
	  for (;;) {
	    var priv = new BN(drbg.generate(bytes));
	    if (priv.cmp(ns2) > 0)
	      continue;

	    priv.iaddn(1);
	    return this.keyFromPrivate(priv);
	  }
	};

	EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
	  var delta = msg.byteLength() * 8 - this.n.bitLength();
	  if (delta > 0)
	    msg = msg.ushrn(delta);
	  if (!truncOnly && msg.cmp(this.n) >= 0)
	    return msg.sub(this.n);
	  else
	    return msg;
	};

	EC.prototype.sign = function sign(msg, key, enc, options) {
	  if (typeof enc === 'object') {
	    options = enc;
	    enc = null;
	  }
	  if (!options)
	    options = {};

	  key = this.keyFromPrivate(key, enc);
	  msg = this._truncateToN(new BN(msg, 16));

	  // Zero-extend key to provide enough entropy
	  var bytes = this.n.byteLength();
	  var bkey = key.getPrivate().toArray('be', bytes);

	  // Zero-extend nonce to have the same byte size as N
	  var nonce = msg.toArray('be', bytes);

	  // Instantiate Hmac_DRBG
	  var drbg = new HmacDRBG({
	    hash: this.hash,
	    entropy: bkey,
	    nonce: nonce,
	    pers: options.pers,
	    persEnc: options.persEnc || 'utf8',
	  });

	  // Number of bytes to generate
	  var ns1 = this.n.sub(new BN(1));

	  for (var iter = 0; ; iter++) {
	    var k = options.k ?
	      options.k(iter) :
	      new BN(drbg.generate(this.n.byteLength()));
	    k = this._truncateToN(k, true);
	    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
	      continue;

	    var kp = this.g.mul(k);
	    if (kp.isInfinity())
	      continue;

	    var kpX = kp.getX();
	    var r = kpX.umod(this.n);
	    if (r.cmpn(0) === 0)
	      continue;

	    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
	    s = s.umod(this.n);
	    if (s.cmpn(0) === 0)
	      continue;

	    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
	                        (kpX.cmp(r) !== 0 ? 2 : 0);

	    // Use complement of `s`, if it is > `n / 2`
	    if (options.canonical && s.cmp(this.nh) > 0) {
	      s = this.n.sub(s);
	      recoveryParam ^= 1;
	    }

	    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
	  }
	};

	EC.prototype.verify = function verify(msg, signature, key, enc) {
	  msg = this._truncateToN(new BN(msg, 16));
	  key = this.keyFromPublic(key, enc);
	  signature = new Signature(signature, 'hex');

	  // Perform primitive values validation
	  var r = signature.r;
	  var s = signature.s;
	  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
	    return false;
	  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
	    return false;

	  // Validate signature
	  var sinv = s.invm(this.n);
	  var u1 = sinv.mul(msg).umod(this.n);
	  var u2 = sinv.mul(r).umod(this.n);
	  var p;

	  if (!this.curve._maxwellTrick) {
	    p = this.g.mulAdd(u1, key.getPublic(), u2);
	    if (p.isInfinity())
	      return false;

	    return p.getX().umod(this.n).cmp(r) === 0;
	  }

	  // NOTE: Greg Maxwell's trick, inspired by:
	  // https://git.io/vad3K

	  p = this.g.jmulAdd(u1, key.getPublic(), u2);
	  if (p.isInfinity())
	    return false;

	  // Compare `p.x` of Jacobian point with `r`,
	  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
	  // inverse of `p.z^2`
	  return p.eqXToP(r);
	};

	EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
	  assert((3 & j) === j, 'The recovery param is more than two bits');
	  signature = new Signature(signature, enc);

	  var n = this.n;
	  var e = new BN(msg);
	  var r = signature.r;
	  var s = signature.s;

	  // A set LSB signifies that the y-coordinate is odd
	  var isYOdd = j & 1;
	  var isSecondKey = j >> 1;
	  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
	    throw new Error('Unable to find sencond key candinate');

	  // 1.1. Let x = r + jn.
	  if (isSecondKey)
	    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
	  else
	    r = this.curve.pointFromX(r, isYOdd);

	  var rInv = signature.r.invm(n);
	  var s1 = n.sub(e).mul(rInv).umod(n);
	  var s2 = s.mul(rInv).umod(n);

	  // 1.6.1 Compute Q = r^-1 (sR -  eG)
	  //               Q = r^-1 (sR + -eG)
	  return this.g.mulAdd(s1, r, s2);
	};

	EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
	  signature = new Signature(signature, enc);
	  if (signature.recoveryParam !== null)
	    return signature.recoveryParam;

	  for (var i = 0; i < 4; i++) {
	    var Qprime;
	    try {
	      Qprime = this.recoverPubKey(e, signature, i);
	    } catch (e) {
	      continue;
	    }

	    if (Qprime.eq(Q))
	      return i;
	  }
	  throw new Error('Unable to find valid recovery factor');
	};
	return ec;
}

var key;
var hasRequiredKey;

function requireKey () {
	if (hasRequiredKey) return key;
	hasRequiredKey = 1;

	var utils = requireUtils();
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var cachedProperty = utils.cachedProperty;

	/**
	* @param {EDDSA} eddsa - instance
	* @param {Object} params - public/private key parameters
	*
	* @param {Array<Byte>} [params.secret] - secret seed bytes
	* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
	* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
	*
	*/
	function KeyPair(eddsa, params) {
	  this.eddsa = eddsa;
	  this._secret = parseBytes(params.secret);
	  if (eddsa.isPoint(params.pub))
	    this._pub = params.pub;
	  else
	    this._pubBytes = parseBytes(params.pub);
	}

	KeyPair.fromPublic = function fromPublic(eddsa, pub) {
	  if (pub instanceof KeyPair)
	    return pub;
	  return new KeyPair(eddsa, { pub: pub });
	};

	KeyPair.fromSecret = function fromSecret(eddsa, secret) {
	  if (secret instanceof KeyPair)
	    return secret;
	  return new KeyPair(eddsa, { secret: secret });
	};

	KeyPair.prototype.secret = function secret() {
	  return this._secret;
	};

	cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
	  return this.eddsa.encodePoint(this.pub());
	});

	cachedProperty(KeyPair, 'pub', function pub() {
	  if (this._pubBytes)
	    return this.eddsa.decodePoint(this._pubBytes);
	  return this.eddsa.g.mul(this.priv());
	});

	cachedProperty(KeyPair, 'privBytes', function privBytes() {
	  var eddsa = this.eddsa;
	  var hash = this.hash();
	  var lastIx = eddsa.encodingLength - 1;

	  var a = hash.slice(0, eddsa.encodingLength);
	  a[0] &= 248;
	  a[lastIx] &= 127;
	  a[lastIx] |= 64;

	  return a;
	});

	cachedProperty(KeyPair, 'priv', function priv() {
	  return this.eddsa.decodeInt(this.privBytes());
	});

	cachedProperty(KeyPair, 'hash', function hash() {
	  return this.eddsa.hash().update(this.secret()).digest();
	});

	cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
	  return this.hash().slice(this.eddsa.encodingLength);
	});

	KeyPair.prototype.sign = function sign(message) {
	  assert(this._secret, 'KeyPair can only verify');
	  return this.eddsa.sign(message, this);
	};

	KeyPair.prototype.verify = function verify(message, sig) {
	  return this.eddsa.verify(message, sig, this);
	};

	KeyPair.prototype.getSecret = function getSecret(enc) {
	  assert(this._secret, 'KeyPair is public only');
	  return utils.encode(this.secret(), enc);
	};

	KeyPair.prototype.getPublic = function getPublic(enc) {
	  return utils.encode(this.pubBytes(), enc);
	};

	key = KeyPair;
	return key;
}

var signature;
var hasRequiredSignature;

function requireSignature () {
	if (hasRequiredSignature) return signature;
	hasRequiredSignature = 1;

	var BN = requireBn$2();
	var utils = requireUtils();
	var assert = utils.assert;
	var cachedProperty = utils.cachedProperty;
	var parseBytes = utils.parseBytes;

	/**
	* @param {EDDSA} eddsa - eddsa instance
	* @param {Array<Bytes>|Object} sig -
	* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
	* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
	* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
	* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
	*/
	function Signature(eddsa, sig) {
	  this.eddsa = eddsa;

	  if (typeof sig !== 'object')
	    sig = parseBytes(sig);

	  if (Array.isArray(sig)) {
	    sig = {
	      R: sig.slice(0, eddsa.encodingLength),
	      S: sig.slice(eddsa.encodingLength),
	    };
	  }

	  assert(sig.R && sig.S, 'Signature without R or S');

	  if (eddsa.isPoint(sig.R))
	    this._R = sig.R;
	  if (sig.S instanceof BN)
	    this._S = sig.S;

	  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
	  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
	}

	cachedProperty(Signature, 'S', function S() {
	  return this.eddsa.decodeInt(this.Sencoded());
	});

	cachedProperty(Signature, 'R', function R() {
	  return this.eddsa.decodePoint(this.Rencoded());
	});

	cachedProperty(Signature, 'Rencoded', function Rencoded() {
	  return this.eddsa.encodePoint(this.R());
	});

	cachedProperty(Signature, 'Sencoded', function Sencoded() {
	  return this.eddsa.encodeInt(this.S());
	});

	Signature.prototype.toBytes = function toBytes() {
	  return this.Rencoded().concat(this.Sencoded());
	};

	Signature.prototype.toHex = function toHex() {
	  return utils.encode(this.toBytes(), 'hex').toUpperCase();
	};

	signature = Signature;
	return signature;
}

var eddsa;
var hasRequiredEddsa;

function requireEddsa () {
	if (hasRequiredEddsa) return eddsa;
	hasRequiredEddsa = 1;

	var hash = requireHash();
	var curves = requireCurves();
	var utils = requireUtils();
	var assert = utils.assert;
	var parseBytes = utils.parseBytes;
	var KeyPair = requireKey();
	var Signature = requireSignature();

	function EDDSA(curve) {
	  assert(curve === 'ed25519', 'only tested with ed25519 so far');

	  if (!(this instanceof EDDSA))
	    return new EDDSA(curve);

	  curve = curves[curve].curve;
	  this.curve = curve;
	  this.g = curve.g;
	  this.g.precompute(curve.n.bitLength() + 1);

	  this.pointClass = curve.point().constructor;
	  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
	  this.hash = hash.sha512;
	}

	eddsa = EDDSA;

	/**
	* @param {Array|String} message - message bytes
	* @param {Array|String|KeyPair} secret - secret bytes or a keypair
	* @returns {Signature} - signature
	*/
	EDDSA.prototype.sign = function sign(message, secret) {
	  message = parseBytes(message);
	  var key = this.keyFromSecret(secret);
	  var r = this.hashInt(key.messagePrefix(), message);
	  var R = this.g.mul(r);
	  var Rencoded = this.encodePoint(R);
	  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
	    .mul(key.priv());
	  var S = r.add(s_).umod(this.curve.n);
	  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
	};

	/**
	* @param {Array} message - message bytes
	* @param {Array|String|Signature} sig - sig bytes
	* @param {Array|String|Point|KeyPair} pub - public key
	* @returns {Boolean} - true if public key matches sig of message
	*/
	EDDSA.prototype.verify = function verify(message, sig, pub) {
	  message = parseBytes(message);
	  sig = this.makeSignature(sig);
	  var key = this.keyFromPublic(pub);
	  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
	  var SG = this.g.mul(sig.S());
	  var RplusAh = sig.R().add(key.pub().mul(h));
	  return RplusAh.eq(SG);
	};

	EDDSA.prototype.hashInt = function hashInt() {
	  var hash = this.hash();
	  for (var i = 0; i < arguments.length; i++)
	    hash.update(arguments[i]);
	  return utils.intFromLE(hash.digest()).umod(this.curve.n);
	};

	EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
	  return KeyPair.fromPublic(this, pub);
	};

	EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
	  return KeyPair.fromSecret(this, secret);
	};

	EDDSA.prototype.makeSignature = function makeSignature(sig) {
	  if (sig instanceof Signature)
	    return sig;
	  return new Signature(this, sig);
	};

	/**
	* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
	*
	* EDDSA defines methods for encoding and decoding points and integers. These are
	* helper convenience methods, that pass along to utility functions implied
	* parameters.
	*
	*/
	EDDSA.prototype.encodePoint = function encodePoint(point) {
	  var enc = point.getY().toArray('le', this.encodingLength);
	  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
	  return enc;
	};

	EDDSA.prototype.decodePoint = function decodePoint(bytes) {
	  bytes = utils.parseBytes(bytes);

	  var lastIx = bytes.length - 1;
	  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & -129);
	  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

	  var y = utils.intFromLE(normed);
	  return this.curve.pointFromY(y, xIsOdd);
	};

	EDDSA.prototype.encodeInt = function encodeInt(num) {
	  return num.toArray('le', this.encodingLength);
	};

	EDDSA.prototype.decodeInt = function decodeInt(bytes) {
	  return utils.intFromLE(bytes);
	};

	EDDSA.prototype.isPoint = function isPoint(val) {
	  return val instanceof this.pointClass;
	};
	return eddsa;
}

var hasRequiredElliptic;

function requireElliptic () {
	if (hasRequiredElliptic) return elliptic;
	hasRequiredElliptic = 1;
	(function (exports) {

		var elliptic = exports;

		elliptic.version = require$$0.version;
		elliptic.utils = requireUtils();
		elliptic.rand = requireBrorand();
		elliptic.curve = requireCurve();
		elliptic.curves = requireCurves();

		// Protocols
		elliptic.ec = requireEc();
		elliptic.eddsa = requireEddsa(); 
	} (elliptic));
	return elliptic;
}

var bn$3 = {exports: {}};

var bn$2 = bn$3.exports;

var hasRequiredBn$1;

function requireBn$1 () {
	if (hasRequiredBn$1) return bn$3.exports;
	hasRequiredBn$1 = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn$2); 
	} (bn$3));
	return bn$3.exports;
}

var browser$2;
var hasRequiredBrowser$2;

function requireBrowser$2 () {
	if (hasRequiredBrowser$2) return browser$2;
	hasRequiredBrowser$2 = 1;
	var elliptic = requireElliptic();
	var BN = requireBn$1();

	browser$2 = function createECDH (curve) {
	  return new ECDH(curve)
	};

	var aliases = {
	  secp256k1: {
	    name: 'secp256k1',
	    byteLength: 32
	  },
	  secp224r1: {
	    name: 'p224',
	    byteLength: 28
	  },
	  prime256v1: {
	    name: 'p256',
	    byteLength: 32
	  },
	  prime192v1: {
	    name: 'p192',
	    byteLength: 24
	  },
	  ed25519: {
	    name: 'ed25519',
	    byteLength: 32
	  },
	  secp384r1: {
	    name: 'p384',
	    byteLength: 48
	  },
	  secp521r1: {
	    name: 'p521',
	    byteLength: 66
	  }
	};

	aliases.p224 = aliases.secp224r1;
	aliases.p256 = aliases.secp256r1 = aliases.prime256v1;
	aliases.p192 = aliases.secp192r1 = aliases.prime192v1;
	aliases.p384 = aliases.secp384r1;
	aliases.p521 = aliases.secp521r1;

	function ECDH (curve) {
	  this.curveType = aliases[curve];
	  if (!this.curveType) {
	    this.curveType = {
	      name: curve
	    };
	  }
	  this.curve = new elliptic.ec(this.curveType.name); // eslint-disable-line new-cap
	  this.keys = void 0;
	}

	ECDH.prototype.generateKeys = function (enc, format) {
	  this.keys = this.curve.genKeyPair();
	  return this.getPublicKey(enc, format)
	};

	ECDH.prototype.computeSecret = function (other, inenc, enc) {
	  inenc = inenc || 'utf8';
	  if (!Buffer$1.isBuffer(other)) {
	    other = new Buffer$1(other, inenc);
	  }
	  var otherPub = this.curve.keyFromPublic(other).getPublic();
	  var out = otherPub.mul(this.keys.getPrivate()).getX();
	  return formatReturnValue(out, enc, this.curveType.byteLength)
	};

	ECDH.prototype.getPublicKey = function (enc, format) {
	  var key = this.keys.getPublic(format === 'compressed', true);
	  if (format === 'hybrid') {
	    if (key[key.length - 1] % 2) {
	      key[0] = 7;
	    } else {
	      key[0] = 6;
	    }
	  }
	  return formatReturnValue(key, enc)
	};

	ECDH.prototype.getPrivateKey = function (enc) {
	  return formatReturnValue(this.keys.getPrivate(), enc)
	};

	ECDH.prototype.setPublicKey = function (pub, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer$1.isBuffer(pub)) {
	    pub = new Buffer$1(pub, enc);
	  }
	  this.keys._importPublic(pub);
	  return this
	};

	ECDH.prototype.setPrivateKey = function (priv, enc) {
	  enc = enc || 'utf8';
	  if (!Buffer$1.isBuffer(priv)) {
	    priv = new Buffer$1(priv, enc);
	  }

	  var _priv = new BN(priv);
	  _priv = _priv.toString(16);
	  this.keys = this.curve.genKeyPair();
	  this.keys._importPrivate(_priv);
	  return this
	};

	function formatReturnValue (bn, enc, len) {
	  if (!Array.isArray(bn)) {
	    bn = bn.toArray();
	  }
	  var buf = new Buffer$1(bn);
	  if (len && buf.length < len) {
	    var zeros = new Buffer$1(len - buf.length);
	    zeros.fill(0);
	    buf = Buffer$1.concat([zeros, buf]);
	  }
	  if (!enc) {
	    return buf
	  } else {
	    return buf.toString(enc)
	  }
	}
	return browser$2;
}

var browser$1 = {};

var mgf;
var hasRequiredMgf;

function requireMgf () {
	if (hasRequiredMgf) return mgf;
	hasRequiredMgf = 1;
	var createHash = requireBrowser$9();
	var Buffer = requireSafeBuffer$2().Buffer;

	mgf = function (seed, len) {
	  var t = Buffer.alloc(0);
	  var i = 0;
	  var c;
	  while (t.length < len) {
	    c = i2ops(i++);
	    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()]);
	  }
	  return t.slice(0, len)
	};

	function i2ops (c) {
	  var out = Buffer.allocUnsafe(4);
	  out.writeUInt32BE(c, 0);
	  return out
	}
	return mgf;
}

var xor;
var hasRequiredXor;

function requireXor () {
	if (hasRequiredXor) return xor;
	hasRequiredXor = 1;
	xor = function xor (a, b) {
	  var len = a.length;
	  var i = -1;
	  while (++i < len) {
	    a[i] ^= b[i];
	  }
	  return a
	};
	return xor;
}

var bn$1 = {exports: {}};

var bn = bn$1.exports;

var hasRequiredBn;

function requireBn () {
	if (hasRequiredBn) return bn$1.exports;
	hasRequiredBn = 1;
	(function (module) {
		(function (module, exports) {

		  // Utils
		  function assert (val, msg) {
		    if (!val) throw new Error(msg || 'Assertion failed');
		  }

		  // Could use `inherits` module, but don't want to move from single file
		  // architecture yet.
		  function inherits (ctor, superCtor) {
		    ctor.super_ = superCtor;
		    var TempCtor = function () {};
		    TempCtor.prototype = superCtor.prototype;
		    ctor.prototype = new TempCtor();
		    ctor.prototype.constructor = ctor;
		  }

		  // BN

		  function BN (number, base, endian) {
		    if (BN.isBN(number)) {
		      return number;
		    }

		    this.negative = 0;
		    this.words = null;
		    this.length = 0;

		    // Reduction context
		    this.red = null;

		    if (number !== null) {
		      if (base === 'le' || base === 'be') {
		        endian = base;
		        base = 10;
		      }

		      this._init(number || 0, base || 10, endian || 'be');
		    }
		  }
		  if (typeof module === 'object') {
		    module.exports = BN;
		  } else {
		    exports.BN = BN;
		  }

		  BN.BN = BN;
		  BN.wordSize = 26;

		  var Buffer;
		  try {
		    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
		      Buffer = window.Buffer;
		    } else {
		      Buffer = requireDist().Buffer;
		    }
		  } catch (e) {
		  }

		  BN.isBN = function isBN (num) {
		    if (num instanceof BN) {
		      return true;
		    }

		    return num !== null && typeof num === 'object' &&
		      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
		  };

		  BN.max = function max (left, right) {
		    if (left.cmp(right) > 0) return left;
		    return right;
		  };

		  BN.min = function min (left, right) {
		    if (left.cmp(right) < 0) return left;
		    return right;
		  };

		  BN.prototype._init = function init (number, base, endian) {
		    if (typeof number === 'number') {
		      return this._initNumber(number, base, endian);
		    }

		    if (typeof number === 'object') {
		      return this._initArray(number, base, endian);
		    }

		    if (base === 'hex') {
		      base = 16;
		    }
		    assert(base === (base | 0) && base >= 2 && base <= 36);

		    number = number.toString().replace(/\s+/g, '');
		    var start = 0;
		    if (number[0] === '-') {
		      start++;
		      this.negative = 1;
		    }

		    if (start < number.length) {
		      if (base === 16) {
		        this._parseHex(number, start, endian);
		      } else {
		        this._parseBase(number, base, start);
		        if (endian === 'le') {
		          this._initArray(this.toArray(), base, endian);
		        }
		      }
		    }
		  };

		  BN.prototype._initNumber = function _initNumber (number, base, endian) {
		    if (number < 0) {
		      this.negative = 1;
		      number = -number;
		    }
		    if (number < 0x4000000) {
		      this.words = [ number & 0x3ffffff ];
		      this.length = 1;
		    } else if (number < 0x10000000000000) {
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff
		      ];
		      this.length = 2;
		    } else {
		      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
		      this.words = [
		        number & 0x3ffffff,
		        (number / 0x4000000) & 0x3ffffff,
		        1
		      ];
		      this.length = 3;
		    }

		    if (endian !== 'le') return;

		    // Reverse the bytes
		    this._initArray(this.toArray(), base, endian);
		  };

		  BN.prototype._initArray = function _initArray (number, base, endian) {
		    // Perhaps a Uint8Array
		    assert(typeof number.length === 'number');
		    if (number.length <= 0) {
		      this.words = [ 0 ];
		      this.length = 1;
		      return this;
		    }

		    this.length = Math.ceil(number.length / 3);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    var j, w;
		    var off = 0;
		    if (endian === 'be') {
		      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
		        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    } else if (endian === 'le') {
		      for (i = 0, j = 0; i < number.length; i += 3) {
		        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
		        this.words[j] |= (w << off) & 0x3ffffff;
		        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
		        off += 24;
		        if (off >= 26) {
		          off -= 26;
		          j++;
		        }
		      }
		    }
		    return this.strip();
		  };

		  function parseHex4Bits (string, index) {
		    var c = string.charCodeAt(index);
		    // 'A' - 'F'
		    if (c >= 65 && c <= 70) {
		      return c - 55;
		    // 'a' - 'f'
		    } else if (c >= 97 && c <= 102) {
		      return c - 87;
		    // '0' - '9'
		    } else {
		      return (c - 48) & 0xf;
		    }
		  }

		  function parseHexByte (string, lowerBound, index) {
		    var r = parseHex4Bits(string, index);
		    if (index - 1 >= lowerBound) {
		      r |= parseHex4Bits(string, index - 1) << 4;
		    }
		    return r;
		  }

		  BN.prototype._parseHex = function _parseHex (number, start, endian) {
		    // Create possibly bigger array to ensure that it fits the number
		    this.length = Math.ceil((number.length - start) / 6);
		    this.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      this.words[i] = 0;
		    }

		    // 24-bits chunks
		    var off = 0;
		    var j = 0;

		    var w;
		    if (endian === 'be') {
		      for (i = number.length - 1; i >= start; i -= 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    } else {
		      var parseLength = number.length - start;
		      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
		        w = parseHexByte(number, start, i) << off;
		        this.words[j] |= w & 0x3ffffff;
		        if (off >= 18) {
		          off -= 18;
		          j += 1;
		          this.words[j] |= w >>> 26;
		        } else {
		          off += 8;
		        }
		      }
		    }

		    this.strip();
		  };

		  function parseBase (str, start, end, mul) {
		    var r = 0;
		    var len = Math.min(str.length, end);
		    for (var i = start; i < len; i++) {
		      var c = str.charCodeAt(i) - 48;

		      r *= mul;

		      // 'a'
		      if (c >= 49) {
		        r += c - 49 + 0xa;

		      // 'A'
		      } else if (c >= 17) {
		        r += c - 17 + 0xa;

		      // '0' - '9'
		      } else {
		        r += c;
		      }
		    }
		    return r;
		  }

		  BN.prototype._parseBase = function _parseBase (number, base, start) {
		    // Initialize as zero
		    this.words = [ 0 ];
		    this.length = 1;

		    // Find length of limb in base
		    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
		      limbLen++;
		    }
		    limbLen--;
		    limbPow = (limbPow / base) | 0;

		    var total = number.length - start;
		    var mod = total % limbLen;
		    var end = Math.min(total, total - mod) + start;

		    var word = 0;
		    for (var i = start; i < end; i += limbLen) {
		      word = parseBase(number, i, i + limbLen, base);

		      this.imuln(limbPow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    if (mod !== 0) {
		      var pow = 1;
		      word = parseBase(number, i, number.length, base);

		      for (i = 0; i < mod; i++) {
		        pow *= base;
		      }

		      this.imuln(pow);
		      if (this.words[0] + word < 0x4000000) {
		        this.words[0] += word;
		      } else {
		        this._iaddn(word);
		      }
		    }

		    this.strip();
		  };

		  BN.prototype.copy = function copy (dest) {
		    dest.words = new Array(this.length);
		    for (var i = 0; i < this.length; i++) {
		      dest.words[i] = this.words[i];
		    }
		    dest.length = this.length;
		    dest.negative = this.negative;
		    dest.red = this.red;
		  };

		  BN.prototype.clone = function clone () {
		    var r = new BN(null);
		    this.copy(r);
		    return r;
		  };

		  BN.prototype._expand = function _expand (size) {
		    while (this.length < size) {
		      this.words[this.length++] = 0;
		    }
		    return this;
		  };

		  // Remove leading `0` from `this`
		  BN.prototype.strip = function strip () {
		    while (this.length > 1 && this.words[this.length - 1] === 0) {
		      this.length--;
		    }
		    return this._normSign();
		  };

		  BN.prototype._normSign = function _normSign () {
		    // -0 = 0
		    if (this.length === 1 && this.words[0] === 0) {
		      this.negative = 0;
		    }
		    return this;
		  };

		  BN.prototype.inspect = function inspect () {
		    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
		  };

		  /*

		  var zeros = [];
		  var groupSizes = [];
		  var groupBases = [];

		  var s = '';
		  var i = -1;
		  while (++i < BN.wordSize) {
		    zeros[i] = s;
		    s += '0';
		  }
		  groupSizes[0] = 0;
		  groupSizes[1] = 0;
		  groupBases[0] = 0;
		  groupBases[1] = 0;
		  var base = 2 - 1;
		  while (++base < 36 + 1) {
		    var groupSize = 0;
		    var groupBase = 1;
		    while (groupBase < (1 << BN.wordSize) / base) {
		      groupBase *= base;
		      groupSize += 1;
		    }
		    groupSizes[base] = groupSize;
		    groupBases[base] = groupBase;
		  }

		  */

		  var zeros = [
		    '',
		    '0',
		    '00',
		    '000',
		    '0000',
		    '00000',
		    '000000',
		    '0000000',
		    '00000000',
		    '000000000',
		    '0000000000',
		    '00000000000',
		    '000000000000',
		    '0000000000000',
		    '00000000000000',
		    '000000000000000',
		    '0000000000000000',
		    '00000000000000000',
		    '000000000000000000',
		    '0000000000000000000',
		    '00000000000000000000',
		    '000000000000000000000',
		    '0000000000000000000000',
		    '00000000000000000000000',
		    '000000000000000000000000',
		    '0000000000000000000000000'
		  ];

		  var groupSizes = [
		    0, 0,
		    25, 16, 12, 11, 10, 9, 8,
		    8, 7, 7, 7, 7, 6, 6,
		    6, 6, 6, 6, 6, 5, 5,
		    5, 5, 5, 5, 5, 5, 5,
		    5, 5, 5, 5, 5, 5, 5
		  ];

		  var groupBases = [
		    0, 0,
		    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
		    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
		    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
		    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
		    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
		  ];

		  BN.prototype.toString = function toString (base, padding) {
		    base = base || 10;
		    padding = padding | 0 || 1;

		    var out;
		    if (base === 16 || base === 'hex') {
		      out = '';
		      var off = 0;
		      var carry = 0;
		      for (var i = 0; i < this.length; i++) {
		        var w = this.words[i];
		        var word = (((w << off) | carry) & 0xffffff).toString(16);
		        carry = (w >>> (24 - off)) & 0xffffff;
		        if (carry !== 0 || i !== this.length - 1) {
		          out = zeros[6 - word.length] + word + out;
		        } else {
		          out = word + out;
		        }
		        off += 2;
		        if (off >= 26) {
		          off -= 26;
		          i--;
		        }
		      }
		      if (carry !== 0) {
		        out = carry.toString(16) + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    if (base === (base | 0) && base >= 2 && base <= 36) {
		      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
		      var groupSize = groupSizes[base];
		      // var groupBase = Math.pow(base, groupSize);
		      var groupBase = groupBases[base];
		      out = '';
		      var c = this.clone();
		      c.negative = 0;
		      while (!c.isZero()) {
		        var r = c.modn(groupBase).toString(base);
		        c = c.idivn(groupBase);

		        if (!c.isZero()) {
		          out = zeros[groupSize - r.length] + r + out;
		        } else {
		          out = r + out;
		        }
		      }
		      if (this.isZero()) {
		        out = '0' + out;
		      }
		      while (out.length % padding !== 0) {
		        out = '0' + out;
		      }
		      if (this.negative !== 0) {
		        out = '-' + out;
		      }
		      return out;
		    }

		    assert(false, 'Base should be between 2 and 36');
		  };

		  BN.prototype.toNumber = function toNumber () {
		    var ret = this.words[0];
		    if (this.length === 2) {
		      ret += this.words[1] * 0x4000000;
		    } else if (this.length === 3 && this.words[2] === 0x01) {
		      // NOTE: at this stage it is known that the top bit is set
		      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
		    } else if (this.length > 2) {
		      assert(false, 'Number can only safely store up to 53 bits');
		    }
		    return (this.negative !== 0) ? -ret : ret;
		  };

		  BN.prototype.toJSON = function toJSON () {
		    return this.toString(16);
		  };

		  BN.prototype.toBuffer = function toBuffer (endian, length) {
		    assert(typeof Buffer !== 'undefined');
		    return this.toArrayLike(Buffer, endian, length);
		  };

		  BN.prototype.toArray = function toArray (endian, length) {
		    return this.toArrayLike(Array, endian, length);
		  };

		  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
		    var byteLength = this.byteLength();
		    var reqLength = length || Math.max(1, byteLength);
		    assert(byteLength <= reqLength, 'byte array longer than desired length');
		    assert(reqLength > 0, 'Requested array length <= 0');

		    this.strip();
		    var littleEndian = endian === 'le';
		    var res = new ArrayType(reqLength);

		    var b, i;
		    var q = this.clone();
		    if (!littleEndian) {
		      // Assume big-endian
		      for (i = 0; i < reqLength - byteLength; i++) {
		        res[i] = 0;
		      }

		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[reqLength - i - 1] = b;
		      }
		    } else {
		      for (i = 0; !q.isZero(); i++) {
		        b = q.andln(0xff);
		        q.iushrn(8);

		        res[i] = b;
		      }

		      for (; i < reqLength; i++) {
		        res[i] = 0;
		      }
		    }

		    return res;
		  };

		  if (Math.clz32) {
		    BN.prototype._countBits = function _countBits (w) {
		      return 32 - Math.clz32(w);
		    };
		  } else {
		    BN.prototype._countBits = function _countBits (w) {
		      var t = w;
		      var r = 0;
		      if (t >= 0x1000) {
		        r += 13;
		        t >>>= 13;
		      }
		      if (t >= 0x40) {
		        r += 7;
		        t >>>= 7;
		      }
		      if (t >= 0x8) {
		        r += 4;
		        t >>>= 4;
		      }
		      if (t >= 0x02) {
		        r += 2;
		        t >>>= 2;
		      }
		      return r + t;
		    };
		  }

		  BN.prototype._zeroBits = function _zeroBits (w) {
		    // Short-cut
		    if (w === 0) return 26;

		    var t = w;
		    var r = 0;
		    if ((t & 0x1fff) === 0) {
		      r += 13;
		      t >>>= 13;
		    }
		    if ((t & 0x7f) === 0) {
		      r += 7;
		      t >>>= 7;
		    }
		    if ((t & 0xf) === 0) {
		      r += 4;
		      t >>>= 4;
		    }
		    if ((t & 0x3) === 0) {
		      r += 2;
		      t >>>= 2;
		    }
		    if ((t & 0x1) === 0) {
		      r++;
		    }
		    return r;
		  };

		  // Return number of used bits in a BN
		  BN.prototype.bitLength = function bitLength () {
		    var w = this.words[this.length - 1];
		    var hi = this._countBits(w);
		    return (this.length - 1) * 26 + hi;
		  };

		  function toBitArray (num) {
		    var w = new Array(num.bitLength());

		    for (var bit = 0; bit < w.length; bit++) {
		      var off = (bit / 26) | 0;
		      var wbit = bit % 26;

		      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
		    }

		    return w;
		  }

		  // Number of trailing zero bits
		  BN.prototype.zeroBits = function zeroBits () {
		    if (this.isZero()) return 0;

		    var r = 0;
		    for (var i = 0; i < this.length; i++) {
		      var b = this._zeroBits(this.words[i]);
		      r += b;
		      if (b !== 26) break;
		    }
		    return r;
		  };

		  BN.prototype.byteLength = function byteLength () {
		    return Math.ceil(this.bitLength() / 8);
		  };

		  BN.prototype.toTwos = function toTwos (width) {
		    if (this.negative !== 0) {
		      return this.abs().inotn(width).iaddn(1);
		    }
		    return this.clone();
		  };

		  BN.prototype.fromTwos = function fromTwos (width) {
		    if (this.testn(width - 1)) {
		      return this.notn(width).iaddn(1).ineg();
		    }
		    return this.clone();
		  };

		  BN.prototype.isNeg = function isNeg () {
		    return this.negative !== 0;
		  };

		  // Return negative clone of `this`
		  BN.prototype.neg = function neg () {
		    return this.clone().ineg();
		  };

		  BN.prototype.ineg = function ineg () {
		    if (!this.isZero()) {
		      this.negative ^= 1;
		    }

		    return this;
		  };

		  // Or `num` with `this` in-place
		  BN.prototype.iuor = function iuor (num) {
		    while (this.length < num.length) {
		      this.words[this.length++] = 0;
		    }

		    for (var i = 0; i < num.length; i++) {
		      this.words[i] = this.words[i] | num.words[i];
		    }

		    return this.strip();
		  };

		  BN.prototype.ior = function ior (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuor(num);
		  };

		  // Or `num` with `this`
		  BN.prototype.or = function or (num) {
		    if (this.length > num.length) return this.clone().ior(num);
		    return num.clone().ior(this);
		  };

		  BN.prototype.uor = function uor (num) {
		    if (this.length > num.length) return this.clone().iuor(num);
		    return num.clone().iuor(this);
		  };

		  // And `num` with `this` in-place
		  BN.prototype.iuand = function iuand (num) {
		    // b = min-length(num, this)
		    var b;
		    if (this.length > num.length) {
		      b = num;
		    } else {
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = this.words[i] & num.words[i];
		    }

		    this.length = b.length;

		    return this.strip();
		  };

		  BN.prototype.iand = function iand (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuand(num);
		  };

		  // And `num` with `this`
		  BN.prototype.and = function and (num) {
		    if (this.length > num.length) return this.clone().iand(num);
		    return num.clone().iand(this);
		  };

		  BN.prototype.uand = function uand (num) {
		    if (this.length > num.length) return this.clone().iuand(num);
		    return num.clone().iuand(this);
		  };

		  // Xor `num` with `this` in-place
		  BN.prototype.iuxor = function iuxor (num) {
		    // a.length > b.length
		    var a;
		    var b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    for (var i = 0; i < b.length; i++) {
		      this.words[i] = a.words[i] ^ b.words[i];
		    }

		    if (this !== a) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = a.length;

		    return this.strip();
		  };

		  BN.prototype.ixor = function ixor (num) {
		    assert((this.negative | num.negative) === 0);
		    return this.iuxor(num);
		  };

		  // Xor `num` with `this`
		  BN.prototype.xor = function xor (num) {
		    if (this.length > num.length) return this.clone().ixor(num);
		    return num.clone().ixor(this);
		  };

		  BN.prototype.uxor = function uxor (num) {
		    if (this.length > num.length) return this.clone().iuxor(num);
		    return num.clone().iuxor(this);
		  };

		  // Not ``this`` with ``width`` bitwidth
		  BN.prototype.inotn = function inotn (width) {
		    assert(typeof width === 'number' && width >= 0);

		    var bytesNeeded = Math.ceil(width / 26) | 0;
		    var bitsLeft = width % 26;

		    // Extend the buffer with leading zeroes
		    this._expand(bytesNeeded);

		    if (bitsLeft > 0) {
		      bytesNeeded--;
		    }

		    // Handle complete words
		    for (var i = 0; i < bytesNeeded; i++) {
		      this.words[i] = ~this.words[i] & 0x3ffffff;
		    }

		    // Handle the residue
		    if (bitsLeft > 0) {
		      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
		    }

		    // And remove leading zeroes
		    return this.strip();
		  };

		  BN.prototype.notn = function notn (width) {
		    return this.clone().inotn(width);
		  };

		  // Set `bit` of `this`
		  BN.prototype.setn = function setn (bit, val) {
		    assert(typeof bit === 'number' && bit >= 0);

		    var off = (bit / 26) | 0;
		    var wbit = bit % 26;

		    this._expand(off + 1);

		    if (val) {
		      this.words[off] = this.words[off] | (1 << wbit);
		    } else {
		      this.words[off] = this.words[off] & ~(1 << wbit);
		    }

		    return this.strip();
		  };

		  // Add `num` to `this` in-place
		  BN.prototype.iadd = function iadd (num) {
		    var r;

		    // negative + positive
		    if (this.negative !== 0 && num.negative === 0) {
		      this.negative = 0;
		      r = this.isub(num);
		      this.negative ^= 1;
		      return this._normSign();

		    // positive + negative
		    } else if (this.negative === 0 && num.negative !== 0) {
		      num.negative = 0;
		      r = this.isub(num);
		      num.negative = 1;
		      return r._normSign();
		    }

		    // a.length > b.length
		    var a, b;
		    if (this.length > num.length) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      this.words[i] = r & 0x3ffffff;
		      carry = r >>> 26;
		    }

		    this.length = a.length;
		    if (carry !== 0) {
		      this.words[this.length] = carry;
		      this.length++;
		    // Copy the rest of the words
		    } else if (a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    return this;
		  };

		  // Add `num` to `this`
		  BN.prototype.add = function add (num) {
		    var res;
		    if (num.negative !== 0 && this.negative === 0) {
		      num.negative = 0;
		      res = this.sub(num);
		      num.negative ^= 1;
		      return res;
		    } else if (num.negative === 0 && this.negative !== 0) {
		      this.negative = 0;
		      res = num.sub(this);
		      this.negative = 1;
		      return res;
		    }

		    if (this.length > num.length) return this.clone().iadd(num);

		    return num.clone().iadd(this);
		  };

		  // Subtract `num` from `this` in-place
		  BN.prototype.isub = function isub (num) {
		    // this - (-num) = this + num
		    if (num.negative !== 0) {
		      num.negative = 0;
		      var r = this.iadd(num);
		      num.negative = 1;
		      return r._normSign();

		    // -this - num = -(this + num)
		    } else if (this.negative !== 0) {
		      this.negative = 0;
		      this.iadd(num);
		      this.negative = 1;
		      return this._normSign();
		    }

		    // At this point both numbers are positive
		    var cmp = this.cmp(num);

		    // Optimization - zeroify
		    if (cmp === 0) {
		      this.negative = 0;
		      this.length = 1;
		      this.words[0] = 0;
		      return this;
		    }

		    // a > b
		    var a, b;
		    if (cmp > 0) {
		      a = this;
		      b = num;
		    } else {
		      a = num;
		      b = this;
		    }

		    var carry = 0;
		    for (var i = 0; i < b.length; i++) {
		      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }
		    for (; carry !== 0 && i < a.length; i++) {
		      r = (a.words[i] | 0) + carry;
		      carry = r >> 26;
		      this.words[i] = r & 0x3ffffff;
		    }

		    // Copy rest of the words
		    if (carry === 0 && i < a.length && a !== this) {
		      for (; i < a.length; i++) {
		        this.words[i] = a.words[i];
		      }
		    }

		    this.length = Math.max(this.length, i);

		    if (a !== this) {
		      this.negative = 1;
		    }

		    return this.strip();
		  };

		  // Subtract `num` from `this`
		  BN.prototype.sub = function sub (num) {
		    return this.clone().isub(num);
		  };

		  function smallMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    var len = (self.length + num.length) | 0;
		    out.length = len;
		    len = (len - 1) | 0;

		    // Peel one iteration (compiler can't do it, because of code complexity)
		    var a = self.words[0] | 0;
		    var b = num.words[0] | 0;
		    var r = a * b;

		    var lo = r & 0x3ffffff;
		    var carry = (r / 0x4000000) | 0;
		    out.words[0] = lo;

		    for (var k = 1; k < len; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = carry >>> 26;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = (k - j) | 0;
		        a = self.words[i] | 0;
		        b = num.words[j] | 0;
		        r = a * b + rword;
		        ncarry += (r / 0x4000000) | 0;
		        rword = r & 0x3ffffff;
		      }
		      out.words[k] = rword | 0;
		      carry = ncarry | 0;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry | 0;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  // TODO(indutny): it may be reasonable to omit it for users who don't need
		  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
		  // multiplication (like elliptic secp256k1).
		  var comb10MulTo = function comb10MulTo (self, num, out) {
		    var a = self.words;
		    var b = num.words;
		    var o = out.words;
		    var c = 0;
		    var lo;
		    var mid;
		    var hi;
		    var a0 = a[0] | 0;
		    var al0 = a0 & 0x1fff;
		    var ah0 = a0 >>> 13;
		    var a1 = a[1] | 0;
		    var al1 = a1 & 0x1fff;
		    var ah1 = a1 >>> 13;
		    var a2 = a[2] | 0;
		    var al2 = a2 & 0x1fff;
		    var ah2 = a2 >>> 13;
		    var a3 = a[3] | 0;
		    var al3 = a3 & 0x1fff;
		    var ah3 = a3 >>> 13;
		    var a4 = a[4] | 0;
		    var al4 = a4 & 0x1fff;
		    var ah4 = a4 >>> 13;
		    var a5 = a[5] | 0;
		    var al5 = a5 & 0x1fff;
		    var ah5 = a5 >>> 13;
		    var a6 = a[6] | 0;
		    var al6 = a6 & 0x1fff;
		    var ah6 = a6 >>> 13;
		    var a7 = a[7] | 0;
		    var al7 = a7 & 0x1fff;
		    var ah7 = a7 >>> 13;
		    var a8 = a[8] | 0;
		    var al8 = a8 & 0x1fff;
		    var ah8 = a8 >>> 13;
		    var a9 = a[9] | 0;
		    var al9 = a9 & 0x1fff;
		    var ah9 = a9 >>> 13;
		    var b0 = b[0] | 0;
		    var bl0 = b0 & 0x1fff;
		    var bh0 = b0 >>> 13;
		    var b1 = b[1] | 0;
		    var bl1 = b1 & 0x1fff;
		    var bh1 = b1 >>> 13;
		    var b2 = b[2] | 0;
		    var bl2 = b2 & 0x1fff;
		    var bh2 = b2 >>> 13;
		    var b3 = b[3] | 0;
		    var bl3 = b3 & 0x1fff;
		    var bh3 = b3 >>> 13;
		    var b4 = b[4] | 0;
		    var bl4 = b4 & 0x1fff;
		    var bh4 = b4 >>> 13;
		    var b5 = b[5] | 0;
		    var bl5 = b5 & 0x1fff;
		    var bh5 = b5 >>> 13;
		    var b6 = b[6] | 0;
		    var bl6 = b6 & 0x1fff;
		    var bh6 = b6 >>> 13;
		    var b7 = b[7] | 0;
		    var bl7 = b7 & 0x1fff;
		    var bh7 = b7 >>> 13;
		    var b8 = b[8] | 0;
		    var bl8 = b8 & 0x1fff;
		    var bh8 = b8 >>> 13;
		    var b9 = b[9] | 0;
		    var bl9 = b9 & 0x1fff;
		    var bh9 = b9 >>> 13;

		    out.negative = self.negative ^ num.negative;
		    out.length = 19;
		    /* k = 0 */
		    lo = Math.imul(al0, bl0);
		    mid = Math.imul(al0, bh0);
		    mid = (mid + Math.imul(ah0, bl0)) | 0;
		    hi = Math.imul(ah0, bh0);
		    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
		    w0 &= 0x3ffffff;
		    /* k = 1 */
		    lo = Math.imul(al1, bl0);
		    mid = Math.imul(al1, bh0);
		    mid = (mid + Math.imul(ah1, bl0)) | 0;
		    hi = Math.imul(ah1, bh0);
		    lo = (lo + Math.imul(al0, bl1)) | 0;
		    mid = (mid + Math.imul(al0, bh1)) | 0;
		    mid = (mid + Math.imul(ah0, bl1)) | 0;
		    hi = (hi + Math.imul(ah0, bh1)) | 0;
		    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
		    w1 &= 0x3ffffff;
		    /* k = 2 */
		    lo = Math.imul(al2, bl0);
		    mid = Math.imul(al2, bh0);
		    mid = (mid + Math.imul(ah2, bl0)) | 0;
		    hi = Math.imul(ah2, bh0);
		    lo = (lo + Math.imul(al1, bl1)) | 0;
		    mid = (mid + Math.imul(al1, bh1)) | 0;
		    mid = (mid + Math.imul(ah1, bl1)) | 0;
		    hi = (hi + Math.imul(ah1, bh1)) | 0;
		    lo = (lo + Math.imul(al0, bl2)) | 0;
		    mid = (mid + Math.imul(al0, bh2)) | 0;
		    mid = (mid + Math.imul(ah0, bl2)) | 0;
		    hi = (hi + Math.imul(ah0, bh2)) | 0;
		    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
		    w2 &= 0x3ffffff;
		    /* k = 3 */
		    lo = Math.imul(al3, bl0);
		    mid = Math.imul(al3, bh0);
		    mid = (mid + Math.imul(ah3, bl0)) | 0;
		    hi = Math.imul(ah3, bh0);
		    lo = (lo + Math.imul(al2, bl1)) | 0;
		    mid = (mid + Math.imul(al2, bh1)) | 0;
		    mid = (mid + Math.imul(ah2, bl1)) | 0;
		    hi = (hi + Math.imul(ah2, bh1)) | 0;
		    lo = (lo + Math.imul(al1, bl2)) | 0;
		    mid = (mid + Math.imul(al1, bh2)) | 0;
		    mid = (mid + Math.imul(ah1, bl2)) | 0;
		    hi = (hi + Math.imul(ah1, bh2)) | 0;
		    lo = (lo + Math.imul(al0, bl3)) | 0;
		    mid = (mid + Math.imul(al0, bh3)) | 0;
		    mid = (mid + Math.imul(ah0, bl3)) | 0;
		    hi = (hi + Math.imul(ah0, bh3)) | 0;
		    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
		    w3 &= 0x3ffffff;
		    /* k = 4 */
		    lo = Math.imul(al4, bl0);
		    mid = Math.imul(al4, bh0);
		    mid = (mid + Math.imul(ah4, bl0)) | 0;
		    hi = Math.imul(ah4, bh0);
		    lo = (lo + Math.imul(al3, bl1)) | 0;
		    mid = (mid + Math.imul(al3, bh1)) | 0;
		    mid = (mid + Math.imul(ah3, bl1)) | 0;
		    hi = (hi + Math.imul(ah3, bh1)) | 0;
		    lo = (lo + Math.imul(al2, bl2)) | 0;
		    mid = (mid + Math.imul(al2, bh2)) | 0;
		    mid = (mid + Math.imul(ah2, bl2)) | 0;
		    hi = (hi + Math.imul(ah2, bh2)) | 0;
		    lo = (lo + Math.imul(al1, bl3)) | 0;
		    mid = (mid + Math.imul(al1, bh3)) | 0;
		    mid = (mid + Math.imul(ah1, bl3)) | 0;
		    hi = (hi + Math.imul(ah1, bh3)) | 0;
		    lo = (lo + Math.imul(al0, bl4)) | 0;
		    mid = (mid + Math.imul(al0, bh4)) | 0;
		    mid = (mid + Math.imul(ah0, bl4)) | 0;
		    hi = (hi + Math.imul(ah0, bh4)) | 0;
		    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
		    w4 &= 0x3ffffff;
		    /* k = 5 */
		    lo = Math.imul(al5, bl0);
		    mid = Math.imul(al5, bh0);
		    mid = (mid + Math.imul(ah5, bl0)) | 0;
		    hi = Math.imul(ah5, bh0);
		    lo = (lo + Math.imul(al4, bl1)) | 0;
		    mid = (mid + Math.imul(al4, bh1)) | 0;
		    mid = (mid + Math.imul(ah4, bl1)) | 0;
		    hi = (hi + Math.imul(ah4, bh1)) | 0;
		    lo = (lo + Math.imul(al3, bl2)) | 0;
		    mid = (mid + Math.imul(al3, bh2)) | 0;
		    mid = (mid + Math.imul(ah3, bl2)) | 0;
		    hi = (hi + Math.imul(ah3, bh2)) | 0;
		    lo = (lo + Math.imul(al2, bl3)) | 0;
		    mid = (mid + Math.imul(al2, bh3)) | 0;
		    mid = (mid + Math.imul(ah2, bl3)) | 0;
		    hi = (hi + Math.imul(ah2, bh3)) | 0;
		    lo = (lo + Math.imul(al1, bl4)) | 0;
		    mid = (mid + Math.imul(al1, bh4)) | 0;
		    mid = (mid + Math.imul(ah1, bl4)) | 0;
		    hi = (hi + Math.imul(ah1, bh4)) | 0;
		    lo = (lo + Math.imul(al0, bl5)) | 0;
		    mid = (mid + Math.imul(al0, bh5)) | 0;
		    mid = (mid + Math.imul(ah0, bl5)) | 0;
		    hi = (hi + Math.imul(ah0, bh5)) | 0;
		    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
		    w5 &= 0x3ffffff;
		    /* k = 6 */
		    lo = Math.imul(al6, bl0);
		    mid = Math.imul(al6, bh0);
		    mid = (mid + Math.imul(ah6, bl0)) | 0;
		    hi = Math.imul(ah6, bh0);
		    lo = (lo + Math.imul(al5, bl1)) | 0;
		    mid = (mid + Math.imul(al5, bh1)) | 0;
		    mid = (mid + Math.imul(ah5, bl1)) | 0;
		    hi = (hi + Math.imul(ah5, bh1)) | 0;
		    lo = (lo + Math.imul(al4, bl2)) | 0;
		    mid = (mid + Math.imul(al4, bh2)) | 0;
		    mid = (mid + Math.imul(ah4, bl2)) | 0;
		    hi = (hi + Math.imul(ah4, bh2)) | 0;
		    lo = (lo + Math.imul(al3, bl3)) | 0;
		    mid = (mid + Math.imul(al3, bh3)) | 0;
		    mid = (mid + Math.imul(ah3, bl3)) | 0;
		    hi = (hi + Math.imul(ah3, bh3)) | 0;
		    lo = (lo + Math.imul(al2, bl4)) | 0;
		    mid = (mid + Math.imul(al2, bh4)) | 0;
		    mid = (mid + Math.imul(ah2, bl4)) | 0;
		    hi = (hi + Math.imul(ah2, bh4)) | 0;
		    lo = (lo + Math.imul(al1, bl5)) | 0;
		    mid = (mid + Math.imul(al1, bh5)) | 0;
		    mid = (mid + Math.imul(ah1, bl5)) | 0;
		    hi = (hi + Math.imul(ah1, bh5)) | 0;
		    lo = (lo + Math.imul(al0, bl6)) | 0;
		    mid = (mid + Math.imul(al0, bh6)) | 0;
		    mid = (mid + Math.imul(ah0, bl6)) | 0;
		    hi = (hi + Math.imul(ah0, bh6)) | 0;
		    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
		    w6 &= 0x3ffffff;
		    /* k = 7 */
		    lo = Math.imul(al7, bl0);
		    mid = Math.imul(al7, bh0);
		    mid = (mid + Math.imul(ah7, bl0)) | 0;
		    hi = Math.imul(ah7, bh0);
		    lo = (lo + Math.imul(al6, bl1)) | 0;
		    mid = (mid + Math.imul(al6, bh1)) | 0;
		    mid = (mid + Math.imul(ah6, bl1)) | 0;
		    hi = (hi + Math.imul(ah6, bh1)) | 0;
		    lo = (lo + Math.imul(al5, bl2)) | 0;
		    mid = (mid + Math.imul(al5, bh2)) | 0;
		    mid = (mid + Math.imul(ah5, bl2)) | 0;
		    hi = (hi + Math.imul(ah5, bh2)) | 0;
		    lo = (lo + Math.imul(al4, bl3)) | 0;
		    mid = (mid + Math.imul(al4, bh3)) | 0;
		    mid = (mid + Math.imul(ah4, bl3)) | 0;
		    hi = (hi + Math.imul(ah4, bh3)) | 0;
		    lo = (lo + Math.imul(al3, bl4)) | 0;
		    mid = (mid + Math.imul(al3, bh4)) | 0;
		    mid = (mid + Math.imul(ah3, bl4)) | 0;
		    hi = (hi + Math.imul(ah3, bh4)) | 0;
		    lo = (lo + Math.imul(al2, bl5)) | 0;
		    mid = (mid + Math.imul(al2, bh5)) | 0;
		    mid = (mid + Math.imul(ah2, bl5)) | 0;
		    hi = (hi + Math.imul(ah2, bh5)) | 0;
		    lo = (lo + Math.imul(al1, bl6)) | 0;
		    mid = (mid + Math.imul(al1, bh6)) | 0;
		    mid = (mid + Math.imul(ah1, bl6)) | 0;
		    hi = (hi + Math.imul(ah1, bh6)) | 0;
		    lo = (lo + Math.imul(al0, bl7)) | 0;
		    mid = (mid + Math.imul(al0, bh7)) | 0;
		    mid = (mid + Math.imul(ah0, bl7)) | 0;
		    hi = (hi + Math.imul(ah0, bh7)) | 0;
		    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
		    w7 &= 0x3ffffff;
		    /* k = 8 */
		    lo = Math.imul(al8, bl0);
		    mid = Math.imul(al8, bh0);
		    mid = (mid + Math.imul(ah8, bl0)) | 0;
		    hi = Math.imul(ah8, bh0);
		    lo = (lo + Math.imul(al7, bl1)) | 0;
		    mid = (mid + Math.imul(al7, bh1)) | 0;
		    mid = (mid + Math.imul(ah7, bl1)) | 0;
		    hi = (hi + Math.imul(ah7, bh1)) | 0;
		    lo = (lo + Math.imul(al6, bl2)) | 0;
		    mid = (mid + Math.imul(al6, bh2)) | 0;
		    mid = (mid + Math.imul(ah6, bl2)) | 0;
		    hi = (hi + Math.imul(ah6, bh2)) | 0;
		    lo = (lo + Math.imul(al5, bl3)) | 0;
		    mid = (mid + Math.imul(al5, bh3)) | 0;
		    mid = (mid + Math.imul(ah5, bl3)) | 0;
		    hi = (hi + Math.imul(ah5, bh3)) | 0;
		    lo = (lo + Math.imul(al4, bl4)) | 0;
		    mid = (mid + Math.imul(al4, bh4)) | 0;
		    mid = (mid + Math.imul(ah4, bl4)) | 0;
		    hi = (hi + Math.imul(ah4, bh4)) | 0;
		    lo = (lo + Math.imul(al3, bl5)) | 0;
		    mid = (mid + Math.imul(al3, bh5)) | 0;
		    mid = (mid + Math.imul(ah3, bl5)) | 0;
		    hi = (hi + Math.imul(ah3, bh5)) | 0;
		    lo = (lo + Math.imul(al2, bl6)) | 0;
		    mid = (mid + Math.imul(al2, bh6)) | 0;
		    mid = (mid + Math.imul(ah2, bl6)) | 0;
		    hi = (hi + Math.imul(ah2, bh6)) | 0;
		    lo = (lo + Math.imul(al1, bl7)) | 0;
		    mid = (mid + Math.imul(al1, bh7)) | 0;
		    mid = (mid + Math.imul(ah1, bl7)) | 0;
		    hi = (hi + Math.imul(ah1, bh7)) | 0;
		    lo = (lo + Math.imul(al0, bl8)) | 0;
		    mid = (mid + Math.imul(al0, bh8)) | 0;
		    mid = (mid + Math.imul(ah0, bl8)) | 0;
		    hi = (hi + Math.imul(ah0, bh8)) | 0;
		    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
		    w8 &= 0x3ffffff;
		    /* k = 9 */
		    lo = Math.imul(al9, bl0);
		    mid = Math.imul(al9, bh0);
		    mid = (mid + Math.imul(ah9, bl0)) | 0;
		    hi = Math.imul(ah9, bh0);
		    lo = (lo + Math.imul(al8, bl1)) | 0;
		    mid = (mid + Math.imul(al8, bh1)) | 0;
		    mid = (mid + Math.imul(ah8, bl1)) | 0;
		    hi = (hi + Math.imul(ah8, bh1)) | 0;
		    lo = (lo + Math.imul(al7, bl2)) | 0;
		    mid = (mid + Math.imul(al7, bh2)) | 0;
		    mid = (mid + Math.imul(ah7, bl2)) | 0;
		    hi = (hi + Math.imul(ah7, bh2)) | 0;
		    lo = (lo + Math.imul(al6, bl3)) | 0;
		    mid = (mid + Math.imul(al6, bh3)) | 0;
		    mid = (mid + Math.imul(ah6, bl3)) | 0;
		    hi = (hi + Math.imul(ah6, bh3)) | 0;
		    lo = (lo + Math.imul(al5, bl4)) | 0;
		    mid = (mid + Math.imul(al5, bh4)) | 0;
		    mid = (mid + Math.imul(ah5, bl4)) | 0;
		    hi = (hi + Math.imul(ah5, bh4)) | 0;
		    lo = (lo + Math.imul(al4, bl5)) | 0;
		    mid = (mid + Math.imul(al4, bh5)) | 0;
		    mid = (mid + Math.imul(ah4, bl5)) | 0;
		    hi = (hi + Math.imul(ah4, bh5)) | 0;
		    lo = (lo + Math.imul(al3, bl6)) | 0;
		    mid = (mid + Math.imul(al3, bh6)) | 0;
		    mid = (mid + Math.imul(ah3, bl6)) | 0;
		    hi = (hi + Math.imul(ah3, bh6)) | 0;
		    lo = (lo + Math.imul(al2, bl7)) | 0;
		    mid = (mid + Math.imul(al2, bh7)) | 0;
		    mid = (mid + Math.imul(ah2, bl7)) | 0;
		    hi = (hi + Math.imul(ah2, bh7)) | 0;
		    lo = (lo + Math.imul(al1, bl8)) | 0;
		    mid = (mid + Math.imul(al1, bh8)) | 0;
		    mid = (mid + Math.imul(ah1, bl8)) | 0;
		    hi = (hi + Math.imul(ah1, bh8)) | 0;
		    lo = (lo + Math.imul(al0, bl9)) | 0;
		    mid = (mid + Math.imul(al0, bh9)) | 0;
		    mid = (mid + Math.imul(ah0, bl9)) | 0;
		    hi = (hi + Math.imul(ah0, bh9)) | 0;
		    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
		    w9 &= 0x3ffffff;
		    /* k = 10 */
		    lo = Math.imul(al9, bl1);
		    mid = Math.imul(al9, bh1);
		    mid = (mid + Math.imul(ah9, bl1)) | 0;
		    hi = Math.imul(ah9, bh1);
		    lo = (lo + Math.imul(al8, bl2)) | 0;
		    mid = (mid + Math.imul(al8, bh2)) | 0;
		    mid = (mid + Math.imul(ah8, bl2)) | 0;
		    hi = (hi + Math.imul(ah8, bh2)) | 0;
		    lo = (lo + Math.imul(al7, bl3)) | 0;
		    mid = (mid + Math.imul(al7, bh3)) | 0;
		    mid = (mid + Math.imul(ah7, bl3)) | 0;
		    hi = (hi + Math.imul(ah7, bh3)) | 0;
		    lo = (lo + Math.imul(al6, bl4)) | 0;
		    mid = (mid + Math.imul(al6, bh4)) | 0;
		    mid = (mid + Math.imul(ah6, bl4)) | 0;
		    hi = (hi + Math.imul(ah6, bh4)) | 0;
		    lo = (lo + Math.imul(al5, bl5)) | 0;
		    mid = (mid + Math.imul(al5, bh5)) | 0;
		    mid = (mid + Math.imul(ah5, bl5)) | 0;
		    hi = (hi + Math.imul(ah5, bh5)) | 0;
		    lo = (lo + Math.imul(al4, bl6)) | 0;
		    mid = (mid + Math.imul(al4, bh6)) | 0;
		    mid = (mid + Math.imul(ah4, bl6)) | 0;
		    hi = (hi + Math.imul(ah4, bh6)) | 0;
		    lo = (lo + Math.imul(al3, bl7)) | 0;
		    mid = (mid + Math.imul(al3, bh7)) | 0;
		    mid = (mid + Math.imul(ah3, bl7)) | 0;
		    hi = (hi + Math.imul(ah3, bh7)) | 0;
		    lo = (lo + Math.imul(al2, bl8)) | 0;
		    mid = (mid + Math.imul(al2, bh8)) | 0;
		    mid = (mid + Math.imul(ah2, bl8)) | 0;
		    hi = (hi + Math.imul(ah2, bh8)) | 0;
		    lo = (lo + Math.imul(al1, bl9)) | 0;
		    mid = (mid + Math.imul(al1, bh9)) | 0;
		    mid = (mid + Math.imul(ah1, bl9)) | 0;
		    hi = (hi + Math.imul(ah1, bh9)) | 0;
		    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
		    w10 &= 0x3ffffff;
		    /* k = 11 */
		    lo = Math.imul(al9, bl2);
		    mid = Math.imul(al9, bh2);
		    mid = (mid + Math.imul(ah9, bl2)) | 0;
		    hi = Math.imul(ah9, bh2);
		    lo = (lo + Math.imul(al8, bl3)) | 0;
		    mid = (mid + Math.imul(al8, bh3)) | 0;
		    mid = (mid + Math.imul(ah8, bl3)) | 0;
		    hi = (hi + Math.imul(ah8, bh3)) | 0;
		    lo = (lo + Math.imul(al7, bl4)) | 0;
		    mid = (mid + Math.imul(al7, bh4)) | 0;
		    mid = (mid + Math.imul(ah7, bl4)) | 0;
		    hi = (hi + Math.imul(ah7, bh4)) | 0;
		    lo = (lo + Math.imul(al6, bl5)) | 0;
		    mid = (mid + Math.imul(al6, bh5)) | 0;
		    mid = (mid + Math.imul(ah6, bl5)) | 0;
		    hi = (hi + Math.imul(ah6, bh5)) | 0;
		    lo = (lo + Math.imul(al5, bl6)) | 0;
		    mid = (mid + Math.imul(al5, bh6)) | 0;
		    mid = (mid + Math.imul(ah5, bl6)) | 0;
		    hi = (hi + Math.imul(ah5, bh6)) | 0;
		    lo = (lo + Math.imul(al4, bl7)) | 0;
		    mid = (mid + Math.imul(al4, bh7)) | 0;
		    mid = (mid + Math.imul(ah4, bl7)) | 0;
		    hi = (hi + Math.imul(ah4, bh7)) | 0;
		    lo = (lo + Math.imul(al3, bl8)) | 0;
		    mid = (mid + Math.imul(al3, bh8)) | 0;
		    mid = (mid + Math.imul(ah3, bl8)) | 0;
		    hi = (hi + Math.imul(ah3, bh8)) | 0;
		    lo = (lo + Math.imul(al2, bl9)) | 0;
		    mid = (mid + Math.imul(al2, bh9)) | 0;
		    mid = (mid + Math.imul(ah2, bl9)) | 0;
		    hi = (hi + Math.imul(ah2, bh9)) | 0;
		    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
		    w11 &= 0x3ffffff;
		    /* k = 12 */
		    lo = Math.imul(al9, bl3);
		    mid = Math.imul(al9, bh3);
		    mid = (mid + Math.imul(ah9, bl3)) | 0;
		    hi = Math.imul(ah9, bh3);
		    lo = (lo + Math.imul(al8, bl4)) | 0;
		    mid = (mid + Math.imul(al8, bh4)) | 0;
		    mid = (mid + Math.imul(ah8, bl4)) | 0;
		    hi = (hi + Math.imul(ah8, bh4)) | 0;
		    lo = (lo + Math.imul(al7, bl5)) | 0;
		    mid = (mid + Math.imul(al7, bh5)) | 0;
		    mid = (mid + Math.imul(ah7, bl5)) | 0;
		    hi = (hi + Math.imul(ah7, bh5)) | 0;
		    lo = (lo + Math.imul(al6, bl6)) | 0;
		    mid = (mid + Math.imul(al6, bh6)) | 0;
		    mid = (mid + Math.imul(ah6, bl6)) | 0;
		    hi = (hi + Math.imul(ah6, bh6)) | 0;
		    lo = (lo + Math.imul(al5, bl7)) | 0;
		    mid = (mid + Math.imul(al5, bh7)) | 0;
		    mid = (mid + Math.imul(ah5, bl7)) | 0;
		    hi = (hi + Math.imul(ah5, bh7)) | 0;
		    lo = (lo + Math.imul(al4, bl8)) | 0;
		    mid = (mid + Math.imul(al4, bh8)) | 0;
		    mid = (mid + Math.imul(ah4, bl8)) | 0;
		    hi = (hi + Math.imul(ah4, bh8)) | 0;
		    lo = (lo + Math.imul(al3, bl9)) | 0;
		    mid = (mid + Math.imul(al3, bh9)) | 0;
		    mid = (mid + Math.imul(ah3, bl9)) | 0;
		    hi = (hi + Math.imul(ah3, bh9)) | 0;
		    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
		    w12 &= 0x3ffffff;
		    /* k = 13 */
		    lo = Math.imul(al9, bl4);
		    mid = Math.imul(al9, bh4);
		    mid = (mid + Math.imul(ah9, bl4)) | 0;
		    hi = Math.imul(ah9, bh4);
		    lo = (lo + Math.imul(al8, bl5)) | 0;
		    mid = (mid + Math.imul(al8, bh5)) | 0;
		    mid = (mid + Math.imul(ah8, bl5)) | 0;
		    hi = (hi + Math.imul(ah8, bh5)) | 0;
		    lo = (lo + Math.imul(al7, bl6)) | 0;
		    mid = (mid + Math.imul(al7, bh6)) | 0;
		    mid = (mid + Math.imul(ah7, bl6)) | 0;
		    hi = (hi + Math.imul(ah7, bh6)) | 0;
		    lo = (lo + Math.imul(al6, bl7)) | 0;
		    mid = (mid + Math.imul(al6, bh7)) | 0;
		    mid = (mid + Math.imul(ah6, bl7)) | 0;
		    hi = (hi + Math.imul(ah6, bh7)) | 0;
		    lo = (lo + Math.imul(al5, bl8)) | 0;
		    mid = (mid + Math.imul(al5, bh8)) | 0;
		    mid = (mid + Math.imul(ah5, bl8)) | 0;
		    hi = (hi + Math.imul(ah5, bh8)) | 0;
		    lo = (lo + Math.imul(al4, bl9)) | 0;
		    mid = (mid + Math.imul(al4, bh9)) | 0;
		    mid = (mid + Math.imul(ah4, bl9)) | 0;
		    hi = (hi + Math.imul(ah4, bh9)) | 0;
		    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
		    w13 &= 0x3ffffff;
		    /* k = 14 */
		    lo = Math.imul(al9, bl5);
		    mid = Math.imul(al9, bh5);
		    mid = (mid + Math.imul(ah9, bl5)) | 0;
		    hi = Math.imul(ah9, bh5);
		    lo = (lo + Math.imul(al8, bl6)) | 0;
		    mid = (mid + Math.imul(al8, bh6)) | 0;
		    mid = (mid + Math.imul(ah8, bl6)) | 0;
		    hi = (hi + Math.imul(ah8, bh6)) | 0;
		    lo = (lo + Math.imul(al7, bl7)) | 0;
		    mid = (mid + Math.imul(al7, bh7)) | 0;
		    mid = (mid + Math.imul(ah7, bl7)) | 0;
		    hi = (hi + Math.imul(ah7, bh7)) | 0;
		    lo = (lo + Math.imul(al6, bl8)) | 0;
		    mid = (mid + Math.imul(al6, bh8)) | 0;
		    mid = (mid + Math.imul(ah6, bl8)) | 0;
		    hi = (hi + Math.imul(ah6, bh8)) | 0;
		    lo = (lo + Math.imul(al5, bl9)) | 0;
		    mid = (mid + Math.imul(al5, bh9)) | 0;
		    mid = (mid + Math.imul(ah5, bl9)) | 0;
		    hi = (hi + Math.imul(ah5, bh9)) | 0;
		    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
		    w14 &= 0x3ffffff;
		    /* k = 15 */
		    lo = Math.imul(al9, bl6);
		    mid = Math.imul(al9, bh6);
		    mid = (mid + Math.imul(ah9, bl6)) | 0;
		    hi = Math.imul(ah9, bh6);
		    lo = (lo + Math.imul(al8, bl7)) | 0;
		    mid = (mid + Math.imul(al8, bh7)) | 0;
		    mid = (mid + Math.imul(ah8, bl7)) | 0;
		    hi = (hi + Math.imul(ah8, bh7)) | 0;
		    lo = (lo + Math.imul(al7, bl8)) | 0;
		    mid = (mid + Math.imul(al7, bh8)) | 0;
		    mid = (mid + Math.imul(ah7, bl8)) | 0;
		    hi = (hi + Math.imul(ah7, bh8)) | 0;
		    lo = (lo + Math.imul(al6, bl9)) | 0;
		    mid = (mid + Math.imul(al6, bh9)) | 0;
		    mid = (mid + Math.imul(ah6, bl9)) | 0;
		    hi = (hi + Math.imul(ah6, bh9)) | 0;
		    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
		    w15 &= 0x3ffffff;
		    /* k = 16 */
		    lo = Math.imul(al9, bl7);
		    mid = Math.imul(al9, bh7);
		    mid = (mid + Math.imul(ah9, bl7)) | 0;
		    hi = Math.imul(ah9, bh7);
		    lo = (lo + Math.imul(al8, bl8)) | 0;
		    mid = (mid + Math.imul(al8, bh8)) | 0;
		    mid = (mid + Math.imul(ah8, bl8)) | 0;
		    hi = (hi + Math.imul(ah8, bh8)) | 0;
		    lo = (lo + Math.imul(al7, bl9)) | 0;
		    mid = (mid + Math.imul(al7, bh9)) | 0;
		    mid = (mid + Math.imul(ah7, bl9)) | 0;
		    hi = (hi + Math.imul(ah7, bh9)) | 0;
		    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
		    w16 &= 0x3ffffff;
		    /* k = 17 */
		    lo = Math.imul(al9, bl8);
		    mid = Math.imul(al9, bh8);
		    mid = (mid + Math.imul(ah9, bl8)) | 0;
		    hi = Math.imul(ah9, bh8);
		    lo = (lo + Math.imul(al8, bl9)) | 0;
		    mid = (mid + Math.imul(al8, bh9)) | 0;
		    mid = (mid + Math.imul(ah8, bl9)) | 0;
		    hi = (hi + Math.imul(ah8, bh9)) | 0;
		    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
		    w17 &= 0x3ffffff;
		    /* k = 18 */
		    lo = Math.imul(al9, bl9);
		    mid = Math.imul(al9, bh9);
		    mid = (mid + Math.imul(ah9, bl9)) | 0;
		    hi = Math.imul(ah9, bh9);
		    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
		    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
		    w18 &= 0x3ffffff;
		    o[0] = w0;
		    o[1] = w1;
		    o[2] = w2;
		    o[3] = w3;
		    o[4] = w4;
		    o[5] = w5;
		    o[6] = w6;
		    o[7] = w7;
		    o[8] = w8;
		    o[9] = w9;
		    o[10] = w10;
		    o[11] = w11;
		    o[12] = w12;
		    o[13] = w13;
		    o[14] = w14;
		    o[15] = w15;
		    o[16] = w16;
		    o[17] = w17;
		    o[18] = w18;
		    if (c !== 0) {
		      o[19] = c;
		      out.length++;
		    }
		    return out;
		  };

		  // Polyfill comb
		  if (!Math.imul) {
		    comb10MulTo = smallMulTo;
		  }

		  function bigMulTo (self, num, out) {
		    out.negative = num.negative ^ self.negative;
		    out.length = self.length + num.length;

		    var carry = 0;
		    var hncarry = 0;
		    for (var k = 0; k < out.length - 1; k++) {
		      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
		      // note that ncarry could be >= 0x3ffffff
		      var ncarry = hncarry;
		      hncarry = 0;
		      var rword = carry & 0x3ffffff;
		      var maxJ = Math.min(k, num.length - 1);
		      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
		        var i = k - j;
		        var a = self.words[i] | 0;
		        var b = num.words[j] | 0;
		        var r = a * b;

		        var lo = r & 0x3ffffff;
		        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
		        lo = (lo + rword) | 0;
		        rword = lo & 0x3ffffff;
		        ncarry = (ncarry + (lo >>> 26)) | 0;

		        hncarry += ncarry >>> 26;
		        ncarry &= 0x3ffffff;
		      }
		      out.words[k] = rword;
		      carry = ncarry;
		      ncarry = hncarry;
		    }
		    if (carry !== 0) {
		      out.words[k] = carry;
		    } else {
		      out.length--;
		    }

		    return out.strip();
		  }

		  function jumboMulTo (self, num, out) {
		    var fftm = new FFTM();
		    return fftm.mulp(self, num, out);
		  }

		  BN.prototype.mulTo = function mulTo (num, out) {
		    var res;
		    var len = this.length + num.length;
		    if (this.length === 10 && num.length === 10) {
		      res = comb10MulTo(this, num, out);
		    } else if (len < 63) {
		      res = smallMulTo(this, num, out);
		    } else if (len < 1024) {
		      res = bigMulTo(this, num, out);
		    } else {
		      res = jumboMulTo(this, num, out);
		    }

		    return res;
		  };

		  // Cooley-Tukey algorithm for FFT
		  // slightly revisited to rely on looping instead of recursion

		  function FFTM (x, y) {
		    this.x = x;
		    this.y = y;
		  }

		  FFTM.prototype.makeRBT = function makeRBT (N) {
		    var t = new Array(N);
		    var l = BN.prototype._countBits(N) - 1;
		    for (var i = 0; i < N; i++) {
		      t[i] = this.revBin(i, l, N);
		    }

		    return t;
		  };

		  // Returns binary-reversed representation of `x`
		  FFTM.prototype.revBin = function revBin (x, l, N) {
		    if (x === 0 || x === N - 1) return x;

		    var rb = 0;
		    for (var i = 0; i < l; i++) {
		      rb |= (x & 1) << (l - i - 1);
		      x >>= 1;
		    }

		    return rb;
		  };

		  // Performs "tweedling" phase, therefore 'emulating'
		  // behaviour of the recursive algorithm
		  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
		    for (var i = 0; i < N; i++) {
		      rtws[i] = rws[rbt[i]];
		      itws[i] = iws[rbt[i]];
		    }
		  };

		  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
		    this.permute(rbt, rws, iws, rtws, itws, N);

		    for (var s = 1; s < N; s <<= 1) {
		      var l = s << 1;

		      var rtwdf = Math.cos(2 * Math.PI / l);
		      var itwdf = Math.sin(2 * Math.PI / l);

		      for (var p = 0; p < N; p += l) {
		        var rtwdf_ = rtwdf;
		        var itwdf_ = itwdf;

		        for (var j = 0; j < s; j++) {
		          var re = rtws[p + j];
		          var ie = itws[p + j];

		          var ro = rtws[p + j + s];
		          var io = itws[p + j + s];

		          var rx = rtwdf_ * ro - itwdf_ * io;

		          io = rtwdf_ * io + itwdf_ * ro;
		          ro = rx;

		          rtws[p + j] = re + ro;
		          itws[p + j] = ie + io;

		          rtws[p + j + s] = re - ro;
		          itws[p + j + s] = ie - io;

		          /* jshint maxdepth : false */
		          if (j !== l) {
		            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

		            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
		            rtwdf_ = rx;
		          }
		        }
		      }
		    }
		  };

		  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
		    var N = Math.max(m, n) | 1;
		    var odd = N & 1;
		    var i = 0;
		    for (N = N / 2 | 0; N; N = N >>> 1) {
		      i++;
		    }

		    return 1 << i + 1 + odd;
		  };

		  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
		    if (N <= 1) return;

		    for (var i = 0; i < N / 2; i++) {
		      var t = rws[i];

		      rws[i] = rws[N - i - 1];
		      rws[N - i - 1] = t;

		      t = iws[i];

		      iws[i] = -iws[N - i - 1];
		      iws[N - i - 1] = -t;
		    }
		  };

		  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
		    var carry = 0;
		    for (var i = 0; i < N / 2; i++) {
		      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
		        Math.round(ws[2 * i] / N) +
		        carry;

		      ws[i] = w & 0x3ffffff;

		      if (w < 0x4000000) {
		        carry = 0;
		      } else {
		        carry = w / 0x4000000 | 0;
		      }
		    }

		    return ws;
		  };

		  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
		    var carry = 0;
		    for (var i = 0; i < len; i++) {
		      carry = carry + (ws[i] | 0);

		      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
		      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
		    }

		    // Pad with zeroes
		    for (i = 2 * len; i < N; ++i) {
		      rws[i] = 0;
		    }

		    assert(carry === 0);
		    assert((carry & -8192) === 0);
		  };

		  FFTM.prototype.stub = function stub (N) {
		    var ph = new Array(N);
		    for (var i = 0; i < N; i++) {
		      ph[i] = 0;
		    }

		    return ph;
		  };

		  FFTM.prototype.mulp = function mulp (x, y, out) {
		    var N = 2 * this.guessLen13b(x.length, y.length);

		    var rbt = this.makeRBT(N);

		    var _ = this.stub(N);

		    var rws = new Array(N);
		    var rwst = new Array(N);
		    var iwst = new Array(N);

		    var nrws = new Array(N);
		    var nrwst = new Array(N);
		    var niwst = new Array(N);

		    var rmws = out.words;
		    rmws.length = N;

		    this.convert13b(x.words, x.length, rws, N);
		    this.convert13b(y.words, y.length, nrws, N);

		    this.transform(rws, _, rwst, iwst, N, rbt);
		    this.transform(nrws, _, nrwst, niwst, N, rbt);

		    for (var i = 0; i < N; i++) {
		      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
		      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
		      rwst[i] = rx;
		    }

		    this.conjugate(rwst, iwst, N);
		    this.transform(rwst, iwst, rmws, _, N, rbt);
		    this.conjugate(rmws, _, N);
		    this.normalize13b(rmws, N);

		    out.negative = x.negative ^ y.negative;
		    out.length = x.length + y.length;
		    return out.strip();
		  };

		  // Multiply `this` by `num`
		  BN.prototype.mul = function mul (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return this.mulTo(num, out);
		  };

		  // Multiply employing FFT
		  BN.prototype.mulf = function mulf (num) {
		    var out = new BN(null);
		    out.words = new Array(this.length + num.length);
		    return jumboMulTo(this, num, out);
		  };

		  // In-place Multiplication
		  BN.prototype.imul = function imul (num) {
		    return this.clone().mulTo(num, this);
		  };

		  BN.prototype.imuln = function imuln (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);

		    // Carry
		    var carry = 0;
		    for (var i = 0; i < this.length; i++) {
		      var w = (this.words[i] | 0) * num;
		      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
		      carry >>= 26;
		      carry += (w / 0x4000000) | 0;
		      // NOTE: lo is 27bit maximum
		      carry += lo >>> 26;
		      this.words[i] = lo & 0x3ffffff;
		    }

		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }

		    return this;
		  };

		  BN.prototype.muln = function muln (num) {
		    return this.clone().imuln(num);
		  };

		  // `this` * `this`
		  BN.prototype.sqr = function sqr () {
		    return this.mul(this);
		  };

		  // `this` * `this` in-place
		  BN.prototype.isqr = function isqr () {
		    return this.imul(this.clone());
		  };

		  // Math.pow(`this`, `num`)
		  BN.prototype.pow = function pow (num) {
		    var w = toBitArray(num);
		    if (w.length === 0) return new BN(1);

		    // Skip leading zeroes
		    var res = this;
		    for (var i = 0; i < w.length; i++, res = res.sqr()) {
		      if (w[i] !== 0) break;
		    }

		    if (++i < w.length) {
		      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
		        if (w[i] === 0) continue;

		        res = res.mul(q);
		      }
		    }

		    return res;
		  };

		  // Shift-left in-place
		  BN.prototype.iushln = function iushln (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;
		    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
		    var i;

		    if (r !== 0) {
		      var carry = 0;

		      for (i = 0; i < this.length; i++) {
		        var newCarry = this.words[i] & carryMask;
		        var c = ((this.words[i] | 0) - newCarry) << r;
		        this.words[i] = c | carry;
		        carry = newCarry >>> (26 - r);
		      }

		      if (carry) {
		        this.words[i] = carry;
		        this.length++;
		      }
		    }

		    if (s !== 0) {
		      for (i = this.length - 1; i >= 0; i--) {
		        this.words[i + s] = this.words[i];
		      }

		      for (i = 0; i < s; i++) {
		        this.words[i] = 0;
		      }

		      this.length += s;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishln = function ishln (bits) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushln(bits);
		  };

		  // Shift-right in-place
		  // NOTE: `hint` is a lowest bit before trailing zeroes
		  // NOTE: if `extended` is present - it will be filled with destroyed bits
		  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var h;
		    if (hint) {
		      h = (hint - (hint % 26)) / 26;
		    } else {
		      h = 0;
		    }

		    var r = bits % 26;
		    var s = Math.min((bits - r) / 26, this.length);
		    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		    var maskedWords = extended;

		    h -= s;
		    h = Math.max(0, h);

		    // Extended mode, copy masked part
		    if (maskedWords) {
		      for (var i = 0; i < s; i++) {
		        maskedWords.words[i] = this.words[i];
		      }
		      maskedWords.length = s;
		    }

		    if (s === 0) ; else if (this.length > s) {
		      this.length -= s;
		      for (i = 0; i < this.length; i++) {
		        this.words[i] = this.words[i + s];
		      }
		    } else {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    var carry = 0;
		    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
		      var word = this.words[i] | 0;
		      this.words[i] = (carry << (26 - r)) | (word >>> r);
		      carry = word & mask;
		    }

		    // Push carried bits as a mask
		    if (maskedWords && carry !== 0) {
		      maskedWords.words[maskedWords.length++] = carry;
		    }

		    if (this.length === 0) {
		      this.words[0] = 0;
		      this.length = 1;
		    }

		    return this.strip();
		  };

		  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
		    // TODO(indutny): implement me
		    assert(this.negative === 0);
		    return this.iushrn(bits, hint, extended);
		  };

		  // Shift-left
		  BN.prototype.shln = function shln (bits) {
		    return this.clone().ishln(bits);
		  };

		  BN.prototype.ushln = function ushln (bits) {
		    return this.clone().iushln(bits);
		  };

		  // Shift-right
		  BN.prototype.shrn = function shrn (bits) {
		    return this.clone().ishrn(bits);
		  };

		  BN.prototype.ushrn = function ushrn (bits) {
		    return this.clone().iushrn(bits);
		  };

		  // Test if n bit is set
		  BN.prototype.testn = function testn (bit) {
		    assert(typeof bit === 'number' && bit >= 0);
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) return false;

		    // Check bit and return
		    var w = this.words[s];

		    return !!(w & q);
		  };

		  // Return only lowers bits of number (in-place)
		  BN.prototype.imaskn = function imaskn (bits) {
		    assert(typeof bits === 'number' && bits >= 0);
		    var r = bits % 26;
		    var s = (bits - r) / 26;

		    assert(this.negative === 0, 'imaskn works only with positive numbers');

		    if (this.length <= s) {
		      return this;
		    }

		    if (r !== 0) {
		      s++;
		    }
		    this.length = Math.min(s, this.length);

		    if (r !== 0) {
		      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
		      this.words[this.length - 1] &= mask;
		    }

		    return this.strip();
		  };

		  // Return only lowers bits of number
		  BN.prototype.maskn = function maskn (bits) {
		    return this.clone().imaskn(bits);
		  };

		  // Add plain number `num` to `this`
		  BN.prototype.iaddn = function iaddn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.isubn(-num);

		    // Possible sign change
		    if (this.negative !== 0) {
		      if (this.length === 1 && (this.words[0] | 0) < num) {
		        this.words[0] = num - (this.words[0] | 0);
		        this.negative = 0;
		        return this;
		      }

		      this.negative = 0;
		      this.isubn(num);
		      this.negative = 1;
		      return this;
		    }

		    // Add without checks
		    return this._iaddn(num);
		  };

		  BN.prototype._iaddn = function _iaddn (num) {
		    this.words[0] += num;

		    // Carry
		    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
		      this.words[i] -= 0x4000000;
		      if (i === this.length - 1) {
		        this.words[i + 1] = 1;
		      } else {
		        this.words[i + 1]++;
		      }
		    }
		    this.length = Math.max(this.length, i + 1);

		    return this;
		  };

		  // Subtract plain number `num` from `this`
		  BN.prototype.isubn = function isubn (num) {
		    assert(typeof num === 'number');
		    assert(num < 0x4000000);
		    if (num < 0) return this.iaddn(-num);

		    if (this.negative !== 0) {
		      this.negative = 0;
		      this.iaddn(num);
		      this.negative = 1;
		      return this;
		    }

		    this.words[0] -= num;

		    if (this.length === 1 && this.words[0] < 0) {
		      this.words[0] = -this.words[0];
		      this.negative = 1;
		    } else {
		      // Carry
		      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
		        this.words[i] += 0x4000000;
		        this.words[i + 1] -= 1;
		      }
		    }

		    return this.strip();
		  };

		  BN.prototype.addn = function addn (num) {
		    return this.clone().iaddn(num);
		  };

		  BN.prototype.subn = function subn (num) {
		    return this.clone().isubn(num);
		  };

		  BN.prototype.iabs = function iabs () {
		    this.negative = 0;

		    return this;
		  };

		  BN.prototype.abs = function abs () {
		    return this.clone().iabs();
		  };

		  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
		    var len = num.length + shift;
		    var i;

		    this._expand(len);

		    var w;
		    var carry = 0;
		    for (i = 0; i < num.length; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      var right = (num.words[i] | 0) * mul;
		      w -= right & 0x3ffffff;
		      carry = (w >> 26) - ((right / 0x4000000) | 0);
		      this.words[i + shift] = w & 0x3ffffff;
		    }
		    for (; i < this.length - shift; i++) {
		      w = (this.words[i + shift] | 0) + carry;
		      carry = w >> 26;
		      this.words[i + shift] = w & 0x3ffffff;
		    }

		    if (carry === 0) return this.strip();

		    // Subtraction overflow
		    assert(carry === -1);
		    carry = 0;
		    for (i = 0; i < this.length; i++) {
		      w = -(this.words[i] | 0) + carry;
		      carry = w >> 26;
		      this.words[i] = w & 0x3ffffff;
		    }
		    this.negative = 1;

		    return this.strip();
		  };

		  BN.prototype._wordDiv = function _wordDiv (num, mode) {
		    var shift = this.length - num.length;

		    var a = this.clone();
		    var b = num;

		    // Normalize
		    var bhi = b.words[b.length - 1] | 0;
		    var bhiBits = this._countBits(bhi);
		    shift = 26 - bhiBits;
		    if (shift !== 0) {
		      b = b.ushln(shift);
		      a.iushln(shift);
		      bhi = b.words[b.length - 1] | 0;
		    }

		    // Initialize quotient
		    var m = a.length - b.length;
		    var q;

		    if (mode !== 'mod') {
		      q = new BN(null);
		      q.length = m + 1;
		      q.words = new Array(q.length);
		      for (var i = 0; i < q.length; i++) {
		        q.words[i] = 0;
		      }
		    }

		    var diff = a.clone()._ishlnsubmul(b, 1, m);
		    if (diff.negative === 0) {
		      a = diff;
		      if (q) {
		        q.words[m] = 1;
		      }
		    }

		    for (var j = m - 1; j >= 0; j--) {
		      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
		        (a.words[b.length + j - 1] | 0);

		      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
		      // (0x7ffffff)
		      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

		      a._ishlnsubmul(b, qj, j);
		      while (a.negative !== 0) {
		        qj--;
		        a.negative = 0;
		        a._ishlnsubmul(b, 1, j);
		        if (!a.isZero()) {
		          a.negative ^= 1;
		        }
		      }
		      if (q) {
		        q.words[j] = qj;
		      }
		    }
		    if (q) {
		      q.strip();
		    }
		    a.strip();

		    // Denormalize
		    if (mode !== 'div' && shift !== 0) {
		      a.iushrn(shift);
		    }

		    return {
		      div: q || null,
		      mod: a
		    };
		  };

		  // NOTE: 1) `mode` can be set to `mod` to request mod only,
		  //       to `div` to request div only, or be absent to
		  //       request both div & mod
		  //       2) `positive` is true if unsigned mod is requested
		  BN.prototype.divmod = function divmod (num, mode, positive) {
		    assert(!num.isZero());

		    if (this.isZero()) {
		      return {
		        div: new BN(0),
		        mod: new BN(0)
		      };
		    }

		    var div, mod, res;
		    if (this.negative !== 0 && num.negative === 0) {
		      res = this.neg().divmod(num, mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.iadd(num);
		        }
		      }

		      return {
		        div: div,
		        mod: mod
		      };
		    }

		    if (this.negative === 0 && num.negative !== 0) {
		      res = this.divmod(num.neg(), mode);

		      if (mode !== 'mod') {
		        div = res.div.neg();
		      }

		      return {
		        div: div,
		        mod: res.mod
		      };
		    }

		    if ((this.negative & num.negative) !== 0) {
		      res = this.neg().divmod(num.neg(), mode);

		      if (mode !== 'div') {
		        mod = res.mod.neg();
		        if (positive && mod.negative !== 0) {
		          mod.isub(num);
		        }
		      }

		      return {
		        div: res.div,
		        mod: mod
		      };
		    }

		    // Both numbers are positive at this point

		    // Strip both numbers to approximate shift value
		    if (num.length > this.length || this.cmp(num) < 0) {
		      return {
		        div: new BN(0),
		        mod: this
		      };
		    }

		    // Very short reduction
		    if (num.length === 1) {
		      if (mode === 'div') {
		        return {
		          div: this.divn(num.words[0]),
		          mod: null
		        };
		      }

		      if (mode === 'mod') {
		        return {
		          div: null,
		          mod: new BN(this.modn(num.words[0]))
		        };
		      }

		      return {
		        div: this.divn(num.words[0]),
		        mod: new BN(this.modn(num.words[0]))
		      };
		    }

		    return this._wordDiv(num, mode);
		  };

		  // Find `this` / `num`
		  BN.prototype.div = function div (num) {
		    return this.divmod(num, 'div', false).div;
		  };

		  // Find `this` % `num`
		  BN.prototype.mod = function mod (num) {
		    return this.divmod(num, 'mod', false).mod;
		  };

		  BN.prototype.umod = function umod (num) {
		    return this.divmod(num, 'mod', true).mod;
		  };

		  // Find Round(`this` / `num`)
		  BN.prototype.divRound = function divRound (num) {
		    var dm = this.divmod(num);

		    // Fast case - exact division
		    if (dm.mod.isZero()) return dm.div;

		    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

		    var half = num.ushrn(1);
		    var r2 = num.andln(1);
		    var cmp = mod.cmp(half);

		    // Round down
		    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

		    // Round up
		    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
		  };

		  BN.prototype.modn = function modn (num) {
		    assert(num <= 0x3ffffff);
		    var p = (1 << 26) % num;

		    var acc = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      acc = (p * acc + (this.words[i] | 0)) % num;
		    }

		    return acc;
		  };

		  // In-place division by number
		  BN.prototype.idivn = function idivn (num) {
		    assert(num <= 0x3ffffff);

		    var carry = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var w = (this.words[i] | 0) + carry * 0x4000000;
		      this.words[i] = (w / num) | 0;
		      carry = w % num;
		    }

		    return this.strip();
		  };

		  BN.prototype.divn = function divn (num) {
		    return this.clone().idivn(num);
		  };

		  BN.prototype.egcd = function egcd (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var x = this;
		    var y = p.clone();

		    if (x.negative !== 0) {
		      x = x.umod(p);
		    } else {
		      x = x.clone();
		    }

		    // A * x + B * y = x
		    var A = new BN(1);
		    var B = new BN(0);

		    // C * x + D * y = y
		    var C = new BN(0);
		    var D = new BN(1);

		    var g = 0;

		    while (x.isEven() && y.isEven()) {
		      x.iushrn(1);
		      y.iushrn(1);
		      ++g;
		    }

		    var yp = y.clone();
		    var xp = x.clone();

		    while (!x.isZero()) {
		      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        x.iushrn(i);
		        while (i-- > 0) {
		          if (A.isOdd() || B.isOdd()) {
		            A.iadd(yp);
		            B.isub(xp);
		          }

		          A.iushrn(1);
		          B.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        y.iushrn(j);
		        while (j-- > 0) {
		          if (C.isOdd() || D.isOdd()) {
		            C.iadd(yp);
		            D.isub(xp);
		          }

		          C.iushrn(1);
		          D.iushrn(1);
		        }
		      }

		      if (x.cmp(y) >= 0) {
		        x.isub(y);
		        A.isub(C);
		        B.isub(D);
		      } else {
		        y.isub(x);
		        C.isub(A);
		        D.isub(B);
		      }
		    }

		    return {
		      a: C,
		      b: D,
		      gcd: y.iushln(g)
		    };
		  };

		  // This is reduced incarnation of the binary EEA
		  // above, designated to invert members of the
		  // _prime_ fields F(p) at a maximal speed
		  BN.prototype._invmp = function _invmp (p) {
		    assert(p.negative === 0);
		    assert(!p.isZero());

		    var a = this;
		    var b = p.clone();

		    if (a.negative !== 0) {
		      a = a.umod(p);
		    } else {
		      a = a.clone();
		    }

		    var x1 = new BN(1);
		    var x2 = new BN(0);

		    var delta = b.clone();

		    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
		      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
		      if (i > 0) {
		        a.iushrn(i);
		        while (i-- > 0) {
		          if (x1.isOdd()) {
		            x1.iadd(delta);
		          }

		          x1.iushrn(1);
		        }
		      }

		      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
		      if (j > 0) {
		        b.iushrn(j);
		        while (j-- > 0) {
		          if (x2.isOdd()) {
		            x2.iadd(delta);
		          }

		          x2.iushrn(1);
		        }
		      }

		      if (a.cmp(b) >= 0) {
		        a.isub(b);
		        x1.isub(x2);
		      } else {
		        b.isub(a);
		        x2.isub(x1);
		      }
		    }

		    var res;
		    if (a.cmpn(1) === 0) {
		      res = x1;
		    } else {
		      res = x2;
		    }

		    if (res.cmpn(0) < 0) {
		      res.iadd(p);
		    }

		    return res;
		  };

		  BN.prototype.gcd = function gcd (num) {
		    if (this.isZero()) return num.abs();
		    if (num.isZero()) return this.abs();

		    var a = this.clone();
		    var b = num.clone();
		    a.negative = 0;
		    b.negative = 0;

		    // Remove common factor of two
		    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
		      a.iushrn(1);
		      b.iushrn(1);
		    }

		    do {
		      while (a.isEven()) {
		        a.iushrn(1);
		      }
		      while (b.isEven()) {
		        b.iushrn(1);
		      }

		      var r = a.cmp(b);
		      if (r < 0) {
		        // Swap `a` and `b` to make `a` always bigger than `b`
		        var t = a;
		        a = b;
		        b = t;
		      } else if (r === 0 || b.cmpn(1) === 0) {
		        break;
		      }

		      a.isub(b);
		    } while (true);

		    return b.iushln(shift);
		  };

		  // Invert number in the field F(num)
		  BN.prototype.invm = function invm (num) {
		    return this.egcd(num).a.umod(num);
		  };

		  BN.prototype.isEven = function isEven () {
		    return (this.words[0] & 1) === 0;
		  };

		  BN.prototype.isOdd = function isOdd () {
		    return (this.words[0] & 1) === 1;
		  };

		  // And first word and num
		  BN.prototype.andln = function andln (num) {
		    return this.words[0] & num;
		  };

		  // Increment at the bit position in-line
		  BN.prototype.bincn = function bincn (bit) {
		    assert(typeof bit === 'number');
		    var r = bit % 26;
		    var s = (bit - r) / 26;
		    var q = 1 << r;

		    // Fast case: bit is much higher than all existing words
		    if (this.length <= s) {
		      this._expand(s + 1);
		      this.words[s] |= q;
		      return this;
		    }

		    // Add bit and propagate, if needed
		    var carry = q;
		    for (var i = s; carry !== 0 && i < this.length; i++) {
		      var w = this.words[i] | 0;
		      w += carry;
		      carry = w >>> 26;
		      w &= 0x3ffffff;
		      this.words[i] = w;
		    }
		    if (carry !== 0) {
		      this.words[i] = carry;
		      this.length++;
		    }
		    return this;
		  };

		  BN.prototype.isZero = function isZero () {
		    return this.length === 1 && this.words[0] === 0;
		  };

		  BN.prototype.cmpn = function cmpn (num) {
		    var negative = num < 0;

		    if (this.negative !== 0 && !negative) return -1;
		    if (this.negative === 0 && negative) return 1;

		    this.strip();

		    var res;
		    if (this.length > 1) {
		      res = 1;
		    } else {
		      if (negative) {
		        num = -num;
		      }

		      assert(num <= 0x3ffffff, 'Number is too big');

		      var w = this.words[0] | 0;
		      res = w === num ? 0 : w < num ? -1 : 1;
		    }
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Compare two numbers and return:
		  // 1 - if `this` > `num`
		  // 0 - if `this` == `num`
		  // -1 - if `this` < `num`
		  BN.prototype.cmp = function cmp (num) {
		    if (this.negative !== 0 && num.negative === 0) return -1;
		    if (this.negative === 0 && num.negative !== 0) return 1;

		    var res = this.ucmp(num);
		    if (this.negative !== 0) return -res | 0;
		    return res;
		  };

		  // Unsigned comparison
		  BN.prototype.ucmp = function ucmp (num) {
		    // At this point both numbers have the same sign
		    if (this.length > num.length) return 1;
		    if (this.length < num.length) return -1;

		    var res = 0;
		    for (var i = this.length - 1; i >= 0; i--) {
		      var a = this.words[i] | 0;
		      var b = num.words[i] | 0;

		      if (a === b) continue;
		      if (a < b) {
		        res = -1;
		      } else if (a > b) {
		        res = 1;
		      }
		      break;
		    }
		    return res;
		  };

		  BN.prototype.gtn = function gtn (num) {
		    return this.cmpn(num) === 1;
		  };

		  BN.prototype.gt = function gt (num) {
		    return this.cmp(num) === 1;
		  };

		  BN.prototype.gten = function gten (num) {
		    return this.cmpn(num) >= 0;
		  };

		  BN.prototype.gte = function gte (num) {
		    return this.cmp(num) >= 0;
		  };

		  BN.prototype.ltn = function ltn (num) {
		    return this.cmpn(num) === -1;
		  };

		  BN.prototype.lt = function lt (num) {
		    return this.cmp(num) === -1;
		  };

		  BN.prototype.lten = function lten (num) {
		    return this.cmpn(num) <= 0;
		  };

		  BN.prototype.lte = function lte (num) {
		    return this.cmp(num) <= 0;
		  };

		  BN.prototype.eqn = function eqn (num) {
		    return this.cmpn(num) === 0;
		  };

		  BN.prototype.eq = function eq (num) {
		    return this.cmp(num) === 0;
		  };

		  //
		  // A reduce context, could be using montgomery or something better, depending
		  // on the `m` itself.
		  //
		  BN.red = function red (num) {
		    return new Red(num);
		  };

		  BN.prototype.toRed = function toRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    assert(this.negative === 0, 'red works only with positives');
		    return ctx.convertTo(this)._forceRed(ctx);
		  };

		  BN.prototype.fromRed = function fromRed () {
		    assert(this.red, 'fromRed works only with numbers in reduction context');
		    return this.red.convertFrom(this);
		  };

		  BN.prototype._forceRed = function _forceRed (ctx) {
		    this.red = ctx;
		    return this;
		  };

		  BN.prototype.forceRed = function forceRed (ctx) {
		    assert(!this.red, 'Already a number in reduction context');
		    return this._forceRed(ctx);
		  };

		  BN.prototype.redAdd = function redAdd (num) {
		    assert(this.red, 'redAdd works only with red numbers');
		    return this.red.add(this, num);
		  };

		  BN.prototype.redIAdd = function redIAdd (num) {
		    assert(this.red, 'redIAdd works only with red numbers');
		    return this.red.iadd(this, num);
		  };

		  BN.prototype.redSub = function redSub (num) {
		    assert(this.red, 'redSub works only with red numbers');
		    return this.red.sub(this, num);
		  };

		  BN.prototype.redISub = function redISub (num) {
		    assert(this.red, 'redISub works only with red numbers');
		    return this.red.isub(this, num);
		  };

		  BN.prototype.redShl = function redShl (num) {
		    assert(this.red, 'redShl works only with red numbers');
		    return this.red.shl(this, num);
		  };

		  BN.prototype.redMul = function redMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.mul(this, num);
		  };

		  BN.prototype.redIMul = function redIMul (num) {
		    assert(this.red, 'redMul works only with red numbers');
		    this.red._verify2(this, num);
		    return this.red.imul(this, num);
		  };

		  BN.prototype.redSqr = function redSqr () {
		    assert(this.red, 'redSqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqr(this);
		  };

		  BN.prototype.redISqr = function redISqr () {
		    assert(this.red, 'redISqr works only with red numbers');
		    this.red._verify1(this);
		    return this.red.isqr(this);
		  };

		  // Square root over p
		  BN.prototype.redSqrt = function redSqrt () {
		    assert(this.red, 'redSqrt works only with red numbers');
		    this.red._verify1(this);
		    return this.red.sqrt(this);
		  };

		  BN.prototype.redInvm = function redInvm () {
		    assert(this.red, 'redInvm works only with red numbers');
		    this.red._verify1(this);
		    return this.red.invm(this);
		  };

		  // Return negative clone of `this` % `red modulo`
		  BN.prototype.redNeg = function redNeg () {
		    assert(this.red, 'redNeg works only with red numbers');
		    this.red._verify1(this);
		    return this.red.neg(this);
		  };

		  BN.prototype.redPow = function redPow (num) {
		    assert(this.red && !num.red, 'redPow(normalNum)');
		    this.red._verify1(this);
		    return this.red.pow(this, num);
		  };

		  // Prime numbers with efficient reduction
		  var primes = {
		    k256: null,
		    p224: null,
		    p192: null,
		    p25519: null
		  };

		  // Pseudo-Mersenne prime
		  function MPrime (name, p) {
		    // P = 2 ^ N - K
		    this.name = name;
		    this.p = new BN(p, 16);
		    this.n = this.p.bitLength();
		    this.k = new BN(1).iushln(this.n).isub(this.p);

		    this.tmp = this._tmp();
		  }

		  MPrime.prototype._tmp = function _tmp () {
		    var tmp = new BN(null);
		    tmp.words = new Array(Math.ceil(this.n / 13));
		    return tmp;
		  };

		  MPrime.prototype.ireduce = function ireduce (num) {
		    // Assumes that `num` is less than `P^2`
		    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
		    var r = num;
		    var rlen;

		    do {
		      this.split(r, this.tmp);
		      r = this.imulK(r);
		      r = r.iadd(this.tmp);
		      rlen = r.bitLength();
		    } while (rlen > this.n);

		    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
		    if (cmp === 0) {
		      r.words[0] = 0;
		      r.length = 1;
		    } else if (cmp > 0) {
		      r.isub(this.p);
		    } else {
		      if (r.strip !== undefined) {
		        // r is BN v4 instance
		        r.strip();
		      } else {
		        // r is BN v5 instance
		        r._strip();
		      }
		    }

		    return r;
		  };

		  MPrime.prototype.split = function split (input, out) {
		    input.iushrn(this.n, 0, out);
		  };

		  MPrime.prototype.imulK = function imulK (num) {
		    return num.imul(this.k);
		  };

		  function K256 () {
		    MPrime.call(
		      this,
		      'k256',
		      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
		  }
		  inherits(K256, MPrime);

		  K256.prototype.split = function split (input, output) {
		    // 256 = 9 * 26 + 22
		    var mask = 0x3fffff;

		    var outLen = Math.min(input.length, 9);
		    for (var i = 0; i < outLen; i++) {
		      output.words[i] = input.words[i];
		    }
		    output.length = outLen;

		    if (input.length <= 9) {
		      input.words[0] = 0;
		      input.length = 1;
		      return;
		    }

		    // Shift by 9 limbs
		    var prev = input.words[9];
		    output.words[output.length++] = prev & mask;

		    for (i = 10; i < input.length; i++) {
		      var next = input.words[i] | 0;
		      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
		      prev = next;
		    }
		    prev >>>= 22;
		    input.words[i - 10] = prev;
		    if (prev === 0 && input.length > 10) {
		      input.length -= 10;
		    } else {
		      input.length -= 9;
		    }
		  };

		  K256.prototype.imulK = function imulK (num) {
		    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
		    num.words[num.length] = 0;
		    num.words[num.length + 1] = 0;
		    num.length += 2;

		    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
		    var lo = 0;
		    for (var i = 0; i < num.length; i++) {
		      var w = num.words[i] | 0;
		      lo += w * 0x3d1;
		      num.words[i] = lo & 0x3ffffff;
		      lo = w * 0x40 + ((lo / 0x4000000) | 0);
		    }

		    // Fast length reduction
		    if (num.words[num.length - 1] === 0) {
		      num.length--;
		      if (num.words[num.length - 1] === 0) {
		        num.length--;
		      }
		    }
		    return num;
		  };

		  function P224 () {
		    MPrime.call(
		      this,
		      'p224',
		      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
		  }
		  inherits(P224, MPrime);

		  function P192 () {
		    MPrime.call(
		      this,
		      'p192',
		      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
		  }
		  inherits(P192, MPrime);

		  function P25519 () {
		    // 2 ^ 255 - 19
		    MPrime.call(
		      this,
		      '25519',
		      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
		  }
		  inherits(P25519, MPrime);

		  P25519.prototype.imulK = function imulK (num) {
		    // K = 0x13
		    var carry = 0;
		    for (var i = 0; i < num.length; i++) {
		      var hi = (num.words[i] | 0) * 0x13 + carry;
		      var lo = hi & 0x3ffffff;
		      hi >>>= 26;

		      num.words[i] = lo;
		      carry = hi;
		    }
		    if (carry !== 0) {
		      num.words[num.length++] = carry;
		    }
		    return num;
		  };

		  // Exported mostly for testing purposes, use plain name instead
		  BN._prime = function prime (name) {
		    // Cached version of prime
		    if (primes[name]) return primes[name];

		    var prime;
		    if (name === 'k256') {
		      prime = new K256();
		    } else if (name === 'p224') {
		      prime = new P224();
		    } else if (name === 'p192') {
		      prime = new P192();
		    } else if (name === 'p25519') {
		      prime = new P25519();
		    } else {
		      throw new Error('Unknown prime ' + name);
		    }
		    primes[name] = prime;

		    return prime;
		  };

		  //
		  // Base reduction engine
		  //
		  function Red (m) {
		    if (typeof m === 'string') {
		      var prime = BN._prime(m);
		      this.m = prime.p;
		      this.prime = prime;
		    } else {
		      assert(m.gtn(1), 'modulus must be greater than 1');
		      this.m = m;
		      this.prime = null;
		    }
		  }

		  Red.prototype._verify1 = function _verify1 (a) {
		    assert(a.negative === 0, 'red works only with positives');
		    assert(a.red, 'red works only with red numbers');
		  };

		  Red.prototype._verify2 = function _verify2 (a, b) {
		    assert((a.negative | b.negative) === 0, 'red works only with positives');
		    assert(a.red && a.red === b.red,
		      'red works only with red numbers');
		  };

		  Red.prototype.imod = function imod (a) {
		    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
		    return a.umod(this.m)._forceRed(this);
		  };

		  Red.prototype.neg = function neg (a) {
		    if (a.isZero()) {
		      return a.clone();
		    }

		    return this.m.sub(a)._forceRed(this);
		  };

		  Red.prototype.add = function add (a, b) {
		    this._verify2(a, b);

		    var res = a.add(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.iadd = function iadd (a, b) {
		    this._verify2(a, b);

		    var res = a.iadd(b);
		    if (res.cmp(this.m) >= 0) {
		      res.isub(this.m);
		    }
		    return res;
		  };

		  Red.prototype.sub = function sub (a, b) {
		    this._verify2(a, b);

		    var res = a.sub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res._forceRed(this);
		  };

		  Red.prototype.isub = function isub (a, b) {
		    this._verify2(a, b);

		    var res = a.isub(b);
		    if (res.cmpn(0) < 0) {
		      res.iadd(this.m);
		    }
		    return res;
		  };

		  Red.prototype.shl = function shl (a, num) {
		    this._verify1(a);
		    return this.imod(a.ushln(num));
		  };

		  Red.prototype.imul = function imul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.imul(b));
		  };

		  Red.prototype.mul = function mul (a, b) {
		    this._verify2(a, b);
		    return this.imod(a.mul(b));
		  };

		  Red.prototype.isqr = function isqr (a) {
		    return this.imul(a, a.clone());
		  };

		  Red.prototype.sqr = function sqr (a) {
		    return this.mul(a, a);
		  };

		  Red.prototype.sqrt = function sqrt (a) {
		    if (a.isZero()) return a.clone();

		    var mod3 = this.m.andln(3);
		    assert(mod3 % 2 === 1);

		    // Fast case
		    if (mod3 === 3) {
		      var pow = this.m.add(new BN(1)).iushrn(2);
		      return this.pow(a, pow);
		    }

		    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
		    //
		    // Find Q and S, that Q * 2 ^ S = (P - 1)
		    var q = this.m.subn(1);
		    var s = 0;
		    while (!q.isZero() && q.andln(1) === 0) {
		      s++;
		      q.iushrn(1);
		    }
		    assert(!q.isZero());

		    var one = new BN(1).toRed(this);
		    var nOne = one.redNeg();

		    // Find quadratic non-residue
		    // NOTE: Max is such because of generalized Riemann hypothesis.
		    var lpow = this.m.subn(1).iushrn(1);
		    var z = this.m.bitLength();
		    z = new BN(2 * z * z).toRed(this);

		    while (this.pow(z, lpow).cmp(nOne) !== 0) {
		      z.redIAdd(nOne);
		    }

		    var c = this.pow(z, q);
		    var r = this.pow(a, q.addn(1).iushrn(1));
		    var t = this.pow(a, q);
		    var m = s;
		    while (t.cmp(one) !== 0) {
		      var tmp = t;
		      for (var i = 0; tmp.cmp(one) !== 0; i++) {
		        tmp = tmp.redSqr();
		      }
		      assert(i < m);
		      var b = this.pow(c, new BN(1).iushln(m - i - 1));

		      r = r.redMul(b);
		      c = b.redSqr();
		      t = t.redMul(c);
		      m = i;
		    }

		    return r;
		  };

		  Red.prototype.invm = function invm (a) {
		    var inv = a._invmp(this.m);
		    if (inv.negative !== 0) {
		      inv.negative = 0;
		      return this.imod(inv).redNeg();
		    } else {
		      return this.imod(inv);
		    }
		  };

		  Red.prototype.pow = function pow (a, num) {
		    if (num.isZero()) return new BN(1).toRed(this);
		    if (num.cmpn(1) === 0) return a.clone();

		    var windowSize = 4;
		    var wnd = new Array(1 << windowSize);
		    wnd[0] = new BN(1).toRed(this);
		    wnd[1] = a;
		    for (var i = 2; i < wnd.length; i++) {
		      wnd[i] = this.mul(wnd[i - 1], a);
		    }

		    var res = wnd[0];
		    var current = 0;
		    var currentLen = 0;
		    var start = num.bitLength() % 26;
		    if (start === 0) {
		      start = 26;
		    }

		    for (i = num.length - 1; i >= 0; i--) {
		      var word = num.words[i];
		      for (var j = start - 1; j >= 0; j--) {
		        var bit = (word >> j) & 1;
		        if (res !== wnd[0]) {
		          res = this.sqr(res);
		        }

		        if (bit === 0 && current === 0) {
		          currentLen = 0;
		          continue;
		        }

		        current <<= 1;
		        current |= bit;
		        currentLen++;
		        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

		        res = this.mul(res, wnd[current]);
		        currentLen = 0;
		        current = 0;
		      }
		      start = 26;
		    }

		    return res;
		  };

		  Red.prototype.convertTo = function convertTo (num) {
		    var r = num.umod(this.m);

		    return r === num ? r.clone() : r;
		  };

		  Red.prototype.convertFrom = function convertFrom (num) {
		    var res = num.clone();
		    res.red = null;
		    return res;
		  };

		  //
		  // Montgomery method engine
		  //

		  BN.mont = function mont (num) {
		    return new Mont(num);
		  };

		  function Mont (m) {
		    Red.call(this, m);

		    this.shift = this.m.bitLength();
		    if (this.shift % 26 !== 0) {
		      this.shift += 26 - (this.shift % 26);
		    }

		    this.r = new BN(1).iushln(this.shift);
		    this.r2 = this.imod(this.r.sqr());
		    this.rinv = this.r._invmp(this.m);

		    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
		    this.minv = this.minv.umod(this.r);
		    this.minv = this.r.sub(this.minv);
		  }
		  inherits(Mont, Red);

		  Mont.prototype.convertTo = function convertTo (num) {
		    return this.imod(num.ushln(this.shift));
		  };

		  Mont.prototype.convertFrom = function convertFrom (num) {
		    var r = this.imod(num.mul(this.rinv));
		    r.red = null;
		    return r;
		  };

		  Mont.prototype.imul = function imul (a, b) {
		    if (a.isZero() || b.isZero()) {
		      a.words[0] = 0;
		      a.length = 1;
		      return a;
		    }

		    var t = a.imul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;

		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.mul = function mul (a, b) {
		    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

		    var t = a.mul(b);
		    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
		    var u = t.isub(c).iushrn(this.shift);
		    var res = u;
		    if (u.cmp(this.m) >= 0) {
		      res = u.isub(this.m);
		    } else if (u.cmpn(0) < 0) {
		      res = u.iadd(this.m);
		    }

		    return res._forceRed(this);
		  };

		  Mont.prototype.invm = function invm (a) {
		    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
		    var res = this.imod(a._invmp(this.m).mul(this.r2));
		    return res._forceRed(this);
		  };
		})(module, bn); 
	} (bn$1));
	return bn$1.exports;
}

var withPublic_1;
var hasRequiredWithPublic;

function requireWithPublic () {
	if (hasRequiredWithPublic) return withPublic_1;
	hasRequiredWithPublic = 1;
	var BN = requireBn();
	var Buffer = requireSafeBuffer$2().Buffer;

	function withPublic (paddedMsg, key) {
	  return Buffer.from(paddedMsg
	    .toRed(BN.mont(key.modulus))
	    .redPow(new BN(key.publicExponent))
	    .fromRed()
	    .toArray())
	}

	withPublic_1 = withPublic;
	return withPublic_1;
}

var publicEncrypt;
var hasRequiredPublicEncrypt;

function requirePublicEncrypt () {
	if (hasRequiredPublicEncrypt) return publicEncrypt;
	hasRequiredPublicEncrypt = 1;
	var parseKeys = requireParseAsn1();
	var randomBytes = requireBrowser$a();
	var createHash = requireBrowser$9();
	var mgf = requireMgf();
	var xor = requireXor();
	var BN = requireBn();
	var withPublic = requireWithPublic();
	var crt = requireBrowserifyRsa();
	var Buffer = requireSafeBuffer$2().Buffer;

	publicEncrypt = function publicEncrypt (publicKey, msg, reverse) {
	  var padding;
	  if (publicKey.padding) {
	    padding = publicKey.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }
	  var key = parseKeys(publicKey);
	  var paddedMsg;
	  if (padding === 4) {
	    paddedMsg = oaep(key, msg);
	  } else if (padding === 1) {
	    paddedMsg = pkcs1(key, msg, reverse);
	  } else if (padding === 3) {
	    paddedMsg = new BN(msg);
	    if (paddedMsg.cmp(key.modulus) >= 0) {
	      throw new Error('data too long for modulus')
	    }
	  } else {
	    throw new Error('unknown padding')
	  }
	  if (reverse) {
	    return crt(paddedMsg, key)
	  } else {
	    return withPublic(paddedMsg, key)
	  }
	};

	function oaep (key, msg) {
	  var k = key.modulus.byteLength();
	  var mLen = msg.length;
	  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
	  var hLen = iHash.length;
	  var hLen2 = 2 * hLen;
	  if (mLen > k - hLen2 - 2) {
	    throw new Error('message too long')
	  }
	  var ps = Buffer.alloc(k - mLen - hLen2 - 2);
	  var dblen = k - hLen - 1;
	  var seed = randomBytes(hLen);
	  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen));
	  var maskedSeed = xor(seed, mgf(maskedDb, hLen));
	  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
	}
	function pkcs1 (key, msg, reverse) {
	  var mLen = msg.length;
	  var k = key.modulus.byteLength();
	  if (mLen > k - 11) {
	    throw new Error('message too long')
	  }
	  var ps;
	  if (reverse) {
	    ps = Buffer.alloc(k - mLen - 3, 0xff);
	  } else {
	    ps = nonZero(k - mLen - 3);
	  }
	  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
	}
	function nonZero (len) {
	  var out = Buffer.allocUnsafe(len);
	  var i = 0;
	  var cache = randomBytes(len * 2);
	  var cur = 0;
	  var num;
	  while (i < len) {
	    if (cur === cache.length) {
	      cache = randomBytes(len * 2);
	      cur = 0;
	    }
	    num = cache[cur++];
	    if (num) {
	      out[i++] = num;
	    }
	  }
	  return out
	}
	return publicEncrypt;
}

var privateDecrypt;
var hasRequiredPrivateDecrypt;

function requirePrivateDecrypt () {
	if (hasRequiredPrivateDecrypt) return privateDecrypt;
	hasRequiredPrivateDecrypt = 1;
	var parseKeys = requireParseAsn1();
	var mgf = requireMgf();
	var xor = requireXor();
	var BN = requireBn();
	var crt = requireBrowserifyRsa();
	var createHash = requireBrowser$9();
	var withPublic = requireWithPublic();
	var Buffer = requireSafeBuffer$2().Buffer;

	privateDecrypt = function privateDecrypt (privateKey, enc, reverse) {
	  var padding;
	  if (privateKey.padding) {
	    padding = privateKey.padding;
	  } else if (reverse) {
	    padding = 1;
	  } else {
	    padding = 4;
	  }

	  var key = parseKeys(privateKey);
	  var k = key.modulus.byteLength();
	  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
	    throw new Error('decryption error')
	  }
	  var msg;
	  if (reverse) {
	    msg = withPublic(new BN(enc), key);
	  } else {
	    msg = crt(enc, key);
	  }
	  var zBuffer = Buffer.alloc(k - msg.length);
	  msg = Buffer.concat([zBuffer, msg], k);
	  if (padding === 4) {
	    return oaep(key, msg)
	  } else if (padding === 1) {
	    return pkcs1(key, msg, reverse)
	  } else if (padding === 3) {
	    return msg
	  } else {
	    throw new Error('unknown padding')
	  }
	};

	function oaep (key, msg) {
	  var k = key.modulus.byteLength();
	  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest();
	  var hLen = iHash.length;
	  if (msg[0] !== 0) {
	    throw new Error('decryption error')
	  }
	  var maskedSeed = msg.slice(1, hLen + 1);
	  var maskedDb = msg.slice(hLen + 1);
	  var seed = xor(maskedSeed, mgf(maskedDb, hLen));
	  var db = xor(maskedDb, mgf(seed, k - hLen - 1));
	  if (compare(iHash, db.slice(0, hLen))) {
	    throw new Error('decryption error')
	  }
	  var i = hLen;
	  while (db[i] === 0) {
	    i++;
	  }
	  if (db[i++] !== 1) {
	    throw new Error('decryption error')
	  }
	  return db.slice(i)
	}

	function pkcs1 (key, msg, reverse) {
	  var p1 = msg.slice(0, 2);
	  var i = 2;
	  var status = 0;
	  while (msg[i++] !== 0) {
	    if (i >= msg.length) {
	      status++;
	      break
	    }
	  }
	  var ps = msg.slice(2, i - 1);

	  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
	    status++;
	  }
	  if (ps.length < 8) {
	    status++;
	  }
	  if (status) {
	    throw new Error('decryption error')
	  }
	  return msg.slice(i)
	}
	function compare (a, b) {
	  a = Buffer.from(a);
	  b = Buffer.from(b);
	  var dif = 0;
	  var len = a.length;
	  if (a.length !== b.length) {
	    dif++;
	    len = Math.min(a.length, b.length);
	  }
	  var i = -1;
	  while (++i < len) {
	    dif += (a[i] ^ b[i]);
	  }
	  return dif
	}
	return privateDecrypt;
}

var hasRequiredBrowser$1;

function requireBrowser$1 () {
	if (hasRequiredBrowser$1) return browser$1;
	hasRequiredBrowser$1 = 1;
	(function (exports) {
		exports.publicEncrypt = requirePublicEncrypt();
		exports.privateDecrypt = requirePrivateDecrypt();

		exports.privateEncrypt = function privateEncrypt (key, buf) {
		  return exports.publicEncrypt(key, buf, true)
		};

		exports.publicDecrypt = function publicDecrypt (key, buf) {
		  return exports.privateDecrypt(key, buf, true)
		}; 
	} (browser$1));
	return browser$1;
}

var browser = {};

var hasRequiredBrowser;

function requireBrowser () {
	if (hasRequiredBrowser) return browser;
	hasRequiredBrowser = 1;

	function oldBrowser () {
	  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
	}
	var safeBuffer = requireSafeBuffer$2();
	var randombytes = requireBrowser$a();
	var Buffer = safeBuffer.Buffer;
	var kBufferMaxLength = safeBuffer.kMaxLength;
	var crypto = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
	var kMaxUint32 = Math.pow(2, 32) - 1;
	function assertOffset (offset, length) {
	  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
	    throw new TypeError('offset must be a number')
	  }

	  if (offset > kMaxUint32 || offset < 0) {
	    throw new TypeError('offset must be a uint32')
	  }

	  if (offset > kBufferMaxLength || offset > length) {
	    throw new RangeError('offset out of range')
	  }
	}

	function assertSize (size, offset, length) {
	  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
	    throw new TypeError('size must be a number')
	  }

	  if (size > kMaxUint32 || size < 0) {
	    throw new TypeError('size must be a uint32')
	  }

	  if (size + offset > length || size > kBufferMaxLength) {
	    throw new RangeError('buffer too small')
	  }
	}
	if ((crypto && crypto.getRandomValues) || !process$1.browser) {
	  browser.randomFill = randomFill;
	  browser.randomFillSync = randomFillSync;
	} else {
	  browser.randomFill = oldBrowser;
	  browser.randomFillSync = oldBrowser;
	}
	function randomFill (buf, offset, size, cb) {
	  if (!Buffer.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
	    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
	  }

	  if (typeof offset === 'function') {
	    cb = offset;
	    offset = 0;
	    size = buf.length;
	  } else if (typeof size === 'function') {
	    cb = size;
	    size = buf.length - offset;
	  } else if (typeof cb !== 'function') {
	    throw new TypeError('"cb" argument must be a function')
	  }
	  assertOffset(offset, buf.length);
	  assertSize(size, offset, buf.length);
	  return actualFill(buf, offset, size, cb)
	}

	function actualFill (buf, offset, size, cb) {
	  if (process$1.browser) {
	    var ourBuf = buf.buffer;
	    var uint = new Uint8Array(ourBuf, offset, size);
	    crypto.getRandomValues(uint);
	    if (cb) {
	      process$1.nextTick(function () {
	        cb(null, buf);
	      });
	      return
	    }
	    return buf
	  }
	  if (cb) {
	    randombytes(size, function (err, bytes) {
	      if (err) {
	        return cb(err)
	      }
	      bytes.copy(buf, offset);
	      cb(null, buf);
	    });
	    return
	  }
	  var bytes = randombytes(size);
	  bytes.copy(buf, offset);
	  return buf
	}
	function randomFillSync (buf, offset, size) {
	  if (typeof offset === 'undefined') {
	    offset = 0;
	  }
	  if (!Buffer.isBuffer(buf) && !(buf instanceof commonjsGlobal.Uint8Array)) {
	    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
	  }

	  assertOffset(offset, buf.length);

	  if (size === undefined) size = buf.length - offset;

	  assertSize(size, offset, buf.length);

	  return actualFill(buf, offset, size)
	}
	return browser;
}

var hasRequiredCryptoBrowserify;

function requireCryptoBrowserify () {
	if (hasRequiredCryptoBrowserify) return cryptoBrowserify;
	hasRequiredCryptoBrowserify = 1;

	cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$a();
	cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9();
	cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();

	var algos = requireAlgos();
	var algoKeys = Object.keys(algos);
	var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys);
	cryptoBrowserify.getHashes = function () {
	  return hashes
	};

	var p = requireBrowser$7();
	cryptoBrowserify.pbkdf2 = p.pbkdf2;
	cryptoBrowserify.pbkdf2Sync = p.pbkdf2Sync;

	var aes = requireBrowser$5();

	cryptoBrowserify.Cipher = aes.Cipher;
	cryptoBrowserify.createCipher = aes.createCipher;
	cryptoBrowserify.Cipheriv = aes.Cipheriv;
	cryptoBrowserify.createCipheriv = aes.createCipheriv;
	cryptoBrowserify.Decipher = aes.Decipher;
	cryptoBrowserify.createDecipher = aes.createDecipher;
	cryptoBrowserify.Decipheriv = aes.Decipheriv;
	cryptoBrowserify.createDecipheriv = aes.createDecipheriv;
	cryptoBrowserify.getCiphers = aes.getCiphers;
	cryptoBrowserify.listCiphers = aes.listCiphers;

	var dh = requireBrowser$4();

	cryptoBrowserify.DiffieHellmanGroup = dh.DiffieHellmanGroup;
	cryptoBrowserify.createDiffieHellmanGroup = dh.createDiffieHellmanGroup;
	cryptoBrowserify.getDiffieHellman = dh.getDiffieHellman;
	cryptoBrowserify.createDiffieHellman = dh.createDiffieHellman;
	cryptoBrowserify.DiffieHellman = dh.DiffieHellman;

	var sign = requireBrowser$3();

	cryptoBrowserify.createSign = sign.createSign;
	cryptoBrowserify.Sign = sign.Sign;
	cryptoBrowserify.createVerify = sign.createVerify;
	cryptoBrowserify.Verify = sign.Verify;

	cryptoBrowserify.createECDH = requireBrowser$2();

	var publicEncrypt = requireBrowser$1();

	cryptoBrowserify.publicEncrypt = publicEncrypt.publicEncrypt;
	cryptoBrowserify.privateEncrypt = publicEncrypt.privateEncrypt;
	cryptoBrowserify.publicDecrypt = publicEncrypt.publicDecrypt;
	cryptoBrowserify.privateDecrypt = publicEncrypt.privateDecrypt;

	// the least I can do is make error messages for the rest of the node.js/crypto api.
	// ;[
	//   'createCredentials'
	// ].forEach(function (name) {
	//   exports[name] = function () {
	//     throw new Error([
	//       'sorry, ' + name + ' is not implemented yet',
	//       'we accept pull requests',
	//       'https://github.com/crypto-browserify/crypto-browserify'
	//     ].join('\n'))
	//   }
	// })

	var rf = requireBrowser();

	cryptoBrowserify.randomFill = rf.randomFill;
	cryptoBrowserify.randomFillSync = rf.randomFillSync;

	cryptoBrowserify.createCredentials = function () {
	  throw new Error([
	    'sorry, createCredentials is not implemented yet',
	    'we accept pull requests',
	    'https://github.com/crypto-browserify/crypto-browserify'
	  ].join('\n'))
	};

	cryptoBrowserify.constants = {
	  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
	  'DH_CHECK_P_NOT_PRIME': 1,
	  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
	  'DH_NOT_SUITABLE_GENERATOR': 8,
	  'NPN_ENABLED': 1,
	  'ALPN_ENABLED': 1,
	  'RSA_PKCS1_PADDING': 1,
	  'RSA_SSLV23_PADDING': 2,
	  'RSA_NO_PADDING': 3,
	  'RSA_PKCS1_OAEP_PADDING': 4,
	  'RSA_X931_PADDING': 5,
	  'RSA_PKCS1_PSS_PADDING': 6,
	  'POINT_CONVERSION_COMPRESSED': 2,
	  'POINT_CONVERSION_UNCOMPRESSED': 4,
	  'POINT_CONVERSION_HYBRID': 6
	};
	return cryptoBrowserify;
}

var cryptoBrowserifyExports = requireCryptoBrowserify();

const crypto = typeof self !== "undefined" ? self.crypto : cryptoBrowserifyExports.webcrypto;
const ITER_V1 = 19162;
const ITER_V2 = 210012;
const SALT_SIZE = 32;
const NONCE_SIZE = 12;
const KEY_SIZE = 32;
const TAG_SIZE = 16;
const METADATA_SIZE = SALT_SIZE + NONCE_SIZE + TAG_SIZE;
const SALT_START = 0;
const SALT_END = SALT_START + SALT_SIZE;
const NONCE_START = SALT_END;
const NONCE_END = NONCE_START + NONCE_SIZE;
const TAG_START = NONCE_END;
const TAG_END = TAG_START + TAG_SIZE;
const ENCRYPTED_START = TAG_END;
const aad = new Uint8Array(0);
toHexBuffer("01");
const getRandomValues = (array) => {
  crypto.getRandomValues(array);
  return array;
};
const getRandomUUID = () => {
  return crypto.randomUUID();
};
const encryptText = (plainContent, password) => {
  const passwordU8 = Uint8Array.from(Buffer$1.from(password, "utf-8"));
  const plainContentU8 = new TextEncoder().encode(plainContent);
  const saltU8 = getRandomValues(new Uint8Array(SALT_SIZE));
  const nonceU8 = getRandomValues(new Uint8Array(NONCE_SIZE));
  return encrypt_with_password(passwordU8, saltU8, nonceU8, plainContentU8);
};
const decryptText = (encryptedContent, password, version = "2") => {
  const passwordU8 = Uint8Array.from(Buffer$1.from(password, "utf-8"));
  const encrContentU8 = toHexArray(encryptedContent);
  let content = "";
  if (version === "2") {
    try {
      content = decrypt_with_password(passwordU8, encrContentU8, ITER_V2);
      if ((content?.length ?? 0) > 0) {
        return content;
      }
    } catch (e) {
      content = "";
    }
  }
  try {
    content = decrypt_with_password(passwordU8, encrContentU8, ITER_V1);
    if ((content?.length ?? 0) > 0) {
      return content;
    }
  } catch (e) {
    content = "";
  }
  return content;
};
const encrypt_with_password = (passwordU8, saltU8, nonceU8, dataU8) => {
  if (saltU8.length != SALT_SIZE) {
    throw new Error("Error: encrypt_with_password: invalid salt length");
  }
  if (nonceU8.length != NONCE_SIZE) {
    throw new Error("Error: encrypt_with_password: invalid nonce length");
  }
  if (passwordU8.length === 0) {
    throw new Error("Error: encrypt_with_password: invalid password length");
  }
  const key = deriveKey(SHA512, passwordU8, saltU8, ITER_V2, KEY_SIZE);
  const cha = new ChaCha20Poly1305(key);
  const tmp = cha.seal(nonceU8, dataU8, aad);
  const encrData = tmp.subarray(0, tmp.length - TAG_SIZE);
  const tag = tmp.subarray(tmp.length - TAG_SIZE);
  const res = new Uint8Array(encrData.length + METADATA_SIZE);
  res.set(saltU8, SALT_START);
  res.set(nonceU8, NONCE_START);
  res.set(tag, TAG_START);
  res.set(encrData, ENCRYPTED_START);
  return Buffer$1.from(res).toString("hex");
};
const decrypt_with_password = (passwordU8, dataU8, iterations) => {
  if (dataU8.length < METADATA_SIZE) {
    throw new Error("Error: decrypt_with_password: invalid input length: " + dataU8.length);
  }
  const saltU8 = dataU8.subarray(SALT_START, SALT_END);
  const nonceU8 = dataU8.subarray(NONCE_START, NONCE_END);
  const tagU8 = dataU8.subarray(TAG_START, TAG_END);
  const encrDataU8 = dataU8.subarray(ENCRYPTED_START);
  const key = deriveKey(SHA512, passwordU8, saltU8, iterations, KEY_SIZE);
  const cha = new ChaCha20Poly1305(key);
  const tmp = new Uint8Array(encrDataU8.length + TAG_SIZE);
  tmp.set(encrDataU8, 0);
  tmp.set(tagU8, encrDataU8.length);
  const res = cha.open(nonceU8, tmp, aad);
  if (res) {
    return uint8ArrayToUtf8String(res);
  }
  throw new Error("Error: decrypt_with_password: decryption failed");
};

const purpose = {
  hdwallet: 1852,
  multisig: 1854,
  minting: 1855};
const coin = {
  ada: 1815
};
const chain = {
  payment: 0,
  stake: 2,
  drep: 3};

const ErrorSignData = {
  missingRequest: "ErrorSignData.missingRequest",
  missingAddr: "ErrorSignData.missingAddr",
  missingPayload: "ErrorSignData.missingPayload",
  missingAccountData: "ErrorSignData.missingAccountData",
  missingWalletData: "ErrorSignData.missingWalletData",
  failedToSign: "ErrorSignData.failedToSign",
  notAMnemonic: "ErrorSignData.notAMnemonic",
  invalidKey: "ErrorSignData.invalidKey",
  invalidSignature: "ErrorSignData.invalidSignature",
  invalidPayload: "ErrorSignData.invalidPayload",
  invalidPassword: "ErrorSignData.invalidPassword",
  invalidAddress: "ErrorSignData.invalidAddress",
  noDataToSubmit: "ErrorSignData.noDataToSubmit",
  credentialNotFound: "ErrorSignData.credentialNotFound",
  unsupportedWalletType: "ErrorSignData.unsupportedWalletType",
  deviceNotFound: "ErrorSignData.deviceNotFound"
};

const getOwnedCred = (credList, cred, type) => {
  if (!cred || !credList) return null;
  let key;
  for (const creds of credList) {
    switch (type) {
      case "payment":
        key = creds.payment.find((item) => item.cred === cred);
        if (key) return key;
        break;
      case "change":
        key = creds.change.find((item) => item.cred === cred);
        if (key) return key;
        break;
      case "stake":
        key = creds.stake.find((item) => item.cred === cred);
        if (key) return key;
        break;
      case "drep":
        key = creds.drep.find((item) => item.cred === cred);
        if (key) return key;
        break;
      case "cc_cold":
        key = creds.cc_cold.find((item) => item.cred === cred);
        if (key) return key;
        break;
      case "cc_hot":
        key = creds.cc_hot.find((item) => item.cred === cred);
        if (key) return key;
        break;
      default:
        key = creds.payment.find((item) => item.cred === cred);
        if (key) return key;
        key = creds.change.find((item) => item.cred === cred);
        if (key) return key;
        key = creds.stake.find((item) => item.cred === cred);
        if (key) return key;
        key = creds.drep.find((item) => item.cred === cred);
        if (key) return key;
        key = creds.cc_cold.find((item) => item.cred === cred);
        if (key) return key;
        key = creds.cc_hot.find((item) => item.cred === cred);
        if (key) return key;
    }
  }
  return null;
};
const getOwnedCredAndType = (credList, cred, type) => {
  if (!cred || !credList) {
    return { cred: null, type: null };
  }
  let key;
  for (const creds of credList) {
    switch (type) {
      case "payment":
        key = creds.payment.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "payment" };
        break;
      case "change":
        key = creds.change.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "change" };
        break;
      case "stake":
        key = creds.stake.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "stake" };
        break;
      case "drep":
        key = creds.drep.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "drep" };
        break;
      case "cc_cold":
        key = creds.cc_cold.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "cc_cold" };
        break;
      case "cc_hot":
        key = creds.cc_hot.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "cc_hot" };
        break;
      default:
        key = creds.payment.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "payment" };
        key = creds.change.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "change" };
        key = creds.stake.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "stake" };
        key = creds.drep.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "drep" };
        key = creds.cc_cold.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "cc_cold" };
        key = creds.cc_hot.find((item) => item.cred === cred);
        if (key) return { cred: key, type: "cc_hot" };
    }
  }
  return { cred: null, type: null };
};
const getAddressKey = (credList, paymentCred, stakeCred) => {
  let paymentKey = null;
  let changeKey = null;
  let stakeKey = null;
  if (paymentCred) {
    paymentKey = getOwnedCred(credList, paymentCred, "payment");
    if (!paymentKey) {
      changeKey = getOwnedCred(credList, paymentCred, "change");
    }
  }
  if (stakeCred) {
    stakeKey = getOwnedCred(credList, stakeCred, "stake");
  }
  return { paymentKey, changeKey, stakeKey };
};
const getAddressDetails = (keys, addrBech32) => {
  const { paymentCred, stakeCred, stakePointer } = getAddressCredentials(addrBech32);
  const { paymentKey, changeKey, stakeKey } = getAddressKey(keys, paymentCred, stakeCred);
  return { paymentCred, stakeCred, stakePointer, paymentKey, changeKey, stakeKey };
};
const isOwnedPaymentAddress = (keys, addrBech32) => {
  const addrDetails = getAddressDetails(keys, addrBech32);
  return !!addrDetails.paymentKey || !!addrDetails.changeKey;
};
const getAllUsedAddresses = (accountData) => {
  const list = [];
  const stakeCred = accountData.keys.stake.length > 0 ? accountData.keys.stake[0].cred : null;
  const networkId = accountData.state.networkId;
  const isPayScript = !!accountData.account.paymentScript;
  const isStakeScript = !!accountData.account.stakeScript;
  if (stakeCred) {
    for (const key of accountData.keys.payment) {
      if (key.used) {
        list.push(getBaseAddressFromCred(key.cred, stakeCred, networkId, isPayScript, isStakeScript));
      }
    }
    for (const key of accountData.keys.change) {
      if (key.used) {
        list.push(getBaseAddressFromCred(key.cred, stakeCred, networkId, isPayScript, isStakeScript));
      }
    }
  }
  for (const key of accountData.keys.payment) {
    if (key.used) {
      list.push(getEnterpriseAddressFromCred(key.cred, networkId, isPayScript));
    }
  }
  for (const key of accountData.keys.change) {
    if (key.used) {
      list.push(getEnterpriseAddressFromCred(key.cred, networkId, isPayScript));
    }
  }
  return list;
};
const generatePlateHex = (accPubBech32) => {
  const cslPubKey = getCSLBip32PublicKey(accPubBech32);
  const hex = toHexString(cslPubKey.as_bytes());
  safeFreeCSLObject(cslPubKey);
  return hex;
};
const getAccountKeyDetails = (inputStr, accountData) => {
  if (!inputStr) {
    throw ErrorSignData.missingAddr;
  }
  if (!accountData) {
    throw ErrorSignData.missingAccountData;
  }
  const networkId = accountData.state.networkId;
  const isHex = isHexString(inputStr);
  const isPayScript = !!accountData.account.paymentScript;
  const isStakeScript = !!accountData.account.stakeScript;
  let inputStrHex = null;
  let displayStr = "";
  let displayType = "";
  if (isHex) {
    inputStrHex = inputStr;
  } else {
    try {
      inputStrHex = decodeBech32(inputStr);
      displayStr = inputStr;
    } catch (err) {
      console.error("getAccountKeyDetails: decodeBech32:", err);
      throw ErrorSignData.invalidAddress;
    }
  }
  if (!inputStrHex) {
    console.error("getAccountKeyDetails: invalid input", inputStr, isHex, networkId, accountData);
    throw ErrorSignData.invalidAddress;
  }
  const addressCreds = getAddressCredentials(inputStrHex, null, true);
  let accountCredAndType = getOwnedCredAndType([accountData.keys], addressCreds.paymentCred ?? addressCreds.stakeCred ?? inputStrHex);
  if (!accountCredAndType.type || !accountCredAndType.cred) {
    if (inputStrHex.length === 58) {
      const prefixBytes = inputStrHex.slice(0, 2).toLowerCase();
      inputStrHex = inputStrHex.slice(2);
      accountCredAndType = getOwnedCredAndType([accountData.keys], inputStrHex);
      if (!accountCredAndType.type || !accountCredAndType.cred) {
        console.error("getAccountKeyDetails: no account key", inputStr, isHex, networkId, accountData);
        throw ErrorSignData.credentialNotFound;
      }
      if (prefixBytes === "a1") {
        accountCredAndType.type = "calidus";
      }
    } else {
      console.error("getAccountKeyDetails: no account key", inputStr, isHex, networkId, accountData);
      throw ErrorSignData.credentialNotFound;
    }
  }
  displayType = accountCredAndType.type;
  let credBytes = null;
  if (accountCredAndType.type === "payment" || accountCredAndType.type === "change" || accountCredAndType.type === "stake" || accountCredAndType.type === "script") {
    if (addressCreds.paymentCred && !addressCreds.stakeCred) {
      displayStr = getEnterpriseAddressFromCred(addressCreds.paymentCred, networkId, isPayScript);
      const res = getAddressCredentials(displayStr, null, true);
      credBytes = res.addressBytes;
    } else if (addressCreds.paymentCred && addressCreds.stakeCred) {
      displayStr = getBaseAddressFromCred(addressCreds.paymentCred, addressCreds.stakeCred, networkId, isPayScript, isStakeScript);
      const res = getAddressCredentials(displayStr, null, true);
      credBytes = res.addressBytes;
    } else if (addressCreds.stakeCred) {
      displayStr = getRewardAddressFromCred(addressCreds.stakeCred, networkId, isStakeScript);
      const res = getAddressCredentials(displayStr, null, true);
      credBytes = res.addressBytes;
    }
  } else if (accountCredAndType.type === "drep") {
    displayStr = getDRepAddressFromKeyHash(accountCredAndType.cred.cred, false);
    credBytes = toHexArray(accountCredAndType.cred.cred);
  } else if (accountCredAndType.type === "cc_cold") {
    displayStr = getCCColdAddressFromKeyHash(accountCredAndType.cred.cred);
    credBytes = toHexArray(accountCredAndType.cred.cred);
  } else if (accountCredAndType.type === "cc_hot") {
    displayStr = getCCHotAddressFromKeyHash(accountCredAndType.cred.cred, false);
    credBytes = toHexArray(accountCredAndType.cred.cred);
  } else if (accountCredAndType.type === "calidus") {
    displayStr = getCalidusAddressFromKeyHash(accountCredAndType.cred.cred);
    credBytes = toHexArray(accountCredAndType.cred.cred);
  }
  const _accountCredAndType = accountCredAndType;
  return {
    displayStr,
    displayType,
    accountCredAndType: _accountCredAndType,
    credBytes,
    addrPaymentCred: addressCreds.paymentCred,
    addrStakeCred: addressCreds.stakeCred
  };
};

const getBurnAddress = (networkId) => {
  return networkId === "mainnet" ? "addr1qxnk9w6e3azattu87ythnnjt2vmtlskzcld0ptwa924j0znz7v4zyqfqapmueh24l2r8v848mya68nndvjy783m656kq0cxjsn" : "";
};
const getDonationAddress = (networkId) => {
  return networkId === "mainnet" ? "addr1qyshp5yzn2d8wx8terhgp8fv9j9jjvsrht5qtfm4mrpxnu7cptrxtucjkdrhl5tw6x2ke4c7wlf424w84rq3sn9x8y5sw0ez6c" : "addr_test1qqshp5yzn2d8wx8terhgp8fv9j9jjvsrht5qtfm4mrpxnu7cptrxtucjkdrhl5tw6x2ke4c7wlf424w84rq3sn9x8y5sdeyzk8";
};
const getFeeAddress = (networkId) => {
  return networkId === "mainnet" ? "addr1qxs76zpnfyq5w0xrpjwrkkghch0ew024j83hx0dg00f9xjrx828mrjy00s2sd8awhvummze55m8hq4fqghdzqlcaqwlshwkm0m" : "addr_test1qz6yg3ljtavm7gegp55lm65h7n35rc9u682q0n5q4rc3ahs7eqynq9vqsn44cu6lmxlmrmznhz6sq8zt88fjcyttfyssvvdmgu";
};
const getSwapFeeAddressMS = (networkId) => {
  return networkId === "mainnet" ? "addr1qycewgm43uc96vt3qjp434mqp4jfzttws0xjwqz4a364qu95mx98r9d2mpx5ka4xe5npakhrz2qz4n2tqzgvyngrkedqn3hctc" : "addr_test1qqcewgm43uc96vt3qjp434mqp4jfzttws0xjwqz4a364qu95mx98r9d2mpx5ka4xe5npakhrz2qz4n2tqzgvyngrkedqs82c88";
};
const getSwapFeeAddressDH = (networkId) => {
  return networkId === "mainnet" ? ["addr1q8l7hny7x96fadvq8cukyqkcfca5xmkrvfrrkt7hp76v3qvssm7fz9ajmtd58ksljgkyvqu6gl23hlcfgv7um5v0rn8qtnzlfk"] : [];
};
const getSwapFeeAddressSS = (networkId) => {
  return networkId === "mainnet" ? ["addr1q9w4rju5zsmwp70v0evwzlxkzc0krc80vxyeuwfuxe9fvclkwymls3p25f9f9quvhtchu7jlfzrx6z3pylvpapcq0qmsc9v6e7"] : [];
};
const getEternlCollateralAddress = (networkId) => {
  return networkId === "mainnet" ? "addr1v87c4cxxcvhk04ht2587t0fg4hz27s9xa58l6jl6nt7yp5gqznwnh" : "";
};
function getAddressType(addrBech32) {
  const addrBytes = getAddressBytes(addrBech32);
  if (!addrBytes) {
    throw new Error('Could not parse address "' + addrBech32 + '".');
  }
  return (addrBytes[0] & 240) >> 4;
}
const isScriptAddress = (addrBech32) => {
  let type = null;
  try {
    type = getAddressType(addrBech32);
  } catch (error) {
    return false;
  }
  switch (type) {
    case 2 /* BASE_PAYMENT_KEY_STAKE_SCRIPT */:
    case 1 /* BASE_PAYMENT_SCRIPT_STAKE_KEY */:
    case 3 /* BASE_PAYMENT_SCRIPT_STAKE_SCRIPT */:
    case 5 /* POINTER_SCRIPT */:
    case 7 /* ENTERPRISE_SCRIPT */:
    case 15 /* REWARD_SCRIPT */:
      return true;
  }
  return false;
};
const isScriptPaymentAddress = (addrBech32) => {
  let type = null;
  try {
    type = getAddressType(addrBech32);
  } catch (error) {
    console.warn("Could not determine address type.", error);
    return false;
  }
  switch (type) {
    case 1 /* BASE_PAYMENT_SCRIPT_STAKE_KEY */:
    case 3 /* BASE_PAYMENT_SCRIPT_STAKE_SCRIPT */:
    case 7 /* ENTERPRISE_SCRIPT */:
      return true;
  }
  return false;
};
const isScriptStakeAddress = (addrBech32) => {
  let type = null;
  try {
    type = getAddressType(addrBech32);
  } catch (error) {
    console.warn("Could not determine address type.", error);
    return false;
  }
  switch (type) {
    case 2 /* BASE_PAYMENT_KEY_STAKE_SCRIPT */:
    case 3 /* BASE_PAYMENT_SCRIPT_STAKE_SCRIPT */:
    case 15 /* REWARD_SCRIPT */:
      return true;
  }
  return false;
};

const getTransactionOutputSize = (output) => {
  let hasAddress = (output.address?.length ?? 0) > 0;
  if (!output.address) {
    output.address = getFeeAddress("mainnet");
  }
  let csl;
  try {
    csl = getTransactionOutputFromJSON(output);
  } catch (err) {
  }
  if (!hasAddress) {
    output.address = "";
  }
  const size = csl?.to_bytes().byteLength ?? 0;
  safeFreeCSLObject(csl);
  return size;
};
const getBalanceCbor = (balance) => {
  const cslValue = getValueFromJSON(balance);
  const cbor = toHexString(cslValue.to_bytes());
  safeFreeCSLObject(cslValue);
  return cbor;
};
const getUtxoCborList = (utxoList) => {
  const list = [];
  for (const utxo of utxoList) {
    const cslTxHash = TransactionHash.from_hex(utxo.input.transaction_id);
    const cslInput = TransactionInput.new(cslTxHash, utxo.input.index);
    const cslOutput = getTransactionOutputFromJSON(utxo.output);
    const cslUtxo = TransactionUnspentOutput.new(cslInput, cslOutput);
    list.push(toHexString(cslUtxo.to_bytes()));
    safeFreeCSLObject(cslUtxo);
  }
  return list;
};
const getValueJSONFromCbor = (cbor) => {
  const cslValue = Value.from_hex(cbor);
  const json = getValueJSONFromCSL(cslValue);
  safeFreeCSLObject(cslValue);
  return json;
};

const isNumber = (n) => Number(n) === n;

const createIEpochParameterStore = (networkId) => {
  return {
    networkId,
    network: networkId,
    epochNo: 0,
    totals: createITotals(),
    isAtLeastBabbageEra: false,
    isAtLeastConwayEra: false,
    isAtLeastConwayEra2: false,
    txFeePerByte: 0,
    minUTxOValue: 0,
    stakePoolDeposit: 0,
    utxoCostPerSize: 0,
    utxoCostPerWord: 0,
    decentralization: 0,
    poolRetireMaxEpoch: 0,
    extraPraosEntropy: null,
    collateralPercentage: 0,
    stakePoolTargetNum: 0,
    maxBlockBodySize: 0,
    maxTxSize: 0,
    treasuryCut: 0,
    minPoolCost: 0,
    maxCollateralInputs: 0,
    maxValueSize: 0,
    maxBlockExecutionUnits: {
      memory: 0,
      steps: 0
    },
    maxBlockHeaderSize: 0,
    costModels: {},
    maxTxExecutionUnits: {
      memory: 0,
      steps: 0
    },
    protocolVersion: {
      minor: 0,
      major: 0
    },
    txFeeFixed: 0,
    stakeAddressDeposit: 0,
    monetaryExpansion: 0,
    poolPledgeInfluence: 0,
    executionUnitPrices: {
      memory: 0,
      steps: 0
    },
    costModelId: 0,
    nonce: "",
    pvt: {
      motionNoConfidence: 0,
      committeeNormal: 0,
      committeeNoConfidence: 0,
      hardForkInitiation: 0,
      PPSecurityGroup: 0
    },
    dvt: {
      motionNoConfidence: 0,
      committeeNormal: 0,
      committeeNoConfidence: 0,
      hardForkInitiation: 0,
      updateToConstitution: 0,
      PPNetworkGroup: 0,
      PPEconomicGroup: 0,
      PPTechnicalGroup: 0,
      PPGovGroup: 0,
      TreasuryWithdrawal: 0
    },
    committee: {
      minSize: 0,
      maxTermLength: 0
    },
    govAction: {
      lifeTime: 0,
      deposit: 0
    },
    drep: {
      deposit: 0,
      activity: 0
    }
  };
};
const createITotals = () => {
  return {
    circulation: "0",
    treasury: "0",
    rewards: "0",
    supply: "0",
    reserves: "0",
    reservesDepletion: "0",
    blockLossFactor: 1
  };
};

const ErrorSync = {
  loadUtxoCborList: "ErrorSync.loadUtxoCborList",
  loadUtxoCborFromTxList: "ErrorSync.loadUtxoCborFromTxList",
  loadUtxoCborFromUtxoHashes: "ErrorSync.loadUtxoCborFromUtxoHashes",
  loadUtxoByronList: "ErrorSync.loadUtxoByronList",
  loadStakeInfo: "ErrorSync.loadStakeInfo",
  loadTxCborList: "ErrorSync.loadTxCborList",
  loadTxByronList: "ErrorSync.loadTxByronList",
  loadTxHashList: "ErrorSync.loadTxHashList",
  loadTxHashCount: "ErrorSync.loadTxHashCount",
  loadTxHashCountChunk: "ErrorSync.loadTxHashCountChunk",
  hasTxHash: "ErrorSync.hasTxHash",
  hasTxHashes: "ErrorSync.hasTxHashes",
  syncSchedulerLedger: "ErrorSync.syncSchedulerLedger",
  syncAccountFinish: "ErrorSync.syncAccountFinish",
  runSyncAccount: "ErrorSync.runSyncAccount",
  syncAccountLedgerState: "ErrorSync.syncAccountLedgerState",
  syncAccountLedgerState2: "ErrorSync.syncAccountLedgerState2",
  syncAccountTxHashList: "ErrorSync.syncAccountTxHashList",
  syncAccountTxHashList2: "ErrorSync.syncAccountTxHashList2",
  syncChainTip: "ErrorSync.syncChainTip",
  syncEpochParams: "ErrorSync.syncEpochParams",
  getGovDRepInfo: "ErrorSync.getGovDRepInfo"};

const getRestURL = () => {
  const apiURL = new URL(getApiURL());
  return apiURL.protocol + "//" + apiURL.hostname + (apiURL.port ? ":" + apiURL.port : "");
};

var ApiRequestType = /* @__PURE__ */ ((ApiRequestType2) => {
  ApiRequestType2["syncChainTip"] = "/v2/chain/tip";
  ApiRequestType2["syncEpochParams"] = "/v2/chain/epochparams";
  ApiRequestType2["hasTxHashes"] = "/v2/account/has/tx/hashes";
  ApiRequestType2["syncUtxoCbor"] = "/v2/account/sync/utxo/cbor";
  ApiRequestType2["syncUtxoCborFromTx"] = "/v2/account/sync/utxo/cborfromtx";
  ApiRequestType2["syncUtxoCborFromUtxoHashes"] = "/v2/account/sync/utxo/cborfromutxohashes";
  ApiRequestType2["syncUtxoDetails"] = "/v2/account/sync/utxo/details";
  ApiRequestType2["syncUtxoByron"] = "/v2/account/sync/utxo/byron";
  ApiRequestType2["syncUtxoByronByAddress"] = "/v2/account/sync/utxo/byronbyaddress";
  ApiRequestType2["syncTxCbor"] = "/v2/account/sync/tx/cbor";
  ApiRequestType2["syncTxCborExt"] = "/v2/account/sync/tx/cbor/ext";
  ApiRequestType2["syncTxCount"] = "/v2/account/sync/tx/count";
  ApiRequestType2["syncTxHashes"] = "/v2/account/sync/tx/hashes";
  ApiRequestType2["syncCredUsed"] = "/v2/account/sync/cred/used";
  ApiRequestType2["syncTxByron"] = "/v2/account/sync/tx/byron";
  ApiRequestType2["syncStakeInfo"] = "/v2/account/sync/stake/info";
  ApiRequestType2["syncRewardCount"] = "/v2/account/sync/stake/rewardcount";
  ApiRequestType2["syncAccountReport"] = "/v2/account/sync/report";
  ApiRequestType2["syncBalance"] = "/v2/account/sync/balance";
  ApiRequestType2["syncMultiSig"] = "/v2/wallet/sync/multisig";
  ApiRequestType2["syncMultiSigMeta"] = "/v2/wallet/sync/multisig/meta";
  ApiRequestType2["syncMultiSigCredUsed"] = "/v2/wallet/sync/multisig/cred";
  ApiRequestType2["checkSwapConfirmed"] = "/v2/swap/confirmed";
  ApiRequestType2["swapAggEnabled"] = "/v2/swap/aggenabled";
  ApiRequestType2["swapProviders"] = "/v2/swap/providers";
  ApiRequestType2["swapDH"] = "/v2/swap/dh";
  ApiRequestType2["getGovDRepInfo"] = "/v2/gov/drep";
  ApiRequestType2["getGovDRepList"] = "/v2/gov/drep/list";
  ApiRequestType2["getGovProposalList"] = "/v2/gov/proposal/list";
  ApiRequestType2["getFiatProviders"] = "/v2/fiat/providers";
  ApiRequestType2["resolveUnstoppableDomain"] = "/v2/unstoppabledomain/resolve";
  return ApiRequestType2;
})(ApiRequestType || {});

const createIApiMessage = (ref) => {
  const msg = { type: ref.type };
  if (ref.networkId) {
    msg.networkId = ref.networkId;
  }
  if (ref.content) {
    msg.content = ref.content;
  }
  if (ref.reqId) {
    msg.reqId = ref.reqId;
  }
  return msg;
};

const requestData = (networkId, accountId, type, _error, postData, handleResponse, doRetry = true) => {
  const timerStart = now();
  const _reqId = getShortId();
  return new Promise(async (resolve, reject) => {
    let toidAbort = -1;
    let toidTimeout = -1;
    const _onError = (err) => {
      clearTimeout(toidAbort);
      clearTimeout(toidTimeout);
      if (typeof err !== "string") {
        err = err?.message ?? "unknownError";
      }
      error("Error: " + el(_reqId, 10) + ": onError (" + (now() - timerStart) + "ms)", accountId, err);
      return reject(_error + ":" + err + ":" + _reqId);
    };
    let onError = _onError;
    const doRequest = async (attempt = 0) => {
      if (doRetry && attempt === 0) {
        onError = () => doRequest(1);
      } else {
        onError = _onError;
      }
      clearTimeout(toidAbort);
      clearTimeout(toidTimeout);
      const msg = createIApiMessage({ type, networkId, content: postData, reqId: _reqId });
      const timeout = DEFAULT_WS_TIMEOUT_MS;
      const abortController = new AbortController();
      toidAbort = setTimeout(() => {
        abortController.abort("abort");
      }, timeout + 25);
      toidTimeout = setTimeout(() => {
        onError("timeout");
      }, timeout + 50);
      let data;
      try {
        const url = getRestURL() + "/" + networkId + "/v2/api";
        let isText = false;
        data = await fetch(url, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(msg),
          signal: abortController.signal
        }).then((res) => res.clone().json().catch(() => {
          isText = true;
          return res.text();
        }));
        if (isText) {
          console.error("rest", url, "---", data, "---");
          data = JSON.parse(data);
        }
        await gotResult(data.data);
      } catch (err) {
        onError(err);
      }
    };
    const gotResult = async (msg) => {
      clearTimeout(toidAbort);
      clearTimeout(toidTimeout);
      const data = msg?.content ?? void 0;
      const reqId = msg?.reqId ?? "";
      if (reqId !== _reqId) {
        return onError("server:reqid:" + reqId + ":" + _reqId);
      }
      if (!data) {
        return onError("server:reqid:missingData:" + _reqId);
      }
      if (data.id !== accountId) {
        return onError("server:accountid:" + data.id + ":" + accountId);
      }
      if (data.error) {
        if (data.error === "timeout") {
          return onError("server:" + data.error);
        }
        return onError("server:data:" + data.error);
      }
      try {
        const res = await handleResponse(data);
        return resolve(res);
      } catch (err) {
        return onError("data:" + err);
      }
    };
    try {
      await doRequest();
    } catch (err) {
      return onError(err);
    }
  });
};

const getRequestData = () => {
  {
    return requestData;
  }
};

const syncEpochParams = (networkId, accountId, epochList) => {
  if (!accountId) {
    accountId = DEFAULT_ACCOUNT_ID;
  }
  return getRequestData()(
    networkId,
    accountId,
    ApiRequestType.syncEpochParams,
    ErrorSync.syncEpochParams,
    {
      id: accountId,
      epochList
    },
    async (data) => data.epochParamList.length > 0 ? data.epochParamList : null
  );
};

const storeId$9 = "epochParamsStore";
const _epochParams = ref$1(getEpochParams(networkId$9.value, createIEpochParameterStore(networkId$9.value)).value);
const epochParams = computed(() => _epochParams.value);
const _loadedOnce = {};
const updateEpochParams = async (chainTip) => {
  if (chainTip.networkId === networkId$9.value) {
    if (chainTip.epochNo === 0 || epochParams.value.epochNo === chainTip.epochNo && _loadedOnce[networkId$9.value]) {
      return;
    }
    const __epochParams = await syncEpochParams(networkId$9.value, storeId$9, [chainTip.epochNo]);
    if (__epochParams && __epochParams.length === 1) {
      const params = __epochParams[0];
      checkEpochParams(networkId$9.value, params);
      setEpochParams(networkId$9.value, params);
      _reloadEpochParams();
      _loadedOnce[networkId$9.value] = true;
    }
    dispatchSignal(onEpochParamsUpdated);
    return true;
  }
  return _loadedOnce[networkId$9.value];
};
const checkEpochParams = (_networkId, params) => {
  _networkId = _networkId ?? networkId$9.value;
  const __epochParams = params ?? epochParams.value;
  if (!__epochParams) {
    throw ChainError.missingEpochParams;
  }
  if (__epochParams.networkId !== _networkId) {
    throw ChainError.networkIdMismatch;
  }
  if (!isNumber(__epochParams.utxoCostPerSize)) {
    throw ChainError.missingUtxoCostPerSize;
  }
  if (!isNumber(__epochParams.maxValueSize)) {
    throw ChainError.missingMaxValueSize;
  }
  if (!isNumber(__epochParams.maxTxSize)) {
    throw ChainError.missingMaxTxSize;
  }
  if (!isNumber(__epochParams.txFeePerByte)) {
    throw ChainError.missingTxFeePerByte;
  }
  if (!isNumber(__epochParams.txFeeFixed)) {
    throw ChainError.missingTxFeeFixed;
  }
  if (!isNumber(__epochParams.stakePoolDeposit)) {
    throw ChainError.missingStakePoolDeposit;
  }
  if (!isNumber(__epochParams.stakeAddressDeposit)) {
    throw ChainError.missingStakeAddressDeposit;
  }
  __epochParams.isAtLeastBabbageEra = __epochParams.protocolVersion.major >= 7;
  __epochParams.isAtLeastConwayEra = __epochParams.protocolVersion.major >= 9;
  __epochParams.isAtLeastConwayEra2 = __epochParams.protocolVersion.major >= 10;
  if (_networkId === "afpm" && __epochParams.utxoCostPerSize === 34482) {
    __epochParams.utxoCostPerSize = 4310;
  }
  return __epochParams;
};
const _reloadEpochParams = () => {
  _epochParams.value = getEpochParams(networkId$9.value, createIEpochParameterStore(networkId$9.value)).value;
};
addSignalListener(onNetworkIdUpdated, storeId$9, () => {
  _reloadEpochParams();
});

const createUtxoHash = (hash, index) => hash + "#" + index;
const getUtxoHash = (input) => createUtxoHash(input.transaction_id, input.index);

const createIUtxoFilterFlag = (flags) => {
  return {
    filterByCollateral: flags?.filterByCollateral ?? true,
    handlePendingTx: flags?.handlePendingTx ?? true,
    filterByLocked: flags?.filterByLocked ?? true,
    filterBySelected: flags?.filterBySelected ?? true,
    preserveDatums: flags?.preserveDatums ?? true
  };
};

const createIUtxoFromIUtxoDetails = (ref) => {
  const cred = getAddressCredentials(ref.a.b);
  const utxo = {
    input: {
      transaction_id: ref.h,
      index: ref.i
    },
    output: {
      address: ref.a.b,
      amount: {
        coin: ref.o
      }
    },
    pc: cred.paymentCred ?? "",
    sc: cred.stakeCred ?? "",
    p: 0,
    cborSize: 0
  };
  ref.tl.sort((a, b) => a.p.localeCompare(b.p, "en-US"));
  let policy = "";
  for (const token of ref.tl) {
    if (!utxo.output.amount.multiasset) {
      utxo.output.amount.multiasset = {
        [token.p]: {
          [token.n]: token.q
        }
      };
      policy = token.p;
    } else if (token.p !== policy) {
      utxo.output.amount.multiasset[token.p] = {
        [token.n]: token.q
      };
      policy = token.p;
    } else {
      utxo.output.amount.multiasset[token.p][token.n] = token.q;
    }
  }
  if (ref.dh) {
    utxo.output.plutus_data = {
      // TODO: DataHash vs DataHashJSON, which key to use?
      //@ts-ignore
      DataHash: ref.dh
    };
  } else if (ref.id) {
    utxo.output.plutus_data = {
      Data: ref.id.b
    };
  }
  if (ref.rs?.t === "multisig") {
    utxo.output.script_ref = {
      NativeScript: ref.rs.b
      // TODO: when used, use NativeScript.from_hex() to convert into correct type
    };
  } else if (ref.rs) {
    utxo.output.script_ref = {
      PlutusScript: ref.rs.b
    };
  }
  return utxo;
};
const createIUtxoFromTransactionJSON = (output, txHash, outputIndex) => {
  const cred = getAddressCredentials(output.address);
  const utxo = {
    input: {
      transaction_id: txHash,
      index: outputIndex
    },
    output,
    pc: cred.paymentCred ?? "",
    sc: cred.stakeCred ?? "",
    p: 0,
    cborSize: 0
  };
  return utxo;
};

var SyncPriority = /* @__PURE__ */ ((SyncPriority2) => {
  SyncPriority2["low"] = "low";
  SyncPriority2["medium"] = "medium";
  SyncPriority2["high"] = "high";
  SyncPriority2["force"] = "force";
  return SyncPriority2;
})(SyncPriority || {});

var SyncState = /* @__PURE__ */ ((SyncState2) => {
  SyncState2["initializing"] = "initializing";
  SyncState2["idle"] = "idle";
  SyncState2["queued"] = "queued";
  SyncState2["syncing"] = "syncing";
  SyncState2["success"] = "success";
  SyncState2["skipped"] = "skipped";
  SyncState2["error"] = "error";
  return SyncState2;
})(SyncState || {});

const clearIAccountBalances = (balances) => {
  clearBalance(balances.account);
  clearBalance(balances.selected);
  clearBalance(balances.collateral);
  clearBalance(balances.pending);
  clearBalance(balances.locked);
  clearBalance(balances.lockedWithCollateral);
  clearBalance(balances.allOutputs);
  clearBalance(balances.txFees);
  clearBalance(balances.available);
  clearBalance(balances.lockedByTokens);
  clearBalance(balances.lockedByTokensTF);
  clearBalance(balances.lockedByRewards);
  clearBalance(balances.lockedTotal);
  clearBalance(balances.lockedAvailable);
  clearBalance(balances.lockedTotalTF);
  clearBalance(balances.lockedAvailableTF);
};
const createIAccountBalances = (id) => {
  return {
    id,
    account: createIBalance(),
    selected: createIBalance(),
    collateral: createIBalance(),
    pending: createIBalance(),
    locked: createIBalance(),
    lockedWithCollateral: createIBalance(),
    allOutputs: createIBalance(),
    txFees: createIBalance(),
    available: createIBalance(),
    lockedByTokens: createIBalance(),
    lockedByTokensTF: createIBalance(),
    lockedByRewards: createIBalance(),
    lockedTotal: createIBalance(),
    lockedAvailable: createIBalance(),
    lockedTotalTF: createIBalance(),
    lockedAvailableTF: createIBalance()
  };
};

const createIUtxoBalance = (pageNo, stakeCred, txHashList) => {
  const balance = createIBalance();
  balance.pageNo = pageNo;
  balance.stakeCred = stakeCred;
  return balance;
};

const createIGovDelegation = (ref) => {
  return {
    drep: ref.drep,
    isScript: ref.isScript,
    epoch: ref.epoch,
    slot: ref.slot,
    idx: ref.idx
  };
};
const createIGovDelegationList = (refs) => {
  const list = [];
  if (!refs) {
    return list;
  }
  for (const ref of refs) {
    list.push(createIGovDelegation(ref));
  }
  return list;
};

const createIRewardInfo = (ref) => {
  return {
    id: ref.id,
    networkId: ref.networkId,
    cred: ref.cred,
    bech32: ref.bech32,
    rewards: ref.rewards,
    registered: ref.registered ?? false,
    //IStakeInfoSync
    rewardList: ref.rewardList ?? [],
    registrationList: ref.registrationList ?? [],
    deregistrationList: ref.deregistrationList ?? [],
    delegationList: ref.delegationList ?? [],
    currentEpochNo: ref.currentEpochNo,
    currentEpochStart: ref.currentEpochStart,
    nextEpochStart: ref.nextEpochStart,
    afterNextEpochStart: ref.afterNextEpochStart,
    rewardCount: ref.rewardCount,
    currentEpochDelegation: ref.currentEpochDelegation,
    nextDelegation: ref.nextDelegation,
    afterNextDelegations: ref.afterNextDelegations,
    // Governance
    hasActiveDRep: ref.hasActiveDRep ?? false,
    govDelegationList: createIGovDelegationList(ref.govDelegationList)
  };
};

const updateIAccountDBDataIfNeeded = (obj, ref) => {
  updateIAccountIfNeeded(obj.account, ref.account);
  updateIAccountStateIfNeeded(obj.state, ref.state);
  updateIAccountSettingsIfNeeded(obj.settings, ref.settings);
  updateIAccountCredsIfNeeded(obj.keys, ref.keys);
  updateIAccountBalanceIfNeeded(obj.balance, ref.balance);
  updateIRewardInfoIfNeeded(obj.rewardInfoList, ref.rewardInfoList);
};
const updateIAccountIfNeeded = (obj, ref) => {
  if (obj.pub !== ref.pub || obj.id !== ref.id || obj.signType !== ref.signType) {
    throw DataError.updateIAccountIfNeeded;
  }
  return obj;
};
const updateIAccountSettingsIfNeeded = (obj, ref) => {
  if (obj.id !== ref.id || obj.networkId !== ref.networkId) {
    throw DataError.updateIAccountSettingsIfNeeded;
  }
  if (obj.name !== ref.name) {
    obj.name = ref.name;
  }
  if (obj.adahandle !== ref.adahandle) {
    obj.adahandle = ref.adahandle;
  }
  if (obj.sam.enabled !== ref.sam.enabled) {
    obj.sam.enabled = ref.sam.enabled;
  }
  if (obj.sam.addr !== ref.sam.addr) {
    obj.sam.addr = ref.sam.addr;
  }
  if (obj.aum.enabled !== ref.aum.enabled) {
    obj.aum.enabled = ref.aum.enabled;
  }
  if (obj.aw.enabled !== ref.aw.enabled) {
    obj.aw.enabled = ref.aw.enabled;
  }
  if (obj.sendAll.enabled !== ref.sendAll.enabled) {
    obj.sendAll.enabled = ref.sendAll.enabled;
  }
  if (obj.favorite?.enabled !== ref.favorite?.enabled) {
    if (!obj.favorite) {
      obj.favorite = { enabled: ref.favorite?.enabled ?? false };
    } else {
      obj.favorite.enabled = ref.favorite?.enabled ?? false;
    }
  }
  if (obj.manualSync.enabled !== ref.manualSync.enabled) {
    obj.manualSync.enabled = ref.manualSync.enabled;
  }
  if (obj.historySync.enabled !== ref.historySync.enabled) {
    obj.historySync.enabled = ref.historySync.enabled;
  }
  if (obj.preserveDatums?.enabled !== ref.preserveDatums?.enabled) {
    if (!obj.preserveDatums) {
      obj.preserveDatums = { enabled: ref.preserveDatums?.enabled ?? false };
    } else {
      obj.preserveDatums.enabled = ref.preserveDatums?.enabled ?? false;
    }
  }
  if (obj.tf.enabled !== ref.tf.enabled) {
    obj.tf.enabled = ref.tf.enabled;
  }
  if (obj.tf.bundleSize !== ref.tf.bundleSize) {
    obj.tf.bundleSize = ref.tf.bundleSize;
  }
  if (obj.collateral.enabled !== ref.collateral.enabled) {
    obj.collateral.enabled = ref.collateral.enabled;
  }
  if (obj.collateral.eternl !== ref.collateral.eternl) {
    obj.collateral.eternl = ref.collateral.eternl;
  }
  if (obj.catalyst_cip15.encryptedKey !== ref.catalyst_cip15.encryptedKey) {
    obj.catalyst_cip15 = ref.catalyst_cip15;
  }
  if (!obj.notifications) {
    obj.notifications = {
      tx: true,
      txMS: true
    };
  }
  if (ref.notifications) {
    if (obj.notifications["tx"] !== ref.notifications["tx"]) {
      obj.notifications["tx"] = ref.notifications["tx"];
    }
    if (obj.notifications["txMS"] !== ref.notifications["txMS"]) {
      obj.notifications["txMS"] = ref.notifications["txMS"];
    }
  }
  return obj;
};
const updateIAccountSettingsPartial = (obj, ref) => {
  if (obj.id !== ref.id || obj.networkId !== ref.networkId) {
    throw DataError.updateIAccountSettingsIfNeeded;
  }
  if (ref.hasOwnProperty("name") && obj.name !== ref.name) {
    obj.name = ref.name;
  }
  if (ref.hasOwnProperty("adahandle") && obj.adahandle !== ref.adahandle) {
    obj.adahandle = ref.adahandle;
  }
  if (ref.sam?.hasOwnProperty("enabled") && obj.sam.enabled !== ref.sam.enabled) {
    obj.sam.enabled = ref.sam.enabled;
  }
  if (ref.sam?.hasOwnProperty("addr") && obj.sam.addr !== ref.sam.addr) {
    obj.sam.addr = ref.sam.addr;
  }
  if (ref.aum?.hasOwnProperty("enabled") && obj.aum.enabled !== ref.aum.enabled) {
    obj.aum.enabled = ref.aum.enabled;
  }
  if (ref.aw?.hasOwnProperty("enabled") && obj.aw.enabled !== ref.aw.enabled) {
    obj.aw.enabled = ref.aw.enabled;
  }
  if (ref.sendAll?.hasOwnProperty("enabled") && obj.sendAll.enabled !== ref.sendAll.enabled) {
    obj.sendAll.enabled = ref.sendAll.enabled;
  }
  if (ref.favorite?.hasOwnProperty("enabled") && obj.favorite?.enabled !== ref.favorite?.enabled) {
    if (!obj.favorite) {
      obj.favorite = { enabled: ref.favorite?.enabled ?? false };
    } else {
      obj.favorite.enabled = ref.favorite?.enabled ?? false;
    }
  }
  if (ref.manualSync?.hasOwnProperty("enabled") && obj.manualSync.enabled !== ref.manualSync.enabled) {
    obj.manualSync.enabled = ref.manualSync.enabled;
  }
  if (ref.historySync?.hasOwnProperty("enabled") && obj.historySync.enabled !== ref.historySync.enabled) {
    obj.historySync.enabled = ref.historySync.enabled;
  }
  if (ref.preserveDatums?.hasOwnProperty("enabled") && obj.preserveDatums?.enabled !== ref.preserveDatums?.enabled) {
    if (!obj.preserveDatums) {
      obj.preserveDatums = { enabled: ref.preserveDatums?.enabled ?? false };
    } else {
      obj.preserveDatums.enabled = ref.preserveDatums?.enabled ?? false;
    }
  }
  if (ref.tf?.hasOwnProperty("enabled") && obj.tf.enabled !== ref.tf.enabled) {
    obj.tf.enabled = ref.tf.enabled;
  }
  if (ref.tf?.hasOwnProperty("bundleSize") && obj.tf.bundleSize !== ref.tf.bundleSize) {
    obj.tf.bundleSize = ref.tf.bundleSize ?? 20;
  }
  if (ref.collateral?.hasOwnProperty("enabled") && obj.collateral.enabled !== ref.collateral.enabled) {
    obj.collateral.enabled = ref.collateral.enabled;
  }
  if (ref.collateral?.hasOwnProperty("eternl") && obj.collateral.eternl !== ref.collateral.eternl) {
    obj.collateral.eternl = ref.collateral.eternl;
  }
  if (ref.catalyst_cip15?.hasOwnProperty("encryptedKey") && obj.catalyst_cip15.encryptedKey !== ref.catalyst_cip15.encryptedKey) {
    obj.catalyst_cip15 = ref.catalyst_cip15;
  }
  if (!obj.notifications) {
    obj.notifications = {
      tx: true,
      txMS: true
    };
  }
  if (ref.notifications) {
    if (ref.notifications.hasOwnProperty("tx") && obj.notifications.tx !== ref.notifications.tx) {
      obj.notifications.tx = ref.notifications.tx;
    }
    if (ref.notifications.hasOwnProperty("txMS") && obj.notifications.txMS !== ref.notifications.txMS) {
      obj.notifications.txMS = ref.notifications.txMS;
    }
  }
  return obj;
};
const updateIAccountStateIfNeeded = (obj, ref) => {
  if (obj.id !== ref.id || obj.networkId !== ref.networkId) {
    throw DataError.updateIAccountStateIfNeeded;
  }
  if (obj.lastTimestamp !== ref.lastTimestamp) {
    obj.lastTimestamp = ref.lastTimestamp ?? 0;
  }
  if (obj.numTxHashes !== ref.numTxHashes) {
    obj.numTxHashes = ref.numTxHashes ?? 0;
  }
  if (obj.numTxHashesUninitialized !== ref.numTxHashesUninitialized) {
    obj.numTxHashesUninitialized = ref.numTxHashesUninitialized ?? 0;
  }
  return obj;
};
const updateIAccountBalanceIfNeeded = (obj, ref) => {
  if (obj.id !== ref.id || obj.networkId !== ref.networkId) {
    throw DataError.updateIAccountBalanceIfNeeded;
  }
  updateIBalanceIfNeeded(obj, ref);
  if (obj.coinOpk !== ref.coinOpk) {
    obj.coinOpk = ref.coinOpk;
  }
  if (obj.stakeOpkOsk !== ref.stakeOpkOsk) {
    obj.stakeOpkOsk = ref.stakeOpkOsk;
  }
  if (obj.stakeOpkEsk !== ref.stakeOpkEsk) {
    obj.stakeOpkEsk = ref.stakeOpkEsk;
  }
  if (obj.stakeEpkOsk !== ref.stakeEpkOsk) {
    obj.stakeEpkOsk = ref.stakeEpkOsk;
  }
  return obj;
};
const updateIAccountCredsIfNeeded = (obj, ref) => {
  if (obj.id !== ref.id || obj.networkId !== ref.networkId || obj.pub !== ref.pub || obj.index !== ref.index) {
    throw DataError.updateIAccountCredsIfNeeded;
  }
  if (obj.payment.length !== ref.payment.length) {
    obj.payment = ref.payment;
  }
  if (obj.change.length !== ref.change.length) {
    obj.change = ref.change;
  }
  if (obj.stake.length !== ref.stake.length) {
    obj.stake = ref.stake;
  }
  if (obj.drep.length !== ref.drep.length) {
    obj.drep = ref.drep;
  }
  if (obj.cc_cold.length !== ref.cc_cold.length) {
    obj.cc_cold = ref.cc_cold;
  }
  if (obj.cc_hot.length !== ref.cc_hot.length) {
    obj.cc_hot = ref.cc_hot;
  }
  return obj;
};
const updateIRewardInfoIfNeeded = (objList, refList) => {
  const objStr = JSON.stringify(objList);
  const refStr = JSON.stringify(refList);
  if (objStr === refStr) {
    return;
  }
  for (let i = 0; i < refList.length; i++) {
    const ref = refList[i];
    const obj = objList.find((_obj) => _obj.cred === ref.cred);
    if (!obj) {
      objList.push(createIRewardInfo(ref));
    } else {
      if (obj.id !== ref.id || obj.networkId !== ref.networkId) {
        throw DataError.updateIRewardInfoIfNeeded;
      }
      if (obj.currentEpochNo !== ref.currentEpochNo) {
        obj.currentEpochNo = ref.currentEpochNo;
      }
      if (obj.currentEpochStart !== ref.currentEpochStart) {
        obj.currentEpochStart = ref.currentEpochStart;
      }
      if (obj.nextEpochStart !== ref.nextEpochStart) {
        obj.nextEpochStart = ref.nextEpochStart;
      }
      if (obj.afterNextEpochStart !== ref.afterNextEpochStart) {
        obj.afterNextEpochStart = ref.afterNextEpochStart;
      }
      if (obj.rewardCount !== ref.rewardCount) {
        obj.rewardCount = ref.rewardCount;
      }
      obj.currentEpochDelegation = ref.currentEpochDelegation;
      obj.nextDelegation = ref.nextDelegation;
      obj.afterNextDelegations = ref.afterNextDelegations;
      if (obj.rewards !== ref.rewards) {
        obj.rewards = ref.rewards;
      }
      if (obj.registered !== ref.registered) {
        obj.registered = ref.registered;
      }
      if (obj.hasActiveDRep !== ref.hasActiveDRep) {
        obj.hasActiveDRep = ref.hasActiveDRep;
      }
      if (obj.govDelegationList.length !== ref.govDelegationList.length) {
        obj.govDelegationList = ref.govDelegationList;
      }
    }
  }
};
const updateValueJSONIfNeeded = (obj, ref) => {
  if (obj.coin !== ref.coin) {
    obj.coin = ref.coin;
  }
  if (obj.multiasset && !ref.multiasset) {
    delete obj.multiasset;
    return;
  }
  if (!obj.multiasset && ref.multiasset) {
    obj.multiasset = ref.multiasset;
    return;
  }
  const objAssetStr = JSON.stringify(obj.multiasset);
  const refAssetStr = JSON.stringify(ref.multiasset);
  if (objAssetStr !== refAssetStr) {
    obj.multiasset = ref.multiasset;
  }
};
const updateIBalanceIfNeeded = (obj, ref) => {
  updateValueJSONIfNeeded(obj, ref);
  if (obj.rewards !== ref.rewards) {
    obj.rewards = ref.rewards;
  }
  const total = add(obj.coin, obj.rewards);
  if (obj.total !== total) {
    obj.total = total;
  }
};

const isHDAccountPath = (account) => account.path[0] === purpose.hdwallet && account.path[1] === coin.ada;
const isMultiSigAccountPath = (account) => account.path[0] === purpose.multisig && account.path[1] === coin.ada;
const isHDAccount = (path) => !!path && path.length > 2 && path[0] === purpose.hdwallet;

const signTypeList = [
  "mnemonic",
  "ledger",
  "trezor",
  "keystone",
  "onekey",
  "bitbox",
  "readonly",
  "multisig",
  "cli"
];
const signTypeFeaturesMap = signTypeList.reduce((o, n) => {
  o[n] = 0 /* NONE */;
  return o;
}, {});
signTypeFeaturesMap["mnemonic"] = 511 /* ALL */;
signTypeFeaturesMap["ledger"] = 511 /* ALL */;
signTypeFeaturesMap["trezor"] = 511 /* ALL */ & -17 /* GOV_DREP */ & -65 /* SIGN_DATA */;
signTypeFeaturesMap["keystone"] = 511 /* ALL */;
signTypeFeaturesMap["onekey"] = 511 /* ALL */ & -17 /* GOV_DREP */;
signTypeFeaturesMap["readonly"] = 511 /* ALL */ & -129 /* ADD_ACCOUNTS */;
signTypeFeaturesMap["bitbox"] = 1 /* STAKING */ | 8 /* GOV_DELEGATE */ | 128 /* ADD_ACCOUNTS */;
signTypeFeaturesMap["multisig"] = 1 /* STAKING */ | 8 /* GOV_DELEGATE */ | 256 /* ENTERPRISE_ADDR */;
signTypeFeaturesMap["cli"] = 511 /* ALL */ & -129 /* ADD_ACCOUNTS */;
const isDAppSupported = (signType) => (signTypeFeaturesMap[signType] & 32 /* DAPP */) !== 0;

const createIAccountSettings = (id, networkId, ref) => {
  return {
    id,
    networkId,
    name: ref?.name ?? null,
    sam: {
      enabled: ref?.sam?.enabled ?? true,
      addr: ref?.sam?.addr ?? null
    },
    aw: {
      enabled: ref?.aw?.enabled ?? true
    },
    aum: {
      enabled: ref?.aum?.enabled ?? true
    },
    sendAll: {
      enabled: ref?.sendAll?.enabled ?? true
    },
    manualSync: {
      enabled: ref?.manualSync?.enabled ?? false
    },
    historySync: {
      enabled: ref?.historySync?.enabled ?? false
    },
    tf: {
      enabled: ref?.tf?.enabled ?? true,
      bundleSize: ref?.tf?.bundleSize ?? 20
    },
    collateral: {
      enabled: ref?.collateral?.enabled ?? true,
      eternl: ref?.collateral?.eternl ?? true
    },
    favorite: {
      enabled: ref?.favorite?.enabled ?? false
    },
    preserveDatums: {
      enabled: ref?.preserveDatums?.enabled ?? false
    },
    catalyst_cip15: {
      encryptedKey: ref?.catalyst_cip15?.encryptedKey ?? null,
      minVersion: ref?.catalyst_cip15?.minVersion ?? null
    },
    notifications: {
      tx: ref?.notifications?.tx ?? true,
      txMS: ref?.notifications?.txMS ?? true
    }
  };
};
const createIAccountState = (id, networkId) => {
  return {
    id,
    networkId,
    lastTimestamp: 0,
    numTxHashes: 0,
    numTxHashesUninitialized: 0
  };
};
const createIAccountBalance = (id, networkId) => {
  const balance = createIBalance();
  balance.id = id;
  balance.networkId = networkId;
  balance.rewards = "0";
  balance.total = "0";
  balance.coinOpk = "0";
  balance.stakeOpkOsk = "0";
  balance.stakeOpkEsk = "0";
  balance.stakeEpkOsk = "0";
  return balance;
};
const createIAccountCreds = (id, networkId, pub, path) => {
  return {
    id,
    networkId,
    pub,
    path,
    index: path[2],
    payment: [],
    change: [],
    stake: [],
    drep: [],
    cc_cold: [],
    cc_hot: []
  };
};

const minCollateral = (networkId) => {
  switch (networkId) {
    case "sancho":
      return "5000000";
    default:
      return "5000000";
  }
};
const maxCollateral = (networkId) => {
  switch (networkId) {
    case "sancho":
      return "20000000";
    default:
      return "20000000";
  }
};

const ErrorAddrType = {
  invalid: "ErrorAddrType.invalid"
};

const ErrorDB = {
  AccountDB: "ErrorDB.AccountDB",
  AccountTxCborDB: "ErrorDB.AccountTxCborDB",
  WalletDB: "ErrorDB.WalletDB",
  refNotFound: "ErrorDB.AccountDB.refNotFound",
  getUtxoPageList: "ErrorDB.AccountDB.getUtxoPageList"
};

const WalletError = {
  missingWalletData: "WalletError.missingWalletData"
};

const WorkerError = {
  initWorkerList: "WorkerError.initWorkerList"
};

const AdaHandleError = {
  invalidAdaHandle: "AdaHandleError.invalidAdaHandle",
  invalidAddress: "AdaHandleError.invalidAddress",
  adaHandleNotResolved: "AdaHandleError.adaHandleNotResolved"
};

const UnstoppableDomainsError = {
  invalidDomain: "UnstoppableDomainsError.invalidDomain",
  invalidAddress: "UnstoppableDomainsError.invalidAddress",
  addressNotSet: "UnstoppableDomainsError.addressNotSet",
  domainNotFound: "UnstoppableDomainsError.domainNotFound",
  notResolved: "UnstoppableDomainsError.notResolved"
};

const getDefaultErrorMessage = (err) => {
  switch (err) {
    case AccountError.wrongCustomAddress:
      return "The custom address set for the single address mode does not belong to this account.";
    case DataError.updateIAccountIfNeeded:
      return "ErrorData: mismatch (IAccount)";
    case DataError.updateIAccountStateIfNeeded:
      return "ErrorData: mismatch (IAccountState)";
    case DataError.updateIAccountBalanceIfNeeded:
      return "ErrorData: mismatch (IAccountBalance)";
    case DataError.updateIAccountCredsIfNeeded:
      return "ErrorData: mismatch (IAccountCreds)";
    case DataError.updateIAccountSettingsIfNeeded:
      return "ErrorData: mismatch (IAccountSettings)";
    case DataError.updateIAccountSettingsPartial:
      return "ErrorData: mismatch (IAccountSettings (1))";
    case DataError.updateIAccountSettings:
      return "ErrorData: mismatch (IAccountSettings (2))";
    case DataError.updateIRewardInfoIfNeeded:
      return "ErrorData: mismatch (IRewardInfo)";
    case DataError.updateIUtxoBalanceIfNeeded:
      return "ErrorData: mismatch (IUtxoBalance)";
    case DataError.updateIUtxoBalanceListIfNeeded:
      return "ErrorData: mismatch (IUtxoBalance list)";
    case DataError.updateIWalletDBDataIfNeeded:
      return "ErrorData: mismatch (IWalletDBData)";
    case DataError.updateIAccountDBDataIfNeeded:
      return "ErrorData: mismatch (IAccountDBData)";
    case DataError.missingAccountSettings:
      return "ErrorData: missing account settings";
    case DataError.missingAccountData:
      return "ErrorData: missing account data";
    case DataError.noIAccountBalance:
      return "ErrorData: missing balance";
    case DataError.noIStakeInfo:
      return "ErrorData: missing stakeInfo";
    case ErrorDB.AccountDB:
      return "ErrorDB: AccountDB";
    case ErrorDB.AccountTxCborDB:
      return "ErrorDB: AccountTxCborDB";
    case ErrorDB.WalletDB:
      return "ErrorDB: WalletDB";
    case ErrorDB.refNotFound:
      return "ErrorDB: reference (addr, pc, sc) could not be found";
    case ErrorSync.loadUtxoCborList:
      return "ErrorSync: could not load utxo cbor list.";
    case ErrorSync.loadStakeInfo:
      return "ErrorSync: could not load rewards balance.";
    case ErrorSync.loadTxCborList:
      return "ErrorSync: could not load tx cbor list.";
    case ErrorSync.loadTxHashList:
      return "ErrorSync: could not load tx hash list (loading).";
    case ErrorSync.loadTxHashCount:
      return "ErrorSync: could not load tx hash count (loading).";
    case ErrorSync.loadTxHashCountChunk:
      return "ErrorSync: could not load tx hash count chunk (loading).";
    case ErrorSync.hasTxHash:
      return "ErrorSync: could not load tx hash list (discovering).";
    case ErrorSync.syncAccountFinish:
      return "ErrorSync: failed to sync ledger state (finish)";
    case ErrorSync.runSyncAccount:
      return "ErrorSync: failed to sync ledger state (run)";
    case ErrorSync.syncSchedulerLedger:
      return "ErrorSync: failed to sync ledger state (scheduler)";
    case ErrorSync.syncAccountLedgerState:
      return "ErrorSync: failed to sync ledger state (inner)";
    case ErrorSync.syncAccountLedgerState2:
      return "ErrorSync: failed to sync ledger state (main)";
    case ErrorSync.syncAccountTxHashList:
      return "ErrorSync: failed to sync tx hash list (inner)";
    case ErrorSync.syncAccountTxHashList2:
      return "ErrorSync: failed to sync tx hash list (main)";
    case ErrorSync.syncEpochParams:
      return "ErrorSync: failed to sync epoch params";
    case ErrorAddrType.invalid:
      return "The address you entered is invalid.";
    case WalletError.missingWalletData:
      return "ErrorWallet: wallet data missing";
    case WorkerError.initWorkerList:
      return "ErrorWorker: could not initialize worker";
    case AdaHandleError.adaHandleNotResolved:
      return "ADA Handle could not be found.";
    case AdaHandleError.invalidAdaHandle:
      return "Invalid ADA Handle.";
    case AdaHandleError.invalidAddress:
      return "Invalid ADA Handle address.";
    case UnstoppableDomainsError.notResolved:
      return "Unstoppable Domain could not be resolved.";
    case UnstoppableDomainsError.domainNotFound:
      return "Unstoppable Domain could not be found.";
    case UnstoppableDomainsError.addressNotSet:
      return "Unstoppable Domain ADA address not set.";
    case UnstoppableDomainsError.invalidDomain:
      return "Invalid Unstoppable Domain URL.";
    case UnstoppableDomainsError.invalidAddress:
      return "Invalid Unstoppable Domain address.";
  }
  return "Undefined Error:" + err;
};

const getRefListByIdList = (networkId, accountId, idList) => {
  return AccountDB$1.getDB(networkId, accountId).then((db) => {
    return db.transaction("r", db.ref, async (tx) => {
      return db.ref.where("id").anyOf(idList).toArray();
    }).catch((reason) => []);
  });
};
const getRefById = (networkId, accountId, id) => {
  console.warn("**D*D*D*D*D*D*D 111 getRefById", id);
  return AccountDB$1.getDB(networkId, accountId).then((db) => {
    console.warn("**D*D*D*D*D*D*D 222 getRefById", id, db.ref);
    return db.transaction("r", db.ref, async (tx) => {
      console.warn("**D*D*D*D*D*D*D 333");
      const res = await db.ref.get(id);
      console.warn("**D*D*D*D*D*D*D", res);
      return res;
    }).catch((reason) => {
      console.error(reason);
      return void 0;
    });
  });
};
const getRefListByRefs = (networkId, id, refList, limit = 0) => {
  return AccountDB$1.getDB(networkId, id).then((db) => {
    return db.transaction("r", db.ref, async (tx) => {
      let result;
      if (limit) {
        result = await db.ref.where("ref").anyOf(refList).limit(limit).primaryKeys();
      } else {
        result = await db.ref.where("ref").anyOf(refList).primaryKeys();
      }
      return result;
    }).catch((reason) => []);
  });
};
const getRefListByRefsLoose = (networkId, id, refList, limit = 0) => {
  return AccountDB$1.getDB(networkId, id).then((db) => {
    return db.transaction("r", db.ref, async (tx) => {
      let result;
      if (limit) {
        result = await db.ref.where("ref").startsWithAnyOfIgnoreCase(refList).limit(limit).primaryKeys();
      } else {
        result = await db.ref.where("ref").startsWithAnyOfIgnoreCase(refList).primaryKeys();
      }
      return result;
    }).catch((reason) => []);
  });
};
const addRefList = async (networkId, id, refList) => {
  return AccountDB$1.getDB(networkId, id).then((db) => {
    return db.transaction("rw", db.ref, async (tx) => {
      const dbList = await db.ref.where("ref").anyOf(refList).toArray();
      const newRefList = [];
      for (let i = refList.length - 1; i >= 0; i--) {
        const ref = refList[i];
        let found = false;
        for (const item of dbList) {
          if (item.ref === ref) {
            found = true;
            break;
          }
        }
        if (!found) {
          newRefList.push({ ref });
        }
      }
      if (newRefList.length > 0) {
        const newRefIdList = await db.ref.bulkAdd(newRefList, { allKeys: true });
        for (let i = 0; i < newRefList.length; i++) {
          newRefList[i].id = newRefIdList[i];
          dbList.push(newRefList[i]);
        }
      }
      return dbList;
    });
  });
};
const addAndGetRefId = async (networkId, accountId, ref) => {
  return ref ? (await addRefList(networkId, accountId, [ref]))?.[0].id ?? -1 : -1;
};
const mapRefs = (addrList, utxoList) => {
  for (const utxo of utxoList) {
    let refUtxo = utxo.output.address;
    if (typeof refUtxo === "number") {
      const ref = addrList.find((item) => item.id === refUtxo) ?? null;
      if (ref) {
        utxo.output.address = ref.ref;
      } else {
        console.error("mapRefs", ref, refUtxo, addrList, utxoList);
        error(getDefaultErrorMessage(ErrorDB.refNotFound));
      }
    }
    refUtxo = utxo.pc;
    if (typeof refUtxo === "number") {
      const ref = addrList.find((item) => item.id === refUtxo) ?? null;
      if (ref) {
        utxo.pc = ref.ref;
      } else {
        console.error("mapRefs", ref, refUtxo, addrList, utxoList);
        error(getDefaultErrorMessage(ErrorDB.refNotFound));
      }
    }
    refUtxo = utxo.sc;
    if (typeof refUtxo === "number" && refUtxo >= 0) {
      const ref = addrList.find((item) => item.id === refUtxo) ?? null;
      if (ref) {
        utxo.sc = ref.ref;
      } else {
        console.error("mapRefs", ref, refUtxo, addrList, utxoList);
        error(getDefaultErrorMessage(ErrorDB.refNotFound));
      }
    }
  }
};
const RefDB = {
  getRefById,
  getRefListByIdList,
  getRefListByRefs,
  getRefListByRefsLoose,
  addRefList,
  addAndGetRefId,
  mapRefs
};

const putLockedUtxoList = (networkId, id, idList) => AccountDB$1.getDB(networkId, id).then((db) => db.lockedUtxoList.put({ id, l: idList }));
const getUtxoPageList = async (networkId, accountId, utxoType, stakeCred) => {
  const stakeCredRefId = await RefDB.addAndGetRefId(networkId, accountId, stakeCred);
  return AccountDB$1.getDB(networkId, accountId).then((db) => {
    let store = null;
    switch (utxoType) {
      case "opk":
        store = db.pageList;
        break;
      case "opkosk":
        store = db.pageList;
        break;
      case "opkesk":
        store = db.pageList;
        break;
      case "epkosk":
        store = db.pageListEpkOsk;
        break;
    }
    if (store) {
      return store.where("sc").equals(stakeCredRefId).toArray();
    }
    throw ErrorDB.getUtxoPageList;
  });
};
const deleteUtxoPage = async (networkId, accountId, utxoType, pageNo, stakeCred) => {
  const stakeCredRefId = await RefDB.addAndGetRefId(networkId, accountId, stakeCred);
  return AccountDB$1.getDB(networkId, accountId).then((db) => {
    let storePage = null;
    let storeUtxoList = null;
    switch (utxoType) {
      case "opk":
        storePage = db.pageList;
        storeUtxoList = db.utxoList;
        break;
      case "opkosk":
        storePage = db.pageList;
        storeUtxoList = db.utxoList;
        break;
      case "opkesk":
        storePage = db.pageList;
        storeUtxoList = db.utxoList;
        break;
      case "epkosk":
        storePage = db.pageListEpkOsk;
        storeUtxoList = db.utxoListEpkOsk;
        break;
    }
    if (!storePage || !storeUtxoList) {
      return false;
    }
    return db.transaction("rw", [storePage, storeUtxoList], async (tx) => {
      const calls = [];
      calls.push(storePage.where("[p+sc]").equals([pageNo, stakeCredRefId]).delete());
      calls.push(storeUtxoList.where("[p+sc]").equals([pageNo, stakeCredRefId]).delete());
      await Promise.all(calls);
      return true;
    }).catch((reason) => {
      error(reason);
      return false;
    });
  });
};
const putUtxoPage = async (networkId, accountId, utxoType, pageNo, utxoPage, utxoList, stakeCred) => {
  if (utxoPage.p !== pageNo) {
    return new Promise((resolve) => resolve(false));
  }
  const stakeCredRefId = await RefDB.addAndGetRefId(networkId, accountId, stakeCred);
  utxoPage.sc = stakeCredRefId;
  const addressList = /* @__PURE__ */ new Set();
  for (const utxo of utxoList) {
    if (typeof utxo.output.address === "string") {
      addressList.add(utxo.output.address);
    }
    if (typeof utxo.pc === "string") {
      addressList.add(utxo.pc);
    }
    if (typeof utxo.sc === "string") {
      if (utxo.sc === "") {
        utxo.sc = "enterprise";
        addressList.add("enterprise");
      } else {
        if (utxoType === "opkesk") {
          utxo.sc = "external";
          addressList.add("external");
        } else {
          addressList.add(utxo.sc);
        }
      }
    }
  }
  const refList = await RefDB.addRefList(networkId, accountId, Array.from(addressList));
  return AccountDB$1.getDB(networkId, accountId).then((db) => {
    let storePage = null;
    let storeUtxoList = null;
    switch (utxoType) {
      case "opk":
        storePage = db.pageList;
        storeUtxoList = db.utxoList;
        break;
      case "opkosk":
        storePage = db.pageList;
        storeUtxoList = db.utxoList;
        break;
      case "opkesk":
        storePage = db.pageList;
        storeUtxoList = db.utxoList;
        break;
      case "epkosk":
        storePage = db.pageListEpkOsk;
        storeUtxoList = db.utxoListEpkOsk;
        break;
    }
    if (!storePage || !storeUtxoList) {
      return false;
    }
    return db.transaction("rw", [storePage, storeUtxoList], async (tx) => {
      const calls = [];
      calls.push(storePage.where("[p+sc]").equals([pageNo, stakeCredRefId]).delete());
      calls.push(storeUtxoList.where("[p+sc]").equals([pageNo, stakeCredRefId]).delete());
      await Promise.all(calls);
      const _utxoList = json(utxoList);
      for (const utxo of _utxoList) {
        if (typeof utxo.output.address === "string") {
          const ref = refList.find((r) => r.ref === utxo.output.address);
          if (!ref?.id) {
            throw Error("putUtxoPage: utxo address not found in ref table: " + JSON.stringify(utxo));
          }
          utxo.output.address = ref.id;
        }
        if (typeof utxo.pc === "string") {
          const ref = refList.find((r) => r.ref === utxo.pc);
          if (!ref?.id) {
            throw Error("putUtxoPage: utxo paymentCred not found in ref table: " + JSON.stringify(utxo));
          }
          utxo.pc = ref.id;
        }
        if (typeof utxo.sc === "string") {
          const ref = refList.find((r) => r.ref === utxo.sc);
          if (!ref?.id) {
            throw Error("putUtxoPage: utxo stakeCred not found in ref table: " + JSON.stringify(utxo));
          }
          utxo.sc = ref.id;
        }
      }
      calls.length = 0;
      calls.push(storePage.put(utxoPage));
      calls.push(storeUtxoList.bulkPut(_utxoList));
      await Promise.all(calls);
      return true;
    }).catch((reason) => {
      error(reason);
      return false;
    });
  });
};
const uniqueAddressList = (utxoList, utxoType) => {
  const addressList = /* @__PURE__ */ new Set();
  for (const utxo of utxoList) {
    addressList.add(utxo.output.address);
    addressList.add(utxo.pc);
    if (utxo.sc === "") {
      utxo.sc = "enterprise";
      addressList.add("enterprise");
    } else {
      if (utxoType === "opkesk") {
        utxo.sc = "external";
        addressList.add("external");
      } else {
        addressList.add(utxo.sc);
      }
    }
  }
  return Array.from(addressList);
};
const UtxoListDB = {
  getUtxoPageList,
  deleteUtxoPage,
  putUtxoPage,
  putLockedUtxoList,
  uniqueAddressList
};

const accountSchemaV10 = {
  keys: "id",
  state: "id",
  settings: "id",
  rewardInfo: "cred, bech32, id",
  rewardHistory: "++id, [refId+epochNo]",
  // only contain data for stake key with index 0
  // Account address combinations:
  //
  // (a) OPK:       enterprise (ADA     controlled, rewards not earned, unstaked)
  // (b) OPK + OSK:       base (ADA     controlled, rewards     earned, staked)
  // (c) OPK + ESK:       base (ADA     controlled, rewards not earned, staked externally)
  // (d) EPK + OSK:       base (ADA not controlled, rewards     earned, staked)
  // Account balances:
  // (1) (OPK),       (a,b,c): amount of ADA on OPK + amount of ADA on rewards addresses of OSK
  // (2) (OSK),       (b,d):   amount of ADA on payment keys (OPK or EPK) combined with OSK (stake) earning rewards
  // (3) (OPK + ESK), (c):     amount of ADA on OPK combined with ESK, externally staked ADA, not earning rewards
  balance: "id",
  // (a,b,c), (1) + (3), normal balance
  ref: "++id, ref",
  pageList: "++_id, p, sc, [p+sc]",
  pageListEpkOsk: "++_id, p, sc, [p+sc]",
  utxoList: "++_id, c, p, pc, sc, [p+sc], [pc+sc]",
  // includes opk, opkosk, opkesk
  utxoListEpkOsk: "++_id, c, p, pc, sc, [p+sc], [pc+sc]",
  txList: "hash, slot, [slot+hash+t], t, c, *al",
  // compound index used to get consistent slot sorting
  lockedUtxoList: "id"
};
const accountSchemaV12 = {
  ...accountSchemaV10,
  txList: "hash, slot, [slot+idx+t], t, c, *al"
};
const accountSchemaV15 = {
  ...accountSchemaV12,
  reportList: "id, slot, year, month, day, [year+month+day], c, *al"
};
class AccountDB extends Dexie {
  keys;
  state;
  settings;
  rewardInfo;
  rewardHistory;
  ref;
  balance;
  pageList;
  // includes opk, opkosk, opkesk
  pageListEpkOsk;
  utxoList;
  // includes opk, opkosk, opkesk
  utxoListEpkOsk;
  txList;
  reportList;
  // daily aggregated txList
  lockedUtxoList;
  constructor(networkId, accountId) {
    super("eternl-" + accountId + "-" + networkId);
    this.version(16).stores(accountSchemaV15).upgrade((tx) => {
      this.table("state").clear();
      this.table("keys").clear();
      this.table("ref").clear();
      this.table("balance").clear();
      this.table("rewardInfo").clear();
      this.table("lockedUtxoList").clear();
      this.table("pageList").clear();
      this.table("pageListEpkOsk").clear();
      this.table("utxoList").clear();
      this.table("utxoListEpkOsk").clear();
      return tx.table("txList").clear();
    });
  }
}
const dbMap$7 = networkIdList.reduce((o, n) => {
  o[n] = {};
  return o;
}, {});
const getDB$8 = async (networkId, id) => {
  let db = dbMap$7[networkId][id];
  if (!db) {
    db = new AccountDB(networkId, id);
    dbMap$7[networkId][id] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const getKeys = (networkId, id) => getDB$8(networkId, id).then((db) => db.keys.get(id));
const getState = (networkId, id) => getDB$8(networkId, id).then((db) => db.state.get(id));
const getSettings$1 = (networkId, id) => getDB$8(networkId, id).then((db) => db.settings.get(id));
const getBalance$1 = (networkId, id) => getDB$8(networkId, id).then((db) => db.balance.get(id));
const getRewardInfo = (networkId, id, cred) => getDB$8(networkId, id).then((db) => db.rewardInfo.get(cred));
const getRewardHistory$1 = (networkId, id, refId, limit = 20, offset = 0, reverse = true) => {
  return getDB$8(networkId, id).then((db) => {
    return db.transaction("r", [db.rewardHistory], async (tx) => {
      const query = db.rewardHistory.where("[refId+epochNo]").between([refId, 0], [refId, Number.MAX_SAFE_INTEGER]);
      if (reverse) {
        return query.reverse().offset(offset).limit(limit).toArray();
      } else {
        return (await query.offset(offset).limit(limit).toArray()).sort((a, b) => b.epochNo - a.epochNo);
      }
    });
  });
};
const getRewardHistoryCount$1 = (networkId, id, refId) => getDB$8(networkId, id).then((db) => db.rewardHistory.where({ refId }).count());
const getTxHashKeyList = (networkId, id, keyList) => getDB$8(networkId, id).then((db) => db.txList.where("hash").anyOf(keyList).primaryKeys());
const getTxHashListCount = (networkId, id) => getDB$8(networkId, id).then((db) => db.txList.count());
const getMaxSlotNo = (networkId, id) => getDB$8(networkId, id).then((db) => {
  return db.transaction("r", [db.txList], async (tx) => {
    const last = await db.txList.orderBy("slot").last();
    return last?.slot ?? 0;
  });
});
const getReportList = (networkId, id) => getDB$8(networkId, id).then((db) => db.reportList.toArray());
const bulkPutReportList = (networkId, id, list) => getDB$8(networkId, id).then((db) => db.reportList.bulkPut(list));
const putKeys = (keys) => getDB$8(keys.networkId, keys.id).then((db) => db.keys.put(keys));
const putState = (state) => getDB$8(state.networkId, state.id).then((db) => db.state.put(state));
const putSettings$1 = (settings) => getDB$8(settings.networkId, settings.id).then((db) => db.settings.put(settings));
const putBalance$1 = (balance) => getDB$8(balance.networkId, balance.id).then((db) => db.balance.put(balance));
const putRewardInfo = (rewards) => getDB$8(rewards.networkId, rewards.id).then((db) => db.rewardInfo.put(rewards));
const bulkAddRewardHistory = async (networkId, id, itemList) => getDB$8(networkId, id).then((db) => {
  if (itemList.length === 0) {
    return;
  }
  const refId = itemList[0].refId;
  let firstEpochNo = Number.MAX_SAFE_INTEGER;
  for (const epoch of itemList) {
    if (epoch.epochNo < firstEpochNo) {
      firstEpochNo = epoch.epochNo;
    }
  }
  db.transaction("rw", [db.rewardHistory], async (tx) => {
    await db.rewardHistory.where("[refId+epochNo]").between([refId, firstEpochNo], [refId, Number.MAX_SAFE_INTEGER]).delete();
    await db.rewardHistory.bulkAdd(itemList);
  });
});
const bulkAddTxHashList = async (networkId, id, addTxList, lastSlotNo) => {
  return await getDB$8(networkId, id).then((db) => {
    return db.transaction("rw", [db.txList], async (tx) => {
      let potentiallyDeleteTxList = await db.txList.where("slot").aboveOrEqual(lastSlotNo).toArray();
      for (let i = potentiallyDeleteTxList.length - 1; i >= 0; i--) {
        const index = addTxList.findIndex((item) => item.hash === potentiallyDeleteTxList[i].hash);
        if (index >= 0) {
          potentiallyDeleteTxList.splice(i, 1);
          addTxList.splice(index, 1);
        }
      }
      if (potentiallyDeleteTxList.length > 0) {
        await db.txList.bulkDelete(potentiallyDeleteTxList.map((item) => item.hash));
      }
      if (addTxList.length > 0) {
        await db.txList.bulkPut(createITxBalanceList(addTxList));
      }
      return addTxList.length;
    });
  });
};
const wipeAccountData = async (networkId, accountId) => {
  return getDB$8(networkId, accountId).then(async (db) => {
    await db.state.clear();
    await db.keys.clear();
    await db.ref.clear();
    await db.balance.clear();
    await db.rewardInfo.clear();
    await db.rewardHistory.clear();
    await db.lockedUtxoList.clear();
    await db.pageList.clear();
    await db.pageListEpkOsk.clear();
    await db.utxoList.clear();
    await db.utxoListEpkOsk.clear();
    await db.txList.clear();
    await db.reportList.clear();
    return true;
  });
};
const getAccountData = (networkId, account) => {
  const accountId = account.id;
  return getDB$8(networkId, accountId).then((db) => {
    return db.transaction("r", [db.keys, db.state, db.settings, db.balance, db.rewardInfo], async (tx) => {
      let keys = await db.keys.get(accountId);
      let state = void 0;
      let settings = void 0;
      let balance = void 0;
      let rewardInfoList = void 0;
      if (!keys) {
        throw new Error("No account data found: " + accountId);
      } else {
        const calls = [];
        calls.push(db.state.get(accountId));
        calls.push(db.settings.get(accountId));
        calls.push(db.balance.get(accountId));
        calls.push(db.rewardInfo.toArray());
        const data = await Promise.all(calls);
        state = data[0];
        settings = data[1];
        balance = data[2];
        rewardInfoList = data[3];
      }
      return {
        account,
        state,
        settings,
        keys,
        balance,
        rewardInfoList,
        initialized: false
      };
    });
  });
};
const createAccountData = async (networkId, account, walletSettings) => {
  const accountId = account.id;
  let recoverySettings = void 0;
  try {
    recoverySettings = await dispatchSignal(doGetAccountSettingsFromRecovery, networkId, accountId) ?? void 0;
  } catch (e) {
    error("Error getRecoveryAccountSetting:", e);
  }
  return getDB$8(networkId, accountId).then((db) => {
    return db.transaction("rw", [db.keys, db.state, db.settings, db.balance, db.rewardInfo], async (tx) => {
      let keys = await db.keys.get(accountId);
      let state = void 0;
      let settings = await db.settings.get(accountId) ?? recoverySettings;
      let balance = void 0;
      let rewardInfoList = void 0;
      const hadSettings = !!settings;
      if (!keys) {
        keys = createIAccountCreds(accountId, networkId, account.pub, account.path);
        state = createIAccountState(accountId, networkId);
        settings = settings ?? createIAccountSettings(accountId, networkId, account);
        if (!hadSettings && walletSettings) {
          const _set = {
            ...walletSettings
          };
          _set.id = accountId;
          _set.networkId = networkId;
          updateIAccountSettingsPartial(settings, _set);
        }
        balance = createIAccountBalance(accountId, networkId);
        rewardInfoList = [];
        const calls = [];
        calls.push(db.keys.put(json(keys)));
        calls.push(db.state.put(json(state)));
        calls.push(db.settings.put(json(settings)));
        calls.push(db.balance.put(json(balance)));
        await Promise.all(calls);
      } else {
        const calls = [];
        calls.push(db.state.get(accountId));
        calls.push(db.settings.get(accountId));
        calls.push(db.balance.get(accountId));
        calls.push(db.rewardInfo.toArray());
        const data = await Promise.all(calls);
        state = data[0];
        settings = data[1];
        balance = data[2];
        rewardInfoList = data[3];
      }
      return {
        account,
        state,
        settings,
        keys,
        balance,
        rewardInfoList,
        initialized: false
      };
    });
  });
};
const removeDB$1 = (networkId, accountId) => Dexie.delete("eternl-" + accountId + "-" + networkId);
const handleRefs = async (db, utxoList, utxoType) => {
  const addrList = await db.ref.where("id").anyOf(uniqueAddressList(utxoList, utxoType)).toArray();
  RefDB.mapRefs(addrList, utxoList);
};
const putSyncUpdate = async (appAccount, rewardInfoList, onlyUpdateBalance) => {
  const networkId = appAccount.data.state.networkId;
  const accountId = appAccount.id;
  const accountBalance = createIAccountBalance(accountId, networkId);
  const stakeCredRefIdEnt = await RefDB.addAndGetRefId(networkId, accountId, "enterprise");
  const stakeCredRefIdExt = await RefDB.addAndGetRefId(networkId, accountId, "external");
  return getDB$8(networkId, accountId).then((db) => {
    return db.transaction("rw", [
      db.balance,
      db.rewardInfo,
      db.txList,
      db.ref,
      db.utxoList,
      db.utxoListEpkOsk,
      db.lockedUtxoList
    ], async (tx) => {
      const minCol = Number(minCollateral(networkId));
      const maxCol = Number(maxCollateral(networkId));
      let calls = [];
      calls.push(db.utxoList.where("sc").equals(stakeCredRefIdEnt).toArray());
      calls.push(db.utxoList.where("sc").noneOf([stakeCredRefIdEnt, stakeCredRefIdExt]).toArray());
      calls.push(db.utxoList.where("sc").equals(stakeCredRefIdExt).toArray());
      calls.push(db.utxoListEpkOsk.toArray());
      calls.push(db.utxoList.where("c").between(minCol, maxCol, true, true).toArray());
      calls.push(db.lockedUtxoList.toArray());
      const data = await Promise.all(calls);
      const utxoListOpk = data[0];
      const utxoListOpkOsk = data[1];
      const utxoListOpkEsk = data[2];
      const utxoListEpkOsk = data[3];
      const utxoListCollateral = data[4];
      const lockedUtxoList = data[5];
      const balanceOpkMap = {};
      const balanceOpkOskMap = {};
      const balanceOpkEskMap = {};
      const balanceEpkOskMap = {};
      const balanceListOpk = [];
      const balanceListOpkOsk = [];
      const balanceListOpkEsk = [];
      const balanceListEpkOsk = [];
      const callsPre = [];
      callsPre.push(handleRefs(db, utxoListOpk, "opk"));
      callsPre.push(handleRefs(db, utxoListOpkOsk, "opkosk"));
      callsPre.push(handleRefs(db, utxoListOpkEsk, "opkesk"));
      callsPre.push(handleRefs(db, utxoListEpkOsk, "epkosk"));
      callsPre.push(handleRefs(db, utxoListCollateral, "opk"));
      await Promise.all(callsPre);
      for (const utxo of utxoListOpk) {
        if (appAccount.data.account.paymentScript || appAccount.data.account.stakeScript) {
          if (!isScriptAddress(utxo.output.address)) {
            continue;
          }
        }
        let balance = balanceOpkMap[utxo.sc];
        if (!balance) {
          balanceOpkMap[utxo.sc] = balance = createIUtxoBalance(0, utxo.sc.toString());
          balanceListOpk.push(balance);
        }
        if (balance) {
          addValueToValue(balance, utxo.output.amount);
          updateBalanceTotal(balance);
        }
      }
      for (const utxo of utxoListOpkOsk) {
        if (appAccount.data.account.paymentScript || appAccount.data.account.stakeScript) {
          if (!isScriptAddress(utxo.output.address)) {
            continue;
          }
        }
        let balance = balanceOpkOskMap[utxo.sc];
        if (!balance) {
          balanceOpkOskMap[utxo.sc] = balance = createIUtxoBalance(0, utxo.sc.toString());
          balanceListOpkOsk.push(balance);
        }
        if (balance) {
          addValueToValue(balance, utxo.output.amount);
          updateBalanceTotal(balance);
        }
      }
      for (const utxo of utxoListOpkEsk) {
        if (appAccount.data.account.paymentScript || appAccount.data.account.stakeScript) {
          if (!isScriptAddress(utxo.output.address)) {
            continue;
          }
        }
        let balance = balanceOpkEskMap[utxo.sc];
        if (!balance) {
          balanceOpkEskMap[utxo.sc] = balance = createIUtxoBalance(0, utxo.sc.toString());
          balanceListOpkEsk.push(balance);
        }
        if (balance) {
          addValueToValue(balance, utxo.output.amount);
          updateBalanceTotal(balance);
        }
      }
      for (const utxo of utxoListEpkOsk) {
        if (appAccount.data.account.paymentScript || appAccount.data.account.stakeScript) {
          if (!isScriptAddress(utxo.output.address)) {
            continue;
          }
        }
        let balance = balanceEpkOskMap[utxo.sc];
        if (!balance) {
          balanceEpkOskMap[utxo.sc] = balance = createIUtxoBalance(0, utxo.sc.toString());
          balanceListEpkOsk.push(balance);
        }
        if (balance) {
          addValueToValue(balance, utxo.output.amount);
          updateBalanceTotal(balance);
        }
      }
      const totalOpk = createIBalance();
      const totalOpkOsk = createIBalance();
      const totalOpkEsk = createIBalance();
      const totalEpkOsk = createIBalance();
      for (const balanceOpk of balanceListOpk) {
        addToBalance(totalOpk, balanceOpk, false);
        addToBalance(accountBalance, balanceOpk, false);
      }
      for (const rewardInfo of rewardInfoList) {
        addRewardsToBalance(totalOpkOsk, rewardInfo);
        addRewardsToBalance(accountBalance, rewardInfo);
      }
      for (const balanceOpkOsk of balanceListOpkOsk) {
        addToBalance(totalOpkOsk, balanceOpkOsk, true);
        addToBalance(accountBalance, balanceOpkOsk, true);
      }
      for (const balanceOpkEsk of balanceListOpkEsk) {
        addToBalance(totalOpkEsk, balanceOpkEsk, false);
        addToBalance(accountBalance, balanceOpkEsk, false);
      }
      for (const balanceEpkOsk of balanceListEpkOsk) {
        addToBalance(totalEpkOsk, balanceEpkOsk, false);
      }
      updateBalanceTotal(totalOpk);
      updateBalanceTotal(totalOpkOsk);
      updateBalanceTotal(totalOpkEsk);
      updateBalanceTotal(totalEpkOsk);
      accountBalance.coinOpk = totalOpk.total;
      accountBalance.stakeOpkOsk = totalOpkOsk.total;
      accountBalance.stakeOpkEsk = totalOpkEsk.total;
      accountBalance.stakeEpkOsk = totalEpkOsk.coin;
      updateBalanceTotal(accountBalance);
      const calls2 = [];
      if (!onlyUpdateBalance && rewardInfoList.length > 0) {
        calls2.push(db.rewardInfo.bulkPut(rewardInfoList));
      }
      calls2.push(db.balance.put(accountBalance));
      await Promise.all(calls2);
      const utxoMap = {
        opk: utxoListOpk,
        numOpk: utxoListOpk.length,
        opkosk: utxoListOpkOsk,
        numOpkOsk: utxoListOpkOsk.length,
        opkesk: utxoListOpkEsk,
        numOpkEsk: utxoListOpkEsk.length,
        epkosk: utxoListEpkOsk,
        numEpkOsk: utxoListEpkOsk.length,
        allOpk: [],
        // Don't merge all utxos here. We do that once in the main thread.
        collateral: utxoListCollateral.filter((utxo) => !utxo.output.amount.multiasset),
        locked: [],
        selected: appAccount.utxoMap.selected
      };
      if (utxoListOpk.length > MAX_UTXOS) {
        utxoMap.opk = trimUtxoList(utxoListOpk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (utxoListOpkOsk.length > MAX_UTXOS) {
        utxoMap.opkosk = trimUtxoList(utxoListOpkOsk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (utxoListOpkEsk.length > MAX_UTXOS) {
        utxoMap.opkesk = trimUtxoList(utxoListOpkEsk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (utxoListEpkOsk.length > MAX_UTXOS) {
        utxoMap.epkosk = trimUtxoList(utxoListEpkOsk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (lockedUtxoList.length > 0) {
        utxoMap.locked = lockedUtxoList[0].l;
      }
      if (utxoMap.collateral.length > MAX_COLLATERAL_UTXOS) {
        utxoMap.collateral.length = MAX_COLLATERAL_UTXOS;
      }
      return { utxoMap };
    }).catch((reason) => {
      error(reason);
      return { utxoMap: null };
    });
  });
};
const getUtxoMap = async (appAccount) => {
  const networkId = appAccount.data.state.networkId;
  const accountId = appAccount.id;
  const stakeCredRefIdEnt = await RefDB.addAndGetRefId(networkId, accountId, "enterprise");
  const stakeCredRefIdExt = await RefDB.addAndGetRefId(networkId, accountId, "external");
  return getDB$8(networkId, accountId).then((db) => {
    return db.transaction("rw", [
      db.balance,
      db.rewardInfo,
      db.ref,
      db.utxoList,
      db.utxoListEpkOsk,
      db.lockedUtxoList
    ], async (tx) => {
      const minCol = Number(minCollateral(networkId));
      const maxCol = Number(maxCollateral(networkId));
      let calls = [];
      calls.push(db.utxoList.where("sc").equals(stakeCredRefIdEnt).toArray());
      calls.push(db.utxoList.where("sc").noneOf([stakeCredRefIdEnt, stakeCredRefIdExt]).toArray());
      calls.push(db.utxoList.where("sc").equals(stakeCredRefIdExt).toArray());
      calls.push(db.utxoListEpkOsk.toArray());
      calls.push(db.utxoList.where("c").between(minCol, maxCol, true, true).toArray());
      calls.push(db.lockedUtxoList.toArray());
      const data = await Promise.all(calls);
      const utxoListOpk = data[0];
      const utxoListOpkOsk = data[1];
      const utxoListOpkEsk = data[2];
      const utxoListEpkOsk = data[3];
      const utxoListCollateral = data[4];
      const lockedUtxoList = data[5];
      const calls2 = [];
      calls2.push(handleRefs(db, utxoListOpk, "opk"));
      calls2.push(handleRefs(db, utxoListOpkOsk, "opkosk"));
      calls2.push(handleRefs(db, utxoListOpkEsk, "opkesk"));
      calls2.push(handleRefs(db, utxoListEpkOsk, "epkosk"));
      calls2.push(handleRefs(db, utxoListCollateral, "opk"));
      await Promise.all(calls2);
      const utxoMap = {
        opk: utxoListOpk,
        numOpk: utxoListOpk.length,
        opkosk: utxoListOpkOsk,
        numOpkOsk: utxoListOpkOsk.length,
        opkesk: utxoListOpkEsk,
        numOpkEsk: utxoListOpkEsk.length,
        epkosk: utxoListEpkOsk,
        numEpkOsk: utxoListEpkOsk.length,
        allOpk: [],
        // Don't merge all utxos here. We do that once in the main thread.
        collateral: utxoListCollateral.filter((utxo) => !utxo.output.amount.multiasset),
        locked: [],
        selected: appAccount.utxoMap.selected
      };
      if (utxoListOpk.length > MAX_UTXOS) {
        utxoMap.opk = trimUtxoList(utxoListOpk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (utxoListOpkOsk.length > MAX_UTXOS) {
        utxoMap.opkosk = trimUtxoList(utxoListOpkOsk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (utxoListOpkEsk.length > MAX_UTXOS) {
        utxoMap.opkesk = trimUtxoList(utxoListOpkEsk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (utxoListEpkOsk.length > MAX_UTXOS) {
        utxoMap.epkosk = trimUtxoList(utxoListEpkOsk, MIN_ADA_ONLY_UTXOS, MAX_UTXOS);
      }
      if (lockedUtxoList.length > 0) {
        utxoMap.locked = lockedUtxoList[0].l;
      }
      if (utxoMap.collateral.length > MAX_COLLATERAL_UTXOS) {
        utxoMap.collateral.length = MAX_COLLATERAL_UTXOS;
      }
      return { utxoMap };
    }).catch((reason) => {
      error(reason);
      return { utxoMap: null };
    });
  });
};
const AccountDB$1 = {
  getKeys,
  getState,
  getSettings: getSettings$1,
  getBalance: getBalance$1,
  getRewardInfo,
  getRewardHistory: getRewardHistory$1,
  getRewardHistoryCount: getRewardHistoryCount$1,
  // getTxHashList,
  getTxHashKeyList,
  getTxHashListCount,
  getMaxSlotNo,
  getUtxoMap,
  getReportList,
  bulkPutReportList,
  putKeys,
  putState,
  putSettings: putSettings$1,
  putBalance: putBalance$1,
  putRewardInfo,
  // putTxHash,
  // bulkPutTxHashList,
  bulkAddTxHashList,
  // bulkFilterTxHashes,
  bulkAddRewardHistory,
  wipeAccountData,
  createAccountData,
  getAccountData,
  getDB: getDB$8,
  removeDB: removeDB$1,
  putSyncUpdate
};

const onWalletListUpdated = "onWalletListUpdated";
const onAccountSyncInfoUpdated = "onAccountSyncInfoUpdated";
const onAccountDataUpdated = "onAccountDataUpdated";
const onFirstAccountDataUpdated = "onFirstAccountDataUpdated";
const onAccountSettingsUpdated = "onAccountSettingsUpdated";
const doReloadWalletList = "doReloadWalletList";
const doRemoveAccount = "doRemoveAccount";
const doSyncAllAccounts = "doSyncAllAccounts";
const doForceSyncAllAccounts = "doForceSyncAllAccounts";
const doFullWalletResync = "doFullWalletResync";
const doFullAccountResync = "doFullAccountResync";
const doToggleManualSyncForAllAccounts = "doToggleManualSyncForAllAccounts";
const onWalletSettingsUpdated = "onWalletSettingsUpdated";
const onAccountRemoved = "onAccountRemoved";
const onRemoveAllAccountsFromSync = "onRemoveAllAccountsFromSync";
const onTxHistoryAccountUpdated = "onTxHistoryAccountUpdated";

const toidMap = /* @__PURE__ */ new Map();
const updateSelectedId$1 = (appAccount, selectedAccountId) => {
  appAccount.isSelectedAccount = appAccount.data.account.id === selectedAccountId;
};
const updateDappId$1 = (appAccount, dappAccountId) => {
  appAccount.isDappAccount = appAccount.data.account.id === dappAccountId && isDAppSupported(appAccount.data.account.signType);
};
const setInitializingManual = (appAccount, timeStampOffset = 0) => {
  clearTimeout(toidMap.get(appAccount.id) ?? -1);
  const syncInfo = appAccount.syncInfo;
  syncInfo.isInitializing = true;
  syncInfo.state = SyncState.initializing;
  syncInfo.stateTimestamp = Date.now() - timeStampOffset;
  syncInfo.error = null;
  dispatchSignalSyncTo(appAccount.walletId, onAccountSyncInfoUpdated, appAccount, true);
};
const setIdleManual = (appAccount, timeStampOffset = 0) => {
  clearTimeout(toidMap.get(appAccount.id) ?? -1);
  const syncInfo = appAccount.syncInfo;
  syncInfo.isInitializing = true;
  syncInfo.state = SyncState.idle;
  syncInfo.stateTimestamp = appAccount.data.state.lastTimestamp;
  syncInfo.error = null;
  dispatchSignalSyncTo(appAccount.walletId, onAccountSyncInfoUpdated, appAccount, true);
};
const saveAccountSettings = async (appAccount) => {
  await AccountDB$1.putSettings(json(appAccount.data.settings));
  dispatchSignalSync(onAccountSettingsUpdated, appAccount);
  dispatchSignalSync(doSendUpdateAccountData, appAccount.id, appAccount.walletId);
  return true;
};

const getDappWalletId = (networkId) => getRef("dappWalledId_" + networkId);
const getDappAccountId = (networkId) => getRef("dappAccountId_" + networkId);
const getDappAccountUpdated = (networkId) => getRef("dappAccountUpdated_" + networkId);
const setDappAccountUpdated = (networkId, value) => {
  getDappAccountUpdated(networkId).value = value;
  forceSetLS("dappAccountUpdated_" + networkId, value);
};
const getFixedDappWalletId = (networkId) => getRef("fixedDappWalledId_" + networkId);
const getFixedDappAccountId = (networkId) => getRef("fixedDappAccountId_" + networkId);
const getSelectedAccountId = (networkId) => getRef("selectedAccountId_" + networkId);
const getSelectedWalletId = (networkId) => getRef("selectedWalletId_" + networkId);

const dappConnectionsEnabled = useLocalStorage("dappConnectionsEnabled", true, { listenToStorageChanges: true });
const showDappConnector = useLocalStorage("showDappConnector", false, { listenToStorageChanges: true });
const fixedDappWalletId = computed(() => getFixedDappWalletId(networkId$9.value).value);
const fixedDappAccountId = computed(() => getFixedDappAccountId(networkId$9.value).value);
const rawDappWalletId = computed(() => getDappWalletId(networkId$9.value).value);
const rawDappAccountId = computed(() => getDappAccountId(networkId$9.value).value);
const dappWalletId$1 = computed(() => {
  if (showDappConnector.value && !dappConnectionsEnabled.value) {
    return "";
  }
  return fixedDappWalletId.value || rawDappWalletId.value;
});
const dappAccountId$1 = computed(() => {
  if (showDappConnector.value && !dappConnectionsEnabled.value) {
    return "";
  }
  return fixedDappAccountId.value || rawDappAccountId.value;
});
const dappAccountUpdated = getDappAccountUpdated(networkId$9.value);
const isDappAccountEnabled = computed(() => !showDappConnector.value || !!dappConnectionsEnabled.value);
const isDappAccountSet = computed(() => !!dappAccountId$1.value);
const __toggleDappConnectionsEnabled = () => {
  dappConnectionsEnabled.value = !dappConnectionsEnabled.value;
  setDappAccountUpdated(networkId$9.value, Date.now().toString());
};
watch(showDappConnector, () => {
  if (!showDappConnector.value) {
    dappConnectionsEnabled.value = true;
  }
  setDappAccountUpdated(networkId$9.value, Date.now().toString());
}, { immediate: true });

const toggleFixedDappAccountId = (walletId, accountId) => dispatchSignalSync(doToggleFixedDappAccountId, walletId, accountId);
function useDappAccount() {
  return {
    dappAccountId: dappAccountId$1,
    dappWalletId: dappWalletId$1,
    dappAccountUpdated,
    isDappAccountSet,
    isDappAccountEnabled,
    showDappConnector,
    toggleFixedDappAccountId,
    toggleDappAccountEnabled: __toggleDappConnectionsEnabled
  };
}

const _walletId = ref$1(getSelectedWalletId(networkId$9.value).value);
const _accountId = ref$1(getSelectedAccountId(networkId$9.value).value);
const selectedWalletId$1 = computed(() => _walletId.value);
const selectedAccountId$1 = computed(() => _accountId.value);
computed(() => {
  const lsRef = getSelectedWalletId(networkId$9.value);
  const lsValue = lsRef.value;
  return lsValue;
});
computed(() => {
  const lsRef = getSelectedAccountId(networkId$9.value);
  const lsValue = lsRef.value;
  return lsValue;
});

const switchWalletAccount = (walletId, accountId) => {
  dispatchSignalSync(doSwitchSelectedWalletAccount, walletId, accountId);
};
function useSelectedAccount() {
  return {
    selectedAccountId: selectedAccountId$1,
    selectedWalletId: selectedWalletId$1,
    switchWalletAccount
  };
}

const ErrorBuildTx = {
  notNecessaryCU: "ErrorBuildTx.notNecessaryCU",
  notNecessaryTF: "ErrorBuildTx.notNecessaryTF",
  notNecessaryCS: "ErrorBuildTx.notNecessaryCS",
  missingAddress: "ErrorBuildTx.missingAddress",
  valueIsZero: "ErrorBuildTx.valueIsZero",
  valueTooLow: "ErrorBuildTx.valueTooLow",
  notAtLeastOneUtxo: "ErrorBuildTx.notAtLeastOneUtxo",
  notEnoughUtxos: "ErrorBuildTx.notEnoughUtxos",
  notEnoughAda: "ErrorBuildTx.notEnoughAda",
  couldNotCoverFee: "ErrorBuildTx.couldNotCoverFee",
  couldNotCoverAmount: "ErrorBuildTx.couldNotCoverAmount",
  tokenNotFound: "ErrorBuildTx.tokenNotFound",
  notEnoughTokens: "ErrorBuildTx.notEnoughTokens",
  tooManyAssets: "ErrorBuildTx.tooManyAssets",
  utxoSizeScriptRef: "ErrorBuildTx.utxoSizeScriptRef",
  utxoSizePlutusData: "ErrorBuildTx.utxoSizePlutusData",
  missingBurnAddress: "ErrorBuildTx.missingBurnAddress",
  missingPoolId: "ErrorBuildTx.missingPoolId",
  missingStakeInfo: "ErrorBuildTx.missingStakeInfo",
  missingAccountData: "ErrorBuildTx.missingAccountData",
  maxBudgetReached: "ErrorBuildTx.maxBudgetReached",
  noActiveDRep: "ErrorBuildTx.noActiveDRep"};

const _cborSizeMap = {};
const _scoreMap = {};
const sortInputListByScore = (utxoList, txFeePerByte, bundleSize) => {
  for (const utxo of utxoList) {
    const hash = getUtxoHash(utxo.input);
    if (_scoreMap[hash] > 0) {
      utxo.score = _scoreMap[hash];
      continue;
    }
    const cborSize = getUtxoCborSize(utxo.output, hash);
    let score = parseFloat(divide(subtract(utxo.output.amount.coin, cborSize * txFeePerByte), 1e6, 3));
    if (bundleSize > 0) {
      const multiasset = utxo.output.amount.multiasset;
      if (multiasset) {
        let numAssets = getNumAssets2(multiasset);
        if (numAssets === 0) numAssets = 1;
        score = score * (bundleSize / numAssets);
      } else {
        score = score * bundleSize;
      }
    }
    _scoreMap[hash] = score;
    utxo.score = score;
  }
  utxoList.sort((a, b) => compare$1(
    _scoreMap[getUtxoHash(a.input)],
    "<",
    _scoreMap[getUtxoHash(b.input)]
  ) ? -1 : 1);
};
const getUtxoCborSize = (output, hash) => {
  let cborSize = 0;
  if (hash) {
    cborSize = _cborSizeMap[hash] ?? 0;
    if (cborSize > 0) {
      return cborSize;
    }
  }
  const size = getTransactionOutputSize(output);
  if (hash) {
    _cborSizeMap[hash] = size;
  }
  return size;
};
const getNumAssets2 = (multiasset) => {
  let numAssets = 0;
  if (multiasset) {
    const multiAssetList = Object.entries(multiasset);
    for (const multiAsset of multiAssetList) {
      const assetList = Object.entries(multiAsset[1]);
      numAssets += assetList.length;
    }
  }
  return numAssets;
};

const getMinUtxo = (output, utxoCostPerSize, isAtLeastEraBabbage, hash, setMinValueIfNeeded = false) => {
  if (!output || !isAtLeastEraBabbage) {
    return getMinUtxoBeforeBabbage(output?.amount.multiasset, utxoCostPerSize);
  }
  let cborSize = getUtxoCborSize(output, hash);
  let minUtxoValue = ((cborSize + 160) * utxoCostPerSize).toString();
  if (compare$1(output.amount.coin, "<", minUtxoValue)) {
    const current = output.amount.coin;
    output.amount.coin = minUtxoValue;
    cborSize = getUtxoCborSize(output, hash);
    minUtxoValue = ((cborSize + 160) * utxoCostPerSize).toString();
    if (setMinValueIfNeeded) {
      output.amount.coin = minUtxoValue;
    } else {
      output.amount.coin = current;
    }
  }
  output.cborSize = cborSize;
  return minUtxoValue;
};
const getMinUtxoPlusExtra = (output, utxoCostPerSize, isAtLeastEraBabbage) => {
  const min = getMinUtxo(output, utxoCostPerSize, isAtLeastEraBabbage);
  return add(min, Math.min(2e6, Math.floor(parseFloat(multiply(min, 1.1)))));
};
const getMinUtxoBeforeBabbage = (multiAsset, utxoCostPerSize) => {
  const k1 = 6;
  const k2 = 12;
  const k3 = 28;
  const k4 = 8;
  const utxoEntrySizeWithoutVal = 27;
  const adaOnlyUTxOSize = 29;
  let minUtxo = utxoCostPerSize * adaOnlyUTxOSize;
  if (!multiAsset) return minUtxo.toString();
  const multiAssetList = Object.entries(multiAsset);
  let numAssets = 0;
  let assetNameSet = /* @__PURE__ */ new Set();
  for (const multiAsset2 of multiAssetList) {
    const assetList = Object.entries(multiAsset2[1]);
    for (const asset of assetList) {
      const assetName = asset[0];
      asset[1];
      assetNameSet.add(assetName);
      numAssets++;
    }
  }
  const sumAssetNameLengths = Array.from(assetNameSet).reduce((acc, val) => acc + val.length, 0) / 2;
  const roundupBytesToWords = Math.floor((numAssets * k2 + sumAssetNameLengths + multiAssetList.length * k3 + (k4 - 1)) / k4);
  const tokenBundleSize = k1 + roundupBytesToWords;
  const minAda = Math.floor(minUtxo / adaOnlyUTxOSize) * (utxoEntrySizeWithoutVal + tokenBundleSize);
  if (minAda > Number(minUtxo)) {
    minUtxo = minAda;
  }
  return minUtxo.toString();
};

const getSplitOutput = (address, splitOutputList, maxValueSize, force = false) => {
  if (splitOutputList.length === 0 || force) {
    let splitOutput = createTransactionOutputJSON();
    splitOutput.address = address;
    splitOutput.amount.multiasset = {};
    splitOutputList.push(splitOutput);
    return splitOutput;
  } else {
    let splitOutput = splitOutputList[splitOutputList.length - 1];
    const cborSize = getUtxoCborSize(splitOutput);
    if (cborSize > maxValueSize) {
      splitOutput = createTransactionOutputJSON();
      splitOutput.address = address;
      splitOutput.amount.multiasset = {};
      splitOutputList.push(splitOutput);
    }
    return splitOutput;
  }
};
const getTFOutput = (address, splitOutputList, bundleSize, maxValueSize, force = false, coin = "0") => {
  if (splitOutputList.length === 0 || force) {
    let splitOutput = createTransactionOutputJSON();
    splitOutput.address = address;
    if (force) {
      splitOutput.amount.coin = coin;
    } else {
      splitOutput.amount.multiasset = {};
    }
    splitOutputList.push(splitOutput);
    return splitOutput;
  } else {
    let splitOutput = splitOutputList[splitOutputList.length - 1];
    const cborSize = getUtxoCborSize(splitOutput);
    const numAssets = getNumAssets2(splitOutput.amount.multiasset);
    if (cborSize > maxValueSize || numAssets > bundleSize) {
      splitOutput = createTransactionOutputJSON();
      splitOutput.address = address;
      splitOutput.amount.multiasset = {};
      splitOutputList.push(splitOutput);
    }
    return splitOutput;
  }
};
const splitLargeOutputMin = (epochParams, output) => {
  if (!epochParams) {
    return [];
  }
  if (!output.amount.multiasset) {
    return [];
  }
  const utxoCostPerSize = epochParams.utxoCostPerSize;
  const isAtLeastBabbageEra = epochParams.isAtLeastBabbageEra;
  const maxValueSize = epochParams.maxValueSize - 100;
  const splitOutputList = [];
  if (output.script_ref) {
    throw ErrorBuildTx.utxoSizeScriptRef;
  }
  if (output.plutus_data) {
    throw ErrorBuildTx.utxoSizePlutusData;
  }
  let splitOutput = getSplitOutput(output.address, splitOutputList, maxValueSize);
  let to = splitOutput.amount.multiasset;
  const multiAssetList = Object.entries(output.amount.multiasset);
  for (const multiAsset of multiAssetList) {
    const policyId = multiAsset[0];
    const assetList = Object.entries(multiAsset[1]);
    for (const asset of assetList) {
      const assetName = asset[0];
      const quantity = asset[1];
      if (!to[policyId]) {
        to[policyId] = {};
      }
      to[policyId][assetName] = quantity;
      const newSplitOutput = getSplitOutput(output.address, splitOutputList, maxValueSize);
      if (newSplitOutput !== splitOutput) {
        delete to[policyId][assetName];
        trimMultiAsset(to);
        splitOutput = newSplitOutput;
        to = splitOutput.amount.multiasset;
        if (!to[policyId]) {
          to[policyId] = {};
        }
        to[policyId][assetName] = quantity;
      }
    }
  }
  for (let i = splitOutputList.length - 1; i >= 0; i--) {
    const splitOutput2 = splitOutputList[i];
    trimMultiAsset(splitOutput2.amount.multiasset);
    if (!splitOutput2.amount.multiasset) {
      splitOutputList.splice(i, 1);
      continue;
    }
    splitOutput2.amount.coin = getMinUtxo(splitOutput2, utxoCostPerSize, isAtLeastBabbageEra);
  }
  return splitOutputList;
};
const splitTokenFragmentation = (output, bundleSize, epochParams, numAdaOnlyUtxos, createCollateral = false, allowOutputSplitting = false) => {
  if (!epochParams) {
    return [];
  }
  if (output.script_ref) {
    return [];
  }
  if (output.plutus_data) {
    return [];
  }
  const tfOutputList = [];
  const numAssets = getNumAssets2(output.amount.multiasset);
  const maxNumAssets = bundleSize * 1.2;
  if (numAssets < maxNumAssets) {
    if (numAssets === 0 && tfOutputList.length > 0) {
      createSplitAdaOnlyOutput(epochParams, output.amount.coin, output.address, tfOutputList, epochParams.utxoCostPerSize, epochParams.isAtLeastBabbageEra, numAdaOnlyUtxos, createCollateral, allowOutputSplitting);
    }
    return tfOutputList;
  }
  const utxoCostPerSize = epochParams.utxoCostPerSize;
  const isAtLeastBabbageEra = epochParams.isAtLeastBabbageEra;
  const maxValueSize = epochParams.maxValueSize - 100;
  let coin = output.amount.coin;
  let tfOutput = getTFOutput(output.address, tfOutputList, bundleSize, maxValueSize);
  let to = tfOutput.amount.multiasset;
  const multiAssetList = Object.entries(output.amount.multiasset);
  for (const multiAsset of multiAssetList) {
    const policyId = multiAsset[0];
    const assetList = Object.entries(multiAsset[1]);
    for (const asset of assetList) {
      const assetName = asset[0];
      const quantity = asset[1];
      if (!to[policyId]) {
        to[policyId] = {};
      }
      to[policyId][assetName] = quantity;
      const newTfOutput = getTFOutput(output.address, tfOutputList, bundleSize, maxValueSize);
      if (newTfOutput !== tfOutput) {
        delete to[policyId][assetName];
        trimMultiAsset(to);
        tfOutput = newTfOutput;
        to = tfOutput.amount.multiasset;
        if (!to[policyId]) {
          to[policyId] = {};
        }
        to[policyId][assetName] = quantity;
      }
    }
  }
  for (const tfOutput2 of tfOutputList) {
    trimMultiAsset(tfOutput2.amount.multiasset);
    tfOutput2.amount.coin = getMinUtxoPlusExtra(tfOutput2, utxoCostPerSize, isAtLeastBabbageEra);
    coin = subtract(coin, tfOutput2.amount.coin);
  }
  createSplitAdaOnlyOutput(epochParams, coin, output.address, tfOutputList, utxoCostPerSize, isAtLeastBabbageEra, numAdaOnlyUtxos, createCollateral, allowOutputSplitting);
  return tfOutputList;
};
const createSplitAdaOnlyOutput = (epochParams, coin, outputAddress, tfOutputList, utxoCostPerSize, isAtLeastBabbageEra, numAdaOnlyUtxos, createCollateral = false, allowOutputSplitting = false) => {
  if (!isGreaterThanZero(coin)) {
    return;
  }
  const minUtxo = createTransactionOutputJSON({ address: outputAddress, amount: { coin: "0" } });
  const adaOnlyMinUtxoValue = getMinUtxo(minUtxo, utxoCostPerSize, isAtLeastBabbageEra, void 0, true);
  if (tfOutputList.length > 0 && compare$1(coin, "<", adaOnlyMinUtxoValue)) {
    tfOutputList[tfOutputList.length - 1].amount.coin = add(tfOutputList[tfOutputList.length - 1].amount.coin, coin);
    return;
  }
  if (createCollateral) {
    const minCol = minCollateral(epochParams.networkId);
    if (compare$1(coin, "<", minCol)) {
      getTFOutput(outputAddress, tfOutputList, 0, 0, true, coin);
      return;
    } else {
      getTFOutput(outputAddress, tfOutputList, 0, 0, true, minCol);
      coin = subtract(coin, minCol);
    }
  }
  if (tfOutputList.length > 0 && compare$1(coin, "<", adaOnlyMinUtxoValue)) {
    tfOutputList[tfOutputList.length - 1].amount.coin = add(tfOutputList[tfOutputList.length - 1].amount.coin, coin);
    return;
  }
  if (!allowOutputSplitting || numAdaOnlyUtxos >= 6 || compare$1(coin, "<", "20000000")) {
    getTFOutput(outputAddress, tfOutputList, 0, 0, true, coin);
    return;
  }
  let numSplits = 0;
  while (numSplits < 3 && compare$1(coin, ">=", "20000000")) {
    const coinSplit = divide(coin, 2, 0);
    getTFOutput(outputAddress, tfOutputList, 0, 0, true, coinSplit);
    coin = subtract(coin, coinSplit);
    numSplits++;
  }
  getTFOutput(outputAddress, tfOutputList, 0, 0, true, coin);
};

var ITransactionState = /* @__PURE__ */ ((ITransactionState2) => {
  ITransactionState2[ITransactionState2["None"] = 0] = "None";
  ITransactionState2[ITransactionState2["SIGNED"] = 1] = "SIGNED";
  ITransactionState2[ITransactionState2["SUBMITTED"] = 2] = "SUBMITTED";
  ITransactionState2[ITransactionState2["INVALID"] = 4] = "INVALID";
  ITransactionState2[ITransactionState2["EXPIRED"] = 8] = "EXPIRED";
  ITransactionState2[ITransactionState2["ON_CHAIN"] = 16] = "ON_CHAIN";
  return ITransactionState2;
})(ITransactionState || {});
const checkStateFlag = (value, flag) => {
  if (!value) {
    return false;
  }
  return (value & flag) !== 0;
};
const isInvalidState = (status) => checkStateFlag(status, 4 /* INVALID */);
const isExpiredState = (status) => checkStateFlag(status, 8 /* EXPIRED */);
const isSubmittedState = (status) => checkStateFlag(status, 2 /* SUBMITTED */);
const isSignedState = (status) => checkStateFlag(status, 1 /* SIGNED */);
const isOnChainState = (status) => checkStateFlag(status, 16 /* ON_CHAIN */);
const setInvalidState = (tx, isSet = true) => setITransactionState(tx, 4 /* INVALID */, isSet);
const setExpiredState = (tx, isSet = true) => setITransactionState(tx, 8 /* EXPIRED */, isSet);
const setSubmittedState = (tx, isSet = true) => setITransactionState(tx, 2 /* SUBMITTED */, isSet);
const setSignedState = (tx, isSet = true) => setITransactionState(tx, 1 /* SIGNED */, isSet);
const setOnChainState = (tx, isSet = true) => setITransactionState(tx, 16 /* ON_CHAIN */, isSet);
const setITransactionState = (tx, statusFlag, value) => {
  if (!tx.state) {
    tx.state = 0 /* None */;
  }
  if (value === 0 || !value) {
    tx.state = unsetStatusFlag(tx.state, statusFlag);
  } else {
    tx.state = setStatusFlag(tx.state, statusFlag);
  }
};
const setStatusFlag = (status, flag) => {
  return status | flag;
};
const unsetStatusFlag = (status, flag) => {
  return status & ~flag;
};

const _accountTxConfigMap = {};
const _accountTxMap = {};
const _accountBuiltTxMap = {};
const _accountBuiltTxBalanceMap = {};
const createTransactionJSON = () => {
  return reactive({
    hash: "",
    size: 0,
    time: 0,
    body: {
      inputs: [],
      outputs: [],
      fee: "0"
    },
    is_valid: false,
    state: ITransactionState.None,
    witness_set: {}
  });
};
const createITxBuildConfig = (txIndex) => {
  return reactive({
    txIndex,
    metadataPassword: null,
    metadata674Lines: [],
    maxCoinOutputIndex: -1,
    consumeAllInputs: false,
    forceSendAll: false,
    forceWithdrawal: false,
    allowUtxoManagement: false,
    addDonation: false
  });
};
const _resetTx = (tx, ref) => {
  tx.body = {
    inputs: [],
    outputs: [],
    fee: "0"
  };
  tx.is_valid = false;
  tx.witness_set = {};
  tx.time = 0;
  if (tx.auxiliary_data) {
    delete tx.auxiliary_data;
  }
  if (tx.inputUtxoList) {
    delete tx.inputUtxoList;
  }
  if (tx.outputData) {
    delete tx.outputData;
  }
  if (tx.colOutputDataList) {
    delete tx.colOutputDataList;
  }
  if (tx.state) {
    delete tx.state;
  }
  if (tx.hasConwaySetTag) {
    delete tx.hasConwaySetTag;
  }
  if (tx.cbor) {
    delete tx.cbor;
  }
  if (tx.unknownInputUtxoList) {
    delete tx.unknownInputUtxoList;
  }
  tx.size = 0;
  tx.hash = "";
  return tx;
};
const _resetTxConfig = (txconfig) => {
  txconfig.metadataPassword = null;
  txconfig.metadata674Lines = [];
  return txconfig;
};
const _resetTxBalance = (txBalance) => {
  txBalance.hash = "";
  txBalance.slot = -1;
  txBalance.idx = -1;
  txBalance.coin = "0";
  txBalance.c = 0;
  txBalance.al = [];
  txBalance.t = ITxBalanceType.uninitialized;
  return txBalance;
};
const createTx = (accountId, index = 0, reset = false) => {
  if (!_accountTxMap[accountId]) {
    _accountTxMap[accountId] = reactive([]);
    _accountBuiltTxMap[accountId] = reactive([]);
    _accountBuiltTxBalanceMap[accountId] = reactive([]);
    _accountTxConfigMap[accountId] = reactive([]);
  }
  if (_accountTxMap[accountId].length < index + 1) {
    for (let i = _accountTxMap[accountId].length; i < index + 1; i++) {
      _accountTxMap[accountId].push(createTransactionJSON());
      _accountBuiltTxMap[accountId].push(createTransactionJSON());
      _accountBuiltTxBalanceMap[accountId].push(createITxBalance());
      _accountTxConfigMap[accountId].push(createITxBuildConfig(i));
    }
  }
  if (reset) {
    const tx = _accountTxMap[accountId][index];
    const builtTx = _accountBuiltTxMap[accountId][index];
    const builtTxBalance = _accountBuiltTxBalanceMap[accountId][index];
    const txBuildConfig = _accountTxConfigMap[accountId][index];
    _resetTx(tx);
    _resetTx(builtTx);
    _resetTxConfig(txBuildConfig);
    _resetTxBalance(builtTxBalance);
  }
  return {
    tx: _accountTxMap[accountId][index],
    config: _accountTxConfigMap[accountId][index],
    builtTx: _accountBuiltTxMap[accountId][index],
    builtTxBalance: _accountBuiltTxBalanceMap[accountId][index]
  };
};
const createTxList = (accountId, index = 0) => {
  if (!accountId) {
    return [];
  }
  createTx(accountId, index);
  return _accountTxMap[accountId];
};
const createBuiltTxList = (accountId) => {
  if (!accountId) {
    return [];
  }
  createTx(accountId);
  return _accountBuiltTxMap[accountId];
};
const getStagingTxList = (accountId) => {
  if (!accountId) {
    return [];
  }
  const list = createTxList(accountId);
  return list;
};
const getBuiltTxList = (accountId) => {
  if (!accountId) {
    return [];
  }
  const list = createBuiltTxList(accountId);
  return list;
};

const storeId$8 = "accountBalancesStore";
const _balancesMap = /* @__PURE__ */ new Map();
const _rewardsLocked = {};
const getIAccountBalances = (accountId, balances) => {
  if (balances && !_balancesMap.has(accountId)) {
    _balancesMap.set(accountId, reactive(balances));
  }
  const _balances = _balancesMap.get(accountId);
  if (!_balances) {
    throw "getIAccountBalances";
  }
  return _balances;
};
const updatePendingBalance = (appAccount) => {
  if (!appAccount.isSelectedAccount && !appAccount.isDappAccount) {
    return;
  }
  let {
    pendingInputList,
    pendingOutputList
  } = cachePendingUtxoList(appAccount);
  if (appAccount.utxoMap.selected.length > 0) {
    pendingInputList = pendingInputList.concat();
    pendingOutputList = pendingOutputList.concat();
    filterUtxosByMustInclude(pendingInputList, appAccount.utxoMap.selected);
    filterUtxosByMustInclude(pendingOutputList, appAccount.utxoMap.selected);
  }
  const balances = getIAccountBalances(appAccount.id);
  clearBalance(balances.pending);
  if (pendingInputList.length > 0) {
    addUtxosToBalance(balances.pending, pendingInputList, true);
  }
  if (pendingOutputList.length > 0) {
    addUtxosToBalance(balances.pending, pendingOutputList);
  }
};
const updateBalances = (appAccount) => {
  const accountId = appAccount.id;
  const accountData = appAccount.data;
  const balances = getIAccountBalances(appAccount.id);
  const info = appAccount.data.rewardInfoList[0];
  const isRewardsLocked = _rewardsLocked[accountId] || !accountData.settings.aw.enabled || !(info && info.hasActiveDRep);
  const {
    selectedUtxoList,
    lockedUtxoList,
    collateralUtxoList
  } = getUtxos(appAccount);
  if (appAccount.utxoMap.selected.length > 0) {
    filterUtxosByMustInclude(lockedUtxoList, appAccount.utxoMap.selected);
    filterUtxosByMustInclude(collateralUtxoList, appAccount.utxoMap.selected);
  }
  clearIAccountBalances(balances);
  addUtxosToBalance(balances.selected, selectedUtxoList);
  addUtxosToBalance(balances.locked, lockedUtxoList);
  updatePendingBalance(appAccount);
  addToBalance(balances.lockedWithCollateral, balances.locked);
  if (collateralUtxoList.length > 0) {
    const collateralUtxo = collateralUtxoList[0];
    addUtxosToBalance(balances.collateral, [collateralUtxo]);
    if (!lockedUtxoList.some((utxo) => getUtxoHash(utxo.input) === getUtxoHash(collateralUtxo.input))) {
      addUtxosToBalance(balances.lockedWithCollateral, [collateralUtxo]);
    }
  }
  addToBalance(balances.account, appAccount.data.balance, true, true);
  let stagingTxList = getStagingTxList(accountId);
  let builtTxList = getBuiltTxList(accountId);
  for (let txIndex = 0; txIndex < stagingTxList.length; txIndex++) {
    let stagingTx = stagingTxList[txIndex];
    let builtTx = stagingTx;
    if (txIndex < builtTxList.length) {
      builtTx = builtTxList[txIndex];
    }
    let stagingOutputList = stagingTx.body.outputs;
    builtTx.body.outputs;
    let isOneOutputZero = false;
    for (let outputIndex = 0; outputIndex < stagingOutputList.length; outputIndex++) {
      let outputBuilt = stagingOutputList[outputIndex];
      if (isZero(outputBuilt.amount.coin)) {
        isOneOutputZero = true;
      }
      addValueToValue(balances.allOutputs, outputBuilt.amount);
    }
    if (!isOneOutputZero) {
      addValueToValue(balances.txFees, { coin: builtTx.body.fee });
    }
  }
  updateBalanceTotal(balances.allOutputs);
  updateBalanceTotal(balances.txFees);
  if (isZero(balances.selected.coin)) {
    addToBalance(balances.available, {
      coin: balances.account.coin,
      multiasset: balances.account.multiasset,
      rewards: "0"}, false);
  } else {
    addToBalance(balances.available, balances.selected);
  }
  addToBalance(balances.available, {
    coin: "0",
    rewards: balances.account.rewards}, true);
  updateBalanceTotal(balances.available);
  const multiassetOutput = createTransactionOutputJSON({
    address: getDonationAddress(networkId$9.value),
    amount: {
      coin: "0",
      multiasset: {}
      // empty first
    }
  });
  addValueToValue(multiassetOutput.amount, { coin: "0", multiasset: balances.available.multiasset });
  if (isZero(balances.selected.coin)) {
    for (const lockedUtxo of lockedUtxoList) {
      addValueToValue(multiassetOutput.amount, lockedUtxo.output.amount, true);
    }
  }
  multiassetOutput.amount.coin = "0";
  decreaseBalance(balances.available, balances.allOutputs, true, true);
  addValueToValue(multiassetOutput.amount, { coin: "0", multiasset: balances.allOutputs.multiasset }, true);
  try {
    let minUtxoValue = "0";
    const epochParams = checkEpochParams(networkId$9.value);
    const splitOutputList = splitLargeOutputMin(epochParams, multiassetOutput);
    for (const splitOutput of splitOutputList) {
      minUtxoValue = add(minUtxoValue, splitOutput.amount.coin);
    }
    addValueToValue(balances.lockedByTokens, { coin: minUtxoValue });
  } catch (err) {
    console.error(el(storeId$8), sl("updateBalances"), err);
  }
  updateBalanceTotal(balances.lockedByTokens);
  addToBalance(balances.lockedTotal, balances.lockedByTokens);
  if (isRewardsLocked) {
    balances.lockedByRewards.coin = "0";
    balances.lockedByRewards.rewards = balances.account.rewards;
    balances.lockedByRewards.total = balances.account.rewards;
    addToBalance(balances.lockedTotal, balances.lockedByRewards);
  }
  addToBalance(balances.lockedTotal, balances.locked);
  updateBalanceTotal(balances.lockedTotal);
  addToBalance(balances.lockedAvailable, balances.available);
  if (selectedUtxoList.length === 0) {
    addToBalance(balances.lockedAvailable, balances.pending);
  }
  decreaseBalance(balances.lockedAvailable, balances.lockedTotal, true, true);
  try {
    let minUtxoValue = "0";
    const epochParams = checkEpochParams(networkId$9.value);
    const bundleSize = accountData.settings.tf.bundleSize;
    const splitOutputList = splitTokenFragmentation(
      multiassetOutput,
      bundleSize,
      epochParams,
      0,
      collateralUtxoList.length < 3 && accountData.settings.collateral.enabled
    );
    if (splitOutputList.length > 0) {
      for (const splitOutput of splitOutputList) {
        if (splitOutput.amount.multiasset) {
          minUtxoValue = add(minUtxoValue, splitOutput.amount.coin);
        }
      }
      addValueToValue(balances.lockedByTokensTF, { coin: minUtxoValue });
    } else {
      addToBalance(balances.lockedByTokensTF, balances.lockedByTokens);
    }
  } catch (err) {
    console.error(el(storeId$8), sl("updateBalances"), err);
  }
  updateBalanceTotal(balances.lockedByTokensTF);
  addToBalance(balances.lockedTotalTF, balances.lockedByTokensTF);
  if (isRewardsLocked) {
    addToBalance(balances.lockedTotalTF, balances.lockedByRewards);
  }
  addToBalance(balances.lockedTotalTF, balances.locked);
  updateBalanceTotal(balances.lockedTotalTF);
  addToBalance(balances.lockedAvailableTF, balances.available);
  if (selectedUtxoList.length === 0) {
    addToBalance(balances.lockedAvailableTF, balances.pending);
  }
  decreaseBalance(balances.lockedAvailableTF, balances.lockedTotalTF, true, true);
  dispatchSignalSync(onAccountBalancesUpdated, balances, accountId);
  return balances;
};
const setRewardsLocked = (accountId, locked) => {
  if (!accountId) {
    return false;
  }
  _rewardsLocked[accountId] = locked;
  return locked;
};

const onInterval1s = "onInterval1s";
const onInterval4s = "onInterval4s";
const onInterval8s = "onInterval8s";
const onInterval20s = "onInterval20s";
const onInterval60s = "onInterval60s";
const onIntervalRapid = "onIntervalRapid";

const doInitFirstWorker = "doInitFirstWorker";
const doSyncAccount = "doSyncAccount";
const doForceSyncAccount = "doForceSyncAccount";
const doReloadAccount = "doReloadAccount";
const doForceSyncImportantAccounts = "doSyncImportantAccounts";

const doRemovePendingTx = "doRemovePendingTx";
const doUpdatePendingTxStatus = "doUpdatePendingTxStatus";
const onPendingTxListUpdated = "onPendingTxListUpdated";
const doAddSignedTxList = "doAddSignedTxList";
const doProcessSubmittedTxList = "doProcessSubmittedTxList";

const doLogVerbose$1 = false;
const storeId$7 = "appAccountStore";
const { dappAccountId } = useDappAccount();
const { selectedAccountId } = useSelectedAccount();
const _legacySettings = [];
const _appWalletInitList = reactive([]);
const _appAccountMap = reactive(/* @__PURE__ */ new Map());
const _appAccountCredMap = reactive(/* @__PURE__ */ new Map());
const _favoriteAccountIdList = reactive([]);
const _numAccountIds = ref$1(0);
computed(() => _favoriteAccountIdList);
computed(() => _numAccountIds.value);
let _running = false;
const getIAppAccount = (accountId, walletId, accountData) => {
  if (!accountId) {
    return null;
  }
  let appAccount = _appAccountMap.get(accountId + walletId) ?? null;
  if (appAccount) {
    if (accountData) {
      updateIAccountDBDataIfNeeded(appAccount.data, accountData);
    }
    return appAccount;
  }
  return createIAppAccount(accountId, walletId, accountData);
};
const createIAppAccount = (accountId, walletId, accountData) => {
  if (!accountData) {
    return null;
  }
  if (!walletId) {
    return null;
  }
  const signType = accountData.account.signType;
  const isReadOnly = signType === "readonly";
  const isMnemonic = signType === "mnemonic";
  const isCLI = signType === "cli";
  const isMultiSig = signType === "multisig";
  const isLedger = signType === "ledger";
  const isTrezor = signType === "trezor";
  const isKeystone = signType === "keystone";
  const isOneKey = signType === "onekey";
  const isBitBox = signType === "bitbox";
  const isHardware = isLedger || isTrezor || isKeystone || isOneKey || isBitBox;
  const newAccount = reactive({
    id: accountId,
    walletId,
    data: accountData,
    syncInfo: {
      isInitializing: true,
      state: SyncState.initializing,
      stateTimestamp: 0,
      lastRewardSync: 0,
      error: null,
      nextSyncDelay: LOW_PRIO_SYNC_SEC * 1e3,
      history: {
        initializing: 0,
        idle: 0,
        queued: 0,
        syncing: 0,
        success: 0,
        skipped: 0,
        error: 0
      }
    },
    utxoMap: {
      opk: [],
      opkosk: [],
      opkesk: [],
      epkosk: [],
      numOpk: 0,
      numOpkOsk: 0,
      numOpkEsk: 0,
      numEpkOsk: 0,
      allOpk: [],
      collateral: [],
      locked: [],
      selected: []
    },
    multiSigTxList: [],
    hasNewNotifications: false,
    isSelectedAccount: accountId === selectedAccountId.value,
    isDappAccount: accountId === dappAccountId.value,
    isReadOnly,
    isMnemonic,
    isCLI,
    isLedger,
    isTrezor,
    isKeystone,
    isOneKey,
    isBitBox,
    isHardware,
    isMultiSig
  });
  getIAccountBalances(accountId, createIAccountBalances(accountId));
  const updateAndSync = (doScheduleSync, priority, isInitialCall = false) => {
    if (newAccount.isDappAccount || newAccount.isSelectedAccount) {
      newAccount.syncInfo.nextSyncDelay = HIGH_PRIO_SYNC_SEC * 1e3;
    } else {
      newAccount.syncInfo.nextSyncDelay = LOW_PRIO_SYNC_SEC * 1e3;
    }
    if (doScheduleSync) {
      const isManualSync = newAccount.data.settings.manualSync.enabled;
      if (isManualSync && isInitialCall) {
        if (newAccount.isSelectedAccount || newAccount.isDappAccount) {
          setInitializingManual(newAccount);
          dispatchSignalSync(doSyncAccount, newAccount, priority);
        } else {
          setIdleManual(newAccount);
        }
        return;
      }
      if (!isManualSync || isManualSync && priority === SyncPriority.force) {
        dispatchSignalSync(doSyncAccount, newAccount, priority);
      } else {
        setIdleManual(newAccount);
      }
    }
  };
  watch(selectedAccountId, (newValue) => {
    const wasSelectedAccount = newAccount.isSelectedAccount;
    updateSelectedId$1(newAccount, newValue);
    if (newAccount.isSelectedAccount !== wasSelectedAccount) {
      updateAndSync(newValue === newAccount.id, SyncPriority.medium);
    }
  }, { immediate: true });
  watch(dappAccountId, (newValue) => {
    const wasDappAccount = newAccount.isDappAccount;
    updateDappId$1(newAccount, newValue);
    if (newAccount.isDappAccount !== wasDappAccount) {
      updateAndSync(newValue === newAccount.id, SyncPriority.medium);
    }
  }, { immediate: true });
  addSignalListener(onAccountSettingsUpdated, accountId, (appAccount) => {
    if (appAccount.id === newAccount.id && !newAccount.data.settings.manualSync.enabled) {
      updateAndSync(true, SyncPriority.medium);
    }
  }, doLogVerbose$1);
  addSignalListener(doForceSyncImportantAccounts, accountId, () => {
    updateAndSync(false, SyncPriority.low);
    if (newAccount.isDappAccount || newAccount.isSelectedAccount) {
      dispatchSignalSync(doSyncAccount, newAccount, SyncPriority.force);
    }
  }, doLogVerbose$1);
  addSignalListener(doSyncAllAccounts + "_" + walletId, accountId, (initial = false) => {
    updateAndSync(true, initial ? SyncPriority.low : SyncPriority.medium, initial);
  }, doLogVerbose$1);
  addSignalListener(doForceSyncAccount, accountId, () => {
    updateAndSync(true, SyncPriority.force);
  }, doLogVerbose$1);
  addSignalListener(doForceSyncAllAccounts + "_" + walletId, accountId, () => {
    updateAndSync(true, SyncPriority.high);
  }, doLogVerbose$1);
  addSignalListener(doFullWalletResync + "_" + walletId, accountId, async () => {
    updateAndSync(false, SyncPriority.low);
    await AccountDB$1.wipeAccountData(accountData.state.networkId, accountId);
    await AccountDB$1.createAccountData(accountData.state.networkId, accountData.account, accountData.settings);
    newAccount.syncInfo.lastRewardSync = 0;
    dispatchSignalSync(doSyncAccount, newAccount, SyncPriority.force);
  }, doLogVerbose$1);
  addSignalListener(doFullAccountResync, accountId, async () => {
    updateAndSync(false, SyncPriority.low);
    await AccountDB$1.wipeAccountData(accountData.state.networkId, accountId);
    await AccountDB$1.createAccountData(accountData.state.networkId, accountData.account, accountData.settings);
    newAccount.syncInfo.lastRewardSync = 0;
    dispatchSignalSync(doSyncAccount, newAccount, SyncPriority.force);
  }, doLogVerbose$1);
  let syncedOnce = false;
  addSignalListener(onAccountDataUpdated, accountId, (appAccount) => {
    if (appAccount.id === accountId) {
      updateBalances(newAccount);
      if (!syncedOnce) {
        syncedOnce = true;
        dispatchSignalSync(onFirstAccountDataUpdated, newAccount);
      }
    }
  }, doLogVerbose$1);
  addSignalListener(doToggleLockedUtxo, accountId, async (utxo) => {
    await toggleLockedUtxo(newAccount, utxo);
    updateBalances(newAccount);
  }, doLogVerbose$1);
  addSignalListener(doToggleSelectedUtxo, accountId, (utxo) => {
    toggleSelectedUtxo(newAccount, utxo);
    updateBalances(newAccount);
  }, doLogVerbose$1);
  addSignalListener(doClearSelectedUtxos, accountId, () => {
    clearSelectedUtxos(newAccount);
    updateBalances(newAccount);
  }, doLogVerbose$1);
  addSignalListener(doUpdateAccountBalances, accountId, () => {
    updateBalances(newAccount);
  }, doLogVerbose$1);
  addSignalListener(onPendingTxListUpdated, accountId, () => {
    updatePendingBalance(newAccount);
  }, doLogVerbose$1);
  addSignalListener(onEpochParamsUpdated, accountId, () => {
    newAccount.syncInfo.lastRewardSync = 0;
  }, doLogVerbose$1);
  _appAccountMap.set(accountId + walletId, newAccount);
  updateAndSync(false, SyncPriority.low);
  return newAccount;
};
const removeIAppAccount = async (accountId, walletId) => {
  removeSignalListener(onAccountSettingsUpdated, accountId, doLogVerbose$1);
  removeSignalListener(doForceSyncImportantAccounts, accountId, doLogVerbose$1);
  removeSignalListener(doSyncAllAccounts + "_" + walletId, accountId, doLogVerbose$1);
  removeSignalListener(doForceSyncAllAccounts + "_" + walletId, accountId, doLogVerbose$1);
  removeSignalListener(doFullWalletResync + "_" + walletId, accountId, doLogVerbose$1);
  removeSignalListener(doFullAccountResync, accountId, doLogVerbose$1);
  removeSignalListener(onAccountDataUpdated, accountId, doLogVerbose$1);
  removeSignalListener(doToggleLockedUtxo, accountId, doLogVerbose$1);
  removeSignalListener(doToggleSelectedUtxo, accountId, doLogVerbose$1);
  removeSignalListener(doClearSelectedUtxos, accountId, doLogVerbose$1);
  removeSignalListener(doUpdateAccountBalances, accountId, doLogVerbose$1);
  removeSignalListener(onPendingTxListUpdated, accountId, doLogVerbose$1);
  removeSignalListener(onEpochParamsUpdated, accountId, doLogVerbose$1);
  let appAccount = _appAccountMap.get(accountId + walletId);
  if (appAccount) {
    _appAccountMap.delete(accountId + walletId);
    try {
      await AccountDB$1.removeDB(appAccount.data.state.networkId, accountId);
    } catch (err) {
      console.error(err);
    }
  }
};
const initAppAccountList = (appWallet, priority) => {
  if (!getNextAccountToLoad(appWallet)) {
    return;
  }
  if (_appWalletInitList.includes(appWallet)) {
    _appWalletInitList.splice(_appWalletInitList.indexOf(appWallet), 1);
  }
  if (priority !== SyncPriority.low) {
    _appWalletInitList.unshift(appWallet);
  } else {
    _appWalletInitList.push(appWallet);
  }
  if (!_running) {
    addSignalListener(onIntervalRapid, storeId$7, doInitNextAppAccount);
  }
};
const reloadAccountData = async (walletId, accountId) => {
  const appAccount = getIAppAccount(accountId, walletId);
  if (!appAccount) {
    return;
  }
  await dispatchSignal(doReloadAccount, appAccount);
};
const updateFavoriteAccountList = () => {
  const appAccountList = _appAccountMap.values();
  const favoriteAccountIdList2 = [];
  let numAccountIds2 = 0;
  for (const appAccount of appAccountList) {
    if (isHDAccountPath(appAccount.data.account)) {
      numAccountIds2++;
    }
    if (appAccount.data.settings.favorite?.enabled ?? false) {
      favoriteAccountIdList2.push({
        accountId: appAccount.id,
        walletId: appAccount.walletId
      });
    }
  }
  _favoriteAccountIdList.splice(0, _favoriteAccountIdList.length, ...favoriteAccountIdList2);
  _numAccountIds.value = numAccountIds2;
};
const doInitNextAppAccount = async () => {
  if (_appWalletInitList.length === 0) {
    _running = false;
    return true;
  }
  if (_running) {
    return false;
  }
  _running = true;
  const appWallet = _appWalletInitList[0];
  let account = getNextAccountToLoad(appWallet);
  let atLeastOneAccountLoaded = !!account;
  try {
    if (atLeastOneAccountLoaded) {
      if (doLogVerbose$1) ;
      while (account) {
        const refAccount = appWallet.accountList[0] ?? null;
        let overwriteSettings = isHDAccountPath(account) ? _legacySettings.find((item) => item?.id === account.id) ?? refAccount?.data.settings ?? appWallet.data.wallet.legacySettings : void 0;
        const accountData = await AccountDB$1.createAccountData(networkId$9.value, account, overwriteSettings);
        const appAccount = getIAppAccount(account.id, appWallet.id, accountData);
        appWallet.accountList.push(appAccount);
        try {
          dispatchSignalSync(onAppAccountAddedToAppWallet);
          await dispatchSignal(doAddAccountToRecovery, accountData);
        } catch (e) {
          console.error("Error in appAccount", e);
        }
        if (doLogVerbose$1) ;
        account = getNextAccountToLoad(appWallet);
      }
      if (doLogVerbose$1) ;
    }
  } catch (err) {
    console.error(err);
  }
  _appWalletInitList.splice(_appWalletInitList.indexOf(appWallet), 1);
  if (atLeastOneAccountLoaded) {
    dispatchSignalSync(doSyncAllAccounts + "_" + appWallet.id, true);
  }
  _running = false;
  if (_appWalletInitList.length > 0) ; else {
    removeSignalListener(onIntervalRapid, storeId$7);
  }
  return false;
};
const getNextAccountToLoad = (appWallet) => {
  for (const account of appWallet.data.wallet.accountList) {
    if (!appWallet.accountList.some((appAccount) => appAccount.data.account.id === account.id)) {
      appWallet.accountsLoaded = false;
      return account;
    }
  }
  appWallet.accountsLoaded = true;
  return null;
};
const findIAppAccountById = (accountId, preferNonReadOnly = false) => {
  const appAccountList = _appAccountMap.values();
  let foundAppAccount = null;
  for (const appAccount of appAccountList) {
    if (appAccount.id === accountId) {
      if (preferNonReadOnly && appAccount.isReadOnly) {
        foundAppAccount = appAccount;
        continue;
      }
      return appAccount;
    }
  }
  return foundAppAccount;
};
const getIAppAccountByAddress = (address, preferNonReadOnly = false) => {
  const { paymentCred, stakeCred } = getAddressCredentials(address);
  return getIAppAccountByCred(paymentCred ?? stakeCred ?? "noset");
};
const getIAppAccountByCred = (cred, preferNonReadOnly = false, type) => {
  const accountId = _appAccountCredMap.get(cred);
  if (accountId) {
    return findIAppAccountById(accountId, preferNonReadOnly);
  }
  const appAccountList = _appAccountMap.values();
  for (const appAccount of appAccountList) {
    const key = getOwnedCred([appAccount.data.keys], cred, type);
    if (key) {
      _appAccountCredMap.set(cred, appAccount.id);
      return findIAppAccountById(appAccount.id, preferNonReadOnly);
    }
  }
  return null;
};

const createIUtxo = (ref, doParseCoin = true) => {
  const utxo = createTransactionUnspentOutputJSON(ref);
  if (!ref?.pc || !ref?.sc) {
    const creds = getAddressCredentials(utxo.output.address);
    utxo.pc = creds.paymentCred ?? ref?.pc ?? utxo.output.address;
    utxo.sc = creds.stakeCred ?? ref?.sc ?? "";
  } else {
    utxo.pc = ref?.pc ?? utxo.output.address;
    utxo.sc = ref?.sc ?? "";
  }
  if (doParseCoin) {
    utxo.c = parseInt(utxo.output.amount.coin);
  }
  if (ref?.p) {
    utxo.p = ref.p;
  }
  if (ref?.cborSize) {
    utxo.cborSize = ref.cborSize;
  }
  return utxo;
};

const CertificateTypes = Object.values(CertificateKind).filter((v) => isNaN(Number(v)));

const loadUtxoCborFromTxList = async (networkId, accountId, utxoList) => {
  const chunkSize = 500;
  const res = [];
  for (let i = 0; i < utxoList.length + chunkSize; i += chunkSize) {
    const subArray = utxoList.slice(i, i + chunkSize);
    if (subArray.length > 0) {
      res[i] = await loadUtxoCborFromTxListChunk(networkId, accountId, subArray);
    }
  }
  return res.flat();
};
const loadUtxoCborFromTxListChunk = async (networkId, accountId, utxoList) => {
  if (utxoList.length === 0) {
    return [];
  }
  if (!accountId) {
    accountId = DEFAULT_ACCOUNT_ID;
  }
  return getRequestData()(
    networkId,
    accountId,
    ApiRequestType.syncUtxoCborFromTx,
    ErrorSync.loadUtxoCborFromTxList,
    {
      id: accountId,
      utxoList
    },
    async (data) => {
      if (!data.utxoCborList) {
        throw "missingUtxoCborList";
      }
      return data.utxoCborList;
    }
  );
};
const loadUtxoCborFromUtxoHashes = async (networkId, accountId, utxoHashList) => {
  if (utxoHashList.length === 0) {
    return [];
  }
  return getRequestData()(
    networkId,
    accountId,
    ApiRequestType.syncUtxoCborFromUtxoHashes,
    ErrorSync.loadUtxoCborFromUtxoHashes,
    {
      id: accountId,
      utxoList: utxoHashList
    },
    async (data) => {
      if (!data.utxoCborList) {
        throw "missingUtxoCborList";
      }
      return data.utxoCborList;
    }
  );
};
const loadUtxoByronList = async (networkId, accountId, utxoList) => {
  if (!accountId) {
    accountId = DEFAULT_ACCOUNT_ID;
  }
  return getRequestData()(
    networkId,
    accountId,
    ApiRequestType.syncUtxoByron,
    ErrorSync.loadUtxoByronList,
    {
      id: accountId,
      utxoList
    },
    async (data) => {
      return data.utxoList ?? [];
    }
  );
};

const doLog$1 = false;
const storeId$6 = "calcTxBalanceUtil";
const calcAccountTxBalance = async (appAccount, tx, txBalance) => {
  if (!txBalance) {
    txBalance = createITxBalance();
  }
  const networkId = appAccount.data.state.networkId;
  const accountId = appAccount.id;
  const start = now();
  let time = start;
  const inputUtxoList = new Array();
  const unknownInputList = getAllInputUtxoHashList(tx);
  const { pendingOutputList } = getPendingUtxoList(appAccount);
  for (let i = unknownInputList.length - 1; i >= 0; i--) {
    const [hash, _idx] = unknownInputList[i].split("#");
    const idx = Number(_idx);
    const utxo = pendingOutputList.find((utxo2) => utxo2.input.transaction_id === hash && utxo2.input.index === idx) ?? appAccount.utxoMap.allOpk.find((utxo2) => utxo2.input.transaction_id === hash && utxo2.input.index === idx);
    if (utxo) {
      inputUtxoList.push(createIUtxo(utxo));
      unknownInputList.splice(i, 1);
    }
  }
  try {
    txBalance.hash = tx.hash;
    await calcTxBalance(networkId, tx, txBalance, inputUtxoList, unknownInputList, accountId, appAccount.data.keys);
    if (doLog$1) ;
    if (doLog$1) ;
  } catch (err) {
    console.error(el(storeId$6), sl("calcAccountTxBalance"), "error", accountId, err);
    throw err;
  }
  return txBalance;
};
const fillInputUtxoList = async (networkId, tx, knownUtxoList) => {
  const inputUtxoList = new Array();
  const unknownInputList = getAllInputUtxoHashList(tx);
  if (knownUtxoList) {
    filterKnownUtxos(knownUtxoList, inputUtxoList, unknownInputList);
  }
  try {
    await loadUnknownUtxos(networkId, inputUtxoList, unknownInputList);
    if (doLog$1) ;
    if (!tx.inputUtxoList) {
      tx.inputUtxoList = inputUtxoList;
    } else {
      addMissingUtxosToList(tx.inputUtxoList, inputUtxoList);
    }
    if (doLog$1) ;
  } catch (err) {
    console.error(el(storeId$6), sl("fillInputUtxoList"), "error", err);
    throw err;
  }
};
const calcTxBalance = async (networkId, tx, txBalance, inputUtxoList, unknownInputList, accountId, keys) => {
  const uniqueAddressSet = /* @__PURE__ */ new Set();
  const uniqueAssetNameSet = /* @__PURE__ */ new Set();
  const _txBody = tx.body;
  const _txAuxData = tx.auxiliary_data;
  const _txWitnessSet = tx.witness_set;
  clearValueJSON(txBalance);
  if (unknownInputList.length > 0) {
    await loadUnknownUtxos(networkId, inputUtxoList, unknownInputList);
  }
  if (!tx.is_valid) {
    txBalance.fsc = true;
  }
  tx.unknownInputUtxoList = unknownInputList;
  if (!tx.inputUtxoList) {
    tx.inputUtxoList = inputUtxoList;
  } else {
    addMissingUtxosToList(tx.inputUtxoList, inputUtxoList);
  }
  processBody(txBalance, tx.inputUtxoList, _txBody, _txWitnessSet, uniqueAddressSet, uniqueAssetNameSet, keys);
  processMetadata(txBalance, _txAuxData);
  if (accountId) {
    await processTags(networkId, accountId, txBalance, uniqueAddressSet, uniqueAssetNameSet);
  } else {
    txBalance.asl = Array.from(uniqueAddressSet);
  }
  return txBalance;
};
const getITxBalanceType = (amount, fee, hasOwnWithdrawal, hasExternalWithdrawal = false) => {
  let type = ITxBalanceType.uninitialized;
  if (hasOwnWithdrawal) {
    type = type | ITxBalanceType.withdrawal;
  }
  if (hasExternalWithdrawal) {
    type = type | ITxBalanceType.externalWithdrawal;
  }
  if (amount.multiasset && Object.values(amount.multiasset).some((assets) => Object.values(assets).some((amount2) => compare$1(amount2, ">", 0)))) {
    type = type | ITxBalanceType.receivedTokens;
  }
  if (amount.multiasset && Object.values(amount.multiasset).some((assets) => Object.values(assets).some((amount2) => compare$1(amount2, "<", 0)))) {
    type = type | ITxBalanceType.sentTokens;
  }
  if (compare$1(abs(amount.coin), "==", fee)) {
    type = type | ITxBalanceType.intraWallet;
  }
  if (compare$1(amount.coin, "<", 0)) {
    type = type | ITxBalanceType.sentAda;
  } else if (compare$1(amount.coin, ">", 0)) {
    if (!((type & ITxBalanceType.withdrawal) === ITxBalanceType.withdrawal)) {
      type = type | ITxBalanceType.receivedAda;
    }
  } else {
    type = type | ITxBalanceType.external;
  }
  return type;
};
const processBody = (txBalance, utxoCacheList, txBody, txWitnessSet, uniqueAddressSet, uniqueAssetNameSet, keys) => {
  const keysList = keys ? [keys] : [];
  let ownWithdrawals = null;
  let externalWithdrawals = null;
  if (keys && txBody.withdrawals) {
    for (const withdrawal of Object.entries(txBody.withdrawals)) {
      const credentials = getAddressCredentials(withdrawal[0]);
      if (credentials.stakeCred) {
        if (getOwnedCred(keysList, credentials.stakeCred, "stake")) {
          ownWithdrawals = add(ownWithdrawals ?? "0", withdrawal[1]);
        } else {
          externalWithdrawals = add(externalWithdrawals ?? "0", withdrawal[1]);
        }
      }
    }
    if (ownWithdrawals) {
      addValueToValue(txBalance, { coin: ownWithdrawals }, true);
      txBalance.ow = ownWithdrawals;
    }
  }
  for (const input of txBody.inputs) {
    const utxo = utxoCacheList.find((utxo2) => utxo2.input.transaction_id === input.transaction_id && utxo2.input.index === input.index);
    if (!utxo) {
      console.warn(el(storeId$6), sl("processBody"), `input details missing: hash=${input.transaction_id}, index=${input.index}`);
      continue;
    }
    const pc = utxo.pc;
    if (keys && pc.length > 0) {
      if (getOwnedCred(keysList, pc)) {
        addValueToValue(txBalance, utxo.output.amount, true);
      }
      if (uniqueAddressSet) {
        uniqueAddressSet.add(pc);
      }
    }
    if (uniqueAddressSet) {
      uniqueAddressSet.add(utxo.output.address);
    }
  }
  for (let i = 0; i < txBody.outputs.length; i++) {
    const output = createIUtxo({ input: { transaction_id: txBalance.hash, index: i }, output: txBody.outputs[i] });
    const pc = output.pc;
    if (keys && pc.length > 0) {
      if (getOwnedCred(keysList, pc)) {
        addValueToValue(txBalance, output.output.amount, false);
      }
      if (uniqueAddressSet) {
        uniqueAddressSet.add(pc);
      }
    }
    if (uniqueAddressSet) {
      uniqueAddressSet.add(output.output.address);
    }
  }
  txBalance.c = Number(txBalance.coin);
  txBalance.t = getITxBalanceType(txBalance, txBody.fee, (txBalance.ow ?? "0") !== "0", (externalWithdrawals ?? "0") !== "0");
  if ((txBalance.t & ITxBalanceType.sentTokens) === ITxBalanceType.sentTokens || (txBalance.t & ITxBalanceType.sentAda) === ITxBalanceType.sentAda) {
    if (txBody.fee && txBody.fee !== "0") {
      txBalance.f = txBody.fee;
    }
  }
  if (txWitnessSet) {
    if (txWitnessSet.plutus_data || (txWitnessSet.plutus_scripts?.length ?? 0) > 0 || (txWitnessSet.redeemers?.length ?? 0) > 0) {
      txBalance.p = true;
    }
    if (!!txWitnessSet.native_scripts) {
      txBalance.n = true;
    }
  }
  if (!!txBody.mint) {
    let _hasMint = false;
    let _hasBurn = false;
    for (const mint of txBody.mint) {
      for (const mintAssetAmount of Object.values(mint[1])) {
        if (mintAssetAmount.startsWith("-")) {
          if (!_hasBurn) {
            _hasBurn = true;
          }
        } else {
          if (!_hasMint) {
            _hasMint = true;
          }
        }
      }
    }
    if (_hasMint) {
      txBalance.m = true;
    }
    if (_hasBurn) {
      txBalance.b = true;
    }
  }
  for (const cert of txBody.certs ?? []) {
    const id = CertificateTypes.findIndex((type) => type === Object.keys(cert)[0]);
    if (id >= 0) {
      txBalance.cert ? txBalance.cert.push(id) : txBalance.cert = [id];
    } else {
      console.error(el(storeId$6), "unknown certificate type:", Object.keys(cert)[0]);
    }
  }
  if (uniqueAssetNameSet && txBalance.multiasset) {
    for (const polidyId in txBalance.multiasset) {
      for (const assetName in txBalance.multiasset[polidyId]) {
        uniqueAssetNameSet.add(decodeHex(assetName));
        uniqueAssetNameSet.add(getAssetIdBech32(polidyId, assetName));
      }
    }
  }
  if (!!txBody.voting_procedures || !!txBody.voting_proposals) {
    txBalance.v = true;
  }
};
const processMetadata = (txBalance, txAuxData) => {
  delete txBalance.msg;
  delete txBalance.enc;
  delete txBalance.mk;
  if (txAuxData?.metadata) {
    const label674 = txAuxData.metadata["674"];
    if (label674) {
      const msg = {};
      createJsonFromCborJson(JSON.parse(label674), msg);
      if (msg.msg && Array.isArray(msg.msg)) {
        txBalance.msg = msg.msg;
      }
      if (msg.enc && typeof msg.enc === "string") {
        txBalance.enc = msg.enc;
      }
    }
    for (const key of Object.keys(txAuxData.metadata)) {
      txBalance.mk ? txBalance.mk.push(Number(key)) : txBalance.mk = [Number(key)];
    }
  }
  if ((txAuxData?.native_scripts?.length ?? 0) > 0) {
    txBalance.n = true;
  }
  if ((txAuxData?.plutus_scripts?.length ?? 0) > 0) {
    txBalance.p = true;
  }
};
const processTags = async (networkId, accountId, txBalance, uniqueAddressSet, uniqueAssetNameSet) => {
  const list = Array.from(uniqueAddressSet).concat(Array.from(uniqueAssetNameSet ?? []));
  const refIdList = await RefDB.addRefList(networkId, accountId, list);
  for (const address of uniqueAddressSet) {
    const ref = refIdList.find((ref2) => ref2.ref === address);
    if (!ref) {
      console.error(el(storeId$6), sl("calcAccountTxBalance"), "address ref not found:", address);
      continue;
    }
    txBalance.al.push(ref.id);
  }
  if (uniqueAssetNameSet) {
    for (const assetName of uniqueAssetNameSet) {
      const ref = refIdList.find((ref2) => ref2.ref === assetName);
      if (!ref) {
        console.error(el(storeId$6), sl("calcAccountTxBalance"), "assetName ref not found:", assetName);
        continue;
      }
      txBalance.tags ? txBalance.tags.push(ref.id) : txBalance.tags = [ref.id];
    }
  }
};
const loadUnknownUtxos = async (networkId, inputUtxoList, unknownInputList) => {
  if (unknownInputList.length > 0) {
    const inputUtxoCborList = await loadUtxoCborFromTxList(networkId, null, unknownInputList);
    if (inputUtxoCborList.length !== unknownInputList.length) {
      const missingUtxoList = unknownInputList.filter((hash) => !inputUtxoCborList.some((cbor) => cbor.hash === hash));
      const missingUtxoArr = new Array(missingUtxoList.length);
      for (let i = 0; i < missingUtxoList.length; i++) {
        missingUtxoArr[i] = missingUtxoList[i].split("#");
      }
      const utxoByronList = await loadUtxoByronList(networkId, null, missingUtxoArr);
      if (!utxoByronList || inputUtxoCborList.length + utxoByronList.length !== unknownInputList.length) {
        console.warn(el(storeId$6), sl("loadUnknownInputUtxos"), `incomplete cbor response compared to unknown input list: id=${networkId}, inputs=${unknownInputList.length}, cbor=${inputUtxoCborList.length}, byron=${utxoByronList?.length ?? 0}`);
        return -1;
      }
      for (const byronInput of utxoByronList ?? []) {
        const byronUtxo = createIUtxoFromIUtxoDetails(byronInput);
        if (!inputUtxoList.some((utxo) => getUtxoHash(utxo.input) === getUtxoHash(byronUtxo.input))) {
          inputUtxoList.push(byronUtxo);
        }
      }
    }
    for (let i = 0; i < inputUtxoCborList.length; i++) {
      const inputArr = inputUtxoCborList[i].hash.split("#");
      const input = {
        transaction_id: inputArr[0],
        index: parseInt(inputArr[1])
      };
      const cslOutput = getCSLTransactionOutput(inputUtxoCborList[i].cbor);
      const output = getTransactionOutputJSONFromCSL(networkId, cslOutput);
      safeFreeCSLObject(cslOutput);
      const inputUtxo = createIUtxo({ input, output });
      if (!inputUtxoList.some((utxo) => getUtxoHash(utxo.input) === getUtxoHash(inputUtxo.input))) {
        inputUtxoList.push(inputUtxo);
      }
    }
  }
  for (let i = unknownInputList.length - 1; i >= 0; i--) {
    const [hash, _idx] = unknownInputList[i].split("#");
    const idx = Number(_idx);
    const utxo = inputUtxoList.find((utxo2) => utxo2.input.transaction_id === hash && utxo2.input.index === idx);
    if (utxo) {
      unknownInputList.splice(i, 1);
    }
  }
};
const getAllInputUtxoHashList = (tx) => {
  tx.inputUtxoList = tx.inputUtxoList ?? new Array();
  const inputHashSet = /* @__PURE__ */ new Set();
  for (const input of tx.body.reference_inputs ?? []) {
    inputHashSet.add(getUtxoHash(input));
  }
  for (const input of tx.body.collateral ?? []) {
    inputHashSet.add(getUtxoHash(input));
  }
  for (const input of tx.body.inputs ?? []) {
    inputHashSet.add(getUtxoHash(input));
  }
  for (const utxo of tx.inputUtxoList ?? []) {
    inputHashSet.delete(getUtxoHash(utxo.input));
  }
  return Array.from(inputHashSet);
};
const filterKnownUtxos = (knownUtxoList, inputUtxoList, unknownInputList) => {
  for (let i = unknownInputList.length - 1; i >= 0; i--) {
    const utxo = knownUtxoList.find((utxo2) => getUtxoHash(utxo2.input) === unknownInputList[i]);
    if (utxo) {
      inputUtxoList.push(createIUtxo(utxo));
      unknownInputList.splice(i, 1);
    }
  }
};

const pendingSchemaV1 = {
  list: "hash"
};
class PendingTxDB extends Dexie {
  list;
  constructor(networkId) {
    super("eternl-" + networkId + "-pendingtx");
    this.version(1).stores(pendingSchemaV1);
  }
}
const dbMap$6 = networkIdList.reduce((o, n) => {
  o[n] = void 0;
  return o;
}, {});
const getDB$7 = async (networkId) => {
  let db = dbMap$6[networkId];
  if (!db) {
    db = new PendingTxDB(networkId);
    dbMap$6[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const getPendingTxList$1 = (networkId) => getDB$7(networkId).then((db) => db.list.toArray());
const bulkPutPendingTxList = (networkId, list) => getDB$7(networkId).then((db) => db.list.bulkPut(list));
const bulkDeletePendingTxList = (networkId, list) => getDB$7(networkId).then((db) => db.list.bulkDelete(list));
const clearPendingTxList = (networkId) => getDB$7(networkId).then((db) => db.list.clear());
const removeDB = (networkId) => Dexie.delete("eternl-" + networkId + "-pendingtx");
const PendingTxDB$1 = {
  getPendingTxList: getPendingTxList$1,
  bulkPutPendingTxList,
  bulkDeletePendingTxList,
  clearPendingTxList,
  removeDB
};

const storeId$5 = "pendingTxStore";
const pendingTxList = ref$1([]);
let _updateCounter = 0;
const _accountUpdateMap = {};
const _pendingInputMap = {};
const _pendingOutputMap = {};
let _pendingWithdrawalMap = {};
let _hintUpdateCounter = -1;
let _hintOutputList = [];
const _loadPendingTxList = () => {
  return PendingTxDB$1.getPendingTxList(networkId$9.value);
};
const updatePendingTxList = async (updateList, removeList, forceButDontBroadcast = false) => {
  let statusChanged = false;
  if ((updateList?.length ?? 0) > 0) {
    await PendingTxDB$1.bulkPutPendingTxList(networkId$9.value, json(updateList));
    statusChanged = true;
  }
  if ((removeList?.length ?? 0) > 0) {
    await PendingTxDB$1.bulkDeletePendingTxList(networkId$9.value, json(removeList));
    statusChanged = true;
  }
  if (statusChanged && !forceButDontBroadcast) {
    await dispatchSignal(doSendUpdatePendingTx);
  }
  const numPendingTx = pendingTxList.value.length;
  pendingTxList.value = await PendingTxDB$1.getPendingTxList(networkId$9.value);
  _updateCounter++;
  if (!(numPendingTx === 0 && pendingTxList.value.length === 0)) {
    await dispatchSignal(onPendingTxListUpdated);
  }
  return pendingTxList;
};
const getPendingTxList = (skipUpdate = false) => {
  if (!skipUpdate && pendingTxList.value.length === 0) {
    updatePendingTxList();
  }
  return pendingTxList;
};
const getSubmittedPendingTxList = () => {
  return pendingTxList.value.filter((tx) => isSignedState(tx.state) && isSubmittedState(tx.state) && !isInvalidState(tx.state) && !isExpiredState(tx.state));
};
const getHintPendingTxList = () => {
  return pendingTxList.value;
};
const addSignedTx = async (txList) => {
  const calls = [];
  for (const tx of txList) {
    setSignedState(tx);
    calls.push(fillInputUtxoList(networkId$9.value, tx, tx.inputUtxoList));
  }
  if (calls.length > 0) {
    await Promise.all(calls);
  }
  return updatePendingTxList(txList);
};
const cachePendingUtxoList = (appAccount) => {
  const accountId = appAccount.id;
  if (_accountUpdateMap[accountId] === _updateCounter) {
    return {
      pendingInputList: _pendingInputMap[accountId],
      pendingOutputList: _pendingOutputMap[accountId],
      pendingWithdrawalMap: _pendingWithdrawalMap
    };
  }
  const pendingTxList2 = getSubmittedPendingTxList();
  const pendingInputList = [];
  const pendingOutputList = [];
  const pendingWithdrawalMap = {};
  for (const pendingTx of pendingTxList2) {
    if (isInvalidState(pendingTx.state)) {
      continue;
    }
    if (pendingTx.inputUtxoList) {
      for (const utxo of pendingTx.inputUtxoList) {
        const appAccountCred = getIAppAccountByCred((utxo.pc ?? "") + "");
        if (appAccount.id === appAccountCred?.id) {
          if (!pendingInputList.some((pendingUtxo) => getUtxoHash(pendingUtxo.input) === getUtxoHash(utxo.input))) {
            pendingInputList.push(utxo);
          }
        }
      }
    }
    for (let i = 0; i < pendingTx.body.outputs.length; i++) {
      const pendingTxOutput = pendingTx.body.outputs[i];
      if (isOwnedPaymentAddress([appAccount.data.keys], pendingTxOutput.address)) {
        if (!pendingOutputList.some((pendingUtxo) => pendingUtxo.input.transaction_id === pendingTx.hash && pendingUtxo.input.index === i)) {
          const utxo = createIUtxoFromTransactionJSON(pendingTxOutput, pendingTx.hash, i);
          pendingOutputList.push(utxo);
        }
      }
    }
    if (pendingTx.body.withdrawals) {
      for (const withdrawal of Object.entries(pendingTx.body.withdrawals)) {
        const cred = getAddressCredentials(withdrawal[0]);
        pendingWithdrawalMap[cred.stakeCred ?? ""] = withdrawal[1];
      }
    }
  }
  _accountUpdateMap[accountId] = _updateCounter;
  _pendingInputMap[accountId] = pendingInputList;
  _pendingOutputMap[accountId] = pendingOutputList;
  _pendingWithdrawalMap = pendingWithdrawalMap;
  return {
    pendingInputList: _pendingInputMap[accountId],
    pendingOutputList: _pendingOutputMap[accountId],
    pendingWithdrawalMap: _pendingWithdrawalMap
  };
};
const getPendingUtxoList = (appAccount) => {
  const accountId = appAccount.id;
  return {
    pendingInputList: _pendingInputMap[accountId],
    pendingOutputList: _pendingOutputMap[accountId],
    pendingWithdrawalMap: _pendingWithdrawalMap
  };
};
const cacheHintUtxoList = () => {
  if (_hintUpdateCounter === _updateCounter) {
    return _hintOutputList;
  }
  const hintTxList = getHintPendingTxList();
  const hintOutputList = [];
  for (const hintTx of hintTxList) {
    if (isInvalidState(hintTx.state)) {
      continue;
    }
    for (let i = 0; i < hintTx.body.outputs.length; i++) {
      const hintTxOutput = hintTx.body.outputs[i];
      const utxo = createIUtxoFromTransactionJSON(hintTxOutput, hintTx.hash, i);
      hintOutputList.push(utxo);
    }
  }
  _hintOutputList = hintOutputList;
  _hintUpdateCounter = _updateCounter;
  return hintOutputList;
};
addSignalListener(doAddSignedTxList, storeId$5, (signedList) => {
  return addSignedTx(signedList);
});

const getOutputBalance = (balance, outputList) => {
  for (const output of outputList) {
    addValueToValue(balance, output.amount);
  }
  updateBalanceTotal(balance);
  return balance;
};
const getInputBalance = (balance, utxoList) => {
  for (const utxo of utxoList) {
    addValueToValue(balance, utxo.output.amount);
  }
  updateBalanceTotal(balance);
  return balance;
};
const filterUtxoFromList = (utxoList, utxo) => {
  for (let i = utxoList.length - 1; i >= 0; i--) {
    const _utxo = utxoList[i];
    if (getUtxoHash(_utxo.input) === getUtxoHash(utxo.input)) {
      utxoList.splice(i, 1);
      break;
    }
  }
  return utxoList;
};
const filterUtxoList = (utxoList, filter) => {
  if (filter.length === 0) {
    return utxoList;
  }
  for (let k = 0; k < filter.length; k++) {
    const filterUtxo = filter[k];
    const filterHash = getUtxoHash(filterUtxo.input);
    for (let i = utxoList.length - 1; i >= 0; i--) {
      const utxo = utxoList[i];
      if (getUtxoHash(utxo.input) === filterHash) {
        utxoList.splice(i, 1);
        break;
      }
    }
  }
  return utxoList;
};
const filterUtxoListByHashList = (utxoList, filter) => {
  if (filter.length === 0) {
    return utxoList;
  }
  for (let i = utxoList.length - 1; i >= 0; i--) {
    const utxo = utxoList[i];
    if (filter.includes(getUtxoHash(utxo.input))) {
      utxoList.splice(i, 1);
    }
  }
  return utxoList;
};
const filterUtxosByMustInclude = (utxoList, mustInclude) => {
  if (mustInclude.length === 0) {
    utxoList.length = 0;
    return utxoList;
  }
  for (let i = utxoList.length - 1; i >= 0; i--) {
    const utxo = utxoList[i];
    if (!mustInclude.includes(getUtxoHash(utxo.input))) {
      utxoList.splice(i, 1);
    }
  }
  return utxoList;
};
const filterUtxoListByPlutus = (utxoList) => {
  for (let i = utxoList.length - 1; i >= 0; i--) {
    const utxo = utxoList[i];
    if (!!utxo.output.plutus_data || !!utxo.output.script_ref) {
      console.warn("filterUtxoListByPlutus", json(utxo));
      utxoList.splice(i, 1);
    }
  }
  return utxoList;
};
const addMissingUtxosToList = (utxoList, toBeAdded) => {
  if (toBeAdded.length === 0) {
    return utxoList;
  }
  if (utxoList.length === 0) {
    utxoList.push(...toBeAdded);
    return utxoList;
  }
  const hashSet = new Set(utxoList.map((utxo) => getUtxoHash(utxo.input)));
  for (let k = 0; k < toBeAdded.length; k++) {
    const filterUtxo = toBeAdded[k];
    const filterHash = getUtxoHash(filterUtxo.input);
    if (!hashSet.has(filterHash)) {
      utxoList.push(filterUtxo);
      hashSet.add(filterHash);
    }
  }
  return utxoList;
};
const trimUtxoList = (utxoList, numMinAdaOnly, numMaxInList) => {
  const adaOnly = utxoList.filter((utxo) => !utxo.output.amount.multiasset);
  const multiAsset = utxoList.filter((utxo) => !!utxo.output.amount.multiasset);
  adaOnly.sort((a, b) => compare$1(a.output.amount.coin, ">", b.output.amount.coin) ? -1 : 1);
  multiAsset.sort((a, b) => {
    return Object.keys(a.output.amount.multiasset ?? {}).length > Object.keys(b.output.amount.multiasset ?? {}).length ? -1 : 1;
  });
  const minNumAdaOnly = Math.min(adaOnly.length, numMinAdaOnly);
  const maxUtxos = numMaxInList - minNumAdaOnly;
  multiAsset.length = Math.min(maxUtxos, multiAsset.length);
  adaOnly.length = Math.min(numMaxInList - multiAsset.length, adaOnly.length);
  return adaOnly.concat(multiAsset);
};
const filterUtxoListByFlags = (utxoList, appAccount, _filterFlags) => {
  const filterFlags = createIUtxoFilterFlag(_filterFlags);
  let onlyUseSelected = filterFlags.filterBySelected && appAccount.utxoMap.selected.length > 0;
  if (filterFlags.handlePendingTx) {
    handlePendingUtxos(utxoList, appAccount);
  }
  if (onlyUseSelected) {
    filterUtxosByMustInclude(utxoList, appAccount.utxoMap.selected);
  }
  if (filterFlags.filterByCollateral) {
    if (utxoList.length > 0 && utxoList.length === appAccount.utxoMap.collateral.length) ; else if (appAccount.utxoMap.collateral.length > 0) {
      appAccount.utxoMap.collateral.sort((a, b) => compare$1(a.output.amount.coin, ">", b.output.amount.coin) ? 1 : -1);
      filterUtxoList(utxoList, [appAccount.utxoMap.collateral[0]]);
    }
  }
  if (filterFlags.filterByLocked) {
    filterUtxoListByHashList(utxoList, appAccount.utxoMap.locked);
  }
  if (filterFlags.preserveDatums) {
    filterUtxoListByPlutus(utxoList);
  }
};
const filterHintUtxoListByFlags = (utxoList) => {
  utxoList.push(...cacheHintUtxoList());
};
const handlePendingUtxos = (utxoList, appAccount) => {
  let {
    pendingInputList,
    pendingOutputList
  } = cachePendingUtxoList(appAccount);
  pendingOutputList = pendingOutputList.concat();
  filterUtxoList(utxoList, pendingInputList);
  filterUtxoList(pendingOutputList, pendingInputList);
  utxoList.push(...pendingOutputList);
};

const addUtxosToAllOpk = (appAccount, utxos) => {
  const epochParams = checkEpochParams(networkId$9.value);
  for (const utxo of utxos) {
    if (appAccount.data.account.paymentScript || appAccount.data.account.stakeScript) {
      if (!isScriptAddress(utxo.output.address)) {
        continue;
      }
    }
    if (epochParams) {
      getMinUtxo(utxo.output, epochParams.utxoCostPerSize, epochParams.isAtLeastBabbageEra, getUtxoHash(utxo.input), false);
    }
    appAccount.utxoMap.allOpk.push(utxo);
  }
};
const updateUtxoLists = (appAccount) => {
  let list = appAccount.utxoMap.allOpk;
  list.length = 0;
  addUtxosToAllOpk(appAccount, appAccount.utxoMap.opk);
  addUtxosToAllOpk(appAccount, appAccount.utxoMap.opkosk);
  addUtxosToAllOpk(appAccount, appAccount.utxoMap.opkesk);
};
const getFilteredUtxoList = (appAccount, filterByCollateral, handlePendingTx, filterByLocked, filterBySelected) => {
  const accountId = appAccount.id;
  const preserveDatums = appAccount.data.settings.preserveDatums?.enabled ?? false;
  if (!accountId) {
    return {
      utxoList: [],
      collateralUtxoList: []
    };
  }
  const utxoList = appAccount.utxoMap.allOpk.concat();
  filterUtxoListByFlags(utxoList, appAccount, {
    filterByCollateral,
    handlePendingTx,
    filterByLocked,
    filterBySelected,
    preserveDatums
  });
  return {
    utxoList,
    // copy or new array
    collateralUtxoList: appAccount.utxoMap.collateral.concat()
    // copy
  };
};
const getHintUtxoList = (appAccount) => {
  const utxoList = appAccount?.utxoMap.allOpk.concat() ?? [];
  const collateralUtxoList = appAccount?.utxoMap.collateral ?? [];
  utxoList.push(...collateralUtxoList);
  filterHintUtxoListByFlags(utxoList);
  return utxoList;
};
const toggleSelectedUtxo = (appAccount, utxo) => {
  const hash = getUtxoHash(utxo.input);
  const isLocked = appAccount.utxoMap.locked.includes(hash);
  const isSelected = appAccount.utxoMap.selected.includes(hash);
  if (!isSelected && !isLocked) {
    appAccount.utxoMap.selected.push(hash);
  } else {
    for (let i = appAccount.utxoMap.selected.length - 1; i >= 0; i--) {
      if (appAccount.utxoMap.selected[i] === hash) {
        appAccount.utxoMap.selected.splice(i, 1);
      }
    }
  }
  dispatchSignalSync(onSelectedUtxoToggled, appAccount.id, utxo);
};
const clearSelectedUtxos = (appAccount) => {
  appAccount.utxoMap.selected.length = 0;
};
const toggleLockedUtxo = (appAccount, utxo) => {
  const hash = getUtxoHash(utxo.input);
  const isLocked = appAccount.utxoMap.locked.includes(hash);
  if (!isLocked) {
    appAccount.utxoMap.locked.push(hash);
  } else {
    for (let i = appAccount.utxoMap.locked.length - 1; i >= 0; i--) {
      if (appAccount.utxoMap.locked[i] === hash) {
        appAccount.utxoMap.locked.splice(i, 1);
      }
    }
  }
  dispatchSignalSync(onLockedUtxoToggled, appAccount.id);
  return UtxoListDB.putLockedUtxoList(appAccount.data.state.networkId, appAccount.id, json(appAccount.utxoMap.locked));
};
const hasLockedUtxos = (appAccount, inputList) => {
  if (!appAccount) {
    return false;
  }
  for (const hash of inputList) {
    if (appAccount.utxoMap.locked.includes(hash)) {
      return true;
    }
  }
  return false;
};
const getLockedUtxos = (appAccount) => {
  if (appAccount.utxoMap.locked.length === 0) {
    return [];
  }
  return _getUtxos(appAccount, appAccount.utxoMap.locked);
};
const getUtxos = (appAccount) => {
  const selectedUtxoList = [];
  const lockedUtxoList = [];
  const collateralUtxoList = [];
  const accountUtxoList = appAccount.utxoMap.allOpk.concat();
  handlePendingUtxos(accountUtxoList, appAccount);
  for (const utxoHash of appAccount.utxoMap.selected) {
    const utxo = accountUtxoList.find((utxo2) => getUtxoHash(utxo2.input) === utxoHash);
    if (utxo) {
      selectedUtxoList.push(utxo);
    }
  }
  for (const utxoHash of appAccount.utxoMap.locked) {
    const utxo = accountUtxoList.find((utxo2) => getUtxoHash(utxo2.input) === utxoHash);
    if (utxo) {
      lockedUtxoList.push(utxo);
    }
  }
  const collateralUtxoHashList = appAccount.utxoMap.collateral.map((utxo) => getUtxoHash(utxo.input));
  for (const utxoHash of collateralUtxoHashList) {
    const utxo = accountUtxoList.find((utxo2) => getUtxoHash(utxo2.input) === utxoHash);
    if (utxo) {
      collateralUtxoList.push(utxo);
    }
  }
  return {
    selectedUtxoList,
    lockedUtxoList,
    collateralUtxoList
  };
};
const _getUtxos = (appAccount, utxoHashList) => {
  const utxoList = [];
  const accountUtxoList = appAccount.utxoMap.allOpk.concat();
  handlePendingUtxos(accountUtxoList, appAccount);
  for (const utxoHash of utxoHashList) {
    const utxo = accountUtxoList.find((utxo2) => getUtxoHash(utxo2.input) === utxoHash);
    if (utxo) {
      utxoList.push(utxo);
    }
  }
  return utxoList;
};

const activeSlotsCoeff$8 = 0.05;
const protocolParams$8 = {"protocolVersion":{"minor":0,"major":2},"decentralisationParam":1,"eMax":18,"extraEntropy":{"tag":"NeutralNonce"},"maxTxSize":16384,"maxBlockBodySize":65536,"maxBlockHeaderSize":1100,"minFeeA":44,"minFeeB":155381,"minUTxOValue":1000000,"poolDeposit":500000000,"minPoolCost":340000000,"keyDeposit":2000000,"nOpt":150,"rho":0.003,"tau":0.2,"a0":0.3};
const updateQuorum$8 = 5;
const networkId$8 = "Mainnet";
const initialFunds$1 = {};
const maxLovelaceSupply$8 = 45000000000000000;
const networkMagic$8 = 764824073;
const epochLength$8 = 432000;
const systemStart$8 = "2017-09-23T21:44:51Z";
const slotsPerKESPeriod$8 = 129600;
const slotLength$8 = 1;
const maxKESEvolutions$8 = 62;
const securityParam$8 = 2160;
const mainnetShelley = {
  activeSlotsCoeff: activeSlotsCoeff$8,
  protocolParams: protocolParams$8,
  updateQuorum: updateQuorum$8,
  networkId: networkId$8,
  initialFunds: initialFunds$1,
  maxLovelaceSupply: maxLovelaceSupply$8,
  networkMagic: networkMagic$8,
  epochLength: epochLength$8,
  systemStart: systemStart$8,
  slotsPerKESPeriod: slotsPerKESPeriod$8,
  slotLength: slotLength$8,
  maxKESEvolutions: maxKESEvolutions$8,
  securityParam: securityParam$8,
};

const maxLovelaceSupply$7 = 45000000000000000;
const securityParam$7 = 36;
const slotsPerKESPeriod$7 = 129600;
const updateQuorum$7 = 1;
const activeSlotsCoeff$7 = 0.05;
const protocolParams$7 = {"minUTxOValue":1000000,"eMax":18,"extraEntropy":{"tag":"NeutralNonce"},"minFeeB":1000,"tau":0.1,"maxBlockBodySize":65536,"minPoolCost":340000000,"minFeeA":1,"maxTxSize":16384,"nOpt":10,"maxBlockHeaderSize":1100,"keyDeposit":2000000,"protocolVersion":{"minor":0,"major":2},"poolDeposit":500000000,"a0":0.3,"rho":0.0003,"decentralisationParam":0.8};
const networkMagic$7 = 141;
const maxKESEvolutions$7 = 62;
const networkId$7 = "Testnet";
const slotLength$7 = 1;
const systemStart$7 = "2021-12-09T22:55:22Z";
const epochLength$7 = 3600;
const guildShelley = {
  maxLovelaceSupply: maxLovelaceSupply$7,
  securityParam: securityParam$7,
  slotsPerKESPeriod: slotsPerKESPeriod$7,
  updateQuorum: updateQuorum$7,
  activeSlotsCoeff: activeSlotsCoeff$7,
  protocolParams: protocolParams$7,
  networkMagic: networkMagic$7,
  maxKESEvolutions: maxKESEvolutions$7,
  networkId: networkId$7,
  slotLength: slotLength$7,
  systemStart: systemStart$7,
  epochLength: epochLength$7,
};

const maxLovelaceSupply$6 = 45000000000000000;
const securityParam$6 = 432;
const slotsPerKESPeriod$6 = 129600;
const updateQuorum$6 = 3;
const activeSlotsCoeff$6 = 0.05;
const protocolParams$6 = {"a0":0.3,"decentralisationParam":1,"eMax":18,"extraEntropy":{"tag":"NeutralNonce"},"keyDeposit":2000000,"maxBlockBodySize":65536,"maxBlockHeaderSize":1100,"maxTxSize":16384,"minFeeA":44,"minFeeB":155381,"minPoolCost":340000000,"minUTxOValue":1000000,"nOpt":150,"poolDeposit":500000000,"protocolVersion":{"major":6,"minor":0},"rho":0.003,"tau":0.2};
const networkMagic$6 = 4;
const initialFunds = {};
const maxKESEvolutions$6 = 62;
const networkId$6 = "Testnet";
const slotLength$6 = 1;
const systemStart$6 = "2023-06-15T00:30:00Z";
const epochLength$6 = 86400;
const sanchoShelley = {
  maxLovelaceSupply: maxLovelaceSupply$6,
  securityParam: securityParam$6,
  slotsPerKESPeriod: slotsPerKESPeriod$6,
  updateQuorum: updateQuorum$6,
  activeSlotsCoeff: activeSlotsCoeff$6,
  protocolParams: protocolParams$6,
  networkMagic: networkMagic$6,
  initialFunds,
  maxKESEvolutions: maxKESEvolutions$6,
  networkId: networkId$6,
  slotLength: slotLength$6,
  systemStart: systemStart$6,
  epochLength: epochLength$6,
};

const activeSlotsCoeff$5 = 0.05;
const epochLength$5 = 432000;
const maxKESEvolutions$5 = 62;
const maxLovelaceSupply$5 = 45000000000000000;
const networkId$5 = "Testnet";
const networkMagic$5 = 1;
const protocolParams$5 = {"protocolVersion":{"minor":0,"major":2},"decentralisationParam":1,"eMax":18,"extraEntropy":{"tag":"NeutralNonce"},"maxTxSize":16384,"maxBlockBodySize":65536,"maxBlockHeaderSize":1100,"minFeeA":44,"minFeeB":155381,"minUTxOValue":1000000,"poolDeposit":500000000,"minPoolCost":340000000,"keyDeposit":2000000,"nOpt":150,"rho":0.003,"tau":0.2,"a0":0.3};
const securityParam$5 = 2160;
const slotLength$5 = 1;
const slotsPerKESPeriod$5 = 129600;
const systemStart$5 = "2022-06-01T00:00:00Z";
const updateQuorum$5 = 5;
const preprodShelley = {
  activeSlotsCoeff: activeSlotsCoeff$5,
  epochLength: epochLength$5,
  maxKESEvolutions: maxKESEvolutions$5,
  maxLovelaceSupply: maxLovelaceSupply$5,
  networkId: networkId$5,
  networkMagic: networkMagic$5,
  protocolParams: protocolParams$5,
  securityParam: securityParam$5,
  slotLength: slotLength$5,
  slotsPerKESPeriod: slotsPerKESPeriod$5,
  systemStart: systemStart$5,
  updateQuorum: updateQuorum$5,
};

const activeSlotsCoeff$4 = 0.05;
const epochLength$4 = 86400;
const maxKESEvolutions$4 = 62;
const maxLovelaceSupply$4 = 45000000000000000;
const networkId$4 = "Testnet";
const networkMagic$4 = 2;
const protocolParams$4 = {"protocolVersion":{"minor":0,"major":6},"decentralisationParam":1,"eMax":18,"extraEntropy":{"tag":"NeutralNonce"},"maxTxSize":16384,"maxBlockBodySize":65536,"maxBlockHeaderSize":1100,"minFeeA":44,"minFeeB":155381,"minUTxOValue":1000000,"poolDeposit":500000000,"minPoolCost":340000000,"keyDeposit":2000000,"nOpt":150,"rho":0.003,"tau":0.2,"a0":0.3};
const securityParam$4 = 432;
const slotLength$4 = 1;
const slotsPerKESPeriod$4 = 129600;
const systemStart$4 = "2022-10-25T00:00:00Z";
const updateQuorum$4 = 5;
const previewShelley = {
  activeSlotsCoeff: activeSlotsCoeff$4,
  epochLength: epochLength$4,
  maxKESEvolutions: maxKESEvolutions$4,
  maxLovelaceSupply: maxLovelaceSupply$4,
  networkId: networkId$4,
  networkMagic: networkMagic$4,
  protocolParams: protocolParams$4,
  securityParam: securityParam$4,
  slotLength: slotLength$4,
  slotsPerKESPeriod: slotsPerKESPeriod$4,
  systemStart: systemStart$4,
  updateQuorum: updateQuorum$4,
};

const systemStart$3 = "2024-06-22T10:37:36.000000000Z";
const networkMagic$3 = 1127;
const networkId$3 = "Testnet";
const activeSlotsCoeff$3 = 0.25;
const securityParam$3 = 216;
const epochLength$3 = 8640;
const slotsPerKESPeriod$3 = 129600;
const maxKESEvolutions$3 = 62;
const slotLength$3 = 1;
const updateQuorum$3 = 2;
const maxLovelaceSupply$3 = 3000000000000000;
const protocolParams$3 = {"minFeeA":45,"minFeeB":156253,"maxBlockBodySize":180224,"maxTxSize":16384,"maxBlockHeaderSize":1100,"keyDeposit":0,"poolDeposit":0,"eMax":18,"nOpt":100,"a0":0,"rho":0.00001,"tau":0.000001,"minPoolCost":0,"decentralisationParam":0.7,"extraEntropy":{"tag":"NeutralNonce"},"protocolVersion":{"major":7,"minor":0},"minUTxOValue":1000000};
const afvtShelley = {
  systemStart: systemStart$3,
  networkMagic: networkMagic$3,
  networkId: networkId$3,
  activeSlotsCoeff: activeSlotsCoeff$3,
  securityParam: securityParam$3,
  epochLength: epochLength$3,
  slotsPerKESPeriod: slotsPerKESPeriod$3,
  maxKESEvolutions: maxKESEvolutions$3,
  slotLength: slotLength$3,
  updateQuorum: updateQuorum$3,
  maxLovelaceSupply: maxLovelaceSupply$3,
  protocolParams: protocolParams$3,
};

const systemStart$2 = "2024-06-22T10:37:36.000000000Z";
const networkMagic$2 = 3327;
const networkId$2 = "Testnet";
const activeSlotsCoeff$2 = 0.25;
const securityParam$2 = 216;
const epochLength$2 = 8640;
const slotsPerKESPeriod$2 = 129600;
const maxKESEvolutions$2 = 62;
const slotLength$2 = 1;
const updateQuorum$2 = 2;
const maxLovelaceSupply$2 = 3000000000000000;
const protocolParams$2 = {"minFeeA":45,"minFeeB":156253,"maxBlockBodySize":180224,"maxTxSize":16384,"maxBlockHeaderSize":1100,"keyDeposit":0,"poolDeposit":0,"eMax":18,"nOpt":100,"a0":0,"rho":0.00001,"tau":0.000001,"minPoolCost":0,"decentralisationParam":0.7,"extraEntropy":{"tag":"NeutralNonce"},"protocolVersion":{"major":7,"minor":0},"minUTxOValue":1000000};
const afvmShelley = {
  systemStart: systemStart$2,
  networkMagic: networkMagic$2,
  networkId: networkId$2,
  activeSlotsCoeff: activeSlotsCoeff$2,
  securityParam: securityParam$2,
  epochLength: epochLength$2,
  slotsPerKESPeriod: slotsPerKESPeriod$2,
  maxKESEvolutions: maxKESEvolutions$2,
  slotLength: slotLength$2,
  updateQuorum: updateQuorum$2,
  maxLovelaceSupply: maxLovelaceSupply$2,
  protocolParams: protocolParams$2,
};

const systemStart$1 = "2024-05-16T17:18:10.000000000Z";
const networkMagic$1 = 3311;
const networkId$1 = "Testnet";
const activeSlotsCoeff$1 = 0.05;
const securityParam$1 = 2160;
const epochLength$1 = 432000;
const slotsPerKESPeriod$1 = 129600;
const maxKESEvolutions$1 = 62;
const slotLength$1 = 1;
const updateQuorum$1 = 2;
const maxLovelaceSupply$1 = 3000000000000000;
const protocolParams$1 = {"minFeeA":47,"minFeeB":158298,"maxBlockBodySize":65536,"maxTxSize":16384,"maxBlockHeaderSize":1100,"keyDeposit":0,"poolDeposit":0,"eMax":18,"nOpt":100,"a0":0,"rho":0.0038,"tau":0.000001,"minPoolCost":0,"decentralisationParam":0.7,"extraEntropy":{"tag":"NeutralNonce"},"protocolVersion":{"major":7,"minor":0},"minUTxOValue":1000000};
const afptShelley = {
  systemStart: systemStart$1,
  networkMagic: networkMagic$1,
  networkId: networkId$1,
  activeSlotsCoeff: activeSlotsCoeff$1,
  securityParam: securityParam$1,
  epochLength: epochLength$1,
  slotsPerKESPeriod: slotsPerKESPeriod$1,
  maxKESEvolutions: maxKESEvolutions$1,
  slotLength: slotLength$1,
  updateQuorum: updateQuorum$1,
  maxLovelaceSupply: maxLovelaceSupply$1,
  protocolParams: protocolParams$1,
};

const systemStart = "2024-05-13T17:40:00.000000000Z";
const networkMagic = 764824073;
const networkId = "Mainnet";
const activeSlotsCoeff = 0.05;
const securityParam = 2160;
const epochLength = 432000;
const slotsPerKESPeriod = 129600;
const maxKESEvolutions = 60;
const slotLength = 1;
const updateQuorum = 5;
const maxLovelaceSupply = 3000000000000000;
const protocolParams = {"minFeeA":47,"minFeeB":158298,"maxBlockBodySize":65536,"maxTxSize":16384,"maxBlockHeaderSize":1100,"keyDeposit":0,"poolDeposit":0,"eMax":18,"nOpt":100,"a0":0,"rho":0.00001,"tau":0.000001,"minPoolCost":0,"decentralisationParam":0.7,"extraEntropy":{"tag":"NeutralNonce"},"protocolVersion":{"major":2,"minor":0},"minUTxOValue":1000000};
const afpmShelley = {
  systemStart,
  networkMagic,
  networkId,
  activeSlotsCoeff,
  securityParam,
  epochLength,
  slotsPerKESPeriod,
  maxKESEvolutions,
  slotLength,
  updateQuorum,
  maxLovelaceSupply,
  protocolParams,
};

const blockVersionData$8 = {"heavyDelThd":"300000000000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxProposalSize":"700","maxTxSize":"4096","mpcThd":"20000000000000","scriptVersion":0,"slotDuration":"20000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"multiplier":"43946000000","summand":"155381000000000"},"unlockStakeEpoch":"18446744073709551615","updateImplicit":"10000","updateProposalThd":"100000000000000","updateVoteThd":"1000000000000"};
const ftsSeed = "76617361206f7061736120736b6f766f726f64612047677572646120626f726f64612070726f766f6461";
const protocolConsts$8 = {"k":2160,"protocolMagic":764824073,"vssMaxTTL":6,"vssMinTTL":2};
const startTime$8 = 1506203091;
const mainnetByron = {
  blockVersionData: blockVersionData$8,
  ftsSeed,
  protocolConsts: protocolConsts$8,
  startTime: startTime$8,
};

const startTime$7 = 1639090522;
const blockVersionData$7 = {"scriptVersion":0,"slotDuration":"100","maxBlockSize":"641000","maxHeaderSize":"200000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"200000","heavyDelThd":"300000","updateVoteThd":"100000","updateProposalThd":"100000","updateImplicit":"10000","softforkRule":{"initThd":"900000","minThd":"600000","thdDecrement":"100000"},"txFeePolicy":{"summand":"0","multiplier":"439460"},"unlockStakeEpoch":"184467"};
const protocolConsts$7 = {"k":36,"protocolMagic":141};
const avvmDistr$2 = {};
const guildByron = {
  startTime: startTime$7,
  blockVersionData: blockVersionData$7,
  protocolConsts: protocolConsts$7,
  avvmDistr: avvmDistr$2,
};

const startTime$6 = 1686789000;
const blockVersionData$6 = {"avvmDistr":{},"heavyDelThd":"300000000000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxProposalSize":"700","maxTxSize":"4096","mpcThd":"20000000000000","scriptVersion":0,"slotDuration":"20000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"multiplier":"43946000000","summand":"155381000000000"},"unlockStakeEpoch":"18446744073709551615","updateImplicit":"10000","updateProposalThd":"100000000000000","updateVoteThd":"1000000000000"};
const protocolConsts$6 = {"k":432,"protocolMagic":4};
const sanchoByron = {
  startTime: startTime$6,
  blockVersionData: blockVersionData$6,
  protocolConsts: protocolConsts$6,
};

const startTime$5 = 1654041600;
const blockVersionData$5 = {"scriptVersion":0,"slotDuration":"20000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"20000000000000","heavyDelThd":"300000000000","updateVoteThd":"1000000000000","updateProposalThd":"100000000000000","updateImplicit":"10000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"summand":"155381000000000","multiplier":"43946000000"},"unlockStakeEpoch":"18446744073709551615"};
const protocolConsts$5 = {"k":2160,"protocolMagic":1};
const preprodByron = {
  startTime: startTime$5,
  blockVersionData: blockVersionData$5,
  protocolConsts: protocolConsts$5,
};

const startTime$4 = 1666656000;
const blockVersionData$4 = {"scriptVersion":0,"slotDuration":"20000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"20000000000000","heavyDelThd":"300000000000","updateVoteThd":"1000000000000","updateProposalThd":"100000000000000","updateImplicit":"10000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"summand":"155381000000000","multiplier":"43946000000"},"unlockStakeEpoch":"18446744073709551615"};
const protocolConsts$4 = {"k":432,"protocolMagic":2};
const previewByron = {
  startTime: startTime$4,
  blockVersionData: blockVersionData$4,
  protocolConsts: protocolConsts$4,
};

const startTime$3 = 1719052656;
const blockVersionData$3 = {"scriptVersion":0,"slotDuration":"20000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"20000000000000","heavyDelThd":"300000000000","updateVoteThd":"1000000000000","updateProposalThd":"100000000000000","updateImplicit":"10000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"summand":"155381000000000","multiplier":"43946000000"},"unlockStakeEpoch":"18446744073709551615"};
const protocolConsts$3 = {"k":216,"protocolMagic":1127};
const avvmDistr$1 = {};
const afvtByron = {
  startTime: startTime$3,
  blockVersionData: blockVersionData$3,
  protocolConsts: protocolConsts$3,
  avvmDistr: avvmDistr$1,
};

const startTime$2 = 1719052656;
const blockVersionData$2 = {"scriptVersion":0,"slotDuration":"20000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"20000000000000","heavyDelThd":"300000000000","updateVoteThd":"1000000000000","updateProposalThd":"100000000000000","updateImplicit":"10000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"summand":"155381000000000","multiplier":"43946000000"},"unlockStakeEpoch":"18446744073709551615"};
const protocolConsts$2 = {"k":216,"protocolMagic":1127};
const avvmDistr = {};
const afvmByron = {
  startTime: startTime$2,
  blockVersionData: blockVersionData$2,
  protocolConsts: protocolConsts$2,
  avvmDistr,
};

const startTime$1 = 1715879890;
const blockVersionData$1 = {"scriptVersion":0,"slotDuration":"20000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"20000000000000","heavyDelThd":"300000000000","updateVoteThd":"1000000000000","updateProposalThd":"100000000000000","updateImplicit":"10000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"summand":"155381000000000","multiplier":"43946000000"},"unlockStakeEpoch":"18446744073709551615"};
const protocolConsts$1 = {"k":2160,"protocolMagic":3311};
const afptByron = {
  startTime: startTime$1,
  blockVersionData: blockVersionData$1,
  protocolConsts: protocolConsts$1,
};

const startTime = 1715622000;
const blockVersionData = {"scriptVersion":0,"slotDuration":"20000","maxBlockSize":"2000000","maxHeaderSize":"2000000","maxTxSize":"4096","maxProposalSize":"700","mpcThd":"20000000000000","heavyDelThd":"300000000000","updateVoteThd":"1000000000000","updateProposalThd":"100000000000000","updateImplicit":"10000","softforkRule":{"initThd":"900000000000000","minThd":"600000000000000","thdDecrement":"50000000000000"},"txFeePolicy":{"summand":"155381000000000","multiplier":"43946000000"},"unlockStakeEpoch":"18446744073709551615"};
const protocolConsts = {"k":2160,"protocolMagic":764824073};
const afpmByron = {
  startTime,
  blockVersionData,
  protocolConsts,
};

const GenesisStore = {
  mainnet: {
    shelley: mainnetShelley,
    byron: mainnetByron
  },
  guild: {
    shelley: guildShelley,
    byron: guildByron
  },
  sancho: {
    shelley: sanchoShelley,
    byron: sanchoByron
  },
  preprod: {
    shelley: preprodShelley,
    byron: preprodByron
  },
  preview: {
    shelley: previewShelley,
    byron: previewByron
  },
  afvt: {
    shelley: afvtShelley,
    byron: afvtByron
  },
  afvm: {
    shelley: afvmShelley,
    byron: afvmByron
  },
  afpt: {
    shelley: afptShelley,
    byron: afptByron
  },
  afpm: {
    shelley: afpmShelley,
    byron: afpmByron
  }
};

const getByron = (networkId) => GenesisStore[networkId].byron;
const getShelley = (networkId) => GenesisStore[networkId].shelley;
const getNetworkMagic = (networkId) => GenesisStore[networkId].shelley.networkMagic;
const getEpochLength = (networkId) => GenesisStore[networkId].shelley.epochLength;
const getShelleyTransitionEpoch = (networkId) => {
  switch (networkId) {
    case "mainnet":
      return 208;
    case "preprod":
      return 4;
    case "preview":
      return 0;
    case "guild":
      return 2;
    case "sancho":
      return 0;
    case "afvt":
      return 0;
    case "afvm":
      return 0;
    case "afpt":
      return 0;
    case "afpm":
      return 2;
    default:
      return 0;
  }
};
const getCommonData = (networkId) => {
  const byron = getByron(networkId);
  const currentTimeSec = Math.floor(now() / 1e3);
  const shelleyTransEpoch = getShelleyTransitionEpoch(networkId);
  const byronEpochLength = byron.protocolConsts.k * 10;
  const byronSlots = shelleyTransEpoch * byronEpochLength;
  const byronSlotLength = byron.blockVersionData.slotDuration;
  const byronEndTime = byron.startTime + Math.floor(shelleyTransEpoch * byronEpochLength * parseInt(byronSlotLength) / 1e3);
  return {
    currentTimeSec,
    shelleyTransEpoch,
    byronEpochLength,
    byronSlots,
    byronSlotLength,
    byronEndTime
  };
};
const getCalculatedChainTip = (networkId) => {
  const byron = getByron(networkId);
  const shelley = getShelley(networkId);
  const common = getCommonData(networkId);
  if (common.currentTimeSec < common.byronEndTime) {
    return Math.floor(
      (common.currentTimeSec - byron.startTime) * 1e3
    ) / parseInt(byron.blockVersionData.slotDuration);
  }
  return common.byronSlots + Math.floor(
    (common.currentTimeSec - common.byronEndTime) / shelley.slotLength
  );
};
const getTimestampFromSlot = (networkId, slotNo) => {
  const byron = getByron(networkId);
  const shelley = getShelley(networkId);
  const common = getCommonData(networkId);
  if (slotNo < common.byronSlots) {
    return byron.startTime * 1e3 + slotNo * parseInt(byron.blockVersionData.slotDuration);
  }
  return (common.byronEndTime + (slotNo - common.byronSlots) * shelley.slotLength) * 1e3;
};
const getDateIdFromSlot = (networkId, slotNo, userSelectedTimezone) => {
  const timeStamp = getTimestampFromSlot(networkId, slotNo);
  const date = new Date(timeStamp);
  const formatter = Intl.DateTimeFormat("de-DE", {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    timeZone: userSelectedTimezone
  });
  const dateArray = formatter.formatToParts(date);
  return {
    year: parseInt(dateArray[4].value),
    month: parseInt(dateArray[2].value),
    day: parseInt(dateArray[0].value),
    timezone: userSelectedTimezone
  };
};
const getEpochFromSlot = (networkId, slotNo) => {
  const byron = getByron(networkId);
  const shelley = getShelley(networkId);
  const common = getCommonData(networkId);
  let timeSec = 0;
  if (slotNo < common.byronSlots) {
    timeSec = byron.startTime + slotNo * parseInt(byron.blockVersionData.slotDuration);
  } else {
    timeSec = common.byronEndTime + (slotNo - common.byronSlots) * shelley.slotLength;
  }
  if (timeSec < common.byronEndTime) {
    return Math.floor(
      (timeSec - byron.startTime) * 1e3 / parseInt(byron.blockVersionData.slotDuration) / common.byronEpochLength
    );
  }
  return common.shelleyTransEpoch + Math.floor(
    (timeSec - common.byronEndTime) / shelley.slotLength / shelley.epochLength
  );
};
const getCalculatedEpochSlot = (networkId) => {
  const shelley = getShelley(networkId);
  const common = getCommonData(networkId);
  const tip = getCalculatedChainTip(networkId) - common.byronSlots - (getCalculatedEpoch(networkId) - common.shelleyTransEpoch) * shelley.epochLength;
  return Math.floor(tip);
};
const getCalculatedEpoch = (id) => {
  const byron = getByron(id);
  const shelley = getShelley(id);
  const common = getCommonData(id);
  if (common.currentTimeSec < common.byronEndTime) {
    return Math.floor(
      (common.currentTimeSec - byron.startTime) * 1e3 / parseInt(byron.blockVersionData.slotDuration) / common.byronEpochLength
    );
  }
  return common.shelleyTransEpoch + Math.floor(
    (common.currentTimeSec - common.byronEndTime) / shelley.slotLength / shelley.epochLength
  );
};
const updateChainTip = (id, chainTip, data) => {
  const shelley = getShelley(id);
  const calcTip = getCalculatedChainTip(id);
  chainTip.blockNo = data.blockNo;
  chainTip.slotNo = data.slotNo;
  chainTip.epochNo = data.epochNo;
  chainTip.epochSlot = data.epochSlot;
  chainTip.epochSlots = shelley.epochLength;
  chainTip.epochPercent = parseFloat((chainTip.epochSlot / chainTip.epochSlots * 100).toFixed(2));
  chainTip.syncProgress = Math.round(chainTip.slotNo / calcTip * 1e4) / 100;
  chainTip.onTip = calcTip - chainTip.slotNo < 300;
  return chainTip;
};

const doBuildTxVoteDelegation = "doBuildTxVoteDelegation";
const onBuiltTxVoteReg = "onBuiltTxVoteReg";
const onBuiltTxVoteDelegation = "onBuiltTxVoteDelegation";
const onTxSignSubmit = "onTxSignSubmit";
const onTxSignCancel = "onTxSignCancel";
const onTxSignReset = "onTxSignReset";
const onTxSubmitted = "onTxSubmitted";
const onDataSignSubmit = "onDataSignSubmit";
const onDataSignCancel = "onDataSignCancel";
const onDataSignReset = "onDataSignReset";
const doOpenTxViewer = "doOpenTxViewer";
const doLoadTxAssetMetadata = "doLoadTxAssetMetadata";
const onTxNoteAdded = "onTxNoteAdded";
const onTxNoteUpdated = "onTxNoteUpdated";
const onTxNoteDeleted = "onTxNoteDeleted";

var MediaSize = /* @__PURE__ */ ((MediaSize2) => {
  MediaSize2[MediaSize2["LOW"] = 128] = "LOW";
  MediaSize2[MediaSize2["HIGH"] = 1024] = "HIGH";
  return MediaSize2;
})(MediaSize || {});
var MediaType = /* @__PURE__ */ ((MediaType2) => {
  MediaType2["IMAGE"] = "IMAGE";
  MediaType2["AUDIO"] = "AUDIO";
  MediaType2["VIDEO"] = "VIDEO";
  MediaType2["PDF"] = "PDF";
  MediaType2["IFRAME"] = "IFRAME";
  MediaType2["MUSIC_SONG"] = "MUSIC_SONG";
  MediaType2["UNDEFINED"] = "UNDEFINED";
  return MediaType2;
})(MediaType || {});

class AssetDB extends Dexie {
  list;
  cdn;
  constructor(networkId) {
    super("eternl-" + networkId + "-asset");
    this.version(1).stores({
      list: "p",
      cdn: "f"
    });
    this.version(2).upgrade((tx) => {
      return tx.table("list").clear();
    });
  }
}
const dbMap$5 = networkIdList.reduce((o, n) => {
  o[n] = null;
  return o;
}, {});
const getDB$6 = async (networkId) => {
  let db = dbMap$5[networkId];
  if (!db) {
    db = new AssetDB(networkId);
    dbMap$5[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const getAssets = (networkId, assets) => {
  return getDB$6(networkId).then((db) => {
    return db.list.bulkGet(Object.keys(assets)).then((dbList) => {
      const assetList = {};
      for (const item of dbList) {
        if (item) {
          const wantedAssets = assets[item.p];
          assetList[item.p] = item.a.filter((ai) => wantedAssets.includes(ai.h));
        }
      }
      return assetList;
    }).catch((e) => null);
  }).catch((e) => null);
};
const putAssets = (networkId, assets) => {
  return getDB$6(networkId).then((db) => {
    return db.transaction("rw", db.list, async (tx) => {
      const dbList = await db.list.bulkGet(Object.keys(assets));
      for (const entry of Object.entries(assets)) {
        const dbAsset = dbList.find((a) => a && a.p === entry[0]);
        if (dbAsset) {
          const assetList = dbAsset.a.filter((a) => !entry[1].some((ai) => ai.h === a.h));
          assetList.push(...entry[1]);
          db.list.put({ p: entry[0], a: assetList });
        } else {
          db.list.put({ p: entry[0], a: entry[1] });
        }
      }
      return true;
    });
  }).catch((e) => false);
};
const removeAllAssets = (networkId) => getDB$6(networkId).then((db) => db.list.clear());
const getCDNImage = (networkId, fingerprint) => {
  return getDB$6(networkId).then((db) => db.cdn.get(fingerprint));
};
const getCDNImages = (networkId, fingerprints) => {
  return getDB$6(networkId).then((db) => {
    return db.transaction("r", db.cdn, async (tx) => {
      return await db.cdn.bulkGet(fingerprints);
    });
  }).catch((e) => []);
};
const putCDNImage = (networkId, image) => {
  return getDB$6(networkId).then((db) => db.cdn.put(image));
};
const putCDNImages = (networkId, images) => {
  return getDB$6(networkId).then((db) => {
    return db.transaction("rw", db.cdn, async (tx) => {
      db.cdn.bulkPut(images);
      return true;
    });
  }).catch((e) => false);
};
const removeAllCDNImages = (networkId) => getDB$6(networkId).then((db) => db.cdn.clear());
const AssetDB$1 = {
  getAssets,
  putAssets,
  getCDNImage,
  getCDNImages,
  putCDNImage,
  putCDNImages,
  removeAllAssets,
  removeAllCDNImages
};

networkIdList.reduce((o, n) => {
  o[n] = {
    postgrest: { rpc(a, b) {
      return { single() {
      } };
    }, url: "", schema: "" },
    postgrestFH: { rpc(a, b) {
      return { single() {
      } };
    }, url: "", schema: "" },
    gql: "",
    fh: {
      jwt_token: "",
      api: ""
    },
    catalyst: "",
    id: n
  };
  if (n === "mainnet") {
    o[n].bf = {
      pid: "Qyj1TZi2K991Na979bZd1VBHw66RxhpW",
      api: "https://cardano-mainnet.blockfrost.io/api/v0"
    };
    o[n].swap = {
      ms: {
        pools: "https://onchain.muesliswap.com/pools/pair",
        orders: "https://onchain.muesliswap.com/orders/all",
        datum: "https://aggregator.muesliswap.com/constructSwapDatum",
        cancel: "https://aggregator.muesliswap.com/cancelSwapTransaction",
        verified: "https://api.muesliswap.com/token-status"
      },
      dh: {
        us: "https://api-us.dexhunterv3.app",
        eu: "https://api-eu.dexhunterv3.app",
        orders: "/swap/orders/",
        lpinfo: "/swap/pairStats/",
        assets: "/swap/tokens",
        estimate: "/swap/estimate",
        restimate: "/swap/reverseEstimate",
        lestimate: "/swap/limit/estimate",
        avgprice: "/swap/averagePrice/",
        build: "/swap/build",
        limit: "/swap/limit/build",
        cancel: "/swap/cancel",
        options: { headers: [{ name: "X-Partner-Id", value: "eternl-Zdfz2u71Q7cL" }] }
      },
      ss: {
        token: "https://eternl.steelswap.io/tokens/list/",
        usdPrice: "https://eternl.steelswap.io/tokens/price/usd/"
      },
      py: {
        floorAndSales: "https://devapi.pyroanalytics.io/v1/policy/collectionFloorAndSales"
      }
    };
    o[n].catalyst = "https://core.projectcatalyst.io/api/v0/fund";
  } else if (n === "preprod") {
    o[n].bf = {
      pid: "preprodmrTNQWgyoje1RDejR7FeJYUAuUSDMbP2",
      api: "https://cardano-preprod.blockfrost.io/api/v0"
    };
    o[n].swap = {
      ms: {
        pools: "https://preprod.onchain.muesliswap.com/pools/pair",
        orders: "https://preprod.onchain.muesliswap.com/orders/all",
        datum: "https://aggregator.muesliswap.com/constructTestnetSwapDatum",
        cancel: "https://aggregator.muesliswap.com/cancelTestnetSwapTransaction",
        verified: ""
      },
      ss: {
        token: "https://ci.cardem.io/api/tokens/list/",
        usdPrice: "https://ci.cardem.io/api/tokens/price/usd/"
      }
    };
    o[n].catalyst = "https://core.projectcatalyst.io/api/v0/fund";
  } else if (n === "preview") {
    o[n].bf = {
      pid: "preview9uvxT4opuz8kZGYYXNLzVsjhk43VYF6U",
      api: "https://cardano-preview.blockfrost.io/api/v0"
    };
  }
  return o;
}, {});
networkIdList.reduce((o, n) => {
  o[n] = [];
  return o;
}, {});
networkIdList.reduce((o, n) => {
  o[n] = {
    postgrest: { rpc(a, b) {
      return { single() {
      } };
    }, url: "", schema: "" },
    postgrestFH: { rpc(a, b) {
      return { single() {
      } };
    }, url: "", schema: "" },
    gql: "",
    fh: {
      jwt_token: "",
      api: ""
    },
    catalyst: "",
    id: n
  };
  return o;
}, {});

const fetchAssetInfo = async (networkId, assetMap) => {
  const url = `/${networkId}/v2/asset/info`;
  const res = await api$1.post(url, { assetList: assetMap }).catch((err) => {
    console.error(el("fetchAssetInfo"), json(err));
  });
  if (res?.data) {
    return res?.data;
  }
  return {};
};
const fetchAssetMetadata = async (networkId, policyId, assetName) => {
  const url = `/${networkId}/v2/asset/metadata`;
  const res = await api$1.post(url, { policyId, assetName }).catch((err) => {
    console.error(el("fetchAssetMetadata"), json(err));
  });
  if (res?.data?.metadata) {
    return res?.data.metadata;
  } else if (res?.data?.cip68meta) {
    return res?.data.cip68meta;
  }
  return [];
};
const fetchAssetCDN = async (networkId, assetList) => {
  const url = `/${networkId}/v2/asset/cdn`;
  const res = await api$1.post(url, { assetList }).catch((err) => {
    console.error(el("fetchAssetCDN"), json(err));
  });
  if (res?.data) {
    return res?.data;
  }
  return [];
};
const fetchImageCDN = async (url, fingerprint) => {
  const res = await api$1.fetchData(url, true, null, {
    responseType: "arraybuffer"
  }).catch((err) => {
    console.warn(el("fetchImageCdn"), fingerprint, json(err));
  });
  if (res) {
    return res;
  }
  return null;
};
const fetchAssetCDNImage = async (networkId, assetCDN, mediaSize = MediaSize.LOW) => {
  const imageParam = assetCDN.l.find((p) => p.s === mediaSize);
  let image = null;
  if (imageParam) {
    const imageUrl = buildUrl(networkId, buildBaseUrl(networkId, assetCDN.f), imageParam);
    if (imageUrl) {
      image = await fetchImageCDN(imageUrl, assetCDN.f);
    }
  }
  return image;
};
const buildBaseUrl = (networkId, fingerprint) => {
  if (networkId === "mainnet") {
    return `https://${fingerprint}.eternl.nftcdn.io/image`;
  } else if (networkId === "preprod" || networkId === "preview") {
    return `https://${fingerprint}.${networkId}.nftcdn.io/image`;
  }
  return null;
};
const buildUrl = (networkId, baseUrl, params) => {
  if (!baseUrl) {
    return null;
  }
  if (params.s) {
    baseUrl += "?size=" + params.s;
  }
  return baseUrl + (networkId !== "preview" ? "&tk=" + params.tk : "");
};

const _assetInfoMap = /* @__PURE__ */ new Map();
const _promiseMap$1 = /* @__PURE__ */ new Map();
const __getAssetInfoMap = () => _assetInfoMap;
const getAssetInfo = async (policyId, assetName) => {
  if (!policyId || !assetName) {
    return void 0;
  }
  let assetInfo = _assetInfoMap.get(policyId)?.get(assetName);
  if (assetInfo) {
    return assetInfo;
  }
  assetInfo = await getAssetInfoFromDB(policyId, assetName);
  if (assetInfo) {
    return assetInfo;
  }
  let assetInfoPromise = _promiseMap$1.get(policyId + assetName);
  if (!assetInfoPromise) {
    assetInfoPromise = loadAssetInfo(policyId, assetName);
    _promiseMap$1.set(policyId + assetName, assetInfoPromise);
  }
  assetInfo = await assetInfoPromise;
  return assetInfo;
};
const getAssetInfoList = async (assetDetailsList) => {
  const assetMap = {};
  for (const assetDetails of assetDetailsList) {
    if (!assetDetails) {
      continue;
    }
    if (assetDetails.ai) {
      continue;
    }
    let assetInfo = _assetInfoMap.get(assetDetails.p)?.get(assetDetails.t.a);
    if (assetInfo) {
      assetDetails.ai = assetInfo;
      continue;
    }
    assetMap[assetDetails.p] = assetMap[assetDetails.p] || [];
    assetMap[assetDetails.p].push(assetDetails.t.a);
  }
  await getAssetInfoFromDBList(assetMap);
  return _assetInfoMap;
};
const addAllAssetInfoToMap = (assetInfoMap) => {
  for (const policyId in assetInfoMap) {
    const assetInfoList = assetInfoMap[policyId];
    let policyMap = _assetInfoMap.get(policyId);
    if (!policyMap) {
      policyMap = /* @__PURE__ */ new Map();
      _assetInfoMap.set(policyId, policyMap);
    }
    for (const assetInfo of assetInfoList) {
      policyMap.set(assetInfo.h, assetInfo);
    }
  }
};
const getAssetInfoFromDB = async (policyId, assetName) => {
  const assetMap = { [policyId]: [assetName] };
  const dbAssets = await AssetDB$1.getAssets(networkId$9.value, assetMap) ?? {};
  const assetInfo = dbAssets[policyId]?.find((ai) => ai.h === assetName);
  addAssetInfoToMap(policyId, assetName, assetInfo);
  return assetInfo;
};
const getAssetInfoFromDBList = async (assetMap) => {
  if (Object.keys(assetMap).length === 0) {
    return;
  }
  const dbAssets = await AssetDB$1.getAssets(networkId$9.value, assetMap) ?? {};
  addAllAssetInfoToMap(dbAssets);
  return dbAssets;
};
const loadAssetInfo = async (policyId, assetName) => {
  const assetMap = { [policyId]: [assetName] };
  const assetInfoMap = await fetchAssetInfo(networkId$9.value, assetMap);
  if (!assetInfoMap) {
    return void 0;
  }
  const assetInfo = assetInfoMap[policyId]?.find((ai) => ai.h === assetName);
  addAssetInfoToMap(policyId, assetName, assetInfo);
  if (assetInfo) {
    await saveAssetInfoToDB(policyId, assetInfo);
  }
  _promiseMap$1.delete(policyId + assetName);
  return assetInfo;
};
const saveAssetInfoToDB = (policyId, assetInfo) => {
  return AssetDB$1.putAssets(networkId$9.value, { [policyId]: [assetInfo] });
};
const addAssetInfoToMap = (policyId, assetName, assetInfo) => {
  if (!assetInfo) {
    return;
  }
  let policyMap = _assetInfoMap.get(policyId);
  if (!policyMap) {
    policyMap = /* @__PURE__ */ new Map();
    _assetInfoMap.set(policyId, policyMap);
  }
  policyMap.set(assetName, assetInfo);
};

const get721MetadataDetails = (policy, name, metadata) => {
  const meta721 = metadata.find((meta) => meta.key === "721")?.json ?? null;
  if (!meta721) {
    return null;
  }
  if (policy in meta721) ; else if (prefix0x(policy) in meta721) {
    policy = prefix0x(policy);
  } else return null;
  const formattedAssetName = formatAssetName(name);
  if (name in meta721[policy]) ; else if (prefix0x(name) in meta721[policy]) {
    name = prefix0x(name);
  } else if (formattedAssetName in meta721[policy]) {
    name = formattedAssetName;
  } else return null;
  return meta721[policy][name];
};
const isValidMetadataList = (metadata) => {
  for (const meta of metadata) {
    if (!("key" in meta) || !("json" in meta)) {
      return false;
    }
  }
  return true;
};
const get1155Metadata = (metadata) => {
  const meta1155 = metadata.find((meta) => meta.key === "721")?.json ?? null;
  return meta1155 && "asset" in meta1155 ? meta1155 : null;
};

const _assetMetaMap = /* @__PURE__ */ new Map();
const _promiseMap = /* @__PURE__ */ new Map();
const __getAssetMetaMap = () => _assetMetaMap;
const getAssetMeta = async (policyId, assetName) => {
  if (!policyId || !assetName) {
    return void 0;
  }
  let metaInfo = _assetMetaMap.get(policyId)?.get(assetName);
  if (metaInfo) {
    return metaInfo;
  }
  let metaInfoPromise = _promiseMap.get(policyId + assetName);
  if (!metaInfoPromise) {
    metaInfoPromise = loadAssetMeta(policyId, assetName);
    _promiseMap.set(policyId + assetName, metaInfoPromise);
  }
  metaInfo = await metaInfoPromise;
  return metaInfo;
};
const loadAssetMeta = async (policyId, assetName) => {
  const serverMeta = await fetchAssetMetadata(networkId$9.value, policyId, assetName);
  if (!serverMeta) {
    return void 0;
  }
  const assetMeta = {};
  let hasMeta = false;
  if (Array.isArray(serverMeta) && isValidMetadataList(serverMeta)) {
    assetMeta.list = serverMeta;
    hasMeta = true;
    const meta721 = get721MetadataDetails(policyId, assetName, serverMeta);
    if (meta721) {
      assetMeta.meta721 = meta721;
    } else {
      const meta1155 = get1155Metadata(serverMeta);
      if (meta1155) {
        assetMeta.meta1155 = meta1155;
      }
    }
  } else if (serverMeta.json) {
    assetMeta.meta68 = serverMeta.json;
    hasMeta = true;
  }
  if (!hasMeta) {
    return void 0;
  }
  addAssetMetaToMap(policyId, assetName, assetMeta);
  _promiseMap.delete(policyId + assetName);
  return assetMeta;
};
const addAssetMetaToMap = (policyId, assetName, metaInfo) => {
  if (!metaInfo) {
    return;
  }
  let policyMap = _assetMetaMap.get(policyId);
  if (!policyMap) {
    policyMap = /* @__PURE__ */ new Map();
    _assetMetaMap.set(policyId, policyMap);
  }
  policyMap.set(assetName, metaInfo);
};

const verifiedAssetMap = ref$1({});
const swapAssetInfoMap = ref$1({});
ref$1(-1);
computed(() => {
  let cnt = 0;
  for (const list of Object.values(swapAssetInfoMap.value)) {
    cnt += list.length;
  }
  return cnt;
});
const isVerifiedAsset = (policyId, hexName) => {
  return verifiedAssetMap.value[policyId]?.includes(hexName) ?? false;
};

const _textDecoder = new TextDecoder("utf-8", { fatal: true });
const getSortedAssetDetailsList = async (ma) => {
  if (!ma) {
    return [];
  }
  const sortedAssetDetailsList = [];
  for (const policyId of Object.keys(ma)) {
    const assetList = Object.entries(ma[policyId]);
    for (const asset of assetList) {
      const assetName = asset[0];
      const quantity = asset[1];
      const assetDetails = createIAssetListItemDetails(policyId, assetName, quantity);
      sortedAssetDetailsList.push(assetDetails);
    }
  }
  await scheduleSetAssetInfoList(sortedAssetDetailsList);
  sortedAssetDetailsList.sort((a, b) => {
    if (compare$1(a.a ?? "0", "<=", b.a ?? "0")) {
      return -1;
    }
    if (a.p !== b.p) {
      return a.p.localeCompare(a.p, "en-US");
    }
    return a.n.localeCompare(b.n, "en-US");
  });
  return sortedAssetDetailsList;
};
const loadAssetMetadata = async (assetDetails) => {
  if (!assetDetails) {
    return;
  }
  const am = await getAssetMeta(assetDetails.p, assetDetails.t.a) ?? void 0;
  if (am) {
    assetDetails.am = am;
  }
};
const searchForAssetId = (str) => {
  if (!str || str.length < 2) {
    return null;
  }
  str = str.toLowerCase();
  const _assetInfoMap = __getAssetInfoMap();
  const _assetMetaMap = __getAssetMetaMap();
  const policyIdList = Array.from(_assetInfoMap.keys());
  const res = [];
  for (const policyId of policyIdList) {
    const assetInfoMap = _assetInfoMap.get(policyId);
    const assetMetaMap = _assetMetaMap.get(policyId);
    const assetInfoList = assetInfoMap ? Array.from(assetInfoMap.values()) : [];
    for (const assetInfo of assetInfoList) {
      try {
        if (policyId === str) {
          res.push(getAssetIdBech32(policyId, assetInfo.h));
          continue;
        }
        let _str = JSON.stringify(assetInfo).toLowerCase();
        if (assetMetaMap) {
          const assetMeta = assetMetaMap.get(assetInfo.h);
          if (assetMeta) {
            _str += " " + JSON.stringify(assetMeta).toLowerCase();
          }
        }
        if (_str.includes(str)) {
          res.push(getAssetIdBech32(policyId, assetInfo.h));
        }
      } catch (err) {
        console.error("getAssetInfoByName", err, assetInfo);
      }
    }
  }
  return res;
};
const cacheUpdateList = /* @__PURE__ */ new Map();
const cachePromises = /* @__PURE__ */ new Map();
const scheduleSetAssetInfo = (assetDetails) => {
  const key = assetDetails.p + assetDetails.t.a;
  let promise = cachePromises.get(key);
  if (promise) {
    let list = cacheUpdateList.get(key) ?? [];
    if (!list.includes(assetDetails)) {
      list.push(assetDetails);
      cacheUpdateList.set(key, list);
    }
    return promise;
  }
  promise = new Promise(async (resolve) => {
    const ai = await getAssetInfo(assetDetails.p, assetDetails.t.a) ?? void 0;
    if (ai) {
      assetDetails.ai = ai;
      assetDetails.n = getAssetName(assetDetails.n, ai, (ai.ts ?? "1") !== "1");
      let list = cacheUpdateList.get(key) ?? [];
      for (const item of list) {
        item.ai = ai;
        item.n = getAssetName(item.n, ai, (ai.ts ?? "1") !== "1");
      }
    } else {
      await dispatchSignal(doLoadTxAssetMetadata, { [assetDetails.p]: { [assetDetails.t.a]: 1 } });
    }
    cachePromises.delete(key);
    cacheUpdateList.delete(key);
    resolve();
  });
  cachePromises.set(key, promise);
  return promise;
};
const scheduleSetAssetInfoList = async (assetDetailsList) => {
  if (assetDetailsList.length === 1) {
    return scheduleSetAssetInfo(assetDetailsList[0]);
  }
  const aiList = await getAssetInfoList(assetDetailsList) ?? void 0;
  if (!aiList) {
    return;
  }
  for (const assetDetails of assetDetailsList) {
    const ai = aiList.get(assetDetails.p)?.get(assetDetails.t.a);
    if (ai) {
      assetDetails.ai = ai;
      assetDetails.n = getAssetName(assetDetails.n, ai, (ai.ts ?? "1") !== "1");
    } else {
      await dispatchSignal(doLoadTxAssetMetadata, { [assetDetails.p]: { [assetDetails.t.a]: 1 } });
    }
  }
};
const createIAssetListItemDetails = (policyId, assetName, quantity) => {
  return reactive({
    p: policyId,
    t: {
      a: assetName,
      q: quantity
    },
    a: "0",
    n: formatAssetName(assetName),
    f: getAssetIdBech32(policyId, assetName)
  });
};
const getAssetName = (assetName, data, preferTicker = false) => {
  if (data?.tr) {
    if (preferTicker) {
      const ticker = data.tr.t;
      if (ticker) {
        return ticker;
      }
    }
    return data.n ?? data.tr.n;
  }
  return data?.n ?? assetName;
};
const formatAssetName = (assetName) => {
  if (!assetName) {
    return "";
  }
  try {
    return _textDecoder.decode(toHexArray(assetName));
  } catch (e) {
  }
  return assetName;
};
const isVerified = (policyId, assetName) => {
  return isVerifiedAsset(policyId, assetName);
};

const _appWalletMap = /* @__PURE__ */ new Map();
const getIAppWallet$1 = (walletId) => {
  if (!walletId) {
    return null;
  }
  const appWallet = _appWalletMap.get(walletId);
  if (appWallet) {
    updateWalletData(appWallet);
    return appWallet;
  }
  return null;
};
const updateWalletData = (appWallet, walletData) => {
  if (walletData) {
    appWallet.data = walletData;
    if (appWallet.accountList.length === appWallet.data.wallet.accountList.length) {
      appWallet.accountsLoaded = false;
      return true;
    }
  }
  return false;
};

const _computedRefString = computed(() => "");
const _mapString = {};
const getAccountName = (accountData, shortVersion = false) => {
  if (!accountData) {
    return _computedRefString;
  }
  const fundId = accountData.state.networkId + "_getAccountName_" + (shortVersion ? "short_" : "") + accountData.account.id;
  if (!_mapString[fundId]) {
    _mapString[fundId] = computed(() => {
      if (accountData.settings.name) {
        return accountData.settings.name;
      }
      if (!shortVersion) {
        return "Account #" + accountData.keys.index;
      } else {
        return "acc#" + accountData.keys.index;
      }
    });
  }
  return _mapString[fundId];
};

class WalletDB extends Dexie {
  list;
  settings;
  balance;
  constructor(networkId) {
    super("eternl-" + networkId + "-wallet");
    this.version(1).stores({
      list: "id, networkId",
      settings: "id, networkId",
      balance: "id, networkId"
    });
  }
}
const dbMap$4 = networkIdList.reduce((o, n) => {
  o[n] = null;
  return o;
}, {});
const getDB$5 = async (networkId) => {
  let db = dbMap$4[networkId];
  if (!db) {
    db = new WalletDB(networkId);
    dbMap$4[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const getBalance = (networkId, id) => getDB$5(networkId).then((db) => db.balance.where("id").equals(id).first());
const putBalance = (balance) => getDB$5(balance.networkId).then((db) => db.balance.put(balance));
const getSettings = (networkId, id) => getDB$5(networkId).then((db) => db.settings.where("id").equals(id).first());
const putSettings = (settings) => {
  return getDB$5(settings.networkId).then(async (db) => {
    await db.settings.put(settings);
    return true;
  }).catch((error) => {
    console.error(error);
    return false;
  });
};
const getWallet = (networkId, id) => getDB$5(networkId).then((db) => db.list.where("id").equals(id).first());
const putWallet = (wallet) => {
  return getDB$5(wallet.networkId).then(async (db) => {
    await db.list.put(wallet);
    return true;
  }).catch((error) => {
    return false;
  });
};
const addWalletData = async (wallet, settings, balance) => {
  try {
    await dispatchSignal(doAddWalletToRecovery, wallet, settings, balance);
  } catch (e) {
    console.error("ERROR: addWalletData: doAddWalletToRecovery", e);
  }
  return getDB$5(wallet.networkId).then((db) => {
    return db.transaction("rw", [db.list, db.settings, db.balance], async (tx) => {
      const calls = [];
      calls.push(db.list.add(wallet));
      calls.push(db.settings.add(settings));
      calls.push(db.balance.add(balance));
      await Promise.all(calls);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const getWalletDataList = (networkId) => {
  return getDB$5(networkId).then((db) => {
    return db.transaction("r", [db.list, db.settings, db.balance], async (tx) => {
      const calls = [];
      calls.push(db.list.toArray());
      calls.push(db.settings.toArray());
      calls.push(db.balance.toArray());
      const results = await Promise.all(calls);
      let walletList = results[0];
      let settingsList = results[1];
      let balanceList = results[2];
      const walletDataList = [];
      for (const wallet of walletList) {
        const settings = settingsList.find((item) => item.id === wallet.id);
        const balance = balanceList.find((item) => item.id === wallet.id);
        if (settings && balance) {
          walletDataList.push({ wallet, settings, balance });
        }
      }
      return walletDataList;
    });
  });
};
const numWalletDataList = (networkId) => {
  return getDB$5(networkId).then((db) => {
    return db.transaction("r", [db.list], (tx) => {
      return db.list.count();
    });
  });
};
const removeWalletData = (networkId, walletId) => {
  return getDB$5(networkId).then((db) => {
    return db.transaction("rw", [db.list, db.settings, db.balance], async (tx) => {
      const calls = [];
      calls.push(db.list.delete(walletId));
      calls.push(db.settings.delete(walletId));
      calls.push(db.balance.delete(walletId));
      await Promise.all(calls);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const WalletDB$1 = {
  getBalance,
  putBalance,
  getSettings,
  putSettings,
  getWallet,
  putWallet,
  addWalletData,
  getWalletDataList,
  removeWalletData,
  numWalletDataList
};

const updateSelectedId = (appWallet, selectedWalletId) => {
  appWallet.isSelectedWallet = appWallet.data.wallet.id === selectedWalletId;
};
const updateDappId = (appWallet, dappWalletId) => {
  appWallet.isDappWallet = appWallet.data.wallet.id === dappWalletId && isDAppSupported(appWallet.data.wallet.signType);
};
const updateHasManualSyncedAccount = (appWallet) => {
  let hasManualSyncAccount = false;
  for (const appAccount of appWallet.accountList) {
    if (appAccount.data.settings.manualSync.enabled) {
      hasManualSyncAccount = true;
      break;
    }
  }
  appWallet.hasManualSyncAccount = hasManualSyncAccount;
};
const updateSyncInfo = (appWallet) => {
  let walletSyncState = SyncState.initializing;
  let walletSyncTimestamp = now();
  let info = "";
  let error = null;
  let numSyncing = 0;
  for (let i = appWallet.accountList.length - 1; i >= 0; i--) {
    const appAccount = appWallet.accountList[i];
    const accountSyncInfo = appAccount.syncInfo;
    if (accountSyncInfo.state === SyncState.syncing || accountSyncInfo.state === SyncState.queued) {
      numSyncing++;
    }
    if (accountSyncInfo.state !== SyncState.idle || walletSyncState === SyncState.initializing) {
      if (accountSyncInfo.state === SyncState.success && walletSyncState !== SyncState.initializing) {
        continue;
      }
      walletSyncState = accountSyncInfo.state;
      walletSyncTimestamp = accountSyncInfo.stateTimestamp;
      info = getAccountName(appAccount.data, true).value;
      error = accountSyncInfo.error;
    }
  }
  if (numSyncing > 1) {
    info += " (+" + (numSyncing - 1) + ")";
  }
  if (error?.info) {
    if (typeof error.info === "object") {
      error.info = JSON.stringify(error.info);
    } else if (typeof error.info === "string") {
      const arr = error.info.split(":");
      if ((arr?.length ?? 0) === 3) {
        error.info = arr[1];
      }
    }
  }
  appWallet.syncInfo.state = walletSyncState;
  appWallet.syncInfo.stateTimestamp = walletSyncTimestamp;
  appWallet.syncInfo.info = info;
  appWallet.syncInfo.error = error;
  appWallet.syncInfo.isInitializing = walletSyncState === SyncState.initializing;
};
const updateBalance = (appWallet) => {
  const walletBalance = createIAccountBalance(appWallet.id, appWallet.data.wallet.networkId);
  for (let i = appWallet.accountList.length - 1; i >= 0; i--) {
    const appAccount = appWallet.accountList[i];
    addToBalance(walletBalance, appAccount.data.balance);
  }
  walletBalance.coin = add(walletBalance.coin, walletBalance.rewards);
  walletBalance.rewards = "0";
  updateIAccountBalanceIfNeeded(appWallet.data.balance, walletBalance);
  saveBalance(appWallet);
};
const updateManualSyncForAllAccounts = async (appWallet, enabled) => {
  const calls = [];
  for (const appAccount of appWallet.accountList) {
    appAccount.data.settings.manualSync.enabled = enabled;
    calls.push(saveAccountSettings(appAccount));
  }
  await Promise.all(calls);
  updateHasManualSyncedAccount(appWallet);
  return enabled;
};
const saveWallet = (appWallet) => WalletDB$1.putWallet(json(appWallet.data.wallet)).then(() => {
  dispatchSignalSync(doSendUpdateWalletList);
  return true;
});
const saveBalance = (appWallet) => WalletDB$1.putBalance(json(appWallet.data.balance)).then(() => {
  dispatchSignalSync(doSendUpdateWalletList);
  return true;
});
const saveWalletSettings = (appWallet) => WalletDB$1.putSettings(json(appWallet.data.settings)).then(() => {
  dispatchSignalSync(doSendUpdateWalletList);
  return true;
});

const doLogVerbose = false;
const { selectedWalletId } = useSelectedAccount();
const { dappWalletId } = useDappAccount();
const getIAppWallet = (walletId, walletData, skipAccountLoading = false) => {
  if (!walletId) {
    return null;
  }
  let appWallet = _appWalletMap.get(walletId);
  if (appWallet) {
    if (updateWalletData(appWallet, walletData)) {
      initAppAccountListIfNeeded(appWallet);
    }
    return appWallet;
  }
  return createIAppWallet(walletId, walletData, skipAccountLoading);
};
const createIAppWallet = (walletId, walletData, skipAccountLoading = false) => {
  if (!walletData) {
    return null;
  }
  const signType = walletData.wallet.signType;
  const isReadOnly = signType === "readonly";
  const isMnemonic = signType === "mnemonic";
  const isCLI = signType === "cli";
  const isMultiSig = signType === "multisig";
  const isLedger = signType === "ledger";
  const isTrezor = signType === "trezor";
  const isKeystone = signType === "keystone";
  const isOneKey = signType === "onekey";
  const isBitBox = signType === "bitbox";
  const isHardware = isLedger || isTrezor || isKeystone || isOneKey || isBitBox;
  const newWallet = reactive({
    id: walletId,
    data: walletData,
    accountList: [],
    skipAccountLoading,
    syncInfo: {
      isInitializing: true,
      state: SyncState.initializing,
      stateTimestamp: Date.now(),
      nextSyncDelay: 0,
      lastRewardSync: 0,
      error: null
    },
    // reports:                  createIReports(),
    isSelectedWallet: false,
    isDappWallet: false,
    isReadOnly,
    isMnemonic,
    isCLI,
    isLedger,
    isTrezor,
    isKeystone,
    isOneKey,
    isBitBox,
    isHardware,
    isMultiSig,
    accountsLoaded: false,
    hasManualSyncAccount: false
  });
  watch(selectedWalletId, (newValue) => {
    updateSelectedId(newWallet, newValue);
    if (newWallet.isSelectedWallet) {
      initAppAccountListIfNeeded(newWallet);
    }
  }, { immediate: true });
  watch(dappWalletId, (newValue) => {
    updateDappId(newWallet, newValue);
    if (newWallet.isDappWallet) {
      initAppAccountListIfNeeded(newWallet);
    }
  }, { immediate: true });
  watch(() => newWallet.accountList.length, () => {
    initAppAccountListIfNeeded(newWallet);
    updateHasManualSyncedAccount(newWallet);
  });
  const updateWallet = (appAccount, forceBalanceUpdate = false) => {
    updateSyncInfo(newWallet);
    updateHasManualSyncedAccount(newWallet);
    if (newWallet.accountList.length > 0 && (forceBalanceUpdate || appAccount.syncInfo.state === SyncState.success)) {
      updateBalance(newWallet);
    }
  };
  addSignalListener(onAccountSyncInfoUpdated, walletId, (appAccount, forceUpdate = false) => {
    updateWallet(appAccount);
    dispatchSignalSyncTo(appAccount.id, onAccountSyncInfoUpdated, forceUpdate);
  }, doLogVerbose);
  addSignalListener(onAccountSettingsUpdated, walletId, (appAccount) => {
    if (appAccount.walletId !== walletId) {
      return;
    }
    updateWallet(appAccount, true);
  }, doLogVerbose);
  _appWalletMap.set(walletId, newWallet);
  return newWallet;
};
const removeIAppWallet = async (walletId) => {
  removeSignalListener(onAccountSyncInfoUpdated, walletId, doLogVerbose);
  removeSignalListener(onAccountSettingsUpdated, walletId, doLogVerbose);
  let appWallet = _appWalletMap.get(walletId);
  if (appWallet) {
    for (const appAccount of appWallet.accountList) {
      await removeIAppAccount(appAccount.id, appAccount.walletId);
      dispatchSignalSync(onAccountRemoved, walletId, appAccount.id, true);
    }
    _appWalletMap.delete(walletId);
  }
};
const removeAccount = async (walletId, accountId, doUpdate = true) => {
  let appWallet = _appWalletMap.get(walletId);
  let removedAccount = false;
  if (appWallet) {
    for (let i = appWallet.accountList.length - 1; i >= 0; i--) {
      const appAccount = appWallet.accountList[i];
      if (appAccount.id !== accountId) {
        continue;
      }
      appWallet.accountList.splice(i, 1);
      for (let k = appWallet.data.wallet.accountList.length - 1; k >= 0; k--) {
        const account = appWallet.data.wallet.accountList[k];
        if (account.id !== accountId) {
          continue;
        }
        appWallet.data.wallet.accountList.splice(i, 1);
      }
      await removeIAppAccount(appAccount.id, appAccount.walletId);
      removedAccount = true;
    }
    if (removedAccount && doUpdate) {
      updateHasManualSyncedAccount(appWallet);
      updateSyncInfo(appWallet);
      updateBalance(appWallet);
      await saveWallet(appWallet);
    }
  }
  dispatchSignalSync(onAccountRemoved, walletId, accountId, removedAccount);
};
const initAppAccountListById = (walletId) => {
  initAppAccountListIfNeeded(getIAppWallet(walletId));
};
const initAppAccountListIfNeeded = (appWallet) => {
  if (appWallet && !appWallet.skipAccountLoading && getNextAccountToLoad(appWallet)) {
    initAppAccountList(appWallet, appWallet.isDappWallet || appWallet.isSelectedWallet ? SyncPriority.high : SyncPriority.low);
  }
};

const _walletIdList = ref$1([]);
computed(() => _walletIdList.value.length > 0);
computed(() => _walletIdList.value.length === 1);

class TransactionNoteDB extends Dexie {
  txNotes;
  constructor(networkId) {
    super("eternl-" + networkId + "-tx-notes");
    this.version(1).stores({
      txNotes: "[txHash+accountId], accountId"
    });
  }
}
const dbMap$3 = networkIdList.reduce((o, n) => {
  o[n] = null;
  return o;
}, {});
const getDB$4 = async (networkId) => {
  let db = dbMap$3[networkId];
  if (!db) {
    db = new TransactionNoteDB(networkId);
    dbMap$3[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const putTransactionNote = async (networkId, transactionNote) => {
  try {
    JSON.stringify(transactionNote);
  } catch (error) {
    console.error("Object cannot be serialized:", error);
    throw new Error("Object cannot be serialized for storage");
  }
  try {
    let db = await getDB$4(networkId);
    let oldNote = await db.txNotes.where("[txHash+accountId]").equals([transactionNote.txHash, transactionNote.accountId]).first();
    if (oldNote) {
      if (oldNote.note.note !== transactionNote.note.note) {
        oldNote.note.note = transactionNote.note.note;
        oldNote.note.updated = Date.now();
      }
      const res = await db.txNotes.where("[txHash+accountId]").equals([transactionNote.txHash, transactionNote.accountId]).modify({ ...oldNote });
      dispatchSignalSync(onTxNoteUpdated, transactionNote);
      return res;
    } else {
      const newEntry = { ...transactionNote };
      const res = await db.txNotes.put(newEntry, [transactionNote.txHash, transactionNote.accountId]);
      dispatchSignalSync(onTxNoteAdded, transactionNote);
    }
  } catch (error) {
    return false;
  }
};
const getTransactionNoteByUser = async (networkId, accountId) => {
  try {
    let db = await getDB$4(networkId);
    let oldNote = await db.txNotes.where("accountId").equals(accountId).toArray();
    return oldNote;
  } catch (error) {
    return [];
  }
};
async function getTxNote(network, accountId, txHash) {
  try {
    return await (await getDB$4(network)).txNotes.get([txHash, accountId]);
  } catch (error) {
    console.error("Failed to get object:", error);
    throw error;
  }
}
async function deleteTxNote(network, accountId, txHash) {
  try {
    await (await getDB$4(network)).txNotes.delete([txHash, accountId]);
    dispatchSignalSync(onTxNoteDeleted, accountId, txHash);
    return true;
  } catch (error) {
    console.error("Failed to get object:", error);
    return false;
  }
}
const TransactionNoteDB$1 = {
  getDB: getDB$4,
  putTransactionNote,
  getTxNote,
  deleteTxNote,
  getTransactionNoteByUser
};

const doLog = false;
const storeId$4 = "walletListStore";
const _isWalletListLoading = ref$1(false);
const _walletGroupNameList = ref$1([]);
const _walletGroupMap = ref$1({});
const _numWalletsMap = ref$1(networkIdList.reduce((o, n) => {
  o[n] = 0;
  return o;
}, {}));
computed(() => _isWalletListLoading.value);
computed(() => _walletGroupNameList.value);
computed(() => _walletGroupMap.value);
const walletIdList = computed(() => _walletIdList.value);
computed(() => _numWalletsMap.value);
computed(() => walletIdList.value.length > 0);
const loadWalletList = async () => {
  if (_isWalletListLoading.value) {
    return;
  }
  _isWalletListLoading.value = true;
  let dbEntryList = await WalletDB$1.getWalletDataList(networkId$9.value);
  if (dbEntryList.length === 0) {
    try {
      const entries = await dispatchSignal(doGetWalletListFromRecovery, networkId$9.value);
      if (entries && entries.length > 0) {
        if (doLog) ;
        dbEntryList = entries;
        for (let recoveryWallet of dbEntryList) {
          await WalletDB$1.addWalletData(recoveryWallet.wallet, recoveryWallet.settings, recoveryWallet.balance);
        }
      }
    } catch (e) {
    }
  } else {
    await dispatchSignal(doUpdateWalletRecoveryData, networkId$9.value, dbEntryList);
  }
  const walletIdList2 = [];
  const groupNameList = [];
  const walletGroupMap2 = {};
  for (const dbEntry of dbEntryList) {
    const walletId = dbEntry.wallet.id;
    const appWallet = getIAppWallet(walletId, dbEntry);
    if (appWallet) {
      walletIdList2.push(walletId);
      const groupName = dbEntry.settings.groupName ?? DEFAULT_WALLET_GROUP_NAME;
      if (!groupNameList.includes(groupName)) {
        groupNameList.push(groupName);
      }
    }
  }
  for (const _walletId of _walletIdList.value) {
    if (!walletIdList2.some((id) => id === _walletId)) {
      await removeIAppWallet(_walletId);
    }
  }
  _walletIdList.value = walletIdList2;
  groupNameList.sort((a, b) => a.localeCompare(b, "en-US"));
  for (const groupName of groupNameList) {
    const list = dbEntryList.filter((data) => (data.settings.groupName ?? DEFAULT_WALLET_GROUP_NAME) === groupName).sort((a, b) => a.settings.name.localeCompare(b.settings.name, "en-US")).map((data) => data.wallet.id);
    walletGroupMap2[groupName] = list;
    for (const walletId of list) {
      initAppAccountListById(walletId);
    }
  }
  _walletGroupMap.value = walletGroupMap2;
  _walletGroupNameList.value = groupNameList;
  await dispatchSignal(onWalletListUpdated);
  for (const networkId2 of networkIdList) {
    _numWalletsMap.value[networkId2] = await WalletDB$1.numWalletDataList(networkId2);
  }
  _isWalletListLoading.value = false;
};
const getWalletNameList = () => {
  const res = [];
  for (const walletId of _walletIdList.value) {
    const appWallet = getIAppWallet(walletId);
    if (appWallet) {
      res.push({ name: appWallet.data.settings.name, id: appWallet.data.wallet.id });
    }
  }
  return res;
};

class DecryptedMsgDB extends Dexie {
  list;
  constructor(networkId) {
    super("eternl-" + networkId + "-decryptedmsg");
    this.version(1).stores({
      list: "hash"
    });
  }
}
const dbMap$2 = networkIdList.reduce((o, n) => {
  o[n] = null;
  return o;
}, {});
const getDB$3 = async (networkId) => {
  let db = dbMap$2[networkId];
  if (!db) {
    db = new DecryptedMsgDB(networkId);
    dbMap$2[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const putDecryptedMsg = (networkId, msg) => {
  return getDB$3(networkId).then((db) => {
    return db.transaction("rw", [db.list], async (tx) => {
      await db.list.put(msg);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const deleteDecryptedMsg = (networkId, hash) => {
  return getDB$3(networkId).then((db) => {
    return db.transaction("rw", [db.list], async (tx) => {
      await db.list.delete(hash);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const getDecryptedMsgList = (networkId) => {
  return getDB$3(networkId).then((db) => db.list.toArray()).catch((error) => {
    return [];
  });
};
const getDecryptedMsgCount = (networkId) => {
  return getDB$3(networkId).then((db) => db.list.count()).catch((error) => {
    return -1;
  });
};
const DecryptedMsgDB$1 = {
  putDecryptedMsg,
  deleteDecryptedMsg,
  getDecryptedMsgList,
  getDecryptedMsgCount
};

const decryptedMsgMap = ref$1(/* @__PURE__ */ new Map());
const saveDecryptedMsg = async (hash, msg) => {
  if (!hash) {
    return;
  }
  const msgCopy = [...msg];
  decryptedMsgMap.value.set(hash, msgCopy);
  await DecryptedMsgDB$1.putDecryptedMsg(networkId$9.value, { hash, msg: msgCopy });
};
const delDecryptedMsg = async (hash) => {
  decryptedMsgMap.value.delete(hash);
  await DecryptedMsgDB$1.deleteDecryptedMsg(networkId$9.value, hash);
};

const storeId$3 = "intervalStore";
let time1s = Date.now();
let time4s = time1s;
let time8s = time1s;
let time20s = time1s;
let time60s = time1s;
const _onInterval = () => {
  const currentTime = Date.now();
  time1s = currentTime;
  const pastTime4s = currentTime - time4s;
  const pastTime8s = currentTime - time8s;
  const pastTime20s = currentTime - time20s;
  const pastTime60s = currentTime - time60s;
  dispatchSignalSync(onInterval1s);
  if (pastTime4s > 3949) {
    time4s = currentTime;
    dispatchSignalSync(onInterval4s);
  }
  if (pastTime8s > 7899) {
    time8s = currentTime;
    dispatchSignalSync(onInterval8s);
  }
  if (pastTime20s > 19849) {
    time20s = currentTime;
    dispatchSignalSync(onInterval20s);
  }
  if (pastTime60s > 59749) {
    time60s = currentTime;
    dispatchSignalSync(onInterval60s);
  }
};
setInterval(_onInterval, 999);
const _onIntervalRapid = () => dispatchSignalSync(onIntervalRapid);
let iid = -1;
let numAdds = 0;
const addIntervalRapid = (_storeId) => {
  clearInterval(iid);
  iid = setInterval(_onIntervalRapid, RAPID_INTERVAL_MS);
  numAdds++;
};
const removeIntervalRapid = (_storeId) => {
  numAdds--;
  if (numAdds <= 0) {
    numAdds = 0;
    clearInterval(iid);
  }
};
addSignalListener(onIntervalRapid + "_add", storeId$3, addIntervalRapid);
addSignalListener(onIntervalRapid + "_remove", storeId$3, removeIntervalRapid);

const storeId$2 = "dateStore";
const timestamp = ref$1(now());
const timestampLocal = ref$1(Date.now());
const timestamp4s = ref$1(now());
const timestamp8s = ref$1(now());
const timestamp20s = ref$1(now());
const timestamp60s = ref$1(now());
addSignalListener(onInterval1s, storeId$2, () => {
  timestamp.value = now();
  timestampLocal.value = Date.now();
});
addSignalListener(onInterval4s, storeId$2, () => {
  timestamp4s.value = now();
});
addSignalListener(onInterval8s, storeId$2, () => {
  timestamp8s.value = now();
});
addSignalListener(onInterval20s, storeId$2, () => {
  timestamp20s.value = now();
});
addSignalListener(onInterval60s, storeId$2, () => {
  timestamp60s.value = now();
});

const createIChainTip = (networkId) => {
  return {
    networkId,
    network: networkId,
    blockNo: 0,
    slotNo: 0,
    epochNo: 0,
    epochSlot: 0,
    epochSlots: 0,
    epochPercent: 0,
    syncProgress: 0,
    onTip: false,
    serverTime: 0
  };
};

const createChainTip = (networkId2) => {
  const chainTip2 = createIChainTip(networkId2);
  updateChainTip(networkId2, chainTip2, chainTip2);
  chainTip2.onTip = false;
  return chainTip2;
};
const _chainTip = ref$1(getChainTip(networkId$9.value, createChainTip(networkId$9.value)).value);
const chainTip = computed(() => _chainTip.value);
const isConnected = ref$1(false);
const onUpdateChainTip = (chainTip2) => {
  if (chainTip2.networkId === networkId$9.value) {
    isConnected.value = chainTip2.epochNo > 0 && chainTip2.onTip;
    if (!Number.isNaN(chainTip2.serverTime) && chainTip2.serverTime > 0) {
      setOffsetFromServer(chainTip2.serverTime);
    }
    setChainTip(networkId$9.value, chainTip2);
    _chainTip.value = chainTip2;
    updateEpochParams(_chainTip.value);
    return true;
  }
  return false;
};
const onUpdateOnTip = (numFailedCalls) => {
  const __chainTip = chainTip.value;
  if (__chainTip.networkId === networkId$9.value) {
    updateChainTip(networkId$9.value, __chainTip, __chainTip);
    if (numFailedCalls > 4) {
      __chainTip.onTip = false;
    }
    isConnected.value = __chainTip.epochNo > 0 && __chainTip.onTip;
    return true;
  }
  return false;
};

const createIAddressBook = (id, networkId) => {
  return {
    id,
    networkId,
    entryList: []
  };
};

class AddressBookDB extends Dexie {
  addressbook;
  constructor(networkId) {
    super("eternl-" + networkId + "-addressbook");
    this.version(1).stores({
      addressbook: "id, networkId"
    });
  }
}
const dbMap$1 = networkIdList.reduce((o, n) => {
  o[n] = null;
  return o;
}, {});
const getDB$2 = async (networkId) => {
  let db = dbMap$1[networkId];
  if (!db) {
    db = new AddressBookDB(networkId);
    dbMap$1[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const addAddressBook = (addressBook) => {
  return getDB$2(addressBook.networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      await db.addressbook.add(addressBook);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const putAddressBook = (addressBook) => {
  return getDB$2(addressBook.networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      await db.addressbook.put(addressBook);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const getAddressBook = (networkId, id) => {
  return getDB$2(networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      let addressBook = await db.addressbook.where("id").equals(id).first();
      return addressBook ?? null;
    });
  }).catch((error) => {
    return null;
  });
};
const removeAddressBock = (networkId, id) => {
  return getDB$2(networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      db.addressbook.delete(id);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const putAddressBookEntry = (networkId, id, entry, oldName) => {
  return getDB$2(networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      let addressBook = await db.addressbook.where("id").equals(id).first();
      if (!addressBook) {
        addressBook = createIAddressBook(id, networkId);
      }
      for (let i = addressBook.entryList.length - 1; i >= 0; i--) {
        const name = addressBook.entryList[i].name;
        if (name === entry.name || name === oldName) {
          addressBook.entryList.splice(i, 1);
        }
      }
      addressBook.entryList.push(entry);
      await db.addressbook.put(addressBook);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const deleteAddressBookEntry = (networkId, id, entryName) => {
  return getDB$2(networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      let addressBook = await db.addressbook.where("id").equals(id).first();
      if (!addressBook) {
        addressBook = createIAddressBook(id, networkId);
      }
      for (let i = addressBook.entryList.length - 1; i >= 0; i--) {
        const listEntry = addressBook.entryList[i];
        if (listEntry.name === entryName) {
          addressBook.entryList.splice(i, 1);
        }
      }
      await db.addressbook.put(addressBook);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const putReportLabelEntry = (networkId, id, entry, oldName = "") => {
  return getDB$2(networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      let addressBook = await db.addressbook.where("id").equals(id).first();
      if (!addressBook) {
        addressBook = createIAddressBook(id, networkId);
      }
      if ((oldName?.length ?? 0) > 0) {
        for (let i = addressBook.entryList.length - 1; i >= 0; i--) {
          const name = addressBook.entryList[i].name;
          const address = addressBook.entryList[i].address;
          if (name === oldName && address === entry.address) {
            addressBook.entryList.splice(i, 1);
          }
        }
      }
      addressBook.entryList.push(entry);
      await db.addressbook.put(addressBook);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const deleteReportLabelEntry = (networkId, id, entryName, entryAddr) => {
  return getDB$2(networkId).then((db) => {
    return db.transaction("rw", [db.addressbook], async (tx) => {
      let addressBook = await db.addressbook.where("id").equals(id).first();
      if (!addressBook) {
        addressBook = createIAddressBook(id, networkId);
      }
      for (let i = addressBook.entryList.length - 1; i >= 0; i--) {
        const listEntry = addressBook.entryList[i];
        if (listEntry.name === entryName && listEntry.address === entryAddr) {
          addressBook.entryList.splice(i, 1);
        }
      }
      await db.addressbook.put(addressBook);
      return true;
    });
  }).catch((error) => {
    return false;
  });
};
const AddressBookDB$1 = {
  addAddressBook,
  putAddressBook,
  getAddressBook,
  putAddressBookEntry,
  deleteAddressBookEntry,
  putReportLabelEntry,
  deleteReportLabelEntry,
  removeAddressBock
};

const globalId = "global";
const _addressBook = ref$1(createIAddressBook(globalId, networkId$9.value));
const addressBook = computed(() => _addressBook.value);
const loadAddressBook = async () => {
  let changed = false;
  const globalAddressBook = await AddressBookDB$1.getAddressBook(networkId$9.value, globalId);
  if (!globalAddressBook) {
    _addressBook.value = createIAddressBook(globalId, networkId$9.value);
    await AddressBookDB$1.addAddressBook(json(_addressBook.value));
  } else {
    _addressBook.value = globalAddressBook;
  }
  return changed;
};
const getAddressBookEntryByAddress = (address, mode) => {
  {
    return _addressBook.value.entryList.find((entry) => entry.address === address) ?? null;
  }
};

const contractSchemaV1 = {
  list: "++id, address, label"
};
const contractSchemaV2 = {
  list: "++id, address, label",
  data: "id"
  // id is now networkId and data is raw
};
class ContractMappingDB extends Dexie {
  list;
  data;
  constructor(networkId) {
    super("eternl-" + networkId + "-contract");
    this.version(1).stores(contractSchemaV1);
    this.version(2).stores(contractSchemaV2).upgrade(async (tx) => {
      console.log("ContractMappingDB: upgrade to v2", networkId);
      await tx.table("list").clear();
    });
  }
}
const dbMap = networkIdList.reduce((o, n) => {
  o[n] = null;
  return o;
}, {});
const getDB$1 = async (networkId) => {
  let db = dbMap[networkId];
  if (!db) {
    db = new ContractMappingDB(networkId);
    dbMap[networkId] = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const putData = (data) => getDB$1(data.id).then((db) => db.data.put(data));
const getData = (networkId) => getDB$1(networkId).then((db) => db.data.toArray());
const ContractMappingDB$1 = {
  putData,
  getData
};

const doLoadContractMapping = "doLoadContractMapping";

const storeId$1 = "contractStore";
const contractMappings = ref$1(null);
const updateContractMapping = async () => {
  const _networkId = networkId$9.value;
  const dbEntries = await ContractMappingDB$1.getData(_networkId);
  if (dbEntries.length > 0) {
    contractMappings.value = dbEntries[0];
  }
};
const getContractProperty = (credOrAddress) => {
  if (contractMappings.value) {
    const cred = credOrAddress.startsWith("addr") ? getAddressCredentials(credOrAddress).paymentCred : credOrAddress;
    const mapping = contractMappings.value.list.find((entry) => entry.contractAddress === cred || entry.mintPolicyID === cred);
    if (mapping) {
      return contractMappings.value.properties[mapping.property] ?? null;
    }
  }
  return null;
};
const getContractMappingByAddresses = (addrList) => {
  const propertyList = [];
  if (addrList.length > 0) {
    for (const address of addrList) {
      const property = getContractProperty(address);
      if (property) {
        propertyList.push(property);
      }
    }
    if (propertyList.length === 0) {
      return propertyList;
    }
    propertyList.sort((a, b) => a.label.localeCompare(b.label, "en-US"));
    for (let i = propertyList.length - 1; i >= 0; i--) {
      const item = propertyList[i];
      const label = item.label.split(" ")[0];
      for (let k = 0; k < i; k++) {
        if (propertyList[k].label.startsWith(label)) {
          propertyList.splice(i, 1);
          break;
        }
      }
    }
  }
  return propertyList;
};
const getContractAddressesByLabel = (labelList) => {
  const addressList = [];
  const mapping = contractMappings.value;
  if (!mapping) {
    return addressList;
  }
  for (const label of labelList) {
    const item = label.split(" ")[0].toLowerCase();
    for (let i = 0; i <= mapping.properties.length; i++) {
      const property = mapping.properties[i];
      if (property && typeof property.label === "string" && property.label.toLowerCase().startsWith(item)) {
        const propertyList = mapping.list.filter((entry) => entry.property === i);
        for (const entry of propertyList) {
          if (entry.contractAddress) {
            addressList.push(entry.contractAddress);
          } else if (entry.mintPolicyID) {
            addressList.push(entry.mintPolicyID);
          }
        }
      }
    }
  }
  return addressList;
};
const load$1 = async () => {
  await dispatchSignal(doLoadContractMapping);
  if (!contractMappings.value) {
    await updateContractMapping();
  }
};
addSignalListener(doInitApp, storeId$1, load$1);

const DEFAULT_CURRENCY_LIST = {
  "currencies": [
    { "id": "btc", "symbol": "₿", "value": 0, "change24h": 0 },
    { "id": "eth", "symbol": "Ξ", "value": 0, "change24h": 0 },
    { "id": "ltc", "symbol": "ltc", "value": 0, "change24h": 0 },
    { "id": "bch", "symbol": "bch", "value": 0, "change24h": 0 },
    { "id": "bnb", "symbol": "bnb", "value": 0, "change24h": 0 },
    { "id": "eos", "symbol": "eos", "value": 0, "change24h": 0 },
    { "id": "xrp", "symbol": "xrp", "value": 0, "change24h": 0 },
    { "id": "xlm", "symbol": "xlm", "value": 0, "change24h": 0 },
    { "id": "link", "symbol": "link", "value": 0, "change24h": 0 },
    { "id": "dot", "symbol": "dot", "value": 0, "change24h": 0 },
    { "id": "yfi", "symbol": "yfi", "value": 0, "change24h": 0 },
    { "id": "usd", "symbol": "$", "value": 0, "change24h": 0 },
    { "id": "aed", "symbol": "aed", "value": 0, "change24h": 0 },
    { "id": "ars", "symbol": "ars", "value": 0, "change24h": 0 },
    { "id": "aud", "symbol": "aud", "value": 0, "change24h": 0 },
    { "id": "bdt", "symbol": "bdt", "value": 0, "change24h": 0 },
    { "id": "bhd", "symbol": "bhd", "value": 0, "change24h": 0 },
    { "id": "bmd", "symbol": "bmd", "value": 0, "change24h": 0 },
    { "id": "brl", "symbol": "brl", "value": 0, "change24h": 0 },
    { "id": "cad", "symbol": "cad", "value": 0, "change24h": 0 },
    { "id": "chf", "symbol": "chf", "value": 0, "change24h": 0 },
    { "id": "clp", "symbol": "clp", "value": 0, "change24h": 0 },
    { "id": "cny", "symbol": "cny", "value": 0, "change24h": 0 },
    { "id": "czk", "symbol": "czk", "value": 0, "change24h": 0 },
    { "id": "dkk", "symbol": "dkk", "value": 0, "change24h": 0 },
    { "id": "eur", "symbol": "€", "value": 0, "change24h": 0 },
    { "id": "gbp", "symbol": "gbp", "value": 0, "change24h": 0 },
    { "id": "gel", "symbol": "gel", "value": 0, "change24h": 0 },
    { "id": "hkd", "symbol": "hkd", "value": 0, "change24h": 0 },
    { "id": "huf", "symbol": "huf", "value": 0, "change24h": 0 },
    { "id": "idr", "symbol": "idr", "value": 0, "change24h": 0 },
    { "id": "ils", "symbol": "ils", "value": 0, "change24h": 0 },
    { "id": "inr", "symbol": "inr", "value": 0, "change24h": 0 },
    { "id": "jpy", "symbol": "jpy", "value": 0, "change24h": 0 },
    { "id": "krw", "symbol": "krw", "value": 0, "change24h": 0 },
    { "id": "kwd", "symbol": "kwd", "value": 0, "change24h": 0 },
    { "id": "lkr", "symbol": "lkr", "value": 0, "change24h": 0 },
    { "id": "mmk", "symbol": "mmk", "value": 0, "change24h": 0 },
    { "id": "mxn", "symbol": "mxn", "value": 0, "change24h": 0 },
    { "id": "myr", "symbol": "myr", "value": 0, "change24h": 0 },
    { "id": "ngn", "symbol": "ngn", "value": 0, "change24h": 0 },
    { "id": "nok", "symbol": "nok", "value": 0, "change24h": 0 },
    { "id": "nzd", "symbol": "nzd", "value": 0, "change24h": 0 },
    { "id": "php", "symbol": "php", "value": 0, "change24h": 0 },
    { "id": "pkr", "symbol": "pkr", "value": 0, "change24h": 0 },
    { "id": "pln", "symbol": "pln", "value": 0, "change24h": 0 },
    { "id": "rub", "symbol": "rub", "value": 0, "change24h": 0 },
    { "id": "sar", "symbol": "sar", "value": 0, "change24h": 0 },
    { "id": "sek", "symbol": "sek", "value": 0, "change24h": 0 },
    { "id": "sgd", "symbol": "sgd", "value": 0, "change24h": 0 },
    { "id": "thb", "symbol": "thb", "value": 0, "change24h": 0 },
    { "id": "try", "symbol": "try", "value": 0, "change24h": 0 },
    { "id": "twd", "symbol": "twd", "value": 0, "change24h": 0 },
    { "id": "uah", "symbol": "uah", "value": 0, "change24h": 0 },
    { "id": "vef", "symbol": "vef", "value": 0, "change24h": 0 },
    { "id": "vnd", "symbol": "vnd", "value": 0, "change24h": 0 },
    { "id": "zar", "symbol": "zar", "value": 0, "change24h": 0 },
    { "id": "xdr", "symbol": "xdr", "value": 0, "change24h": 0 },
    { "id": "xag", "symbol": "xag", "value": 0, "change24h": 0 },
    { "id": "xau", "symbol": "xau", "value": 0, "change24h": 0 },
    { "id": "bits", "symbol": "bits", "value": 0, "change24h": 0 },
    { "id": "sats", "symbol": "sats", "value": 0, "change24h": 0 }
  ],
  "last_update": 0
};
const _appCurrency = getAppCurrency("usd");
const _currencies = getAppCurrencies(DEFAULT_CURRENCY_LIST);
const appCurrency = computed(() => _appCurrency.value);
const appCurrencies = computed(() => _currencies.value);
const setAppCurrencies = (list) => {
  setAppCurrencies$1(list);
};
const getCoinGeckoTicker = (tokenName) => {
  return getCoingeckoTicker(tokenName, createICoingeckoTickerItem()).value;
};
const setCoinGeckoTicker = (tokenName, value) => {
  setCoingeckoTicker(tokenName, value);
};

const API_ENDPOINT = "https://api.coingecko.com/api/v3/";
const API_TIMEOUT = 1e3 * 60 * 5;
const _activeCurrency = ref$1(createICurrencyItem(null));
let _timeoutId = -1;
async function callCurrencyAPI(path) {
  return await api$1.get(API_ENDPOINT + path).catch((e) => {
    return null;
  });
}
const mapSymbol = (symbol) => {
  switch (symbol) {
    case "usd":
      return "$";
    case "eur":
      return "€";
    case "btc":
      return "₿";
    case "eth":
      return "Ξ";
    default:
      return symbol.toLowerCase();
  }
};
const pullCurrencyData = async () => {
  clearTimeout(_timeoutId);
  setActiveCurrency(appCurrency.value);
  if (now() > appCurrencies.value.last_update + API_TIMEOUT) {
    let res = await callCurrencyAPI("simple/supported_vs_currencies");
    if (res) {
      const currencyIds = res;
      const currencyString = currencyIds.join("%2C");
      res = await callCurrencyAPI("simple/price?ids=cardano&vs_currencies=" + currencyString + "&include_24hr_change=true");
      if (res && res.hasOwnProperty("cardano")) {
        const tmp = createICurrency();
        tmp.last_update = now();
        for (const currencyId of currencyIds) {
          if (res.cardano.hasOwnProperty(currencyId)) {
            tmp.currencies.push(createICurrencyItem({
              id: currencyId,
              symbol: mapSymbol(currencyId),
              value: res.cardano[currencyId],
              change24h: res.cardano[currencyId + "_24h_change"]
            }));
          }
        }
        setAppCurrencies(tmp);
      }
    }
  }
  if (appCurrency.value) {
    setActiveCurrency(appCurrency.value);
  } else if (appCurrencies.value.currencies.some((c) => c.id === "usd")) {
    setActiveCurrency("usd");
  }
  _timeoutId = setTimeout(() => {
    pullCurrencyData();
  }, API_TIMEOUT);
};
const setActiveCurrency = (currencyId) => {
  const tmp = currencyId ? appCurrencies.value.currencies.find((c) => c.id === currencyId) ?? createICurrencyItem(null) : null;
  if (tmp) {
    _activeCurrency.value = tmp;
  }
};
const getCurrencyAmount = (lovelace) => {
  if (!_activeCurrency.value?.id) {
    return "";
  }
  const currencyAmount = multiply(divide(lovelace, 1e6), _activeCurrency.value.value, 8);
  return compare$1(currencyAmount, ">", 1e5) ? multiply(currencyAmount, 1, 1) : currencyAmount;
};
const getCurrencyValue = async function(tokenName, tokenBalance, currency) {
  if (currency.id) {
    try {
      const balance = await getAdaValue(tokenName, tokenBalance);
      return multiply(currency.value, balance, 8);
    } catch (err) {
      console.warn(`failure during currency(${currency.id}) conversion: ${currency.value}`, err.message);
    }
  }
  return "";
};
const getAdaValue = async function(tokenName, tokenBalance) {
  let coinName = tokenName.toLowerCase();
  const pricePerAda = await convertToAdaAmount(coinName);
  return multiply(pricePerAda, tokenBalance);
};
const getTickers = async (tokenId) => {
  let res = await callCurrencyAPI("coins/" + tokenId + "/tickers");
  if (res && "tickers" in res) {
    return res.tickers;
  }
  throw new Error("No tickers found for " + tokenId);
};
const convertTokenAmount = async (tokenId, targetCurrency) => {
  let tickers = await getTickers(tokenId);
  for (let element in tickers) {
    let cgAssetNameLowercase = tickers[element].target.toLowerCase();
    if (cgAssetNameLowercase == targetCurrency.toLowerCase()) {
      return tickers[element].last;
    }
  }
  throw new Error("Can not determine price of " + tokenId);
};
const convertToAdaAmount = async (tokenId) => {
  let usdValue = void 0;
  let usdPair = void 0;
  let ticker = getCoinGeckoTicker(tokenId);
  if (ticker.last_update === 0 || now() > ticker.last_update + API_TIMEOUT) {
    let tickers = await getTickers(tokenId);
    for (let element in tickers) {
      let assetNameLowercase = tickers[element].target.toLowerCase();
      if (assetNameLowercase === "usd" || assetNameLowercase === "usdt") {
        usdValue = tickers[element].last;
        usdPair = assetNameLowercase;
      }
      if (assetNameLowercase == "ada") {
        ticker = createICoingeckoTicker(tickers[element]);
        ticker.last_update = now();
      }
    }
    if (usdPair !== void 0 && usdValue !== void 0) {
      let number = await convertTokenAmount("cardano", usdPair);
      let result = usdValue / number;
      let lastUpdate = now();
      ticker = createICoingeckoTicker({
        base: "ada",
        target: tokenId,
        last: result,
        last_update: lastUpdate
      });
    }
    setCoinGeckoTicker(tokenId, ticker);
    return ticker.last;
  } else if (ticker.last_update !== 0) {
    return ticker.last;
  }
  throw new Error("Can not determine price of " + tokenId);
};
function useCurrencyAPI() {
  return {
    activeCurrency: _activeCurrency,
    currencyList: appCurrencies.value,
    setActiveCurrency,
    pullCurrencyData,
    getCurrencyAmount,
    getTokenPrice: convertTokenAmount,
    getCurrencyValue,
    convertToAdaAmount
  };
}

class GuardBlockListDB extends Dexie {
  entry;
  domain;
  allowlist;
  address;
  asset;
  info;
  constructor() {
    super("eternl-guard-blocklist");
    this.version(2).stores({
      entry: "++id, filename",
      domain: "id, *domain",
      allowlist: "id, *domain",
      address: "id, *address",
      asset: "id, *assets",
      info: "id"
    });
  }
}
let guardBlockListDB = null;
const getDB = async () => {
  let db = guardBlockListDB;
  if (!db) {
    db = new GuardBlockListDB();
    guardBlockListDB = db;
  }
  if (!db.isOpen()) {
    await db.open();
  }
  return db;
};
const bulkAddGuardReport = async (reports) => getDB().then((db) => {
  if (reports.r.length === 0) {
    return;
  }
  db.transaction("rw", [db.info, db.entry, db.domain, db.allowlist, db.asset, db.address], async (tx) => {
    await db.info.clear();
    await db.entry.clear();
    await db.domain.clear();
    await db.allowlist.clear();
    await db.asset.clear();
    await db.address.clear();
    await db.info.put({
      id: 1,
      timestamp: Date.now(),
      lastHash: reports.h
    });
    for (const report of reports.r) {
      let inserted = await db.entry.put({
        filename: report.filename,
        description: report.description
      });
      if (report.domains && report.domains.length > 0) {
        await db.domain.put({
          id: inserted,
          domain: report.domains
        });
      }
      if (report.allowlist && report.allowlist.length > 0) {
        await db.allowlist.put({
          id: inserted,
          domain: report.allowlist
        });
      }
      if (report.related_assets && report.related_assets.length > 0) {
        await db.asset.put({
          id: inserted,
          assets: report.related_assets
        });
      }
      if (report.associated_addresses && report.associated_addresses.length > 0) {
        await db.address.put({
          id: inserted,
          address: report.associated_addresses
        });
      }
    }
  });
});
const getLastImportInfo = () => getDB().then((db) => db.info.get(1));
const findDomain = (url) => getDB().then((db) => db.domain.where("domain").anyOf(url).toArray());
const isBlockedDomain = (url) => getDB().then((db) => db.domain.where("domain").equals(url).toArray().then((res) => res.length > 0));
const isAllowedDomain = (url) => getDB().then((db) => db.allowlist.where("domain").equals(url).toArray().then((res) => res.length > 0));
const findAsset = (asset) => getDB().then((db) => db.asset.where("assets").equals(asset).toArray());
const findAddress = (address) => getDB().then((db) => db.address.where("address").anyOf(address).toArray());
const getScamDomainList = () => getDB().then((db) => db.domain.toArray());
const getScamAddressesList = () => getDB().then((db) => db.address.toArray());
const getScamAssetList = () => getDB().then((db) => db.asset.toArray());
const GuardBlockListDB$1 = {
  bulkAddGuardReport,
  getLastImportInfo,
  isBlockedDomain,
  isAllowedDomain,
  findDomain,
  findAsset,
  findAddress,
  getScamAssetList,
  getScamDomainList,
  getScamAddressesList
};

const spamDomains = ref$1([]);
const spamAddress = ref$1([]);
const spamAssets = ref$1([]);
const useGuard = () => {
  const isDomainOnBlockList = async (urlToCheck) => {
    let url;
    try {
      url = new URL(urlToCheck);
    } catch (err) {
      return false;
    }
    let urlParts = url.hostname.split(".");
    let tld = "";
    let domain = "";
    let checkDomain = "";
    if (urlParts.length > 1) {
      tld = urlParts[urlParts.length - 1] ?? "";
      domain = urlParts[urlParts.length - 2] ?? "";
      checkDomain = domain + "." + tld;
    } else if (urlParts.length === 1) {
      domain = urlParts[urlParts.length - 1] ?? "";
      checkDomain = domain;
    }
    if (await GuardBlockListDB$1.isAllowedDomain(checkDomain)) {
      return false;
    }
    if (await GuardBlockListDB$1.isBlockedDomain(domain)) {
      return true;
    }
    while (urlParts.length > 0) {
      checkDomain = urlParts.join(".");
      if (await GuardBlockListDB$1.isBlockedDomain(checkDomain)) {
        return true;
      }
      urlParts.shift();
      if (urlParts.length === 0) {
        break;
      }
    }
    return false;
  };
  const isAddressOnBlockList = (address) => {
    return spamAddress.value.includes(address);
  };
  const isAssetOnBlockList = (asset) => spamAssets.value.includes(asset);
  const getScamAssetList = () => GuardBlockListDB$1.getScamAssetList();
  const cacheServerScamInfos = async () => {
    const guardDomains = await GuardBlockListDB$1.getScamDomainList();
    for (let domains of guardDomains ?? []) {
      for (let domain of domains.domain ?? []) {
        if (!spamDomains.value.includes(domain)) {
          spamDomains.value.push(domain);
        }
      }
    }
    const guardAssets = await GuardBlockListDB$1.getScamAssetList();
    for (let assets of guardAssets ?? []) {
      for (let asset of assets.assets ?? []) {
        if (!spamAssets.value.includes(asset)) {
          spamAssets.value.push(asset);
        }
      }
    }
    const guardAddress = await GuardBlockListDB$1.getScamAddressesList();
    for (let addresses of guardAddress ?? []) {
      for (let address of addresses.address ?? []) {
        if (!spamAddress.value.includes(address)) {
          spamAddress.value.push(address);
        }
      }
    }
  };
  const isSpamAsset = (asset) => {
    if (spamAssets.value.length === 0) ;
    return spamAssets.value.includes(asset.f);
  };
  const numSpamAssets = computed(() => spamAssets.value.length);
  const _spamAssets = computed(() => spamAssets.value);
  return {
    isDomainOnBlockList,
    isAddressOnBlockList,
    isAssetOnBlockList,
    getScamAssetList,
    spamAssets: _spamAssets,
    isSpamAsset,
    numSpamAssets,
    cacheServerScamInfos
  };
};

var BroadcastMsgType = /* @__PURE__ */ ((BroadcastMsgType2) => {
  BroadcastMsgType2["open"] = "eternl-bc-open";
  BroadcastMsgType2["close"] = "eternl-bc-close";
  BroadcastMsgType2["updateNetworkId"] = "eternl-bc-updateNetworkId";
  BroadcastMsgType2["updateWalletList"] = "eternl-bc-updateWalletList";
  BroadcastMsgType2["updateAccountData"] = "eternl-bc-updateAccountData";
  BroadcastMsgType2["updateDappAccountId"] = "eternl-bc-updateDappAccountId";
  BroadcastMsgType2["updatePendingTx"] = "eternl-bc-updatePendingTx";
  BroadcastMsgType2["updatePeerInfoList"] = "eternl-bc-updatePeerInfoList";
  BroadcastMsgType2["updatePeerInfo"] = "eternl-bc-updatePeerInfo";
  BroadcastMsgType2["forcePeerDisconnect"] = "eternl-bc-forcePeerDisconnect";
  BroadcastMsgType2["forcePeerConnect"] = "eternl-bc-forcePeerConnect";
  BroadcastMsgType2["forceWCDisconnect"] = "eternl-bc-forceWCDisconnect";
  BroadcastMsgType2["forceWCConnect"] = "eternl-bc-forceWCConnect";
  BroadcastMsgType2["updateWalletConnectList"] = "eternl-bc-updateWalletConnectList";
  return BroadcastMsgType2;
})(BroadcastMsgType || {});
const isValidBroadcastMsgType = (msgType) => {
  return msgType === "eternl-bc-open" /* open */ || msgType === "eternl-bc-close" /* close */ || msgType === "eternl-bc-updateNetworkId" /* updateNetworkId */ || msgType === "eternl-bc-updateWalletList" /* updateWalletList */ || msgType === "eternl-bc-updateAccountData" /* updateAccountData */ || msgType === "eternl-bc-updateDappAccountId" /* updateDappAccountId */ || msgType === "eternl-bc-updatePendingTx" /* updatePendingTx */ || msgType === "eternl-bc-updatePeerInfoList" /* updatePeerInfoList */ || msgType === "eternl-bc-updatePeerInfo" /* updatePeerInfo */ || msgType === "eternl-bc-forcePeerDisconnect" /* forcePeerDisconnect */ || msgType === "eternl-bc-forcePeerConnect" /* forcePeerConnect */ || msgType === "eternl-bc-forceWCDisconnect" /* forceWCDisconnect */ || msgType === "eternl-bc-updateWalletConnectList" /* updateWalletConnectList */;
};

const txHashReg = /^[0-9a-f]{64}$/;
const putTxBalance = (networkId2, id, item) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.put(item));
const bulkPutTxBalanceList = (networkId2, id, itemList) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.bulkPut(itemList));
const getTxBalanceList = (networkId2, id, limit = 20, offset = 0, reverse = true) => {
  return AccountDB$1.getDB(networkId2, id).then((db) => {
    return db.transaction("r", [db.txList], async (tx) => {
      const query = db.txList.orderBy("slot");
      if (reverse) {
        return (await query.reverse().offset(offset).limit(limit).toArray()).sort((a, b) => {
          const slotDiff = b.slot - a.slot;
          if (slotDiff !== 0) {
            return slotDiff;
          }
          return b.idx - a.idx;
        });
      } else {
        return (await query.offset(offset).limit(limit).toArray()).sort((a, b) => {
          const slotDiff = b.slot - a.slot;
          if (slotDiff !== 0) {
            return slotDiff;
          }
          return b.idx - a.idx;
        });
      }
    });
  });
};
const getTxBalanceListOldest = (networkId2, id, limit = 20, offset = 0) => {
  return AccountDB$1.getDB(networkId2, id).then((db) => {
    return db.transaction("r", [db.txList], async (tx) => {
      const query = db.txList.orderBy("slot");
      return query.offset(offset).limit(limit).toArray();
    });
  });
};
const getTxHashList = (networkId2, id) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.toCollection().primaryKeys());
const getTxBalanceListTest = (networkId2, id) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.toArray());
const hasUninitializedTx = (networkId2, id) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.where("t").equals(ITxBalanceType.uninitialized).limit(1).count());
const getTxBalanceListCounts = (networkId2, id) => AccountDB$1.getDB(networkId2, id).then(async (db) => {
  const calls = [];
  calls.push(db.txList.count());
  calls.push(db.txList.where("t").equals(ITxBalanceType.uninitialized).count());
  const res = await Promise.all(calls);
  const numTxHashes = res[0];
  const numTxHashesUninitialized = res[1];
  return { numTxHashes, numTxHashesUninitialized };
});
const getFirstUninitialized = (networkId2, id) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.where("[slot+idx+t]").below([Dexie.maxKey, Dexie.maxKey, ITxBalanceType.withdrawal]).first());
const getLastUninitialized = (networkId2, id) => AccountDB$1.getDB(networkId2, id).then((db) => db.txList.where("[slot+idx+t]").below([Dexie.maxKey, Dexie.maxKey, ITxBalanceType.withdrawal]).last());
const getNextUninitialized = (networkId2, id, limit) => AccountDB$1.getDB(networkId2, id).then((db) => {
  return db.transaction("r", [db.txList], (tx) => {
    return db.txList.orderBy("slot").reverse().and((tx2) => tx2.t === ITxBalanceType.uninitialized).limit(limit).toArray();
  });
});
const searchTxBalanceByContract = async (networkId2, id, config, excludeTxList = [], limit = 100) => {
  let searchStrList = [];
  const addrList = [];
  const addrIdList = [];
  if (config.searchStr || config.searchStrList.length > 0) {
    searchStrList = [...config.searchStrList];
    if (config.searchStr) {
      for (const searchStr of trimAllStrings(config.searchStr.trim().split(","))) {
        if (searchStr.length > 0 && !searchStrList.includes(searchStr)) {
          searchStrList.push(searchStr);
        }
      }
    }
    for (let i = searchStrList.length - 1; i >= 0; i--) {
      const searchStr = searchStrList[i] = searchStrList[i]?.toLowerCase();
      const contractAddrList = getContractAddressesByLabel([searchStr]);
      if (contractAddrList.length > 0) {
        addrList.push(...contractAddrList);
        searchStrList.splice(i, 1);
      }
    }
    if (addrList.length > 0) {
      addrIdList.push(...await RefDB.getRefListByRefs(networkId2, id, addrList));
    }
  }
  if (addrIdList.length === 0) {
    return [];
  }
  return AccountDB$1.getDB(networkId2, id).then(
    (db) => db.txList.where("al").anyOf(addrIdList).distinct().sortBy("[slot+idx+t]").then((matches) => matches.filter((m) => !excludeTxList.includes(m.hash)).slice(-limit))
  );
};
const searchTxBalance = async (networkId2, id, config, limit = 100) => {
  let searchStrList = [];
  const addrList = [];
  const assetList = [];
  const txHashList = [];
  const numberList = [];
  const refIdList = [];
  const addrIdList = [];
  if (config.searchStr || config.searchStrList.length > 0) {
    searchStrList = [...config.searchStrList];
    if (config.searchStr) {
      for (const searchStr of trimAllStrings(config.searchStr.trim().split(","))) {
        if (searchStr.length > 0 && !searchStrList.includes(searchStr)) {
          searchStrList.push(searchStr);
        }
      }
    }
    for (let i = searchStrList.length - 1; i >= 0; i--) {
      const searchStr = searchStrList[i] = searchStrList[i]?.toLowerCase();
      if (searchStr.startsWith(networkAddressPrefix[networkId2]) && searchStr.length >= 58) {
        addrList.push(searchStr);
        searchStrList.splice(i, 1);
      } else if (searchStr.startsWith("asset") && searchStr.length >= 44) {
        assetList.push(searchStr);
        searchStrList.splice(i, 1);
      } else if (txHashReg.test(searchStr)) {
        txHashList.push(searchStr);
        searchStrList.splice(i, 1);
      } else {
        if (!Number.isNaN(searchStr)) {
          const searchStrNbr = Number(searchStr);
          if (searchStrNbr >= 0) {
            numberList.push(searchStrNbr);
            searchStrList.splice(i, 1);
          }
        }
      }
    }
    if (addrList.length > 0) {
      addrIdList.push(...await RefDB.getRefListByRefs(networkId2, id, addrList));
    }
    if (assetList.length > 0) {
      refIdList.push(...await RefDB.getRefListByRefs(networkId2, id, assetList));
    }
  }
  return AccountDB$1.getDB(networkId2, id).then((db) => {
    return db.transaction("r", [db.txList], async (tx) => {
      let query = null;
      if (typeof config.slotStart === "number" && typeof config.slotEnd === "number") {
        query = db.txList.where("[slot+idx+t]").between([config.slotStart, Dexie.minKey, Dexie.minKey], [config.slotEnd, Dexie.maxKey, Dexie.maxKey], true, true).reverse();
      } else if (typeof config.slotStart === "number") {
        query = db.txList.where("[slot+idx+t]").aboveOrEqual([config.slotStart, Dexie.minKey, Dexie.minKey]).reverse();
      } else if (typeof config.slotEnd === "number") {
        query = db.txList.where("[slot+idx+t]").belowOrEqual([config.slotEnd, Dexie.maxKey, Dexie.maxKey]).reverse();
      }
      const isSorted = !!query;
      if (typeof config.coinLow === "number" && typeof config.coinHigh === "number") {
        query = query ? query.and((tx2) => tx2.c >= config.coinLow && tx2.c <= config.coinHigh && tx2.t !== 0) : db.txList.where("c").between(config.coinLow, config.coinHigh, true, true).and((tx2) => tx2.t !== 0);
      } else if (typeof config.coinLow === "number") {
        query = query ? query.and((tx2) => tx2.c >= config.coinLow && tx2.t !== 0) : db.txList.where("c").aboveOrEqual(config.coinLow).and((tx2) => tx2.t !== 0);
      } else if (typeof config.coinHigh === "number") {
        query = query ? query.and((tx2) => tx2.c <= config.coinHigh && tx2.t !== 0) : db.txList.where("c").belowOrEqual(config.coinHigh).and((tx2) => tx2.t !== 0);
      }
      if (addrIdList.length > 0) {
        query = query ? query.and((tx2) => tx2.al.some((item) => addrIdList.includes(item))) : db.txList.where("al").anyOf(addrIdList);
        if (txHashList.length > 0) {
          query = query ? query.or("hash").anyOf(txHashList) : db.txList.where("hash").anyOf(txHashList);
        }
      } else if (txHashList.length > 0) {
        query = query ? query.and((tx2) => txHashList.includes(tx2.hash)) : db.txList.where("hash").anyOf(txHashList);
      }
      if (refIdList.length > 0 || searchStrList.length > 0 || numberList.length > 0) {
        const filterFn = (tx2) => {
          try {
            if (numberList.length > 0) {
              if (tx2.slot > 0 && numberList.includes(tx2.slot)) {
                return true;
              }
              if ((tx2.block ?? 0) > 0 && numberList.includes(tx2.block)) {
                return true;
              }
            }
            if (tx2.al && refIdList.length > 0) {
              if (refIdList.some((id2) => tx2.al.includes(id2))) {
                return true;
              }
            }
            if (tx2.tags && tx2.tags.length > 0 && refIdList.length > 0) {
              if (refIdList.some((id2) => tx2.tags.includes(id2))) {
                return true;
              }
            }
            if (tx2.msg && searchStrList.length > 0) {
              if (tx2.msg.some((line) => searchStrList.some((searchStr) => line.toLowerCase().includes(searchStr)))) {
                return true;
              }
            }
            return false;
          } catch (err) {
            console.warn("searchTx:", err?.message ?? err, tx2);
            return false;
          }
        };
        query = query ? query.and(filterFn) : db.txList.filter(filterFn);
      }
      if (!query) {
        return [];
      }
      if (isSorted) {
        return query.distinct().limit(limit).toArray();
      } else {
        return query.distinct().sortBy("[slot+idx+t]").then((matches) => matches.slice(-limit));
      }
    });
  });
};
const getTxHistory = (networkId2, accountId, total, limit = 20, offset = 0) => {
  if (total - offset < total / 2) {
    if (offset + limit > total) {
      limit = total - offset;
    }
    offset = Math.max(total - offset - limit, 0);
    return getTxBalanceList(networkId2, accountId, limit, offset, false);
  } else {
    return getTxBalanceList(networkId2, accountId, limit, offset, true);
  }
};
const getTxHistoryOldestToNewest = (networkId2, accountId, limit = 20, offset = 0) => getTxBalanceListOldest(networkId2, accountId, limit, offset);
const getRewardHistory = async (accountId, refId, limit = 20, offset = 0, reverse = true) => {
  return await AccountDB$1.getRewardHistory(networkId$9.value, accountId, refId, limit, offset, reverse);
};
const getRewardHistoryCount = async (accountId, refId) => {
  return await AccountDB$1.getRewardHistoryCount(networkId$9.value, accountId, refId);
};
const HistoryDB = {
  putTxBalance,
  bulkPutTxBalanceList,
  getTxBalanceList,
  getTxBalanceListTest,
  getTxBalanceListCounts,
  hasUninitializedTx,
  getFirstUninitialized,
  getLastUninitialized,
  getNextUninitialized,
  searchTxBalance,
  searchTxBalanceByContract,
  getTxHashList,
  getTxHistory,
  getTxHistoryOldestToNewest,
  getRewardHistory,
  getRewardHistoryCount
};

const storeId = "txHistoryController";
const appAccount = ref$1(null);
const accountData = ref$1(null);
const _isUpdating = ref$1(false);
const _numTxTotal = ref$1(0);
const _numTxLoaded = ref$1(0);
const _numItemsPerPage = ref$1(10);
const _numMaxSearchResults = ref$1(1e4);
const _txList = ref$1([]);
const _txListFirst = ref$1([]);
const _searchConfig = ref$1(null);
const _dbPage = computed(() => (currentPage.value - 1) * _numItemsPerPage.value);
const _txListPage = computed(() => {
  const numItems = _txList.value.length;
  let endIndex = Math.min(_dbPage.value + _numItemsPerPage.value, numItems);
  if (!!_searchConfig.value) {
    return _txList.value.slice(_dbPage.value, endIndex);
  }
  return _txList.value;
});
const _txListDatePage = computed(() => {
  const list = [];
  const _appAccount = appAccount.value;
  if (!_appAccount) {
    return [];
  }
  const networkId = _appAccount.data.state.networkId;
  const tz = appUseUtc.value ? "UTC" : appTimezone.value;
  for (const entry of _txListPage.value) {
    const dateId = getDateIdFromSlot(networkId, entry.slot, tz);
    const _dateTimestamp = Date.UTC(dateId.year, dateId.month - 1, dateId.day);
    const listEntry = list.find((item) => item.date === _dateTimestamp);
    if (!listEntry) {
      list.push({
        date: _dateTimestamp,
        txList: [entry]
      });
    } else {
      listEntry.txList.push(entry);
    }
  }
  return list;
});
const txListRecentNumEntries = ref$1(3);
const _txListRecentPage = computed(() => {
  return _txListFirst.value.slice(0, txListRecentNumEntries.value);
});
const isUpdating = computed(() => _isUpdating.value);
computed(() => _txList.value);
computed(() => _txListPage.value);
const txListRecentPage = computed(() => _txListRecentPage.value);
computed(() => _txListDatePage.value);
const hasSearchConfig = computed(() => !!_searchConfig.value);
computed(() => appAccount.value?.data.state.numTxHashes ?? 0);
const numTxTotal = computed(() => _numTxTotal.value);
computed(() => _numTxLoaded.value);
computed(() => _numItemsPerPage.value);
computed(() => _numMaxSearchResults.value);
computed(() => Math.ceil(numTxTotal.value / _numItemsPerPage.value));
const currentPage = ref$1(1);
const first = ref$1();
let _lastAccountId = "";
const initTxList = async (numItemsPerPage2 = 10, numMaxSearchResults2 = 1e4) => {
  resetTxList();
  _numItemsPerPage.value = numItemsPerPage2;
  _numMaxSearchResults.value = numMaxSearchResults2;
  if (_searchConfig.value) {
    await searchTxList(_searchConfig.value);
  } else {
    await updateTxList(true);
  }
};
const updateTxList = async (doUpdateNumbers) => {
  const _appAccount = appAccount.value;
  if (!_appAccount) {
    return resetTxList();
  }
  const networkId = _appAccount.data.state.networkId;
  const accountId = _appAccount.id;
  const state = _appAccount.data.state;
  if (_lastAccountId !== accountId) {
    _isUpdating.value = true;
  }
  _lastAccountId = accountId;
  if (doUpdateNumbers) {
    const numTx = state.numTxHashes;
    const numTxNotLoaded = state.numTxHashesUninitialized;
    _numTxTotal.value = numTx;
    _numTxLoaded.value = numTx - numTxNotLoaded;
  }
  let total = _numTxTotal.value;
  let offset = _dbPage.value;
  let limit = _numItemsPerPage.value;
  _txList.value = await HistoryDB.getTxHistory(networkId, accountId, total, limit, offset);
  _txListFirst.value = await HistoryDB.getTxHistory(networkId, accountId, total, txListRecentNumEntries.value, 0);
  await dispatchSignal(doUpdatePendingTxStatus);
  _isUpdating.value = false;
};
const searchTxList = async (config) => {
  if (!config || !Object.values(config).some((c) => c !== null && (Array.isArray(c) ? c.length > 0 : true))) {
    _searchConfig.value = null;
    return updateTxList(true);
  }
  const _appAccount = appAccount.value;
  if (!_appAccount) {
    return resetTxList();
  }
  _isUpdating.value = true;
  const networkId = _appAccount.data.state.networkId;
  const accountId = _appAccount.id;
  const multipleSearchList = config.searchStrList;
  if (config.searchStr && config.searchStr.length > 0 && !multipleSearchList.includes(config.searchStr)) {
    multipleSearchList.push(config.searchStr);
  }
  const txBalanceList = [];
  if (multipleSearchList.length > 0) {
    const additionalAssetIdList = [];
    for (let i = 0; i < multipleSearchList.length; i++) {
      const searchStr = multipleSearchList[i];
      const assetIdList = searchForAssetId(searchStr);
      if (assetIdList && (assetIdList?.length ?? 0) > 0) {
        for (const assetId of assetIdList) {
          if (!additionalAssetIdList.includes(assetId)) {
            additionalAssetIdList.push(assetId);
          }
        }
      }
    }
    config.searchStrList.push(...additionalAssetIdList);
  }
  const txList2 = await searchTxHistory(networkId, accountId, config, _numMaxSearchResults.value);
  txBalanceList.push(...txList2);
  _searchConfig.value = config;
  txBalanceList.sort((a, b) => b.slot - a.slot);
  _txList.value = txBalanceList;
  _numTxTotal.value = _txList.value.length;
  currentPage.value = 1;
  first.value = 0;
  _isUpdating.value = false;
};
const resetTxList = () => {
  _numTxTotal.value = 0;
  currentPage.value = 1;
  first.value = 0;
  _txList.value = [];
  _isUpdating.value = false;
};
const searchTxHistory = async (networkId, accountId, config, limit) => {
  const res1 = await HistoryDB.searchTxBalance(networkId, accountId, config, limit);
  const res2 = await HistoryDB.searchTxBalanceByContract(networkId, accountId, config, res1.map((tx) => tx.hash), limit ? limit - res1.length : limit);
  return res1.concat(res2).sort((a, b) => b.slot - a.slot || b.idx - a.idx);
};
const updateCurrentData = async (doUpdateNumbers = false) => {
  if (hasSearchConfig.value) ; else {
    await updateTxList(doUpdateNumbers);
  }
};
watch(currentPage, () => {
  updateCurrentData();
});
watch(accountData, (value) => {
  initTxList();
});
addSignalListener(onTxHistoryAccountUpdated, storeId, (_appAccount) => {
  appAccount.value = _appAccount ?? null;
  accountData.value = _appAccount?.data ?? null;
});
addSignalListener(onAccountDataUpdated, storeId, (_appAccount) => {
  if (_appAccount.id === appAccount.value?.id) {
    return updateCurrentData(true);
  }
});

let wasm;

const heap = new Array(32).fill(undefined);

heap.push(undefined, null, true, false);

function getObject(idx) { return heap[idx]; }

let heap_next = heap.length;

function dropObject(idx) {
    if (idx < 36) return;
    heap[idx] = heap_next;
    heap_next = idx;
}

function takeObject(idx) {
    const ret = getObject(idx);
    dropObject(idx);
    return ret;
}

let cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });

cachedTextDecoder.decode();

let cachegetUint8Memory0 = null;
function getUint8Memory0() {
    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {
        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);
    }
    return cachegetUint8Memory0;
}

function getStringFromWasm0(ptr, len) {
    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
}

function addHeapObject(obj) {
    if (heap_next === heap.length) heap.push(heap.length + 1);
    const idx = heap_next;
    heap_next = heap[idx];

    heap[idx] = obj;
    return idx;
}

function debugString(val) {
    // primitive types
    const type = typeof val;
    if (type == 'number' || type == 'boolean' || val == null) {
        return  `${val}`;
    }
    if (type == 'string') {
        return `"${val}"`;
    }
    if (type == 'symbol') {
        const description = val.description;
        if (description == null) {
            return 'Symbol';
        } else {
            return `Symbol(${description})`;
        }
    }
    if (type == 'function') {
        const name = val.name;
        if (typeof name == 'string' && name.length > 0) {
            return `Function(${name})`;
        } else {
            return 'Function';
        }
    }
    // objects
    if (Array.isArray(val)) {
        const length = val.length;
        let debug = '[';
        if (length > 0) {
            debug += debugString(val[0]);
        }
        for(let i = 1; i < length; i++) {
            debug += ', ' + debugString(val[i]);
        }
        debug += ']';
        return debug;
    }
    // Test for built-in
    const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
    let className;
    if (builtInMatches.length > 1) {
        className = builtInMatches[1];
    } else {
        // Failed to match the standard '[object ClassName]'
        return toString.call(val);
    }
    if (className == 'Object') {
        // we're a user defined class or Object
        // JSON.stringify avoids problems with cycles, and is generally much
        // easier than looping through ownProperties of `val`.
        try {
            return 'Object(' + JSON.stringify(val) + ')';
        } catch (_) {
            return 'Object';
        }
    }
    // errors
    if (val instanceof Error) {
        return `${val.name}: ${val.message}\n${val.stack}`;
    }
    // TODO we could test for more things here, like `Set`s and `Map`s.
    return className;
}

let WASM_VECTOR_LEN = 0;

let cachedTextEncoder = new TextEncoder('utf-8');

const encodeString = (typeof cachedTextEncoder.encodeInto === 'function'
    ? function (arg, view) {
    return cachedTextEncoder.encodeInto(arg, view);
}
    : function (arg, view) {
    const buf = cachedTextEncoder.encode(arg);
    view.set(buf);
    return {
        read: arg.length,
        written: buf.length
    };
});

function passStringToWasm0(arg, malloc, realloc) {

    if (realloc === undefined) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr = malloc(buf.length);
        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr;
    }

    let len = arg.length;
    let ptr = malloc(len);

    const mem = getUint8Memory0();

    let offset = 0;

    for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 0x7F) break;
        mem[ptr + offset] = code;
    }

    if (offset !== len) {
        if (offset !== 0) {
            arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3);
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);

        offset += ret.written;
    }

    WASM_VECTOR_LEN = offset;
    return ptr;
}

let cachegetInt32Memory0 = null;
function getInt32Memory0() {
    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {
        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);
    }
    return cachegetInt32Memory0;
}

function getArrayU8FromWasm0(ptr, len) {
    return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
}

function passArray8ToWasm0(arg, malloc) {
    const ptr = malloc(arg.length * 1);
    getUint8Memory0().set(arg, ptr / 1);
    WASM_VECTOR_LEN = arg.length;
    return ptr;
}

function _assertClass(instance, klass) {
    if (!(instance instanceof klass)) {
        throw new Error(`expected instance of ${klass.name}`);
    }
    return instance.ptr;
}

function isLikeNone(x) {
    return x === undefined || x === null;
}

let cachegetFloat64Memory0 = null;
function getFloat64Memory0() {
    if (cachegetFloat64Memory0 === null || cachegetFloat64Memory0.buffer !== wasm.memory.buffer) {
        cachegetFloat64Memory0 = new Float64Array(wasm.memory.buffer);
    }
    return cachegetFloat64Memory0;
}
/**
*/
const AlgorithmId = Object.freeze({
/**
*r" EdDSA (Pure EdDSA, not HashedEdDSA) - the algorithm used for Cardano addresses
*/
EdDSA:0,"0":"EdDSA",
/**
*r" ChaCha20/Poly1305 w/ 256-bit key, 128-bit tag
*/
ChaCha20Poly1305:1,"1":"ChaCha20Poly1305", });
/**
*/
const KeyType = Object.freeze({
/**
*r" octet key pair
*/
OKP:0,"0":"OKP",
/**
*r" 2-coord EC
*/
EC2:1,"1":"EC2",Symmetric:2,"2":"Symmetric", });
/**
*/
class BigNum {

    static __wrap(ptr) {
        const obj = Object.create(BigNum.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_bignum_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bignum_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {BigNum}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.bignum_from_bytes(ptr0, len0);
        return BigNum.__wrap(ret);
    }
    /**
    * @param {string} string
    * @returns {BigNum}
    */
    static from_str(string) {
        var ptr0 = passStringToWasm0(string, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.bignum_from_str(ptr0, len0);
        return BigNum.__wrap(ret);
    }
    /**
    * @returns {string}
    */
    to_str() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.bignum_to_str(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return getStringFromWasm0(r0, r1);
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
            wasm.__wbindgen_free(r0, r1);
        }
    }
    /**
    * @param {BigNum} other
    * @returns {BigNum}
    */
    checked_mul(other) {
        _assertClass(other, BigNum);
        var ret = wasm.bignum_checked_mul(this.ptr, other.ptr);
        return BigNum.__wrap(ret);
    }
    /**
    * @param {BigNum} other
    * @returns {BigNum}
    */
    checked_add(other) {
        _assertClass(other, BigNum);
        var ret = wasm.bignum_checked_add(this.ptr, other.ptr);
        return BigNum.__wrap(ret);
    }
    /**
    * @param {BigNum} other
    * @returns {BigNum}
    */
    checked_sub(other) {
        _assertClass(other, BigNum);
        var ret = wasm.bignum_checked_sub(this.ptr, other.ptr);
        return BigNum.__wrap(ret);
    }
}
/**
*/
class CBORArray {

    static __wrap(ptr) {
        const obj = Object.create(CBORArray.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cborarray_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborarray_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {CBORArray}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cborarray_from_bytes(ptr0, len0);
        return CBORArray.__wrap(ret);
    }
    /**
    * @returns {CBORArray}
    */
    static new() {
        var ret = wasm.cborarray_new();
        return CBORArray.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        var ret = wasm.cborarray_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {CBORValue}
    */
    get(index) {
        var ret = wasm.cborarray_get(this.ptr, index);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {CBORValue} elem
    */
    add(elem) {
        _assertClass(elem, CBORValue);
        wasm.cborarray_add(this.ptr, elem.ptr);
    }
    /**
    * @param {boolean} use_definite
    */
    set_definite_encoding(use_definite) {
        wasm.cborarray_set_definite_encoding(this.ptr, use_definite);
    }
    /**
    * @returns {boolean}
    */
    is_definite() {
        var ret = wasm.cborarray_is_definite(this.ptr);
        return ret !== 0;
    }
}
/**
*/
class CBORObject {

    static __wrap(ptr) {
        const obj = Object.create(CBORObject.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cborobject_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborobject_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {CBORObject}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cborobject_from_bytes(ptr0, len0);
        return CBORObject.__wrap(ret);
    }
    /**
    * @returns {CBORObject}
    */
    static new() {
        var ret = wasm.cborobject_new();
        return CBORObject.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        var ret = wasm.cborobject_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {CBORValue} key
    * @param {CBORValue} value
    * @returns {CBORValue | undefined}
    */
    insert(key, value) {
        _assertClass(key, CBORValue);
        _assertClass(value, CBORValue);
        var ret = wasm.cborobject_insert(this.ptr, key.ptr, value.ptr);
        return ret === 0 ? undefined : CBORValue.__wrap(ret);
    }
    /**
    * @param {CBORValue} key
    * @returns {CBORValue | undefined}
    */
    get(key) {
        _assertClass(key, CBORValue);
        var ret = wasm.cborobject_get(this.ptr, key.ptr);
        return ret === 0 ? undefined : CBORValue.__wrap(ret);
    }
    /**
    * @returns {CBORArray}
    */
    keys() {
        var ret = wasm.cborobject_keys(this.ptr);
        return CBORArray.__wrap(ret);
    }
    /**
    * @param {boolean} use_definite
    */
    set_definite_encoding(use_definite) {
        wasm.cborobject_set_definite_encoding(this.ptr, use_definite);
    }
    /**
    * @returns {boolean}
    */
    is_definite() {
        var ret = wasm.cborobject_is_definite(this.ptr);
        return ret !== 0;
    }
}
/**
*/
class CBORSpecial {

    static __wrap(ptr) {
        const obj = Object.create(CBORSpecial.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cborspecial_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborspecial_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {CBORSpecial}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cborspecial_from_bytes(ptr0, len0);
        return CBORSpecial.__wrap(ret);
    }
    /**
    * @param {boolean} b
    * @returns {CBORSpecial}
    */
    static new_bool(b) {
        var ret = wasm.cborspecial_new_bool(b);
        return CBORSpecial.__wrap(ret);
    }
    /**
    * @param {number} u
    * @returns {CBORSpecial}
    */
    static new_unassigned(u) {
        var ret = wasm.cborspecial_new_unassigned(u);
        return CBORSpecial.__wrap(ret);
    }
    /**
    * @returns {CBORSpecial}
    */
    static new_break() {
        var ret = wasm.cborspecial_new_break();
        return CBORSpecial.__wrap(ret);
    }
    /**
    * @returns {CBORSpecial}
    */
    static new_null() {
        var ret = wasm.cborspecial_new_null();
        return CBORSpecial.__wrap(ret);
    }
    /**
    * @returns {CBORSpecial}
    */
    static new_undefined() {
        var ret = wasm.cborspecial_new_undefined();
        return CBORSpecial.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        var ret = wasm.cborspecial_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {boolean | undefined}
    */
    as_bool() {
        var ret = wasm.cborspecial_as_bool(this.ptr);
        return ret === 0xFFFFFF ? undefined : ret !== 0;
    }
    /**
    * @returns {number | undefined}
    */
    as_float() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborspecial_as_float(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getFloat64Memory0()[retptr / 8 + 1];
            return r0 === 0 ? undefined : r1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {number | undefined}
    */
    as_unassigned() {
        var ret = wasm.cborspecial_as_unassigned(this.ptr);
        return ret === 0xFFFFFF ? undefined : ret;
    }
}
/**
*/
class CBORValue {

    static __wrap(ptr) {
        const obj = Object.create(CBORValue.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cborvalue_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborvalue_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {CBORValue}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cborvalue_from_bytes(ptr0, len0);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {Int} int
    * @returns {CBORValue}
    */
    static new_int(int) {
        _assertClass(int, Int);
        var ret = wasm.cborvalue_new_int(int.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {CBORValue}
    */
    static new_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cborvalue_new_bytes(ptr0, len0);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {string} text
    * @returns {CBORValue}
    */
    static new_text(text) {
        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cborvalue_new_text(ptr0, len0);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {CBORArray} arr
    * @returns {CBORValue}
    */
    static new_array(arr) {
        _assertClass(arr, CBORArray);
        var ret = wasm.cborvalue_new_array(arr.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {CBORObject} obj
    * @returns {CBORValue}
    */
    static new_object(obj) {
        _assertClass(obj, CBORObject);
        var ret = wasm.cborvalue_new_object(obj.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {TaggedCBOR} tagged
    * @returns {CBORValue}
    */
    static new_tagged(tagged) {
        _assertClass(tagged, TaggedCBOR);
        var ret = wasm.cborvalue_new_tagged(tagged.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {CBORSpecial} special
    * @returns {CBORValue}
    */
    static new_special(special) {
        _assertClass(special, CBORSpecial);
        var ret = wasm.cborvalue_new_special(special.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {Label} label
    * @returns {CBORValue}
    */
    static from_label(label) {
        _assertClass(label, Label);
        var ret = wasm.cborvalue_from_label(label.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        var ret = wasm.cborvalue_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Int | undefined}
    */
    as_int() {
        var ret = wasm.cborvalue_as_int(this.ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    as_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborvalue_as_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {string | undefined}
    */
    as_text() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cborvalue_as_text(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {CBORArray | undefined}
    */
    as_array() {
        var ret = wasm.cborvalue_as_array(this.ptr);
        return ret === 0 ? undefined : CBORArray.__wrap(ret);
    }
    /**
    * @returns {CBORObject | undefined}
    */
    as_object() {
        var ret = wasm.cborvalue_as_object(this.ptr);
        return ret === 0 ? undefined : CBORObject.__wrap(ret);
    }
    /**
    * @returns {TaggedCBOR | undefined}
    */
    as_tagged() {
        var ret = wasm.cborvalue_as_tagged(this.ptr);
        return ret === 0 ? undefined : TaggedCBOR.__wrap(ret);
    }
    /**
    * @returns {CBORSpecial | undefined}
    */
    as_special() {
        var ret = wasm.cborvalue_as_special(this.ptr);
        return ret === 0 ? undefined : CBORSpecial.__wrap(ret);
    }
}
/**
*/
class COSEKey {

    static __wrap(ptr) {
        const obj = Object.create(COSEKey.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cosekey_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosekey_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {COSEKey}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosekey_from_bytes(ptr0, len0);
        return COSEKey.__wrap(ret);
    }
    /**
    * @param {Label} key_type
    */
    set_key_type(key_type) {
        _assertClass(key_type, Label);
        wasm.cosekey_set_key_type(this.ptr, key_type.ptr);
    }
    /**
    * @returns {Label}
    */
    key_type() {
        var ret = wasm.cosekey_key_type(this.ptr);
        return Label.__wrap(ret);
    }
    /**
    * @param {Uint8Array} key_id
    */
    set_key_id(key_id) {
        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.cosekey_set_key_id(this.ptr, ptr0, len0);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    key_id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosekey_key_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Label} algorithm_id
    */
    set_algorithm_id(algorithm_id) {
        _assertClass(algorithm_id, Label);
        wasm.cosekey_set_algorithm_id(this.ptr, algorithm_id.ptr);
    }
    /**
    * @returns {Label | undefined}
    */
    algorithm_id() {
        var ret = wasm.cosekey_algorithm_id(this.ptr);
        return ret === 0 ? undefined : Label.__wrap(ret);
    }
    /**
    * @param {Labels} key_ops
    */
    set_key_ops(key_ops) {
        _assertClass(key_ops, Labels);
        wasm.cosekey_set_key_ops(this.ptr, key_ops.ptr);
    }
    /**
    * @returns {Labels | undefined}
    */
    key_ops() {
        var ret = wasm.cosekey_key_ops(this.ptr);
        return ret === 0 ? undefined : Labels.__wrap(ret);
    }
    /**
    * @param {Uint8Array} base_init_vector
    */
    set_base_init_vector(base_init_vector) {
        var ptr0 = passArray8ToWasm0(base_init_vector, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    base_init_vector() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosekey_base_init_vector(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Label} label
    * @returns {CBORValue | undefined}
    */
    header(label) {
        _assertClass(label, Label);
        var ret = wasm.cosekey_header(this.ptr, label.ptr);
        return ret === 0 ? undefined : CBORValue.__wrap(ret);
    }
    /**
    * @param {Label} label
    * @param {CBORValue} value
    */
    set_header(label, value) {
        _assertClass(label, Label);
        _assertClass(value, CBORValue);
        wasm.cosekey_set_header(this.ptr, label.ptr, value.ptr);
    }
    /**
    * @param {Label} key_type
    * @returns {COSEKey}
    */
    static new(key_type) {
        _assertClass(key_type, Label);
        var ret = wasm.cosekey_new(key_type.ptr);
        return COSEKey.__wrap(ret);
    }
}
/**
*/
class COSESign1 {

    static __wrap(ptr) {
        const obj = Object.create(COSESign1.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cosesign1_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosesign1_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {COSESign1}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosesign1_from_bytes(ptr0, len0);
        return COSESign1.__wrap(ret);
    }
    /**
    * @returns {Headers}
    */
    headers() {
        var ret = wasm.coseencrypt0_headers(this.ptr);
        return Headers.__wrap(ret);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    payload() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.coseencrypt_ciphertext(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    signature() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosesign1_signature(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * For verifying, we will want to reverse-construct this SigStructure to check the signature against
    * # Arguments
    * * `external_aad` - External application data - see RFC 8152 section 4.3. Set to None if not using this.
    * @param {Uint8Array | undefined} external_aad
    * @param {Uint8Array | undefined} external_payload
    * @returns {SigStructure}
    */
    signed_data(external_aad, external_payload) {
        var ptr0 = isLikeNone(external_aad) ? 0 : passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = isLikeNone(external_payload) ? 0 : passArray8ToWasm0(external_payload, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        var ret = wasm.cosesign1_signed_data(this.ptr, ptr0, len0, ptr1, len1);
        return SigStructure.__wrap(ret);
    }
    /**
    * @param {Headers} headers
    * @param {Uint8Array | undefined} payload
    * @param {Uint8Array} signature
    * @returns {COSESign1}
    */
    static new(headers, payload, signature) {
        _assertClass(headers, Headers);
        var ptr0 = isLikeNone(payload) ? 0 : passArray8ToWasm0(payload, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        var ret = wasm.cosesign1_new(headers.ptr, ptr0, len0, ptr1, len1);
        return COSESign1.__wrap(ret);
    }
}
/**
*/
class COSESign1Builder {

    static __wrap(ptr) {
        const obj = Object.create(COSESign1Builder.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cosesign1builder_free(ptr);
    }
    /**
    * @param {Headers} headers
    * @param {Uint8Array} payload
    * @param {boolean} is_payload_external
    * @returns {COSESign1Builder}
    */
    static new(headers, payload, is_payload_external) {
        _assertClass(headers, Headers);
        var ptr0 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosesign1builder_new(headers.ptr, ptr0, len0, is_payload_external);
        return COSESign1Builder.__wrap(ret);
    }
    /**
    */
    hash_payload() {
        wasm.cosesign1builder_hash_payload(this.ptr);
    }
    /**
    * @param {Uint8Array} external_aad
    */
    set_external_aad(external_aad) {
        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.cosesign1builder_set_external_aad(this.ptr, ptr0, len0);
    }
    /**
    * @returns {SigStructure}
    */
    make_data_to_sign() {
        var ret = wasm.cosesign1builder_make_data_to_sign(this.ptr);
        return SigStructure.__wrap(ret);
    }
    /**
    * @param {Uint8Array} signed_sig_structure
    * @returns {COSESign1}
    */
    build(signed_sig_structure) {
        var ptr0 = passArray8ToWasm0(signed_sig_structure, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosesign1builder_build(this.ptr, ptr0, len0);
        return COSESign1.__wrap(ret);
    }
}
/**
*/
class COSESignature {

    static __wrap(ptr) {
        const obj = Object.create(COSESignature.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cosesignature_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosesignature_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {COSESignature}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosesignature_from_bytes(ptr0, len0);
        return COSESignature.__wrap(ret);
    }
    /**
    * @returns {Headers}
    */
    headers() {
        var ret = wasm.coseencrypt0_headers(this.ptr);
        return Headers.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    signature() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosesign1_signature(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Headers} headers
    * @param {Uint8Array} signature
    * @returns {COSESignature}
    */
    static new(headers, signature) {
        _assertClass(headers, Headers);
        var ptr0 = passArray8ToWasm0(signature, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosesignature_new(headers.ptr, ptr0, len0);
        return COSESignature.__wrap(ret);
    }
}
/**
*/
class COSESignatures {

    static __wrap(ptr) {
        const obj = Object.create(COSESignatures.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_cosesignatures_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosesignatures_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {COSESignatures}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.cosesignatures_from_bytes(ptr0, len0);
        return COSESignatures.__wrap(ret);
    }
    /**
    * @returns {COSESignatures}
    */
    static new() {
        var ret = wasm.coserecipients_new();
        return COSESignatures.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        var ret = wasm.coserecipients_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {COSESignature}
    */
    get(index) {
        var ret = wasm.cosesignatures_get(this.ptr, index);
        return COSESignature.__wrap(ret);
    }
    /**
    * @param {COSESignature} elem
    */
    add(elem) {
        _assertClass(elem, COSESignature);
        wasm.cosesignatures_add(this.ptr, elem.ptr);
    }
}
/**
*/
class CounterSignature {

    static __wrap(ptr) {
        const obj = Object.create(CounterSignature.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_countersignature_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.countersignature_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {CounterSignature}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.countersignature_from_bytes(ptr0, len0);
        return CounterSignature.__wrap(ret);
    }
    /**
    * @param {COSESignature} cose_signature
    * @returns {CounterSignature}
    */
    static new_single(cose_signature) {
        _assertClass(cose_signature, COSESignature);
        var ret = wasm.countersignature_new_single(cose_signature.ptr);
        return CounterSignature.__wrap(ret);
    }
    /**
    * @param {COSESignatures} cose_signatures
    * @returns {CounterSignature}
    */
    static new_multi(cose_signatures) {
        _assertClass(cose_signatures, COSESignatures);
        var ret = wasm.countersignature_new_multi(cose_signatures.ptr);
        return CounterSignature.__wrap(ret);
    }
    /**
    * @returns {COSESignatures}
    */
    signatures() {
        var ret = wasm.countersignature_new_multi(this.ptr);
        return COSESignatures.__wrap(ret);
    }
}
/**
*/
class HeaderMap {

    static __wrap(ptr) {
        const obj = Object.create(HeaderMap.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_headermap_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headermap_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {HeaderMap}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.headermap_from_bytes(ptr0, len0);
        return HeaderMap.__wrap(ret);
    }
    /**
    * @param {Label} algorithm_id
    */
    set_algorithm_id(algorithm_id) {
        _assertClass(algorithm_id, Label);
        wasm.headermap_set_algorithm_id(this.ptr, algorithm_id.ptr);
    }
    /**
    * @returns {Label | undefined}
    */
    algorithm_id() {
        var ret = wasm.headermap_algorithm_id(this.ptr);
        return ret === 0 ? undefined : Label.__wrap(ret);
    }
    /**
    * @param {Labels} criticality
    */
    set_criticality(criticality) {
        _assertClass(criticality, Labels);
        wasm.headermap_set_criticality(this.ptr, criticality.ptr);
    }
    /**
    * @returns {Labels | undefined}
    */
    criticality() {
        var ret = wasm.headermap_criticality(this.ptr);
        return ret === 0 ? undefined : Labels.__wrap(ret);
    }
    /**
    * @param {Label} content_type
    */
    set_content_type(content_type) {
        _assertClass(content_type, Label);
        wasm.cosekey_set_algorithm_id(this.ptr, content_type.ptr);
    }
    /**
    * @returns {Label | undefined}
    */
    content_type() {
        var ret = wasm.cosekey_algorithm_id(this.ptr);
        return ret === 0 ? undefined : Label.__wrap(ret);
    }
    /**
    * @param {Uint8Array} key_id
    */
    set_key_id(key_id) {
        var ptr0 = passArray8ToWasm0(key_id, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.headermap_set_key_id(this.ptr, ptr0, len0);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    key_id() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headermap_key_id(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} init_vector
    */
    set_init_vector(init_vector) {
        var ptr0 = passArray8ToWasm0(init_vector, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.cosekey_set_base_init_vector(this.ptr, ptr0, len0);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    init_vector() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.cosekey_base_init_vector(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} partial_init_vector
    */
    set_partial_init_vector(partial_init_vector) {
        var ptr0 = passArray8ToWasm0(partial_init_vector, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        wasm.headermap_set_partial_init_vector(this.ptr, ptr0, len0);
    }
    /**
    * @returns {Uint8Array | undefined}
    */
    partial_init_vector() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headermap_partial_init_vector(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getArrayU8FromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {CounterSignature} counter_signature
    */
    set_counter_signature(counter_signature) {
        _assertClass(counter_signature, CounterSignature);
        wasm.headermap_set_counter_signature(this.ptr, counter_signature.ptr);
    }
    /**
    * @returns {CounterSignature | undefined}
    */
    counter_signature() {
        var ret = wasm.headermap_counter_signature(this.ptr);
        return ret === 0 ? undefined : CounterSignature.__wrap(ret);
    }
    /**
    * @param {Label} label
    * @returns {CBORValue | undefined}
    */
    header(label) {
        _assertClass(label, Label);
        var ret = wasm.headermap_header(this.ptr, label.ptr);
        return ret === 0 ? undefined : CBORValue.__wrap(ret);
    }
    /**
    * @param {Label} label
    * @param {CBORValue} value
    */
    set_header(label, value) {
        _assertClass(label, Label);
        _assertClass(value, CBORValue);
        wasm.headermap_set_header(this.ptr, label.ptr, value.ptr);
    }
    /**
    * @returns {Labels}
    */
    keys() {
        var ret = wasm.headermap_keys(this.ptr);
        return Labels.__wrap(ret);
    }
    /**
    * @returns {HeaderMap}
    */
    static new() {
        var ret = wasm.headermap_new();
        return HeaderMap.__wrap(ret);
    }
}
/**
*/
class Headers {

    static __wrap(ptr) {
        const obj = Object.create(Headers.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_headers_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.headers_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Headers}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.headers_from_bytes(ptr0, len0);
        return Headers.__wrap(ret);
    }
    /**
    * @returns {ProtectedHeaderMap}
    */
    protected() {
        var ret = wasm.headers_protected(this.ptr);
        return ProtectedHeaderMap.__wrap(ret);
    }
    /**
    * @returns {HeaderMap}
    */
    unprotected() {
        var ret = wasm.headers_unprotected(this.ptr);
        return HeaderMap.__wrap(ret);
    }
    /**
    * @param {ProtectedHeaderMap} protected_
    * @param {HeaderMap} unprotected_
    * @returns {Headers}
    */
    static new(protected_, unprotected_) {
        _assertClass(protected_, ProtectedHeaderMap);
        _assertClass(unprotected_, HeaderMap);
        var ret = wasm.headers_new(protected_.ptr, unprotected_.ptr);
        return Headers.__wrap(ret);
    }
}
/**
*/
class Int {

    static __wrap(ptr) {
        const obj = Object.create(Int.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_int_free(ptr);
    }
    /**
    * @param {BigNum} x
    * @returns {Int}
    */
    static new(x) {
        _assertClass(x, BigNum);
        var ptr0 = x.ptr;
        x.ptr = 0;
        var ret = wasm.int_new(ptr0);
        return Int.__wrap(ret);
    }
    /**
    * @param {BigNum} x
    * @returns {Int}
    */
    static new_negative(x) {
        _assertClass(x, BigNum);
        var ptr0 = x.ptr;
        x.ptr = 0;
        var ret = wasm.int_new_negative(ptr0);
        return Int.__wrap(ret);
    }
    /**
    * @param {number} x
    * @returns {Int}
    */
    static new_i32(x) {
        var ret = wasm.int_new_i32(x);
        return Int.__wrap(ret);
    }
    /**
    * @returns {boolean}
    */
    is_positive() {
        var ret = wasm.int_is_positive(this.ptr);
        return ret !== 0;
    }
    /**
    * @returns {BigNum | undefined}
    */
    as_positive() {
        var ret = wasm.int_as_positive(this.ptr);
        return ret === 0 ? undefined : BigNum.__wrap(ret);
    }
    /**
    * @returns {BigNum | undefined}
    */
    as_negative() {
        var ret = wasm.int_as_negative(this.ptr);
        return ret === 0 ? undefined : BigNum.__wrap(ret);
    }
    /**
    * @returns {number | undefined}
    */
    as_i32() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.int_as_i32(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            return r0 === 0 ? undefined : r1;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
}
/**
*/
class Label {

    static __wrap(ptr) {
        const obj = Object.create(Label.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_label_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.label_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Label}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.label_from_bytes(ptr0, len0);
        return Label.__wrap(ret);
    }
    /**
    * @param {Int} int
    * @returns {Label}
    */
    static new_int(int) {
        _assertClass(int, Int);
        var ret = wasm.label_new_int(int.ptr);
        return Label.__wrap(ret);
    }
    /**
    * @param {string} text
    * @returns {Label}
    */
    static new_text(text) {
        var ptr0 = passStringToWasm0(text, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.label_new_text(ptr0, len0);
        return Label.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    kind() {
        var ret = wasm.label_kind(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {Int | undefined}
    */
    as_int() {
        var ret = wasm.label_as_int(this.ptr);
        return ret === 0 ? undefined : Int.__wrap(ret);
    }
    /**
    * @returns {string | undefined}
    */
    as_text() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.label_as_text(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            let v0;
            if (r0 !== 0) {
                v0 = getStringFromWasm0(r0, r1).slice();
                wasm.__wbindgen_free(r0, r1 * 1);
            }
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {number} id
    * @returns {Label}
    */
    static from_algorithm_id(id) {
        var ret = wasm.label_from_algorithm_id(id);
        return Label.__wrap(ret);
    }
    /**
    * @param {number} key_type
    * @returns {Label}
    */
    static from_key_type(key_type) {
        var ret = wasm.label_from_key_type(key_type);
        return Label.__wrap(ret);
    }
    /**
    * @param {number} ec_key
    * @returns {Label}
    */
    static from_ec_key(ec_key) {
        var ret = wasm.label_from_ec_key(ec_key);
        return Label.__wrap(ret);
    }
    /**
    * @param {number} curve_type
    * @returns {Label}
    */
    static from_curve_type(curve_type) {
        var ret = wasm.label_from_curve_type(curve_type);
        return Label.__wrap(ret);
    }
    /**
    * @param {number} key_op
    * @returns {Label}
    */
    static from_key_operation(key_op) {
        var ret = wasm.label_from_key_operation(key_op);
        return Label.__wrap(ret);
    }
}
/**
*/
class Labels {

    static __wrap(ptr) {
        const obj = Object.create(Labels.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_labels_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.labels_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {Labels}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.labels_from_bytes(ptr0, len0);
        return Labels.__wrap(ret);
    }
    /**
    * @returns {Labels}
    */
    static new() {
        var ret = wasm.coserecipients_new();
        return Labels.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    len() {
        var ret = wasm.coserecipients_len(this.ptr);
        return ret >>> 0;
    }
    /**
    * @param {number} index
    * @returns {Label}
    */
    get(index) {
        var ret = wasm.labels_get(this.ptr, index);
        return Label.__wrap(ret);
    }
    /**
    * @param {Label} elem
    */
    add(elem) {
        _assertClass(elem, Label);
        wasm.labels_add(this.ptr, elem.ptr);
    }
}
/**
*/
class ProtectedHeaderMap {

    static __wrap(ptr) {
        const obj = Object.create(ProtectedHeaderMap.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_protectedheadermap_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.protectedheadermap_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {ProtectedHeaderMap}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.protectedheadermap_from_bytes(ptr0, len0);
        return ProtectedHeaderMap.__wrap(ret);
    }
    /**
    * @returns {ProtectedHeaderMap}
    */
    static new_empty() {
        var ret = wasm.protectedheadermap_new_empty();
        return ProtectedHeaderMap.__wrap(ret);
    }
    /**
    * @param {HeaderMap} header_map
    * @returns {ProtectedHeaderMap}
    */
    static new(header_map) {
        _assertClass(header_map, HeaderMap);
        var ret = wasm.protectedheadermap_new(header_map.ptr);
        return ProtectedHeaderMap.__wrap(ret);
    }
    /**
    * @returns {HeaderMap}
    */
    deserialized_headers() {
        var ret = wasm.protectedheadermap_deserialized_headers(this.ptr);
        return HeaderMap.__wrap(ret);
    }
}
/**
*/
class SigStructure {

    static __wrap(ptr) {
        const obj = Object.create(SigStructure.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_sigstructure_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sigstructure_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {SigStructure}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.sigstructure_from_bytes(ptr0, len0);
        return SigStructure.__wrap(ret);
    }
    /**
    * @returns {number}
    */
    context() {
        var ret = wasm.sigstructure_context(this.ptr);
        return ret >>> 0;
    }
    /**
    * @returns {ProtectedHeaderMap}
    */
    body_protected() {
        var ret = wasm.sigstructure_body_protected(this.ptr);
        return ProtectedHeaderMap.__wrap(ret);
    }
    /**
    * @returns {ProtectedHeaderMap | undefined}
    */
    sign_protected() {
        var ret = wasm.sigstructure_sign_protected(this.ptr);
        return ret === 0 ? undefined : ProtectedHeaderMap.__wrap(ret);
    }
    /**
    * @returns {Uint8Array}
    */
    external_aad() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sigstructure_external_aad(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @returns {Uint8Array}
    */
    payload() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.sigstructure_payload(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {ProtectedHeaderMap} sign_protected
    */
    set_sign_protected(sign_protected) {
        _assertClass(sign_protected, ProtectedHeaderMap);
        wasm.sigstructure_set_sign_protected(this.ptr, sign_protected.ptr);
    }
    /**
    * @param {number} context
    * @param {ProtectedHeaderMap} body_protected
    * @param {Uint8Array} external_aad
    * @param {Uint8Array} payload
    * @returns {SigStructure}
    */
    static new(context, body_protected, external_aad, payload) {
        _assertClass(body_protected, ProtectedHeaderMap);
        var ptr0 = passArray8ToWasm0(external_aad, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ptr1 = passArray8ToWasm0(payload, wasm.__wbindgen_malloc);
        var len1 = WASM_VECTOR_LEN;
        var ret = wasm.sigstructure_new(context, body_protected.ptr, ptr0, len0, ptr1, len1);
        return SigStructure.__wrap(ret);
    }
}
/**
*/
class TaggedCBOR {

    static __wrap(ptr) {
        const obj = Object.create(TaggedCBOR.prototype);
        obj.ptr = ptr;

        return obj;
    }

    __destroy_into_raw() {
        const ptr = this.ptr;
        this.ptr = 0;

        return ptr;
    }

    free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_taggedcbor_free(ptr);
    }
    /**
    * @returns {Uint8Array}
    */
    to_bytes() {
        try {
            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
            wasm.taggedcbor_to_bytes(retptr, this.ptr);
            var r0 = getInt32Memory0()[retptr / 4 + 0];
            var r1 = getInt32Memory0()[retptr / 4 + 1];
            var v0 = getArrayU8FromWasm0(r0, r1).slice();
            wasm.__wbindgen_free(r0, r1 * 1);
            return v0;
        } finally {
            wasm.__wbindgen_add_to_stack_pointer(16);
        }
    }
    /**
    * @param {Uint8Array} bytes
    * @returns {TaggedCBOR}
    */
    static from_bytes(bytes) {
        var ptr0 = passArray8ToWasm0(bytes, wasm.__wbindgen_malloc);
        var len0 = WASM_VECTOR_LEN;
        var ret = wasm.taggedcbor_from_bytes(ptr0, len0);
        return TaggedCBOR.__wrap(ret);
    }
    /**
    * @returns {BigNum}
    */
    tag() {
        var ret = wasm.taggedcbor_tag(this.ptr);
        return BigNum.__wrap(ret);
    }
    /**
    * @returns {CBORValue}
    */
    value() {
        var ret = wasm.taggedcbor_value(this.ptr);
        return CBORValue.__wrap(ret);
    }
    /**
    * @param {BigNum} tag
    * @param {CBORValue} value
    * @returns {TaggedCBOR}
    */
    static new(tag, value) {
        _assertClass(tag, BigNum);
        var ptr0 = tag.ptr;
        tag.ptr = 0;
        _assertClass(value, CBORValue);
        var ret = wasm.taggedcbor_new(ptr0, value.ptr);
        return TaggedCBOR.__wrap(ret);
    }
}

async function load(module, imports) {
    if (typeof Response === 'function' && module instanceof Response) {
        if (typeof WebAssembly.instantiateStreaming === 'function') {
            try {
                return await WebAssembly.instantiateStreaming(module, imports);

            } catch (e) {
                if (module.headers.get('Content-Type') != 'application/wasm') {
                    console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n", e);

                } else {
                    throw e;
                }
            }
        }

        const bytes = await module.arrayBuffer();
        return await WebAssembly.instantiate(bytes, imports);

    } else {
        const instance = await WebAssembly.instantiate(module, imports);

        if (instance instanceof WebAssembly.Instance) {
            return { instance, module };

        } else {
            return instance;
        }
    }
}

async function init(input) {
    if (typeof input === 'undefined') {
        input = new URL("cardano_message_signing_bg.wasm", import.meta.url);
    }
    const imports = {};
    imports.wbg = {};
    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {
        takeObject(arg0);
    };
    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {
        var ret = getStringFromWasm0(arg0, arg1);
        return addHeapObject(ret);
    };
    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {
        var ret = debugString(getObject(arg1));
        var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
        var len0 = WASM_VECTOR_LEN;
        getInt32Memory0()[arg0 / 4 + 1] = len0;
        getInt32Memory0()[arg0 / 4 + 0] = ptr0;
    };
    imports.wbg.__wbindgen_throw = function(arg0, arg1) {
        throw new Error(getStringFromWasm0(arg0, arg1));
    };
    imports.wbg.__wbindgen_rethrow = function(arg0) {
        throw takeObject(arg0);
    };

    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {
        input = fetch(input);
    }



    const { instance, module } = await load(await input, imports);

    wasm = instance.exports;
    init.__wbindgen_wasm_module = module;

    return wasm;
}

globalThis["cmsInitialized"] = false;
const loadCMS = async () => {
  if (!init.encrypt_with_password) {
    globalThis["cmsInitialized"] = !!await init("/wasm/cms-v1.0.1.wasm");
  } else {
    globalThis["cmsInitialized"] = true;
  }
};

export { isGreaterThanZero as $, AccountError as A, Bip32PublicKey as B, requireDist as C, requireStreamBrowserify as D, Ed25519Signature as E, FixedTransaction as F, blake2b256 as G, TransactionBody as H, ITxBalanceType as I, AuxiliaryData as J, TransactionWitnessSet as K, Transaction as L, AuxiliaryDataHash as M, CborContainerType as N, getTransactionJSONFromCSL as O, PublicKey as P, now as Q, getUtxoHash as R, addValueToValue as S, TransactionHash as T, neg as U, Vkey as V, add as W, subtract as X, addOutputToBalance as Y, ErrorBuildTx as Z, filterUtxoFromList as _, appLanguageTag as a, NativeScript as a$, getFilteredUtxoList as a0, sortInputListByScore as a1, addToBalance as a2, filterUtxoList as a3, createIBalance as a4, getInputBalance as a5, getOutputBalance as a6, clearBalance as a7, decreaseBalance as a8, doProcessSubmittedTxList as a9, AssetDB$1 as aA, fetchAssetCDN as aB, getSortedAssetDetailsList as aC, doInitApp as aD, SyncState as aE, isMultiSigAccountPath as aF, updateIAccountSettingsPartial as aG, saveAccountSettings as aH, getAppWallet as aI, getIAppWallet$1 as aJ, getAppAccount as aK, getIAppAccount as aL, DataError as aM, decryptText as aN, encryptText as aO, saveWallet as aP, getWalletNameList as aQ, saveWalletSettings as aR, onWalletSettingsUpdated as aS, getIAccountBalances as aT, onTxHistoryAccountUpdated as aU, selectedWalletId$1 as aV, selectedAccountId$1 as aW, doSwitchSelectedWalletAccount as aX, isHDAccount as aY, getCSLVkeywitnessHash as aZ, getCalculatedChainTip as a_, onTxSubmitted as aa, loadUnknownUtxos as ab, getUtxoCborList as ac, getAddressCbor as ad, getLockedUtxos as ae, createTransactionOutputJSON as af, getDonationAddress as ag, getValueJSONFromCbor as ah, checkEpochParams as ai, getAllUsedAddresses as aj, setRewardsLocked as ak, updateBalances as al, isLessThanZero as am, getBalanceCbor as an, freeCSLObjects as ao, doForceSyncImportantAccounts as ap, isSyncLeader as aq, doReloadAccount as ar, getPendingTxList as as, getOwnedCred as at, generatePlateHex as au, getNetworkMagic as av, AdaHandleError as aw, isValidSendAddress as ax, MediaSize as ay, fetchAssetCDNImage as az, abs as b, getIAppWallet as b$, jsonToCsl as b0, getAllInputUtxoHashList as b1, getNativeScriptCredFromHex as b2, getIAppAccountByCred as b3, calcAccountTxBalance as b4, onTxSignReset as b5, onDataSignReset as b6, ErrorSignData as b7, getHintUtxoList as b8, createIUtxo as b9, getContractMappingByAddresses as bA, isScriptAddress as bB, getAccountName as bC, doRemovePendingTx as bD, getAddressBookEntryByAddress as bE, addressBook as bF, getBurnAddress as bG, getSwapFeeAddressMS as bH, getSwapFeeAddressDH as bI, getSwapFeeAddressSS as bJ, getFeeAddress as bK, getEternlCollateralAddress as bL, createIAssetListItemDetails as bM, LanguageKind as bN, TransactionNoteDB$1 as bO, onTxNoteAdded as bP, onTxNoteUpdated as bQ, onTxNoteDeleted as bR, getRandomId as bS, isNaN$1 as bT, useCurrencyAPI as bU, decodeBech32 as bV, getDRepAddressFromKeyHashOld as bW, getAssetIdBech32 as bX, formatAssetName as bY, useGuard as bZ, getIAppAccountByAddress as b_, doForceSyncAccount as ba, getRequestData as bb, ApiRequestType as bc, ErrorSync as bd, useSelectedAccount as be, doOpenTxViewer as bf, createITxBalance as bg, delDecryptedMsg as bh, decryptedMsgMap as bi, saveDecryptedMsg as bj, timestamp as bk, getTimestampFromSlot as bl, chainTip as bm, NativeScripts as bn, cslToJson as bo, getEpochFromSlot as bp, syncEpochParams as bq, getPlutusHVB as br, PlutusScripts as bs, PlutusScript as bt, isOnChainState as bu, isInvalidState as bv, isSubmittedState as bw, isSignedState as bx, createIUtxoFromIUtxoDetails as by, CertificateKind as bz, compare$1 as c, requireCallBind as c$, CertificateTypes as c0, getDRepAddressFromKeyHash as c1, getPoolAddressFromKeyHash as c2, getDRepCredentialsFromAddress as c3, onBuiltTxVoteDelegation as c4, onBuiltTxVoteReg as c5, doBuildTxVoteDelegation as c6, getGovProposalId as c7, isVerified as c8, pow as c9, make_vkey_witness as cA, requireEvents as cB, process$1 as cC, requireSafeBuffer$2 as cD, HeaderMap as cE, Label as cF, AlgorithmId as cG, CBORValue as cH, ProtectedHeaderMap as cI, Headers as cJ, COSESign1Builder as cK, KeyType as cL, COSEKey as cM, BigNum as cN, Int as cO, getAccountKeyDetails as cP, decode_metadatum_to_json_str as cQ, Address as cR, purpose as cS, requireCryptoBrowserify as cT, requireBrowser$9 as cU, requireSha_js as cV, requireUtil$2 as cW, requireShams$1 as cX, requireCallBound as cY, requireDefineDataProperty as cZ, requireHasPropertyDescriptors as c_, loadAssetMetadata as ca, doSendUpdateNetworkId as cb, BroadcastMsgType as cc, timestampLocal as cd, MediaType as ce, getContractAddressesByLabel as cf, doReloadWalletList as cg, getDefaultErrorMessage as ch, getEpochLength as ci, getCalculatedEpochSlot as cj, doForceSyncAllAccounts as ck, isUpdating as cl, txListRecentNumEntries as cm, txListRecentPage as cn, numTxTotal as co, Vkeywitnesses as cp, MetadataList as cq, GeneralTransactionMetadata as cr, BigNum$1 as cs, blake2b256Str as ct, encode_json_str_to_metadatum as cu, MetadataJsonSchema as cv, TransactionMetadatum as cw, hash_transaction as cx, PrivateKey as cy, hash_auxiliary_data as cz, divide as d, updateUtxoLists as d$, requireElliptic as d0, requireRipemd160 as d1, getRandomUUID as d2, requireHash as d3, requireBn$5 as d4, requireBrorand as d5, setSignedState as d6, setExpiredState as d7, isDAppSupported as d8, hasLockedUtxos as d9, doSendUpdatePeerInfo as dA, doSendForcePeerDisconnect as dB, doSendForcePeerConnect as dC, doSendUpdateWalletConnectList as dD, onAppOpen as dE, onAppClose as dF, setActiveInstance as dG, doSetActiveApp as dH, instanceAppId as dI, doUpdatePendingTxStatus as dJ, onAccountDataUpdated as dK, _loadPendingTxList as dL, setSubmittedState as dM, fillInputUtxoList as dN, setInvalidState as dO, setOnChainState as dP, loadUtxoCborFromUtxoHashes as dQ, AccountDB$1 as dR, onInterval8s as dS, SyncPriority as dT, doSyncAccount as dU, useDappAccount as dV, onSyncLeader as dW, doPostInitApp as dX, setAppAccount as dY, setAppWallet as dZ, WalletDB$1 as d_, isExpiredState as da, doAddSignedTxList as db, onTxSignSubmit as dc, onTxSignCancel as dd, updatePendingTxList as de, cachePendingUtxoList as df, cacheHintUtxoList as dg, blake2b224Str as dh, onDataSignSubmit as di, onDataSignCancel as dj, onOnlyDappAccountSet as dk, onInterval20s as dl, onInterval60s as dm, onUpdateChainTip as dn, onUpdateOnTip as dp, requestData as dq, onFocus as dr, isValidBroadcastMsgType as ds, doSendOpen as dt, doSendClose as du, doSendUpdateWalletList as dv, doSendUpdateAccountData as dw, doSendUpdateDappAccountId as dx, doSendUpdatePendingTx as dy, doSendUpdatePeerInfoList as dz, bigToNum as e, onRemoveAllAccountsFromSync as e0, GuardBlockListDB$1 as e1, loadAddressBook as e2, reloadAccountData as e3, removeAccount as e4, doRemoveAccount as e5, updateFavoriteAccountList as e6, onAccountSettingsUpdated as e7, onAppAccountAddedToAppWallet as e8, onAccountRemoved as e9, onWalletListUpdated as ea, updateManualSyncForAllAccounts as eb, doToggleManualSyncForAllAccounts as ec, loadWalletList as ed, loadCSL as ee, loadCMS as ef, getCSLBigNum as eg, doInitFirstWorker as eh, appTimezone as f, appUseUtc as g, appFormatTag as h, isZero as i, multiply as j, getCSLBip32PrivateKey as k, getCSLBip32PublicKey as l, mod as m, Vkeywitness as n, Bip32PrivateKey as o, chain as p, getAddressCredentials as q, round as r, safeFreeCSLObject as s, getAddressKey as t, getBaseAddressFromCred as u, getEnterpriseAddressFromCred as v, getCSLAddress as w, getRewardAddressFromCred as x, isScriptPaymentAddress as y, isScriptStakeAddress as z };
